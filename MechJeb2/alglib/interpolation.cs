/*************************************************************************
ALGLIB 3.19.0 (source code generated 2022-06-07)
Copyright (c) Sergey Bochkanov (ALGLIB project).

>>> SOURCE LICENSE >>>
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation (www.fsf.org); either version 2 of the 
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

A copy of the GNU General Public License is available at
http://www.fsf.org/licensing/licenses
>>> END OF LICENSE >>>
*************************************************************************/
#pragma warning disable 162
#pragma warning disable 164
#pragma warning disable 219
using System;

public partial class alglib
{


    /*************************************************************************
    Barycentric interpolant.
    *************************************************************************/
    public class barycentricinterpolant : alglibobject
    {
        //
        // Public declarations
        //
    
        public barycentricinterpolant()
        {
            _innerobj = new ratint.barycentricinterpolant();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new barycentricinterpolant((ratint.barycentricinterpolant)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private ratint.barycentricinterpolant _innerobj;
        public ratint.barycentricinterpolant innerobj { get { return _innerobj; } }
        public barycentricinterpolant(ratint.barycentricinterpolant obj)
        {
            _innerobj = obj;
        }
    }
    
    /*************************************************************************
    Rational interpolation using barycentric formula

    F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))

    Input parameters:
        B   -   barycentric interpolant built with one of model building
                subroutines.
        T   -   interpolation point

    Result:
        barycentric interpolant F(t)

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static double barycentriccalc(barycentricinterpolant b, double t)
    {
    
        return ratint.barycentriccalc(b.innerobj, t, null);
    }
    
    public static double barycentriccalc(barycentricinterpolant b, double t, alglib.xparams _params)
    {
    
        return ratint.barycentriccalc(b.innerobj, t, _params);
    }
    
    /*************************************************************************
    Differentiation of barycentric interpolant: first derivative.

    Algorithm used in this subroutine is very robust and should not fail until
    provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
    or greater will overflow).

    INPUT PARAMETERS:
        B   -   barycentric interpolant built with one of model building
                subroutines.
        T   -   interpolation point

    OUTPUT PARAMETERS:
        F   -   barycentric interpolant at T
        DF  -   first derivative

    NOTE


      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentricdiff1(barycentricinterpolant b, double t, out double f, out double df)
    {
        f = 0;
        df = 0;
        ratint.barycentricdiff1(b.innerobj, t, ref f, ref df, null);
    }
    
    public static void barycentricdiff1(barycentricinterpolant b, double t, out double f, out double df, alglib.xparams _params)
    {
        f = 0;
        df = 0;
        ratint.barycentricdiff1(b.innerobj, t, ref f, ref df, _params);
    }
    
    /*************************************************************************
    Differentiation of barycentric interpolant: first/second derivatives.

    INPUT PARAMETERS:
        B   -   barycentric interpolant built with one of model building
                subroutines.
        T   -   interpolation point

    OUTPUT PARAMETERS:
        F   -   barycentric interpolant at T
        DF  -   first derivative
        D2F -   second derivative

    NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
    whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
    BarycentricDiff1() subroutine in such cases.


      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentricdiff2(barycentricinterpolant b, double t, out double f, out double df, out double d2f)
    {
        f = 0;
        df = 0;
        d2f = 0;
        ratint.barycentricdiff2(b.innerobj, t, ref f, ref df, ref d2f, null);
    }
    
    public static void barycentricdiff2(barycentricinterpolant b, double t, out double f, out double df, out double d2f, alglib.xparams _params)
    {
        f = 0;
        df = 0;
        d2f = 0;
        ratint.barycentricdiff2(b.innerobj, t, ref f, ref df, ref d2f, _params);
    }
    
    /*************************************************************************
    This subroutine performs linear transformation of the argument.

    INPUT PARAMETERS:
        B       -   rational interpolant in barycentric form
        CA, CB  -   transformation coefficients: x = CA*t + CB

    OUTPUT PARAMETERS:
        B       -   transformed interpolant with X replaced by T

      -- ALGLIB PROJECT --
         Copyright 19.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentriclintransx(barycentricinterpolant b, double ca, double cb)
    {
    
        ratint.barycentriclintransx(b.innerobj, ca, cb, null);
    }
    
    public static void barycentriclintransx(barycentricinterpolant b, double ca, double cb, alglib.xparams _params)
    {
    
        ratint.barycentriclintransx(b.innerobj, ca, cb, _params);
    }
    
    /*************************************************************************
    This  subroutine   performs   linear  transformation  of  the  barycentric
    interpolant.

    INPUT PARAMETERS:
        B       -   rational interpolant in barycentric form
        CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB

    OUTPUT PARAMETERS:
        B       -   transformed interpolant

      -- ALGLIB PROJECT --
         Copyright 19.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentriclintransy(barycentricinterpolant b, double ca, double cb)
    {
    
        ratint.barycentriclintransy(b.innerobj, ca, cb, null);
    }
    
    public static void barycentriclintransy(barycentricinterpolant b, double ca, double cb, alglib.xparams _params)
    {
    
        ratint.barycentriclintransy(b.innerobj, ca, cb, _params);
    }
    
    /*************************************************************************
    Extracts X/Y/W arrays from rational interpolant

    INPUT PARAMETERS:
        B   -   barycentric interpolant

    OUTPUT PARAMETERS:
        N   -   nodes count, N>0
        X   -   interpolation nodes, array[0..N-1]
        F   -   function values, array[0..N-1]
        W   -   barycentric weights, array[0..N-1]

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentricunpack(barycentricinterpolant b, out int n, out double[] x, out double[] y, out double[] w)
    {
        n = 0;
        x = new double[0];
        y = new double[0];
        w = new double[0];
        ratint.barycentricunpack(b.innerobj, ref n, ref x, ref y, ref w, null);
    }
    
    public static void barycentricunpack(barycentricinterpolant b, out int n, out double[] x, out double[] y, out double[] w, alglib.xparams _params)
    {
        n = 0;
        x = new double[0];
        y = new double[0];
        w = new double[0];
        ratint.barycentricunpack(b.innerobj, ref n, ref x, ref y, ref w, _params);
    }
    
    /*************************************************************************
    Rational interpolant from X/Y/W arrays

    F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))

    INPUT PARAMETERS:
        X   -   interpolation nodes, array[0..N-1]
        F   -   function values, array[0..N-1]
        W   -   barycentric weights, array[0..N-1]
        N   -   nodes count, N>0

    OUTPUT PARAMETERS:
        B   -   barycentric interpolant built from (X, Y, W)

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentricbuildxyw(double[] x, double[] y, double[] w, int n, out barycentricinterpolant b)
    {
        b = new barycentricinterpolant();
        ratint.barycentricbuildxyw(x, y, w, n, b.innerobj, null);
    }
    
    public static void barycentricbuildxyw(double[] x, double[] y, double[] w, int n, out barycentricinterpolant b, alglib.xparams _params)
    {
        b = new barycentricinterpolant();
        ratint.barycentricbuildxyw(x, y, w, n, b.innerobj, _params);
    }
    
    /*************************************************************************
    Rational interpolant without poles

    The subroutine constructs the rational interpolating function without real
    poles  (see  'Barycentric rational interpolation with no  poles  and  high
    rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
    information on this subject).

    Input parameters:
        X   -   interpolation nodes, array[0..N-1].
        Y   -   function values, array[0..N-1].
        N   -   number of nodes, N>0.
        D   -   order of the interpolation scheme, 0 <= D <= N-1.
                D<0 will cause an error.
                D>=N it will be replaced with D=N-1.
                if you don't know what D to choose, use small value about 3-5.

    Output parameters:
        B   -   barycentric interpolant.

    Note:
        this algorithm always succeeds and calculates the weights  with  close
        to machine precision.

      -- ALGLIB PROJECT --
         Copyright 17.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentricbuildfloaterhormann(double[] x, double[] y, int n, int d, out barycentricinterpolant b)
    {
        b = new barycentricinterpolant();
        ratint.barycentricbuildfloaterhormann(x, y, n, d, b.innerobj, null);
    }
    
    public static void barycentricbuildfloaterhormann(double[] x, double[] y, int n, int d, out barycentricinterpolant b, alglib.xparams _params)
    {
        b = new barycentricinterpolant();
        ratint.barycentricbuildfloaterhormann(x, y, n, d, b.innerobj, _params);
    }

}
public partial class alglib
{


    /*************************************************************************
    Buffer  object  which  is  used  to  perform  evaluation  requests  in  the
    multithreaded mode (multiple threads working with same IDW object).

    This object should be created with idwcreatecalcbuffer().
    *************************************************************************/
    public class idwcalcbuffer : alglibobject
    {
        //
        // Public declarations
        //
    
        public idwcalcbuffer()
        {
            _innerobj = new idw.idwcalcbuffer();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new idwcalcbuffer((idw.idwcalcbuffer)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private idw.idwcalcbuffer _innerobj;
        public idw.idwcalcbuffer innerobj { get { return _innerobj; } }
        public idwcalcbuffer(idw.idwcalcbuffer obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    IDW (Inverse Distance Weighting) model object.
    *************************************************************************/
    public class idwmodel : alglibobject
    {
        //
        // Public declarations
        //
    
        public idwmodel()
        {
            _innerobj = new idw.idwmodel();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new idwmodel((idw.idwmodel)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private idw.idwmodel _innerobj;
        public idw.idwmodel innerobj { get { return _innerobj; } }
        public idwmodel(idw.idwmodel obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    Builder object used to generate IDW (Inverse Distance Weighting) model.
    *************************************************************************/
    public class idwbuilder : alglibobject
    {
        //
        // Public declarations
        //
    
        public idwbuilder()
        {
            _innerobj = new idw.idwbuilder();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new idwbuilder((idw.idwbuilder)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private idw.idwbuilder _innerobj;
        public idw.idwbuilder innerobj { get { return _innerobj; } }
        public idwbuilder(idw.idwbuilder obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    IDW fitting report:
        rmserror        RMS error
        avgerror        average error
        maxerror        maximum error
        r2              coefficient of determination,  R-squared, 1-RSS/TSS
    *************************************************************************/
    public class idwreport : alglibobject
    {
        //
        // Public declarations
        //
        public double rmserror { get { return _innerobj.rmserror; } set { _innerobj.rmserror = value; } }
        public double avgerror { get { return _innerobj.avgerror; } set { _innerobj.avgerror = value; } }
        public double maxerror { get { return _innerobj.maxerror; } set { _innerobj.maxerror = value; } }
        public double r2 { get { return _innerobj.r2; } set { _innerobj.r2 = value; } }
    
        public idwreport()
        {
            _innerobj = new idw.idwreport();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new idwreport((idw.idwreport)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private idw.idwreport _innerobj;
        public idw.idwreport innerobj { get { return _innerobj; } }
        public idwreport(idw.idwreport obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    This function serializes data structure to string.
    
    Important properties of s_out:
    * it contains alphanumeric characters, dots, underscores, minus signs
    * these symbols are grouped into words, which are separated by spaces
      and Windows-style (CR+LF) newlines
    * although  serializer  uses  spaces and CR+LF as separators, you can 
      replace any separator character by arbitrary combination of spaces,
      tabs, Windows or Unix newlines. It allows flexible reformatting  of
      the  string  in  case you want to include it into text or XML file. 
      But you should not insert separators into the middle of the "words"
      nor you should change case of letters.
    * s_out can be freely moved between 32-bit and 64-bit systems, little
      and big endian machines, and so on. You can serialize structure  on
      32-bit machine and unserialize it on 64-bit one (or vice versa), or
      serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
      serialize  it  in  C# version of ALGLIB and unserialize in C++ one, 
      and vice versa.
    *************************************************************************/
    public static void idwserialize(idwmodel obj, out string s_out)
    {
        alglib.serializer s = new alglib.serializer();
        s.alloc_start();
        idw.idwalloc(s, obj.innerobj, null);
        s.sstart_str();
        idw.idwserialize(s, obj.innerobj, null);
        s.stop();
        s_out = s.get_string();
    }


    /*************************************************************************
    This function unserializes data structure from string.
    *************************************************************************/
    public static void idwunserialize(string s_in, out idwmodel obj)
    {
        alglib.serializer s = new alglib.serializer();
        obj = new idwmodel();
        s.ustart_str(s_in);
        idw.idwunserialize(s, obj.innerobj, null);
        s.stop();
    }


    /*************************************************************************
    This function serializes data structure to stream.
    
    Data stream generated by this function is same as  string  representation
    generated  by  string  version  of  serializer - alphanumeric characters,
    dots, underscores, minus signs, which are grouped into words separated by
    spaces and CR+LF.
    
    We recommend you to read comments on string version of serializer to find
    out more about serialization of AlGLIB objects.
    *************************************************************************/
    public static void idwserialize(idwmodel obj, System.IO.Stream stream_out)
    {
        alglib.serializer s = new alglib.serializer();
        s.alloc_start();
        idw.idwalloc(s, obj.innerobj, null);
        s.sstart_stream(stream_out);
        idw.idwserialize(s, obj.innerobj, null);
        s.stop();
    }


    /*************************************************************************
    This function unserializes data structure from stream.
    *************************************************************************/
    public static void idwunserialize(System.IO.Stream stream_in, out idwmodel obj)
    {
        alglib.serializer s = new alglib.serializer();
        obj = new idwmodel();
        s.ustart_stream(stream_in);
        idw.idwunserialize(s, obj.innerobj, null);
        s.stop();
    }
    
    /*************************************************************************
    This function creates buffer  structure  which  can  be  used  to  perform
    parallel  IDW  model  evaluations  (with  one  IDW  model  instance  being
    used from multiple threads, as long as  different  threads  use  different
    instances of buffer).

    This buffer object can be used with  idwtscalcbuf()  function  (here  "ts"
    stands for "thread-safe", "buf" is a suffix which denotes  function  which
    reuses previously allocated output space).

    How to use it:
    * create IDW model structure or load it from file
    * call idwcreatecalcbuffer(), once per thread working with IDW model  (you
      should call this function only AFTER model initialization, see below for
      more information)
    * call idwtscalcbuf() from different threads,  with  each  thread  working
      with its own copy of buffer object.

    INPUT PARAMETERS
        S           -   IDW model

    OUTPUT PARAMETERS
        Buf         -   external buffer.


    IMPORTANT: buffer object should be used only with  IDW model object  which
               was used to initialize buffer. Any attempt to use buffer   with
               different object is dangerous - you may  get  memory  violation
               error because sizes of internal arrays do not fit to dimensions
               of the IDW structure.

    IMPORTANT: you  should  call  this function only for model which was built
               with model builder (or unserialized from file). Sizes  of  some
               internal structures are determined only after model  is  built,
               so buffer object created before model construction  stage  will
               be useless (and any attempt to use it will result in exception).

      -- ALGLIB --
         Copyright 22.10.2018 by Sergey Bochkanov
    *************************************************************************/
    public static void idwcreatecalcbuffer(idwmodel s, out idwcalcbuffer buf)
    {
        buf = new idwcalcbuffer();
        idw.idwcreatecalcbuffer(s.innerobj, buf.innerobj, null);
    }
    
    public static void idwcreatecalcbuffer(idwmodel s, out idwcalcbuffer buf, alglib.xparams _params)
    {
        buf = new idwcalcbuffer();
        idw.idwcreatecalcbuffer(s.innerobj, buf.innerobj, _params);
    }
    
    /*************************************************************************
    This subroutine creates builder object used  to  generate IDW  model  from
    irregularly sampled (scattered) dataset.  Multidimensional  scalar/vector-
    -valued are supported.

    Builder object is used to fit model to data as follows:
    * builder object is created with idwbuildercreate() function
    * dataset is added with idwbuildersetpoints() function
    * one of the modern IDW algorithms is chosen with either:
      * idwbuildersetalgomstab()            - Multilayer STABilized algorithm (interpolation)
      Alternatively, one of the textbook algorithms can be chosen (not recommended):
      * idwbuildersetalgotextbookshepard()  - textbook Shepard algorithm
      * idwbuildersetalgotextbookmodshepard()-textbook modified Shepard algorithm
    * finally, model construction is performed with idwfit() function.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    INPUT PARAMETERS:
        NX  -   dimensionality of the argument, NX>=1
        NY  -   dimensionality of the function being modeled, NY>=1;
                NY=1 corresponds to classic scalar function, NY>=1 corresponds
                to vector-valued function.

    OUTPUT PARAMETERS:
        State-  builder object

      -- ALGLIB PROJECT --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildercreate(int nx, int ny, out idwbuilder state)
    {
        state = new idwbuilder();
        idw.idwbuildercreate(nx, ny, state.innerobj, null);
    }
    
    public static void idwbuildercreate(int nx, int ny, out idwbuilder state, alglib.xparams _params)
    {
        state = new idwbuilder();
        idw.idwbuildercreate(nx, ny, state.innerobj, _params);
    }
    
    /*************************************************************************
    This function changes number of layers used by IDW-MSTAB algorithm.

    The more layers you have, the finer details can  be  reproduced  with  IDW
    model. The less layers you have, the less memory and CPU time is  consumed
    by the model.

    Memory consumption grows linearly with layers count,  running  time  grows
    sub-linearly.

    The default number of layers is 16, which allows you to reproduce  details
    at distance down to SRad/65536. You will rarely need to change it.

    INPUT PARAMETERS:
        State   -   builder object
        NLayers -   NLayers>=1, the number of layers used by the model.

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildersetnlayers(idwbuilder state, int nlayers)
    {
    
        idw.idwbuildersetnlayers(state.innerobj, nlayers, null);
    }
    
    public static void idwbuildersetnlayers(idwbuilder state, int nlayers, alglib.xparams _params)
    {
    
        idw.idwbuildersetnlayers(state.innerobj, nlayers, _params);
    }
    
    /*************************************************************************
    This function adds dataset to the builder object.

    This function overrides results of the previous calls, i.e. multiple calls
    of this function will result in only the last set being added.

    INPUT PARAMETERS:
        State   -   builder object
        XY      -   points, array[N,NX+NY]. One row  corresponds to  one point
                    in the dataset. First NX elements  are  coordinates,  next
                    NY elements are function values. Array may  be larger than
                    specified, in  this  case  only leading [N,NX+NY] elements
                    will be used.
        N       -   number of points in the dataset, N>=0.

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildersetpoints(idwbuilder state, double[,] xy, int n)
    {
    
        idw.idwbuildersetpoints(state.innerobj, xy, n, null);
    }
    
    public static void idwbuildersetpoints(idwbuilder state, double[,] xy, int n, alglib.xparams _params)
    {
    
        idw.idwbuildersetpoints(state.innerobj, xy, n, _params);
    }
            
    public static void idwbuildersetpoints(idwbuilder state, double[,] xy)
    {
        int n;
    
    
        n = ap.rows(xy);
        idw.idwbuildersetpoints(state.innerobj, xy, n, null);
    
        return;
    }
            
    public static void idwbuildersetpoints(idwbuilder state, double[,] xy, alglib.xparams _params)
    {
        int n;
    
    
        n = ap.rows(xy);
        idw.idwbuildersetpoints(state.innerobj, xy, n, _params);
    
        return;
    }
    
    /*************************************************************************
    This function sets IDW model  construction  algorithm  to  the  Multilayer
    Stabilized IDW method (IDW-MSTAB), a  latest  incarnation  of  the inverse
    distance weighting interpolation which fixes shortcomings of  the original
    and modified Shepard's variants.

    The distinctive features of IDW-MSTAB are:
    1) exact interpolation  is  pursued  (as  opposed  to  fitting  and  noise
       suppression)
    2) improved robustness when compared with that of other algorithms:
       * MSTAB shows almost no strange  fitting  artifacts  like  ripples  and
         sharp spikes (unlike N-dimensional splines and HRBFs)
       * MSTAB does not return function values far from the  interval  spanned
         by the dataset; say, if all your points have |f|<=1, you  can be sure
         that model value won't deviate too much from [-1,+1]
    3) good model construction time competing with that of HRBFs  and  bicubic
       splines
    4) ability to work with any number of dimensions, starting from NX=1

    The drawbacks of IDW-MSTAB (and all IDW algorithms in general) are:
    1) dependence of the model evaluation time on the search radius
    2) bad extrapolation properties, models built by this method  are  usually
       conservative in their predictions

    Thus, IDW-MSTAB is  a  good  "default"  option  if  you  want  to  perform
    scattered multidimensional interpolation. Although it has  its  drawbacks,
    it is easy to use and robust, which makes it a good first step.


    INPUT PARAMETERS:
        State   -   builder object
        SRad    -   initial search radius, SRad>0 is required. A model  value
                    is obtained by "smart" averaging  of  the  dataset  points
                    within search radius.

    NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
            datasets with non-distinct points. In case non-distinct points are
            found, an average value for this point will be calculated.

    NOTE 2: the memory requirements for model storage are O(NPoints*NLayers).
            The model construction needs twice as much memory as model storage.

    NOTE 3: by default 16 IDW layers are built which is enough for most cases.
            You can change this parameter with idwbuildersetnlayers()  method.
            Larger values may be necessary if you need to reproduce  extrafine
            details at distances smaller than SRad/65536.  Smaller value   may
            be necessary if you have to save memory and  computing  time,  and
            ready to sacrifice some model quality.


    ALGORITHM DESCRIPTION

    ALGLIB implementation of IDW is somewhat similar to the modified Shepard's
    method (one with search radius R) but overcomes several of its  drawbacks,
    namely:
    1) a tendency to show stepwise behavior for uniform datasets
    2) a tendency to show terrible interpolation properties for highly
       nonuniform datasets which often arise in geospatial tasks
      (function values are densely sampled across multiple separated
      "tracks")

    IDW-MSTAB method performs several passes over dataset and builds a sequence
    of progressively refined IDW models  (layers),  which starts from one with
    largest search radius SRad  and continues to smaller  search  radii  until
    required number of  layers  is  built.  Highest  layers  reproduce  global
    behavior of the target function at larger distances  whilst  lower  layers
    reproduce fine details at smaller distances.

    Each layer is an IDW model built with following modifications:
    * weights go to zero when distance approach to the current search radius
    * an additional regularizing term is added to the distance: w=1/(d^2+lambda)
    * an additional fictional term with unit weight and zero function value is
      added in order to promote continuity  properties  at  the  isolated  and
      boundary points

    By default, 16 layers is built, which is enough for most  cases.  You  can
    change this parameter with idwbuildersetnlayers() method.

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildersetalgomstab(idwbuilder state, double srad)
    {
    
        idw.idwbuildersetalgomstab(state.innerobj, srad, null);
    }
    
    public static void idwbuildersetalgomstab(idwbuilder state, double srad, alglib.xparams _params)
    {
    
        idw.idwbuildersetalgomstab(state.innerobj, srad, _params);
    }
    
    /*************************************************************************
    This function sets  IDW  model  construction  algorithm  to  the  textbook
    Shepard's algorithm with custom (user-specified) power parameter.

    IMPORTANT: we do NOT recommend using textbook IDW algorithms because  they
               have terrible interpolation properties. Use MSTAB in all cases.

    INPUT PARAMETERS:
        State   -   builder object
        P       -   power parameter, P>0; good value to start with is 2.0

    NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
            datasets with non-distinct points. In case non-distinct points are
            found, an average value for this point will be calculated.

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildersetalgotextbookshepard(idwbuilder state, double p)
    {
    
        idw.idwbuildersetalgotextbookshepard(state.innerobj, p, null);
    }
    
    public static void idwbuildersetalgotextbookshepard(idwbuilder state, double p, alglib.xparams _params)
    {
    
        idw.idwbuildersetalgotextbookshepard(state.innerobj, p, _params);
    }
    
    /*************************************************************************
    This function sets  IDW  model  construction  algorithm  to the 'textbook'
    modified Shepard's algorithm with user-specified search radius.

    IMPORTANT: we do NOT recommend using textbook IDW algorithms because  they
               have terrible interpolation properties. Use MSTAB in all cases.

    INPUT PARAMETERS:
        State   -   builder object
        R       -   search radius

    NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
            datasets with non-distinct points. In case non-distinct points are
            found, an average value for this point will be calculated.

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildersetalgotextbookmodshepard(idwbuilder state, double r)
    {
    
        idw.idwbuildersetalgotextbookmodshepard(state.innerobj, r, null);
    }
    
    public static void idwbuildersetalgotextbookmodshepard(idwbuilder state, double r, alglib.xparams _params)
    {
    
        idw.idwbuildersetalgotextbookmodshepard(state.innerobj, r, _params);
    }
    
    /*************************************************************************
    This function sets prior term (model value at infinity) as  user-specified
    value.

    INPUT PARAMETERS:
        S       -   spline builder
        V       -   value for user-defined prior

    NOTE: for vector-valued models all components of the prior are set to same
          user-specified value

      -- ALGLIB --
         Copyright 29.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildersetuserterm(idwbuilder state, double v)
    {
    
        idw.idwbuildersetuserterm(state.innerobj, v, null);
    }
    
    public static void idwbuildersetuserterm(idwbuilder state, double v, alglib.xparams _params)
    {
    
        idw.idwbuildersetuserterm(state.innerobj, v, _params);
    }
    
    /*************************************************************************
    This function sets constant prior term (model value at infinity).

    Constant prior term is determined as mean value over dataset.

    INPUT PARAMETERS:
        S       -   spline builder

      -- ALGLIB --
         Copyright 29.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildersetconstterm(idwbuilder state)
    {
    
        idw.idwbuildersetconstterm(state.innerobj, null);
    }
    
    public static void idwbuildersetconstterm(idwbuilder state, alglib.xparams _params)
    {
    
        idw.idwbuildersetconstterm(state.innerobj, _params);
    }
    
    /*************************************************************************
    This function sets zero prior term (model value at infinity).

    INPUT PARAMETERS:
        S       -   spline builder

      -- ALGLIB --
         Copyright 29.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwbuildersetzeroterm(idwbuilder state)
    {
    
        idw.idwbuildersetzeroterm(state.innerobj, null);
    }
    
    public static void idwbuildersetzeroterm(idwbuilder state, alglib.xparams _params)
    {
    
        idw.idwbuildersetzeroterm(state.innerobj, _params);
    }
    
    /*************************************************************************
    IDW interpolation: scalar target, 1-dimensional argument

    NOTE: this function modifies internal temporaries of the  IDW  model, thus
          IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
          evaluation from the multiple threads, use idwtscalcbuf()  with  per-
          thread buffer object.

    INPUT PARAMETERS:
        S   -   IDW interpolant built with IDW builder
        X0  -   argument value

    Result:
        IDW interpolant S(X0)

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static double idwcalc1(idwmodel s, double x0)
    {
    
        return idw.idwcalc1(s.innerobj, x0, null);
    }
    
    public static double idwcalc1(idwmodel s, double x0, alglib.xparams _params)
    {
    
        return idw.idwcalc1(s.innerobj, x0, _params);
    }
    
    /*************************************************************************
    IDW interpolation: scalar target, 2-dimensional argument

    NOTE: this function modifies internal temporaries of the  IDW  model, thus
          IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
          evaluation from the multiple threads, use idwtscalcbuf()  with  per-
          thread buffer object.

    INPUT PARAMETERS:
        S       -   IDW interpolant built with IDW builder
        X0, X1  -   argument value

    Result:
        IDW interpolant S(X0,X1)

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static double idwcalc2(idwmodel s, double x0, double x1)
    {
    
        return idw.idwcalc2(s.innerobj, x0, x1, null);
    }
    
    public static double idwcalc2(idwmodel s, double x0, double x1, alglib.xparams _params)
    {
    
        return idw.idwcalc2(s.innerobj, x0, x1, _params);
    }
    
    /*************************************************************************
    IDW interpolation: scalar target, 3-dimensional argument

    NOTE: this function modifies internal temporaries of the  IDW  model, thus
          IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
          evaluation from the multiple threads, use idwtscalcbuf()  with  per-
          thread buffer object.

    INPUT PARAMETERS:
        S       -   IDW interpolant built with IDW builder
        X0,X1,X2-   argument value

    Result:
        IDW interpolant S(X0,X1,X2)

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static double idwcalc3(idwmodel s, double x0, double x1, double x2)
    {
    
        return idw.idwcalc3(s.innerobj, x0, x1, x2, null);
    }
    
    public static double idwcalc3(idwmodel s, double x0, double x1, double x2, alglib.xparams _params)
    {
    
        return idw.idwcalc3(s.innerobj, x0, x1, x2, _params);
    }
    
    /*************************************************************************
    This function calculates values of the IDW model at the given point.

    This is general function which can be used for arbitrary NX (dimension  of
    the space of arguments) and NY (dimension of the function itself). However
    when  you  have  NY=1  you  may  find more convenient to  use  idwcalc1(),
    idwcalc2() or idwcalc3().

    NOTE: this function modifies internal temporaries of the  IDW  model, thus
          IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
          evaluation from the multiple threads, use idwtscalcbuf()  with  per-
          thread buffer object.

    INPUT PARAMETERS:
        S       -   IDW model
        X       -   coordinates, array[NX]. X may have more than NX  elements,
                    in this case only leading NX will be used.

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY]. Y is out-parameter and will  be
                    reallocated after call to this function. In case you  want
                    to reuse previously allocated Y, you may use idwcalcbuf(),
                    which reallocates Y only when it is too small.

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwcalc(idwmodel s, double[] x, out double[] y)
    {
        y = new double[0];
        idw.idwcalc(s.innerobj, x, ref y, null);
    }
    
    public static void idwcalc(idwmodel s, double[] x, out double[] y, alglib.xparams _params)
    {
        y = new double[0];
        idw.idwcalc(s.innerobj, x, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the IDW model at the given point.

    Same as idwcalc(), but does not reallocate Y when in is large enough to
    store function values.

    NOTE: this function modifies internal temporaries of the  IDW  model, thus
          IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
          evaluation from the multiple threads, use idwtscalcbuf()  with  per-
          thread buffer object.

    INPUT PARAMETERS:
        S       -   IDW model
        X       -   coordinates, array[NX]. X may have more than NX  elements,
                    in this case only leading NX will be used.
        Y       -   possibly preallocated array

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY]. Y is not reallocated when it
                    is larger than NY.

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwcalcbuf(idwmodel s, double[] x, ref double[] y)
    {
    
        idw.idwcalcbuf(s.innerobj, x, ref y, null);
    }
    
    public static void idwcalcbuf(idwmodel s, double[] x, ref double[] y, alglib.xparams _params)
    {
    
        idw.idwcalcbuf(s.innerobj, x, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the IDW model at the given point, using
    external  buffer  object  (internal  temporaries  of  IDW  model  are  not
    modified).

    This function allows to use same IDW model object  in  different  threads,
    assuming  that  different   threads  use different instances of the buffer
    structure.

    INPUT PARAMETERS:
        S       -   IDW model, may be shared between different threads
        Buf     -   buffer object created for this particular instance of  IDW
                    model with idwcreatecalcbuffer().
        X       -   coordinates, array[NX]. X may have more than NX  elements,
                    in this case only  leading NX will be used.
        Y       -   possibly preallocated array

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY]. Y is not reallocated when it
                    is larger than NY.

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void idwtscalcbuf(idwmodel s, idwcalcbuffer buf, double[] x, ref double[] y)
    {
    
        idw.idwtscalcbuf(s.innerobj, buf.innerobj, x, ref y, null);
    }
    
    public static void idwtscalcbuf(idwmodel s, idwcalcbuffer buf, double[] x, ref double[] y, alglib.xparams _params)
    {
    
        idw.idwtscalcbuf(s.innerobj, buf.innerobj, x, ref y, _params);
    }
    
    /*************************************************************************
    This function fits IDW model to the dataset using current IDW construction
    algorithm. A model being built and fitting report are returned.

    INPUT PARAMETERS:
        State   -   builder object

    OUTPUT PARAMETERS:
        Model   -   an IDW model built with current algorithm
        Rep     -   model fitting report, fields of this structure contain
                    information about average fitting errors.

    NOTE: although IDW-MSTAB algorithm is an  interpolation  method,  i.e.  it
          tries to fit the model exactly, it can  handle  datasets  with  non-
          distinct points which can not be fit exactly; in such  cases  least-
          squares fitting is performed.

      -- ALGLIB --
         Copyright 22.10.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void idwfit(idwbuilder state, out idwmodel model, out idwreport rep)
    {
        model = new idwmodel();
        rep = new idwreport();
        idw.idwfit(state.innerobj, model.innerobj, rep.innerobj, null);
    }
    
    public static void idwfit(idwbuilder state, out idwmodel model, out idwreport rep, alglib.xparams _params)
    {
        model = new idwmodel();
        rep = new idwreport();
        idw.idwfit(state.innerobj, model.innerobj, rep.innerobj, _params);
    }

}
public partial class alglib
{



}
public partial class alglib
{

    
    /*************************************************************************
    Conversion from barycentric representation to Chebyshev basis.
    This function has O(N^2) complexity.

    INPUT PARAMETERS:
        P   -   polynomial in barycentric form
        A,B -   base interval for Chebyshev polynomials (see below)
                A<>B

    OUTPUT PARAMETERS
        T   -   coefficients of Chebyshev representation;
                P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N-1 },
                where Ti - I-th Chebyshev polynomial.

    NOTES:
        barycentric interpolant passed as P may be either polynomial  obtained
        from  polynomial  interpolation/ fitting or rational function which is
        NOT polynomial. We can't distinguish between these two cases, and this
        algorithm just tries to work assuming that P IS a polynomial.  If not,
        algorithm will return results, but they won't have any meaning.

      -- ALGLIB --
         Copyright 30.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialbar2cheb(barycentricinterpolant p, double a, double b, out double[] t)
    {
        t = new double[0];
        polint.polynomialbar2cheb(p.innerobj, a, b, ref t, null);
    }
    
    public static void polynomialbar2cheb(barycentricinterpolant p, double a, double b, out double[] t, alglib.xparams _params)
    {
        t = new double[0];
        polint.polynomialbar2cheb(p.innerobj, a, b, ref t, _params);
    }
    
    /*************************************************************************
    Conversion from Chebyshev basis to barycentric representation.
    This function has O(N^2) complexity.

    INPUT PARAMETERS:
        T   -   coefficients of Chebyshev representation;
                P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N },
                where Ti - I-th Chebyshev polynomial.
        N   -   number of coefficients:
                * if given, only leading N elements of T are used
                * if not given, automatically determined from size of T
        A,B -   base interval for Chebyshev polynomials (see above)
                A<B

    OUTPUT PARAMETERS
        P   -   polynomial in barycentric form

      -- ALGLIB --
         Copyright 30.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialcheb2bar(double[] t, int n, double a, double b, out barycentricinterpolant p)
    {
        p = new barycentricinterpolant();
        polint.polynomialcheb2bar(t, n, a, b, p.innerobj, null);
    }
    
    public static void polynomialcheb2bar(double[] t, int n, double a, double b, out barycentricinterpolant p, alglib.xparams _params)
    {
        p = new barycentricinterpolant();
        polint.polynomialcheb2bar(t, n, a, b, p.innerobj, _params);
    }
            
    public static void polynomialcheb2bar(double[] t, double a, double b, out barycentricinterpolant p)
    {
        int n;
    
        p = new barycentricinterpolant();
        n = ap.len(t);
        polint.polynomialcheb2bar(t, n, a, b, p.innerobj, null);
    
        return;
    }
            
    public static void polynomialcheb2bar(double[] t, double a, double b, out barycentricinterpolant p, alglib.xparams _params)
    {
        int n;
    
        p = new barycentricinterpolant();
        n = ap.len(t);
        polint.polynomialcheb2bar(t, n, a, b, p.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Conversion from barycentric representation to power basis.
    This function has O(N^2) complexity.

    INPUT PARAMETERS:
        P   -   polynomial in barycentric form
        C   -   offset (see below); 0.0 is used as default value.
        S   -   scale (see below);  1.0 is used as default value. S<>0.

    OUTPUT PARAMETERS
        A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
        N   -   number of coefficients (polynomial degree plus 1)

    NOTES:
    1.  this function accepts offset and scale, which can be  set  to  improve
        numerical properties of polynomial. For example, if P was obtained  as
        result of interpolation on [-1,+1],  you  can  set  C=0  and  S=1  and
        represent  P  as sum of 1, x, x^2, x^3 and so on. In most cases you it
        is exactly what you need.

        However, if your interpolation model was built on [999,1001], you will
        see significant growth of numerical errors when using {1, x, x^2, x^3}
        as basis. Representing P as sum of 1, (x-1000), (x-1000)^2, (x-1000)^3
        will be better option. Such representation can be  obtained  by  using
        1000.0 as offset C and 1.0 as scale S.

    2.  power basis is ill-conditioned and tricks described above can't  solve
        this problem completely. This function  will  return  coefficients  in
        any  case,  but  for  N>8  they  will  become unreliable. However, N's
        less than 5 are pretty safe.

    3.  barycentric interpolant passed as P may be either polynomial  obtained
        from  polynomial  interpolation/ fitting or rational function which is
        NOT polynomial. We can't distinguish between these two cases, and this
        algorithm just tries to work assuming that P IS a polynomial.  If not,
        algorithm will return results, but they won't have any meaning.

      -- ALGLIB --
         Copyright 30.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialbar2pow(barycentricinterpolant p, double c, double s, out double[] a)
    {
        a = new double[0];
        polint.polynomialbar2pow(p.innerobj, c, s, ref a, null);
    }
    
    public static void polynomialbar2pow(barycentricinterpolant p, double c, double s, out double[] a, alglib.xparams _params)
    {
        a = new double[0];
        polint.polynomialbar2pow(p.innerobj, c, s, ref a, _params);
    }
            
    public static void polynomialbar2pow(barycentricinterpolant p, out double[] a)
    {
        double c;
        double s;
    
        a = new double[0];
        c = 0;
        s = 1;
        polint.polynomialbar2pow(p.innerobj, c, s, ref a, null);
    
        return;
    }
            
    public static void polynomialbar2pow(barycentricinterpolant p, out double[] a, alglib.xparams _params)
    {
        double c;
        double s;
    
        a = new double[0];
        c = 0;
        s = 1;
        polint.polynomialbar2pow(p.innerobj, c, s, ref a, _params);
    
        return;
    }
    
    /*************************************************************************
    Conversion from power basis to barycentric representation.
    This function has O(N^2) complexity.

    INPUT PARAMETERS:
        A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
        N   -   number of coefficients (polynomial degree plus 1)
                * if given, only leading N elements of A are used
                * if not given, automatically determined from size of A
        C   -   offset (see below); 0.0 is used as default value.
        S   -   scale (see below);  1.0 is used as default value. S<>0.

    OUTPUT PARAMETERS
        P   -   polynomial in barycentric form


    NOTES:
    1.  this function accepts offset and scale, which can be  set  to  improve
        numerical properties of polynomial. For example, if you interpolate on
        [-1,+1],  you  can  set C=0 and S=1 and convert from sum of 1, x, x^2,
        x^3 and so on. In most cases you it is exactly what you need.

        However, if your interpolation model was built on [999,1001], you will
        see significant growth of numerical errors when using {1, x, x^2, x^3}
        as  input  basis.  Converting  from  sum  of  1, (x-1000), (x-1000)^2,
        (x-1000)^3 will be better option (you have to specify 1000.0 as offset
        C and 1.0 as scale S).

    2.  power basis is ill-conditioned and tricks described above can't  solve
        this problem completely. This function  will  return barycentric model
        in any case, but for N>8 accuracy well degrade. However, N's less than
        5 are pretty safe.

      -- ALGLIB --
         Copyright 30.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialpow2bar(double[] a, int n, double c, double s, out barycentricinterpolant p)
    {
        p = new barycentricinterpolant();
        polint.polynomialpow2bar(a, n, c, s, p.innerobj, null);
    }
    
    public static void polynomialpow2bar(double[] a, int n, double c, double s, out barycentricinterpolant p, alglib.xparams _params)
    {
        p = new barycentricinterpolant();
        polint.polynomialpow2bar(a, n, c, s, p.innerobj, _params);
    }
            
    public static void polynomialpow2bar(double[] a, out barycentricinterpolant p)
    {
        int n;
        double c;
        double s;
    
        p = new barycentricinterpolant();
        n = ap.len(a);
        c = 0;
        s = 1;
        polint.polynomialpow2bar(a, n, c, s, p.innerobj, null);
    
        return;
    }
            
    public static void polynomialpow2bar(double[] a, out barycentricinterpolant p, alglib.xparams _params)
    {
        int n;
        double c;
        double s;
    
        p = new barycentricinterpolant();
        n = ap.len(a);
        c = 0;
        s = 1;
        polint.polynomialpow2bar(a, n, c, s, p.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Lagrange intepolant: generation of the model on the general grid.
    This function has O(N^2) complexity.

    INPUT PARAMETERS:
        X   -   abscissas, array[0..N-1]
        Y   -   function values, array[0..N-1]
        N   -   number of points, N>=1

    OUTPUT PARAMETERS
        P   -   barycentric model which represents Lagrange interpolant
                (see ratint unit info and BarycentricCalc() description for
                more information).

      -- ALGLIB --
         Copyright 02.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialbuild(double[] x, double[] y, int n, out barycentricinterpolant p)
    {
        p = new barycentricinterpolant();
        polint.polynomialbuild(x, y, n, p.innerobj, null);
    }
    
    public static void polynomialbuild(double[] x, double[] y, int n, out barycentricinterpolant p, alglib.xparams _params)
    {
        p = new barycentricinterpolant();
        polint.polynomialbuild(x, y, n, p.innerobj, _params);
    }
            
    public static void polynomialbuild(double[] x, double[] y, out barycentricinterpolant p)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'polynomialbuild': looks like one of arguments has wrong size");
        p = new barycentricinterpolant();
        n = ap.len(x);
        polint.polynomialbuild(x, y, n, p.innerobj, null);
    
        return;
    }
            
    public static void polynomialbuild(double[] x, double[] y, out barycentricinterpolant p, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'polynomialbuild': looks like one of arguments has wrong size");
        p = new barycentricinterpolant();
        n = ap.len(x);
        polint.polynomialbuild(x, y, n, p.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Lagrange intepolant: generation of the model on equidistant grid.
    This function has O(N) complexity.

    INPUT PARAMETERS:
        A   -   left boundary of [A,B]
        B   -   right boundary of [A,B]
        Y   -   function values at the nodes, array[0..N-1]
        N   -   number of points, N>=1
                for N=1 a constant model is constructed.

    OUTPUT PARAMETERS
        P   -   barycentric model which represents Lagrange interpolant
                (see ratint unit info and BarycentricCalc() description for
                more information).

      -- ALGLIB --
         Copyright 03.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialbuildeqdist(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
        p = new barycentricinterpolant();
        polint.polynomialbuildeqdist(a, b, y, n, p.innerobj, null);
    }
    
    public static void polynomialbuildeqdist(double a, double b, double[] y, int n, out barycentricinterpolant p, alglib.xparams _params)
    {
        p = new barycentricinterpolant();
        polint.polynomialbuildeqdist(a, b, y, n, p.innerobj, _params);
    }
            
    public static void polynomialbuildeqdist(double a, double b, double[] y, out barycentricinterpolant p)
    {
        int n;
    
        p = new barycentricinterpolant();
        n = ap.len(y);
        polint.polynomialbuildeqdist(a, b, y, n, p.innerobj, null);
    
        return;
    }
            
    public static void polynomialbuildeqdist(double a, double b, double[] y, out barycentricinterpolant p, alglib.xparams _params)
    {
        int n;
    
        p = new barycentricinterpolant();
        n = ap.len(y);
        polint.polynomialbuildeqdist(a, b, y, n, p.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Lagrange intepolant on Chebyshev grid (first kind).
    This function has O(N) complexity.

    INPUT PARAMETERS:
        A   -   left boundary of [A,B]
        B   -   right boundary of [A,B]
        Y   -   function values at the nodes, array[0..N-1],
                Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
        N   -   number of points, N>=1
                for N=1 a constant model is constructed.

    OUTPUT PARAMETERS
        P   -   barycentric model which represents Lagrange interpolant
                (see ratint unit info and BarycentricCalc() description for
                more information).

      -- ALGLIB --
         Copyright 03.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialbuildcheb1(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
        p = new barycentricinterpolant();
        polint.polynomialbuildcheb1(a, b, y, n, p.innerobj, null);
    }
    
    public static void polynomialbuildcheb1(double a, double b, double[] y, int n, out barycentricinterpolant p, alglib.xparams _params)
    {
        p = new barycentricinterpolant();
        polint.polynomialbuildcheb1(a, b, y, n, p.innerobj, _params);
    }
            
    public static void polynomialbuildcheb1(double a, double b, double[] y, out barycentricinterpolant p)
    {
        int n;
    
        p = new barycentricinterpolant();
        n = ap.len(y);
        polint.polynomialbuildcheb1(a, b, y, n, p.innerobj, null);
    
        return;
    }
            
    public static void polynomialbuildcheb1(double a, double b, double[] y, out barycentricinterpolant p, alglib.xparams _params)
    {
        int n;
    
        p = new barycentricinterpolant();
        n = ap.len(y);
        polint.polynomialbuildcheb1(a, b, y, n, p.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Lagrange intepolant on Chebyshev grid (second kind).
    This function has O(N) complexity.

    INPUT PARAMETERS:
        A   -   left boundary of [A,B]
        B   -   right boundary of [A,B]
        Y   -   function values at the nodes, array[0..N-1],
                Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
        N   -   number of points, N>=1
                for N=1 a constant model is constructed.

    OUTPUT PARAMETERS
        P   -   barycentric model which represents Lagrange interpolant
                (see ratint unit info and BarycentricCalc() description for
                more information).

      -- ALGLIB --
         Copyright 03.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialbuildcheb2(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
        p = new barycentricinterpolant();
        polint.polynomialbuildcheb2(a, b, y, n, p.innerobj, null);
    }
    
    public static void polynomialbuildcheb2(double a, double b, double[] y, int n, out barycentricinterpolant p, alglib.xparams _params)
    {
        p = new barycentricinterpolant();
        polint.polynomialbuildcheb2(a, b, y, n, p.innerobj, _params);
    }
            
    public static void polynomialbuildcheb2(double a, double b, double[] y, out barycentricinterpolant p)
    {
        int n;
    
        p = new barycentricinterpolant();
        n = ap.len(y);
        polint.polynomialbuildcheb2(a, b, y, n, p.innerobj, null);
    
        return;
    }
            
    public static void polynomialbuildcheb2(double a, double b, double[] y, out barycentricinterpolant p, alglib.xparams _params)
    {
        int n;
    
        p = new barycentricinterpolant();
        n = ap.len(y);
        polint.polynomialbuildcheb2(a, b, y, n, p.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Fast equidistant polynomial interpolation function with O(N) complexity

    INPUT PARAMETERS:
        A   -   left boundary of [A,B]
        B   -   right boundary of [A,B]
        F   -   function values, array[0..N-1]
        N   -   number of points on equidistant grid, N>=1
                for N=1 a constant model is constructed.
        T   -   position where P(x) is calculated

    RESULT
        value of the Lagrange interpolant at T

    IMPORTANT
        this function provides fast interface which is not overflow-safe
        nor it is very precise.
        the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
        subroutines unless you are pretty sure that your data will not result
        in overflow.

      -- ALGLIB --
         Copyright 02.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static double polynomialcalceqdist(double a, double b, double[] f, int n, double t)
    {
    
        return polint.polynomialcalceqdist(a, b, f, n, t, null);
    }
    
    public static double polynomialcalceqdist(double a, double b, double[] f, int n, double t, alglib.xparams _params)
    {
    
        return polint.polynomialcalceqdist(a, b, f, n, t, _params);
    }
            
    public static double polynomialcalceqdist(double a, double b, double[] f, double t)
    {
        int n;
    
    
        n = ap.len(f);
        double result = polint.polynomialcalceqdist(a, b, f, n, t, null);
    
        return result;
    }
            
    public static double polynomialcalceqdist(double a, double b, double[] f, double t, alglib.xparams _params)
    {
        int n;
    
    
        n = ap.len(f);
        double result = polint.polynomialcalceqdist(a, b, f, n, t, _params);
    
        return result;
    }
    
    /*************************************************************************
    Fast polynomial interpolation function on Chebyshev points (first kind)
    with O(N) complexity.

    INPUT PARAMETERS:
        A   -   left boundary of [A,B]
        B   -   right boundary of [A,B]
        F   -   function values, array[0..N-1]
        N   -   number of points on Chebyshev grid (first kind),
                X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
                for N=1 a constant model is constructed.
        T   -   position where P(x) is calculated

    RESULT
        value of the Lagrange interpolant at T

    IMPORTANT
        this function provides fast interface which is not overflow-safe
        nor it is very precise.
        the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
        subroutines unless you are pretty sure that your data will not result
        in overflow.

      -- ALGLIB --
         Copyright 02.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static double polynomialcalccheb1(double a, double b, double[] f, int n, double t)
    {
    
        return polint.polynomialcalccheb1(a, b, f, n, t, null);
    }
    
    public static double polynomialcalccheb1(double a, double b, double[] f, int n, double t, alglib.xparams _params)
    {
    
        return polint.polynomialcalccheb1(a, b, f, n, t, _params);
    }
            
    public static double polynomialcalccheb1(double a, double b, double[] f, double t)
    {
        int n;
    
    
        n = ap.len(f);
        double result = polint.polynomialcalccheb1(a, b, f, n, t, null);
    
        return result;
    }
            
    public static double polynomialcalccheb1(double a, double b, double[] f, double t, alglib.xparams _params)
    {
        int n;
    
    
        n = ap.len(f);
        double result = polint.polynomialcalccheb1(a, b, f, n, t, _params);
    
        return result;
    }
    
    /*************************************************************************
    Fast polynomial interpolation function on Chebyshev points (second kind)
    with O(N) complexity.

    INPUT PARAMETERS:
        A   -   left boundary of [A,B]
        B   -   right boundary of [A,B]
        F   -   function values, array[0..N-1]
        N   -   number of points on Chebyshev grid (second kind),
                X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
                for N=1 a constant model is constructed.
        T   -   position where P(x) is calculated

    RESULT
        value of the Lagrange interpolant at T

    IMPORTANT
        this function provides fast interface which is not overflow-safe
        nor it is very precise.
        the best option is to use PolIntBuildCheb2()/BarycentricCalc()
        subroutines unless you are pretty sure that your data will not result
        in overflow.

      -- ALGLIB --
         Copyright 02.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static double polynomialcalccheb2(double a, double b, double[] f, int n, double t)
    {
    
        return polint.polynomialcalccheb2(a, b, f, n, t, null);
    }
    
    public static double polynomialcalccheb2(double a, double b, double[] f, int n, double t, alglib.xparams _params)
    {
    
        return polint.polynomialcalccheb2(a, b, f, n, t, _params);
    }
            
    public static double polynomialcalccheb2(double a, double b, double[] f, double t)
    {
        int n;
    
    
        n = ap.len(f);
        double result = polint.polynomialcalccheb2(a, b, f, n, t, null);
    
        return result;
    }
            
    public static double polynomialcalccheb2(double a, double b, double[] f, double t, alglib.xparams _params)
    {
        int n;
    
    
        n = ap.len(f);
        double result = polint.polynomialcalccheb2(a, b, f, n, t, _params);
    
        return result;
    }

}
public partial class alglib
{


    /*************************************************************************
    1-dimensional spline interpolant
    *************************************************************************/
    public class spline1dinterpolant : alglibobject
    {
        //
        // Public declarations
        //
    
        public spline1dinterpolant()
        {
            _innerobj = new spline1d.spline1dinterpolant();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new spline1dinterpolant((spline1d.spline1dinterpolant)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private spline1d.spline1dinterpolant _innerobj;
        public spline1d.spline1dinterpolant innerobj { get { return _innerobj; } }
        public spline1dinterpolant(spline1d.spline1dinterpolant obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    Spline fitting report:
        RMSError        RMS error
        AvgError        average error
        AvgRelError     average relative error (for non-zero Y[I])
        MaxError        maximum error

    Fields  below are  filled  by   obsolete    functions   (Spline1DFitCubic,
    Spline1DFitHermite). Modern fitting functions do NOT fill these fields:
        TaskRCond       reciprocal of task's condition number
    *************************************************************************/
    public class spline1dfitreport : alglibobject
    {
        //
        // Public declarations
        //
        public double taskrcond { get { return _innerobj.taskrcond; } set { _innerobj.taskrcond = value; } }
        public double rmserror { get { return _innerobj.rmserror; } set { _innerobj.rmserror = value; } }
        public double avgerror { get { return _innerobj.avgerror; } set { _innerobj.avgerror = value; } }
        public double avgrelerror { get { return _innerobj.avgrelerror; } set { _innerobj.avgrelerror = value; } }
        public double maxerror { get { return _innerobj.maxerror; } set { _innerobj.maxerror = value; } }
    
        public spline1dfitreport()
        {
            _innerobj = new spline1d.spline1dfitreport();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new spline1dfitreport((spline1d.spline1dfitreport)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private spline1d.spline1dfitreport _innerobj;
        public spline1d.spline1dfitreport innerobj { get { return _innerobj; } }
        public spline1dfitreport(spline1d.spline1dfitreport obj)
        {
            _innerobj = obj;
        }
    }
    
    /*************************************************************************
    This subroutine builds linear spline interpolant

    INPUT PARAMETERS:
        X   -   spline nodes, array[0..N-1]
        Y   -   function values, array[0..N-1]
        N   -   points count (optional):
                * N>=2
                * if given, only first N points are used to build spline
                * if not given, automatically detected from X/Y sizes
                  (len(X) must be equal to len(Y))

    OUTPUT PARAMETERS:
        C   -   spline interpolant


    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.

      -- ALGLIB PROJECT --
         Copyright 24.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dbuildlinear(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildlinear(x, y, n, c.innerobj, null);
    }
    
    public static void spline1dbuildlinear(double[] x, double[] y, int n, out spline1dinterpolant c, alglib.xparams _params)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildlinear(x, y, n, c.innerobj, _params);
    }
            
    public static void spline1dbuildlinear(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildlinear': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        spline1d.spline1dbuildlinear(x, y, n, c.innerobj, null);
    
        return;
    }
            
    public static void spline1dbuildlinear(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildlinear': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        spline1d.spline1dbuildlinear(x, y, n, c.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    This subroutine builds cubic spline interpolant.

    INPUT PARAMETERS:
        X           -   spline nodes, array[0..N-1].
        Y           -   function values, array[0..N-1].

    OPTIONAL PARAMETERS:
        N           -   points count:
                        * N>=2
                        * if given, only first N points are used to build spline
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))
        BoundLType  -   boundary condition type for the left boundary
        BoundL      -   left boundary condition (first or second derivative,
                        depending on the BoundLType)
        BoundRType  -   boundary condition type for the right boundary
        BoundR      -   right boundary condition (first or second derivative,
                        depending on the BoundRType)

    OUTPUT PARAMETERS:
        C           -   spline interpolant

    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.

    SETTING BOUNDARY VALUES:

    The BoundLType/BoundRType parameters can have the following values:
        * -1, which corresonds to the periodic (cyclic) boundary conditions.
              In this case:
              * both BoundLType and BoundRType must be equal to -1.
              * BoundL/BoundR are ignored
              * Y[last] is ignored (it is assumed to be equal to Y[first]).
        *  0, which  corresponds  to  the  parabolically   terminated  spline
              (BoundL and/or BoundR are ignored).
        *  1, which corresponds to the first derivative boundary condition
        *  2, which corresponds to the second derivative boundary condition
        *  by default, BoundType=0 is used

    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
    However, this subroutine doesn't require you to specify equal  values  for
    the first and last points - it automatically forces them  to  be  equal by
    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
    Y[last_point]. However it is recommended to pass consistent values of Y[],
    i.e. to make Y[first_point]=Y[last_point].

      -- ALGLIB PROJECT --
         Copyright 23.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dbuildcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out spline1dinterpolant c)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr, c.innerobj, null);
    }
    
    public static void spline1dbuildcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out spline1dinterpolant c, alglib.xparams _params)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr, c.innerobj, _params);
    }
            
    public static void spline1dbuildcubic(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildcubic': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        spline1d.spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr, c.innerobj, null);
    
        return;
    }
            
    public static void spline1dbuildcubic(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _params)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildcubic': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        spline1d.spline1dbuildcubic(x, y, n, boundltype, boundl, boundrtype, boundr, c.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    This function solves following problem: given table y[] of function values
    at nodes x[], it calculates and returns table of function derivatives  d[]
    (calculated at the same nodes x[]).

    This function yields same result as Spline1DBuildCubic() call followed  by
    sequence of Spline1DDiff() calls, but it can be several times faster  when
    called for ordered X[] and X2[].

    INPUT PARAMETERS:
        X           -   spline nodes
        Y           -   function values

    OPTIONAL PARAMETERS:
        N           -   points count:
                        * N>=2
                        * if given, only first N points are used
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))
        BoundLType  -   boundary condition type for the left boundary
        BoundL      -   left boundary condition (first or second derivative,
                        depending on the BoundLType)
        BoundRType  -   boundary condition type for the right boundary
        BoundR      -   right boundary condition (first or second derivative,
                        depending on the BoundRType)

    OUTPUT PARAMETERS:
        D           -   derivative values at X[]

    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.
    Derivative values are correctly reordered on return, so  D[I]  is  always
    equal to S'(X[I]) independently of points order.

    SETTING BOUNDARY VALUES:

    The BoundLType/BoundRType parameters can have the following values:
        * -1, which corresonds to the periodic (cyclic) boundary conditions.
              In this case:
              * both BoundLType and BoundRType must be equal to -1.
              * BoundL/BoundR are ignored
              * Y[last] is ignored (it is assumed to be equal to Y[first]).
        *  0, which  corresponds  to  the  parabolically   terminated  spline
              (BoundL and/or BoundR are ignored).
        *  1, which corresponds to the first derivative boundary condition
        *  2, which corresponds to the second derivative boundary condition
        *  by default, BoundType=0 is used

    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
    However, this subroutine doesn't require you to specify equal  values  for
    the first and last points - it automatically forces them  to  be  equal by
    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
    Y[last_point]. However it is recommended to pass consistent values of Y[],
    i.e. to make Y[first_point]=Y[last_point].

      -- ALGLIB PROJECT --
         Copyright 03.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dgriddiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d)
    {
        d = new double[0];
        spline1d.spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, ref d, null);
    }
    
    public static void spline1dgriddiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d, alglib.xparams _params)
    {
        d = new double[0];
        spline1d.spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, ref d, _params);
    }
            
    public static void spline1dgriddiffcubic(double[] x, double[] y, out double[] d)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dgriddiffcubic': looks like one of arguments has wrong size");
        d = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        spline1d.spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, ref d, null);
    
        return;
    }
            
    public static void spline1dgriddiffcubic(double[] x, double[] y, out double[] d, alglib.xparams _params)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dgriddiffcubic': looks like one of arguments has wrong size");
        d = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        spline1d.spline1dgriddiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, ref d, _params);
    
        return;
    }
    
    /*************************************************************************
    This function solves following problem: given table y[] of function values
    at  nodes  x[],  it  calculates  and  returns  tables  of first and second
    function derivatives d1[] and d2[] (calculated at the same nodes x[]).

    This function yields same result as Spline1DBuildCubic() call followed  by
    sequence of Spline1DDiff() calls, but it can be several times faster  when
    called for ordered X[] and X2[].

    INPUT PARAMETERS:
        X           -   spline nodes
        Y           -   function values

    OPTIONAL PARAMETERS:
        N           -   points count:
                        * N>=2
                        * if given, only first N points are used
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))
        BoundLType  -   boundary condition type for the left boundary
        BoundL      -   left boundary condition (first or second derivative,
                        depending on the BoundLType)
        BoundRType  -   boundary condition type for the right boundary
        BoundR      -   right boundary condition (first or second derivative,
                        depending on the BoundRType)

    OUTPUT PARAMETERS:
        D1          -   S' values at X[]
        D2          -   S'' values at X[]

    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.
    Derivative values are correctly reordered on return, so  D[I]  is  always
    equal to S'(X[I]) independently of points order.

    SETTING BOUNDARY VALUES:

    The BoundLType/BoundRType parameters can have the following values:
        * -1, which corresonds to the periodic (cyclic) boundary conditions.
              In this case:
              * both BoundLType and BoundRType must be equal to -1.
              * BoundL/BoundR are ignored
              * Y[last] is ignored (it is assumed to be equal to Y[first]).
        *  0, which  corresponds  to  the  parabolically   terminated  spline
              (BoundL and/or BoundR are ignored).
        *  1, which corresponds to the first derivative boundary condition
        *  2, which corresponds to the second derivative boundary condition
        *  by default, BoundType=0 is used

    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
    However, this subroutine doesn't require you to specify equal  values  for
    the first and last points - it automatically forces them  to  be  equal by
    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
    Y[last_point]. However it is recommended to pass consistent values of Y[],
    i.e. to make Y[first_point]=Y[last_point].

      -- ALGLIB PROJECT --
         Copyright 03.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dgriddiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d1, out double[] d2)
    {
        d1 = new double[0];
        d2 = new double[0];
        spline1d.spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, ref d1, ref d2, null);
    }
    
    public static void spline1dgriddiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d1, out double[] d2, alglib.xparams _params)
    {
        d1 = new double[0];
        d2 = new double[0];
        spline1d.spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, ref d1, ref d2, _params);
    }
            
    public static void spline1dgriddiff2cubic(double[] x, double[] y, out double[] d1, out double[] d2)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dgriddiff2cubic': looks like one of arguments has wrong size");
        d1 = new double[0];
        d2 = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        spline1d.spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, ref d1, ref d2, null);
    
        return;
    }
            
    public static void spline1dgriddiff2cubic(double[] x, double[] y, out double[] d1, out double[] d2, alglib.xparams _params)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dgriddiff2cubic': looks like one of arguments has wrong size");
        d1 = new double[0];
        d2 = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        spline1d.spline1dgriddiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, ref d1, ref d2, _params);
    
        return;
    }
    
    /*************************************************************************
    This function solves following problem: given table y[] of function values
    at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
    function values y2[] (calculated at x2[]).

    This function yields same result as Spline1DBuildCubic() call followed  by
    sequence of Spline1DDiff() calls, but it can be several times faster  when
    called for ordered X[] and X2[].

    INPUT PARAMETERS:
        X           -   old spline nodes
        Y           -   function values
        X2           -  new spline nodes

    OPTIONAL PARAMETERS:
        N           -   points count:
                        * N>=2
                        * if given, only first N points from X/Y are used
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))
        BoundLType  -   boundary condition type for the left boundary
        BoundL      -   left boundary condition (first or second derivative,
                        depending on the BoundLType)
        BoundRType  -   boundary condition type for the right boundary
        BoundR      -   right boundary condition (first or second derivative,
                        depending on the BoundRType)
        N2          -   new points count:
                        * N2>=2
                        * if given, only first N2 points from X2 are used
                        * if not given, automatically detected from X2 size

    OUTPUT PARAMETERS:
        F2          -   function values at X2[]

    ORDER OF POINTS

    Subroutine automatically sorts points, so caller  may pass unsorted array.
    Function  values  are correctly reordered on  return, so F2[I]  is  always
    equal to S(X2[I]) independently of points order.

    SETTING BOUNDARY VALUES:

    The BoundLType/BoundRType parameters can have the following values:
        * -1, which corresonds to the periodic (cyclic) boundary conditions.
              In this case:
              * both BoundLType and BoundRType must be equal to -1.
              * BoundL/BoundR are ignored
              * Y[last] is ignored (it is assumed to be equal to Y[first]).
        *  0, which  corresponds  to  the  parabolically   terminated  spline
              (BoundL and/or BoundR are ignored).
        *  1, which corresponds to the first derivative boundary condition
        *  2, which corresponds to the second derivative boundary condition
        *  by default, BoundType=0 is used

    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
    However, this subroutine doesn't require you to specify equal  values  for
    the first and last points - it automatically forces them  to  be  equal by
    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
    Y[last_point]. However it is recommended to pass consistent values of Y[],
    i.e. to make Y[first_point]=Y[last_point].

      -- ALGLIB PROJECT --
         Copyright 03.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dconvcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2)
    {
        y2 = new double[0];
        spline1d.spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, null);
    }
    
    public static void spline1dconvcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, alglib.xparams _params)
    {
        y2 = new double[0];
        spline1d.spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, _params);
    }
            
    public static void spline1dconvcubic(double[] x, double[] y, double[] x2, out double[] y2)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvcubic': looks like one of arguments has wrong size");
        y2 = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        spline1d.spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, null);
    
        return;
    }
            
    public static void spline1dconvcubic(double[] x, double[] y, double[] x2, out double[] y2, alglib.xparams _params)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvcubic': looks like one of arguments has wrong size");
        y2 = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        spline1d.spline1dconvcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, _params);
    
        return;
    }
    
    /*************************************************************************
    This function solves following problem: given table y[] of function values
    at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
    function values y2[] and derivatives d2[] (calculated at x2[]).

    This function yields same result as Spline1DBuildCubic() call followed  by
    sequence of Spline1DDiff() calls, but it can be several times faster  when
    called for ordered X[] and X2[].

    INPUT PARAMETERS:
        X           -   old spline nodes
        Y           -   function values
        X2           -  new spline nodes

    OPTIONAL PARAMETERS:
        N           -   points count:
                        * N>=2
                        * if given, only first N points from X/Y are used
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))
        BoundLType  -   boundary condition type for the left boundary
        BoundL      -   left boundary condition (first or second derivative,
                        depending on the BoundLType)
        BoundRType  -   boundary condition type for the right boundary
        BoundR      -   right boundary condition (first or second derivative,
                        depending on the BoundRType)
        N2          -   new points count:
                        * N2>=2
                        * if given, only first N2 points from X2 are used
                        * if not given, automatically detected from X2 size

    OUTPUT PARAMETERS:
        F2          -   function values at X2[]
        D2          -   first derivatives at X2[]

    ORDER OF POINTS

    Subroutine automatically sorts points, so caller  may pass unsorted array.
    Function  values  are correctly reordered on  return, so F2[I]  is  always
    equal to S(X2[I]) independently of points order.

    SETTING BOUNDARY VALUES:

    The BoundLType/BoundRType parameters can have the following values:
        * -1, which corresonds to the periodic (cyclic) boundary conditions.
              In this case:
              * both BoundLType and BoundRType must be equal to -1.
              * BoundL/BoundR are ignored
              * Y[last] is ignored (it is assumed to be equal to Y[first]).
        *  0, which  corresponds  to  the  parabolically   terminated  spline
              (BoundL and/or BoundR are ignored).
        *  1, which corresponds to the first derivative boundary condition
        *  2, which corresponds to the second derivative boundary condition
        *  by default, BoundType=0 is used

    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
    However, this subroutine doesn't require you to specify equal  values  for
    the first and last points - it automatically forces them  to  be  equal by
    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
    Y[last_point]. However it is recommended to pass consistent values of Y[],
    i.e. to make Y[first_point]=Y[last_point].

      -- ALGLIB PROJECT --
         Copyright 03.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dconvdiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2)
    {
        y2 = new double[0];
        d2 = new double[0];
        spline1d.spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, ref d2, null);
    }
    
    public static void spline1dconvdiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, alglib.xparams _params)
    {
        y2 = new double[0];
        d2 = new double[0];
        spline1d.spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, ref d2, _params);
    }
            
    public static void spline1dconvdiffcubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvdiffcubic': looks like one of arguments has wrong size");
        y2 = new double[0];
        d2 = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        spline1d.spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, ref d2, null);
    
        return;
    }
            
    public static void spline1dconvdiffcubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2, alglib.xparams _params)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvdiffcubic': looks like one of arguments has wrong size");
        y2 = new double[0];
        d2 = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        spline1d.spline1dconvdiffcubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, ref d2, _params);
    
        return;
    }
    
    /*************************************************************************
    This function solves following problem: given table y[] of function values
    at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
    function  values  y2[],  first  and  second  derivatives  d2[]  and  dd2[]
    (calculated at x2[]).

    This function yields same result as Spline1DBuildCubic() call followed  by
    sequence of Spline1DDiff() calls, but it can be several times faster  when
    called for ordered X[] and X2[].

    INPUT PARAMETERS:
        X           -   old spline nodes
        Y           -   function values
        X2           -  new spline nodes

    OPTIONAL PARAMETERS:
        N           -   points count:
                        * N>=2
                        * if given, only first N points from X/Y are used
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))
        BoundLType  -   boundary condition type for the left boundary
        BoundL      -   left boundary condition (first or second derivative,
                        depending on the BoundLType)
        BoundRType  -   boundary condition type for the right boundary
        BoundR      -   right boundary condition (first or second derivative,
                        depending on the BoundRType)
        N2          -   new points count:
                        * N2>=2
                        * if given, only first N2 points from X2 are used
                        * if not given, automatically detected from X2 size

    OUTPUT PARAMETERS:
        F2          -   function values at X2[]
        D2          -   first derivatives at X2[]
        DD2         -   second derivatives at X2[]

    ORDER OF POINTS

    Subroutine automatically sorts points, so caller  may pass unsorted array.
    Function  values  are correctly reordered on  return, so F2[I]  is  always
    equal to S(X2[I]) independently of points order.

    SETTING BOUNDARY VALUES:

    The BoundLType/BoundRType parameters can have the following values:
        * -1, which corresonds to the periodic (cyclic) boundary conditions.
              In this case:
              * both BoundLType and BoundRType must be equal to -1.
              * BoundL/BoundR are ignored
              * Y[last] is ignored (it is assumed to be equal to Y[first]).
        *  0, which  corresponds  to  the  parabolically   terminated  spline
              (BoundL and/or BoundR are ignored).
        *  1, which corresponds to the first derivative boundary condition
        *  2, which corresponds to the second derivative boundary condition
        *  by default, BoundType=0 is used

    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
    However, this subroutine doesn't require you to specify equal  values  for
    the first and last points - it automatically forces them  to  be  equal by
    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
    Y[last_point]. However it is recommended to pass consistent values of Y[],
    i.e. to make Y[first_point]=Y[last_point].

      -- ALGLIB PROJECT --
         Copyright 03.09.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dconvdiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, out double[] dd2)
    {
        y2 = new double[0];
        d2 = new double[0];
        dd2 = new double[0];
        spline1d.spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, ref d2, ref dd2, null);
    }
    
    public static void spline1dconvdiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, out double[] dd2, alglib.xparams _params)
    {
        y2 = new double[0];
        d2 = new double[0];
        dd2 = new double[0];
        spline1d.spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, ref d2, ref dd2, _params);
    }
            
    public static void spline1dconvdiff2cubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2, out double[] dd2)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvdiff2cubic': looks like one of arguments has wrong size");
        y2 = new double[0];
        d2 = new double[0];
        dd2 = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        spline1d.spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, ref d2, ref dd2, null);
    
        return;
    }
            
    public static void spline1dconvdiff2cubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2, out double[] dd2, alglib.xparams _params)
    {
        int n;
        int boundltype;
        double boundl;
        int boundrtype;
        double boundr;
        int n2;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dconvdiff2cubic': looks like one of arguments has wrong size");
        y2 = new double[0];
        d2 = new double[0];
        dd2 = new double[0];
        n = ap.len(x);
        boundltype = 0;
        boundl = 0;
        boundrtype = 0;
        boundr = 0;
        n2 = ap.len(x2);
        spline1d.spline1dconvdiff2cubic(x, y, n, boundltype, boundl, boundrtype, boundr, x2, n2, ref y2, ref d2, ref dd2, _params);
    
        return;
    }
    
    /*************************************************************************
    This subroutine builds Catmull-Rom spline interpolant.

    INPUT PARAMETERS:
        X           -   spline nodes, array[0..N-1].
        Y           -   function values, array[0..N-1].

    OPTIONAL PARAMETERS:
        N           -   points count:
                        * N>=2
                        * if given, only first N points are used to build spline
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))
        BoundType   -   boundary condition type:
                        * -1 for periodic boundary condition
                        *  0 for parabolically terminated spline (default)
        Tension     -   tension parameter:
                        * tension=0   corresponds to classic Catmull-Rom spline (default)
                        * 0<tension<1 corresponds to more general form - cardinal spline

    OUTPUT PARAMETERS:
        C           -   spline interpolant


    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.

    PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

    Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
    However, this subroutine doesn't require you to specify equal  values  for
    the first and last points - it automatically forces them  to  be  equal by
    copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
    Y[last_point]. However it is recommended to pass consistent values of Y[],
    i.e. to make Y[first_point]=Y[last_point].

      -- ALGLIB PROJECT --
         Copyright 23.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dbuildcatmullrom(double[] x, double[] y, int n, int boundtype, double tension, out spline1dinterpolant c)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildcatmullrom(x, y, n, boundtype, tension, c.innerobj, null);
    }
    
    public static void spline1dbuildcatmullrom(double[] x, double[] y, int n, int boundtype, double tension, out spline1dinterpolant c, alglib.xparams _params)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildcatmullrom(x, y, n, boundtype, tension, c.innerobj, _params);
    }
            
    public static void spline1dbuildcatmullrom(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        int boundtype;
        double tension;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildcatmullrom': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        boundtype = 0;
        tension = 0;
        spline1d.spline1dbuildcatmullrom(x, y, n, boundtype, tension, c.innerobj, null);
    
        return;
    }
            
    public static void spline1dbuildcatmullrom(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _params)
    {
        int n;
        int boundtype;
        double tension;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildcatmullrom': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        boundtype = 0;
        tension = 0;
        spline1d.spline1dbuildcatmullrom(x, y, n, boundtype, tension, c.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    This subroutine builds Hermite spline interpolant.

    INPUT PARAMETERS:
        X           -   spline nodes, array[0..N-1]
        Y           -   function values, array[0..N-1]
        D           -   derivatives, array[0..N-1]
        N           -   points count (optional):
                        * N>=2
                        * if given, only first N points are used to build spline
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))

    OUTPUT PARAMETERS:
        C           -   spline interpolant.


    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.

      -- ALGLIB PROJECT --
         Copyright 23.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, int n, out spline1dinterpolant c)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildhermite(x, y, d, n, c.innerobj, null);
    }
    
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, int n, out spline1dinterpolant c, alglib.xparams _params)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildhermite(x, y, d, n, c.innerobj, _params);
    }
            
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, out spline1dinterpolant c)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(d)))
            throw new alglibexception("Error while calling 'spline1dbuildhermite': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        spline1d.spline1dbuildhermite(x, y, d, n, c.innerobj, null);
    
        return;
    }
            
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, out spline1dinterpolant c, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(d)))
            throw new alglibexception("Error while calling 'spline1dbuildhermite': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        spline1d.spline1dbuildhermite(x, y, d, n, c.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    This subroutine builds Akima spline interpolant

    INPUT PARAMETERS:
        X           -   spline nodes, array[0..N-1]
        Y           -   function values, array[0..N-1]
        N           -   points count (optional):
                        * N>=2
                        * if given, only first N points are used to build spline
                        * if not given, automatically detected from X/Y sizes
                          (len(X) must be equal to len(Y))

    OUTPUT PARAMETERS:
        C           -   spline interpolant


    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.

      -- ALGLIB PROJECT --
         Copyright 24.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dbuildakima(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildakima(x, y, n, c.innerobj, null);
    }
    
    public static void spline1dbuildakima(double[] x, double[] y, int n, out spline1dinterpolant c, alglib.xparams _params)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildakima(x, y, n, c.innerobj, _params);
    }
            
    public static void spline1dbuildakima(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildakima': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        spline1d.spline1dbuildakima(x, y, n, c.innerobj, null);
    
        return;
    }
            
    public static void spline1dbuildakima(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildakima': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        spline1d.spline1dbuildakima(x, y, n, c.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    This subroutine calculates the value of the spline at the given point X.

    INPUT PARAMETERS:
        C   -   spline interpolant
        X   -   point

    Result:
        S(x)

      -- ALGLIB PROJECT --
         Copyright 23.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static double spline1dcalc(spline1dinterpolant c, double x)
    {
    
        return spline1d.spline1dcalc(c.innerobj, x, null);
    }
    
    public static double spline1dcalc(spline1dinterpolant c, double x, alglib.xparams _params)
    {
    
        return spline1d.spline1dcalc(c.innerobj, x, _params);
    }
    
    /*************************************************************************
    This subroutine differentiates the spline.

    INPUT PARAMETERS:
        C   -   spline interpolant.
        X   -   point

    Result:
        S   -   S(x)
        DS  -   S'(x)
        D2S -   S''(x)

      -- ALGLIB PROJECT --
         Copyright 24.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1ddiff(spline1dinterpolant c, double x, out double s, out double ds, out double d2s)
    {
        s = 0;
        ds = 0;
        d2s = 0;
        spline1d.spline1ddiff(c.innerobj, x, ref s, ref ds, ref d2s, null);
    }
    
    public static void spline1ddiff(spline1dinterpolant c, double x, out double s, out double ds, out double d2s, alglib.xparams _params)
    {
        s = 0;
        ds = 0;
        d2s = 0;
        spline1d.spline1ddiff(c.innerobj, x, ref s, ref ds, ref d2s, _params);
    }
    
    /*************************************************************************
    This subroutine unpacks the spline into the coefficients table.

    INPUT PARAMETERS:
        C   -   spline interpolant.
        X   -   point

    OUTPUT PARAMETERS:
        Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
                For I = 0...N-2:
                    Tbl[I,0] = X[i]
                    Tbl[I,1] = X[i+1]
                    Tbl[I,2] = C0
                    Tbl[I,3] = C1
                    Tbl[I,4] = C2
                    Tbl[I,5] = C3
                On [x[i], x[i+1]] spline is equals to:
                    S(x) = C0 + C1*t + C2*t^2 + C3*t^3
                    t = x-x[i]

    NOTE:
        You  can rebuild spline with  Spline1DBuildHermite()  function,  which
        accepts as inputs function values and derivatives at nodes, which  are
        easy to calculate when you have coefficients.

      -- ALGLIB PROJECT --
         Copyright 29.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dunpack(spline1dinterpolant c, out int n, out double[,] tbl)
    {
        n = 0;
        tbl = new double[0,0];
        spline1d.spline1dunpack(c.innerobj, ref n, ref tbl, null);
    }
    
    public static void spline1dunpack(spline1dinterpolant c, out int n, out double[,] tbl, alglib.xparams _params)
    {
        n = 0;
        tbl = new double[0,0];
        spline1d.spline1dunpack(c.innerobj, ref n, ref tbl, _params);
    }
    
    /*************************************************************************
    This subroutine performs linear transformation of the spline argument.

    INPUT PARAMETERS:
        C   -   spline interpolant.
        A, B-   transformation coefficients: x = A*t + B
    Result:
        C   -   transformed spline

      -- ALGLIB PROJECT --
         Copyright 30.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dlintransx(spline1dinterpolant c, double a, double b)
    {
    
        spline1d.spline1dlintransx(c.innerobj, a, b, null);
    }
    
    public static void spline1dlintransx(spline1dinterpolant c, double a, double b, alglib.xparams _params)
    {
    
        spline1d.spline1dlintransx(c.innerobj, a, b, _params);
    }
    
    /*************************************************************************
    This subroutine performs linear transformation of the spline.

    INPUT PARAMETERS:
        C   -   spline interpolant.
        A, B-   transformation coefficients: S2(x) = A*S(x) + B
    Result:
        C   -   transformed spline

      -- ALGLIB PROJECT --
         Copyright 30.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dlintransy(spline1dinterpolant c, double a, double b)
    {
    
        spline1d.spline1dlintransy(c.innerobj, a, b, null);
    }
    
    public static void spline1dlintransy(spline1dinterpolant c, double a, double b, alglib.xparams _params)
    {
    
        spline1d.spline1dlintransy(c.innerobj, a, b, _params);
    }
    
    /*************************************************************************
    This subroutine integrates the spline.

    INPUT PARAMETERS:
        C   -   spline interpolant.
        X   -   right bound of the integration interval [a, x],
                here 'a' denotes min(x[])
    Result:
        integral(S(t)dt,a,x)

      -- ALGLIB PROJECT --
         Copyright 23.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static double spline1dintegrate(spline1dinterpolant c, double x)
    {
    
        return spline1d.spline1dintegrate(c.innerobj, x, null);
    }
    
    public static double spline1dintegrate(spline1dinterpolant c, double x, alglib.xparams _params)
    {
    
        return spline1d.spline1dintegrate(c.innerobj, x, _params);
    }
    
    /*************************************************************************
    Fitting by smoothing (penalized) cubic spline.

    This function approximates N scattered points (some of X[] may be equal to
    each other) by cubic spline with M  nodes  at  equidistant  grid  spanning
    interval [min(x,xc),max(x,xc)].

    The problem is regularized by adding nonlinearity penalty to  usual  least
    squares penalty function:

        MERIT_FUNC = F_LS + F_NL

    where F_LS is a least squares error  term,  and  F_NL  is  a  nonlinearity
    penalty which is roughly proportional to LambdaNS*integral{ S''(x)^2*dx }.
    Algorithm applies automatic renormalization of F_NL  which  makes  penalty
    term roughly invariant to scaling of X[] and changes in M.

    This function is a new edition  of  penalized  regression  spline fitting,
    a fast and compact one which needs much less resources that  its  previous
    version: just O(maxMN) memory and O(maxMN*log(maxMN)) time.

    NOTE: it is OK to run this function with both M<<N and M>>N;  say,  it  is
          possible to process 100 points with 1000-node spline.

    INPUT PARAMETERS:
        X           -   points, array[0..N-1].
        Y           -   function values, array[0..N-1].
        N           -   number of points (optional):
                        * N>0
                        * if given, only first N elements of X/Y are processed
                        * if not given, automatically determined from lengths
        M           -   number of basis functions ( = number_of_nodes), M>=4.
        LambdaNS    -   LambdaNS>=0, regularization  constant  passed by user.
                        It penalizes nonlinearity in the regression spline.
                        Possible values to start from are 0.00001, 0.1, 1

    OUTPUT PARAMETERS:
        S   -   spline interpolant.
        Rep -   Following fields are set:
                * RMSError      rms error on the (X,Y).
                * AvgError      average error on the (X,Y).
                * AvgRelError   average relative error on the non-zero Y
                * MaxError      maximum error

      -- ALGLIB PROJECT --
         Copyright 27.08.2019 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dfit(double[] x, double[] y, int n, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        spline1d.spline1dfit(x, y, n, m, lambdans, s.innerobj, rep.innerobj, null);
    }
    
    public static void spline1dfit(double[] x, double[] y, int n, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        spline1d.spline1dfit(x, y, n, m, lambdans, s.innerobj, rep.innerobj, _params);
    }
            
    public static void spline1dfit(double[] x, double[] y, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfit': looks like one of arguments has wrong size");
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        spline1d.spline1dfit(x, y, n, m, lambdans, s.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void spline1dfit(double[] x, double[] y, int m, double lambdans, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfit': looks like one of arguments has wrong size");
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        spline1d.spline1dfit(x, y, n, m, lambdans, s.innerobj, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    This function builds monotone cubic Hermite interpolant. This interpolant
    is monotonic in [x(0),x(n-1)] and is constant outside of this interval.

    In  case  y[]  form  non-monotonic  sequence,  interpolant  is  piecewise
    monotonic.  Say, for x=(0,1,2,3,4)  and  y=(0,1,2,1,0)  interpolant  will
    monotonically grow at [0..2] and monotonically decrease at [2..4].

    INPUT PARAMETERS:
        X           -   spline nodes, array[0..N-1]. Subroutine automatically
                        sorts points, so caller may pass unsorted array.
        Y           -   function values, array[0..N-1]
        N           -   the number of points(N>=2).

    OUTPUT PARAMETERS:
        C           -   spline interpolant.

     -- ALGLIB PROJECT --
         Copyright 21.06.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dbuildmonotone(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildmonotone(x, y, n, c.innerobj, null);
    }
    
    public static void spline1dbuildmonotone(double[] x, double[] y, int n, out spline1dinterpolant c, alglib.xparams _params)
    {
        c = new spline1dinterpolant();
        spline1d.spline1dbuildmonotone(x, y, n, c.innerobj, _params);
    }
            
    public static void spline1dbuildmonotone(double[] x, double[] y, out spline1dinterpolant c)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildmonotone': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        spline1d.spline1dbuildmonotone(x, y, n, c.innerobj, null);
    
        return;
    }
            
    public static void spline1dbuildmonotone(double[] x, double[] y, out spline1dinterpolant c, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dbuildmonotone': looks like one of arguments has wrong size");
        c = new spline1dinterpolant();
        n = ap.len(x);
        spline1d.spline1dbuildmonotone(x, y, n, c.innerobj, _params);
    
        return;
    }

}
public partial class alglib
{


    /*************************************************************************
    Polynomial fitting report:
        TaskRCond       reciprocal of task's condition number
        RMSError        RMS error
        AvgError        average error
        AvgRelError     average relative error (for non-zero Y[I])
        MaxError        maximum error
    *************************************************************************/
    public class polynomialfitreport : alglibobject
    {
        //
        // Public declarations
        //
        public double taskrcond { get { return _innerobj.taskrcond; } set { _innerobj.taskrcond = value; } }
        public double rmserror { get { return _innerobj.rmserror; } set { _innerobj.rmserror = value; } }
        public double avgerror { get { return _innerobj.avgerror; } set { _innerobj.avgerror = value; } }
        public double avgrelerror { get { return _innerobj.avgrelerror; } set { _innerobj.avgrelerror = value; } }
        public double maxerror { get { return _innerobj.maxerror; } set { _innerobj.maxerror = value; } }
    
        public polynomialfitreport()
        {
            _innerobj = new lsfit.polynomialfitreport();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new polynomialfitreport((lsfit.polynomialfitreport)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private lsfit.polynomialfitreport _innerobj;
        public lsfit.polynomialfitreport innerobj { get { return _innerobj; } }
        public polynomialfitreport(lsfit.polynomialfitreport obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    Barycentric fitting report:
        RMSError        RMS error
        AvgError        average error
        AvgRelError     average relative error (for non-zero Y[I])
        MaxError        maximum error
        TaskRCond       reciprocal of task's condition number
    *************************************************************************/
    public class barycentricfitreport : alglibobject
    {
        //
        // Public declarations
        //
        public double taskrcond { get { return _innerobj.taskrcond; } set { _innerobj.taskrcond = value; } }
        public int dbest { get { return _innerobj.dbest; } set { _innerobj.dbest = value; } }
        public double rmserror { get { return _innerobj.rmserror; } set { _innerobj.rmserror = value; } }
        public double avgerror { get { return _innerobj.avgerror; } set { _innerobj.avgerror = value; } }
        public double avgrelerror { get { return _innerobj.avgrelerror; } set { _innerobj.avgrelerror = value; } }
        public double maxerror { get { return _innerobj.maxerror; } set { _innerobj.maxerror = value; } }
    
        public barycentricfitreport()
        {
            _innerobj = new lsfit.barycentricfitreport();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new barycentricfitreport((lsfit.barycentricfitreport)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private lsfit.barycentricfitreport _innerobj;
        public lsfit.barycentricfitreport innerobj { get { return _innerobj; } }
        public barycentricfitreport(lsfit.barycentricfitreport obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    Least squares fitting report. This structure contains informational fields
    which are set by fitting functions provided by this unit.

    Different functions initialize different sets of  fields,  so  you  should
    read documentation on specific function you used in order  to  know  which
    fields are initialized.

        TaskRCond       reciprocal of task's condition number
        IterationsCount number of internal iterations

        VarIdx          if user-supplied gradient contains errors  which  were
                        detected by nonlinear fitter, this  field  is  set  to
                        index  of  the  first  component  of gradient which is
                        suspected to be spoiled by bugs.

        RMSError        RMS error
        AvgError        average error
        AvgRelError     average relative error (for non-zero Y[I])
        MaxError        maximum error

        WRMSError       weighted RMS error

        CovPar          covariance matrix for parameters, filled by some solvers
        ErrPar          vector of errors in parameters, filled by some solvers
        ErrCurve        vector of fit errors -  variability  of  the  best-fit
                        curve, filled by some solvers.
        Noise           vector of per-point noise estimates, filled by
                        some solvers.
        R2              coefficient of determination (non-weighted, non-adjusted),
                        filled by some solvers.
    *************************************************************************/
    public class lsfitreport : alglibobject
    {
        //
        // Public declarations
        //
        public double taskrcond { get { return _innerobj.taskrcond; } set { _innerobj.taskrcond = value; } }
        public int iterationscount { get { return _innerobj.iterationscount; } set { _innerobj.iterationscount = value; } }
        public int varidx { get { return _innerobj.varidx; } set { _innerobj.varidx = value; } }
        public double rmserror { get { return _innerobj.rmserror; } set { _innerobj.rmserror = value; } }
        public double avgerror { get { return _innerobj.avgerror; } set { _innerobj.avgerror = value; } }
        public double avgrelerror { get { return _innerobj.avgrelerror; } set { _innerobj.avgrelerror = value; } }
        public double maxerror { get { return _innerobj.maxerror; } set { _innerobj.maxerror = value; } }
        public double wrmserror { get { return _innerobj.wrmserror; } set { _innerobj.wrmserror = value; } }
        public double[,] covpar { get { return _innerobj.covpar; } set { _innerobj.covpar = value; } }
        public double[] errpar { get { return _innerobj.errpar; } set { _innerobj.errpar = value; } }
        public double[] errcurve { get { return _innerobj.errcurve; } set { _innerobj.errcurve = value; } }
        public double[] noise { get { return _innerobj.noise; } set { _innerobj.noise = value; } }
        public double r2 { get { return _innerobj.r2; } set { _innerobj.r2 = value; } }
    
        public lsfitreport()
        {
            _innerobj = new lsfit.lsfitreport();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new lsfitreport((lsfit.lsfitreport)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private lsfit.lsfitreport _innerobj;
        public lsfit.lsfitreport innerobj { get { return _innerobj; } }
        public lsfitreport(lsfit.lsfitreport obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    Nonlinear fitter.

    You should use ALGLIB functions to work with fitter.
    Never try to access its fields directly!
    *************************************************************************/
    public class lsfitstate : alglibobject
    {
        //
        // Public declarations
        //
        public bool needf { get { return _innerobj.needf; } set { _innerobj.needf = value; } }
        public bool needfg { get { return _innerobj.needfg; } set { _innerobj.needfg = value; } }
        public bool needfgh { get { return _innerobj.needfgh; } set { _innerobj.needfgh = value; } }
        public bool xupdated { get { return _innerobj.xupdated; } set { _innerobj.xupdated = value; } }
        public double[] c { get { return _innerobj.c; } }
        public double f { get { return _innerobj.f; } set { _innerobj.f = value; } }
        public double[] g { get { return _innerobj.g; } }
        public double[,] h { get { return _innerobj.h; } }
        public double[] x { get { return _innerobj.x; } }
    
        public lsfitstate()
        {
            _innerobj = new lsfit.lsfitstate();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new lsfitstate((lsfit.lsfitstate)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private lsfit.lsfitstate _innerobj;
        public lsfit.lsfitstate innerobj { get { return _innerobj; } }
        public lsfitstate(lsfit.lsfitstate obj)
        {
            _innerobj = obj;
        }
    }
    
    /*************************************************************************
    This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
    Peucker algorithm, which stops after generating specified number of linear
    sections.

    IMPORTANT:
    * it does NOT perform least-squares fitting; it  builds  curve,  but  this
      curve does not minimize some least squares metric.  See  description  of
      RDP algorithm (say, in Wikipedia) for more details on WHAT is performed.
    * this function does NOT work with parametric curves  (i.e.  curves  which
      can be represented as {X(t),Y(t)}. It works with curves   which  can  be
      represented as Y(X). Thus,  it  is  impossible  to  model  figures  like
      circles  with  this  functions.
      If  you  want  to  work  with  parametric   curves,   you   should   use
      ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
      "Interpolation" package.

    INPUT PARAMETERS:
        X       -   array of X-coordinates:
                    * at least N elements
                    * can be unordered (points are automatically sorted)
                    * this function may accept non-distinct X (see below for
                      more information on handling of such inputs)
        Y       -   array of Y-coordinates:
                    * at least N elements
        N       -   number of elements in X/Y
        M       -   desired number of sections:
                    * at most M sections are generated by this function
                    * less than M sections can be generated if we have N<M
                      (or some X are non-distinct).

    OUTPUT PARAMETERS:
        X2      -   X-values of corner points for piecewise approximation,
                    has length NSections+1 or zero (for NSections=0).
        Y2      -   Y-values of corner points,
                    has length NSections+1 or zero (for NSections=0).
        NSections-  number of sections found by algorithm, NSections<=M,
                    NSections can be zero for degenerate datasets
                    (N<=1 or all X[] are non-distinct).

    NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
          curve, (X2[NSection-1],Y2[NSection-1]) is the last point.

      -- ALGLIB --
         Copyright 02.10.2014 by Bochkanov Sergey
    *************************************************************************/
    public static void lstfitpiecewiselinearrdpfixed(double[] x, double[] y, int n, int m, out double[] x2, out double[] y2, out int nsections)
    {
        x2 = new double[0];
        y2 = new double[0];
        nsections = 0;
        lsfit.lstfitpiecewiselinearrdpfixed(x, y, n, m, ref x2, ref y2, ref nsections, null);
    }
    
    public static void lstfitpiecewiselinearrdpfixed(double[] x, double[] y, int n, int m, out double[] x2, out double[] y2, out int nsections, alglib.xparams _params)
    {
        x2 = new double[0];
        y2 = new double[0];
        nsections = 0;
        lsfit.lstfitpiecewiselinearrdpfixed(x, y, n, m, ref x2, ref y2, ref nsections, _params);
    }
    
    /*************************************************************************
    This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
    Peucker algorithm, which stops after achieving desired precision.

    IMPORTANT:
    * it performs non-least-squares fitting; it builds curve, but  this  curve
      does not minimize some least squares  metric.  See  description  of  RDP
      algorithm (say, in Wikipedia) for more details on WHAT is performed.
    * this function does NOT work with parametric curves  (i.e.  curves  which
      can be represented as {X(t),Y(t)}. It works with curves   which  can  be
      represented as Y(X). Thus, it is impossible to model figures like circles
      with this functions.
      If  you  want  to  work  with  parametric   curves,   you   should   use
      ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
      "Interpolation" package.

    INPUT PARAMETERS:
        X       -   array of X-coordinates:
                    * at least N elements
                    * can be unordered (points are automatically sorted)
                    * this function may accept non-distinct X (see below for
                      more information on handling of such inputs)
        Y       -   array of Y-coordinates:
                    * at least N elements
        N       -   number of elements in X/Y
        Eps     -   positive number, desired precision.


    OUTPUT PARAMETERS:
        X2      -   X-values of corner points for piecewise approximation,
                    has length NSections+1 or zero (for NSections=0).
        Y2      -   Y-values of corner points,
                    has length NSections+1 or zero (for NSections=0).
        NSections-  number of sections found by algorithm,
                    NSections can be zero for degenerate datasets
                    (N<=1 or all X[] are non-distinct).

    NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
          curve, (X2[NSection-1],Y2[NSection-1]) is the last point.

      -- ALGLIB --
         Copyright 02.10.2014 by Bochkanov Sergey
    *************************************************************************/
    public static void lstfitpiecewiselinearrdp(double[] x, double[] y, int n, double eps, out double[] x2, out double[] y2, out int nsections)
    {
        x2 = new double[0];
        y2 = new double[0];
        nsections = 0;
        lsfit.lstfitpiecewiselinearrdp(x, y, n, eps, ref x2, ref y2, ref nsections, null);
    }
    
    public static void lstfitpiecewiselinearrdp(double[] x, double[] y, int n, double eps, out double[] x2, out double[] y2, out int nsections, alglib.xparams _params)
    {
        x2 = new double[0];
        y2 = new double[0];
        nsections = 0;
        lsfit.lstfitpiecewiselinearrdp(x, y, n, eps, ref x2, ref y2, ref nsections, _params);
    }
    
    /*************************************************************************
    Fitting by polynomials in barycentric form. This function provides  simple
    unterface for unconstrained unweighted fitting. See  PolynomialFitWC()  if
    you need constrained fitting.

    The task is linear, thus the linear least  squares  solver  is  used.  The
    complexity of this computational scheme is O(N*M^2), mostly  dominated  by
    the least squares solver

    SEE ALSO:
        PolynomialFitWC()

    NOTES:
        you can convert P from barycentric form  to  the  power  or  Chebyshev
        basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
        POLINT subpackage.

    INPUT PARAMETERS:
        X   -   points, array[0..N-1].
        Y   -   function values, array[0..N-1].
        N   -   number of points, N>0
                * if given, only leading N elements of X/Y are used
                * if not given, automatically determined from sizes of X/Y
        M   -   number of basis functions (= polynomial_degree + 1), M>=1

    OUTPUT PARAMETERS:
        Info-   same format as in LSFitLinearW() subroutine:
                * Info>0    task is solved
                * Info<=0   an error occured:
                            -4 means inconvergence of internal SVD
        P   -   interpolant in barycentric form.
        Rep -   report, same format as in LSFitLinearW() subroutine.
                Following fields are set:
                * RMSError      rms error on the (X,Y).
                * AvgError      average error on the (X,Y).
                * AvgRelError   average relative error on the non-zero Y
                * MaxError      maximum error
                                NON-WEIGHTED ERRORS ARE CALCULATED

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB PROJECT --
         Copyright 10.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialfit(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
        info = 0;
        p = new barycentricinterpolant();
        rep = new polynomialfitreport();
        lsfit.polynomialfit(x, y, n, m, ref info, p.innerobj, rep.innerobj, null);
    }
    
    public static void polynomialfit(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglib.xparams _params)
    {
        info = 0;
        p = new barycentricinterpolant();
        rep = new polynomialfitreport();
        lsfit.polynomialfit(x, y, n, m, ref info, p.innerobj, rep.innerobj, _params);
    }
            
    public static void polynomialfit(double[] x, double[] y, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'polynomialfit': looks like one of arguments has wrong size");
        info = 0;
        p = new barycentricinterpolant();
        rep = new polynomialfitreport();
        n = ap.len(x);
        lsfit.polynomialfit(x, y, n, m, ref info, p.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void polynomialfit(double[] x, double[] y, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'polynomialfit': looks like one of arguments has wrong size");
        info = 0;
        p = new barycentricinterpolant();
        rep = new polynomialfitreport();
        n = ap.len(x);
        lsfit.polynomialfit(x, y, n, m, ref info, p.innerobj, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Weighted  fitting by polynomials in barycentric form, with constraints  on
    function values or first derivatives.

    Small regularizing term is used when solving constrained tasks (to improve
    stability).

    Task is linear, so linear least squares solver is used. Complexity of this
    computational scheme is O(N*M^2), mostly dominated by least squares solver

    SEE ALSO:
        PolynomialFit()

    NOTES:
        you can convert P from barycentric form  to  the  power  or  Chebyshev
        basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
        POLINT subpackage.

    INPUT PARAMETERS:
        X   -   points, array[0..N-1].
        Y   -   function values, array[0..N-1].
        W   -   weights, array[0..N-1]
                Each summand in square  sum  of  approximation deviations from
                given  values  is  multiplied  by  the square of corresponding
                weight. Fill it by 1's if you don't  want  to  solve  weighted
                task.
        N   -   number of points, N>0.
                * if given, only leading N elements of X/Y/W are used
                * if not given, automatically determined from sizes of X/Y/W
        XC  -   points where polynomial values/derivatives are constrained,
                array[0..K-1].
        YC  -   values of constraints, array[0..K-1]
        DC  -   array[0..K-1], types of constraints:
                * DC[i]=0   means that P(XC[i])=YC[i]
                * DC[i]=1   means that P'(XC[i])=YC[i]
                SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
        K   -   number of constraints, 0<=K<M.
                K=0 means no constraints (XC/YC/DC are not used in such cases)
        M   -   number of basis functions (= polynomial_degree + 1), M>=1

    OUTPUT PARAMETERS:
        Info-   same format as in LSFitLinearW() subroutine:
                * Info>0    task is solved
                * Info<=0   an error occured:
                            -4 means inconvergence of internal SVD
                            -3 means inconsistent constraints
        P   -   interpolant in barycentric form.
        Rep -   report, same format as in LSFitLinearW() subroutine.
                Following fields are set:
                * RMSError      rms error on the (X,Y).
                * AvgError      average error on the (X,Y).
                * AvgRelError   average relative error on the non-zero Y
                * MaxError      maximum error
                                NON-WEIGHTED ERRORS ARE CALCULATED

    IMPORTANT:
        this subroitine doesn't calculate task's condition number for K<>0.

    SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

    Setting constraints can lead  to undesired  results,  like ill-conditioned
    behavior, or inconsistency being detected. From the other side,  it allows
    us to improve quality of the fit. Here we summarize  our  experience  with
    constrained regression splines:
    * even simple constraints can be inconsistent, see  Wikipedia  article  on
      this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
    * the  greater  is  M (given  fixed  constraints),  the  more chances that
      constraints will be consistent
    * in the general case, consistency of constraints is NOT GUARANTEED.
    * in the one special cases, however, we can  guarantee  consistency.  This
      case  is:  M>1  and constraints on the function values (NOT DERIVATIVES)

    Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
    can't solve your task without them. Anything beyond  special  cases  given
    above is not guaranteed and may result in inconsistency.

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB PROJECT --
         Copyright 10.12.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void polynomialfitwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
        info = 0;
        p = new barycentricinterpolant();
        rep = new polynomialfitreport();
        lsfit.polynomialfitwc(x, y, w, n, xc, yc, dc, k, m, ref info, p.innerobj, rep.innerobj, null);
    }
    
    public static void polynomialfitwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglib.xparams _params)
    {
        info = 0;
        p = new barycentricinterpolant();
        rep = new polynomialfitreport();
        lsfit.polynomialfitwc(x, y, w, n, xc, yc, dc, k, m, ref info, p.innerobj, rep.innerobj, _params);
    }
            
    public static void polynomialfitwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
        info = 0;
        p = new barycentricinterpolant();
        rep = new polynomialfitreport();
        n = ap.len(x);
        k = ap.len(xc);
        lsfit.polynomialfitwc(x, y, w, n, xc, yc, dc, k, m, ref info, p.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void polynomialfitwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglib.xparams _params)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
        info = 0;
        p = new barycentricinterpolant();
        rep = new polynomialfitreport();
        n = ap.len(x);
        k = ap.len(xc);
        lsfit.polynomialfitwc(x, y, w, n, xc, yc, dc, k, m, ref info, p.innerobj, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    This function calculates value of four-parameter logistic (4PL)  model  at
    specified point X. 4PL model has following form:

        F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

    INPUT PARAMETERS:
        X       -   current point, X>=0:
                    * zero X is correctly handled even for B<=0
                    * negative X results in exception.
        A, B, C, D- parameters of 4PL model:
                    * A is unconstrained
                    * B is unconstrained; zero or negative values are handled
                      correctly.
                    * C>0, non-positive value results in exception
                    * D is unconstrained

    RESULT:
        model value at X

    NOTE: if B=0, denominator is assumed to be equal to 2.0 even  for  zero  X
          (strictly speaking, 0^0 is undefined).

    NOTE: this function also throws exception  if  all  input  parameters  are
          correct, but overflow was detected during calculations.

    NOTE: this function performs a lot of checks;  if  you  need  really  high
          performance, consider evaluating model  yourself,  without  checking
          for degenerate cases.


      -- ALGLIB PROJECT --
         Copyright 14.05.2014 by Bochkanov Sergey
    *************************************************************************/
    public static double logisticcalc4(double x, double a, double b, double c, double d)
    {
    
        return lsfit.logisticcalc4(x, a, b, c, d, null);
    }
    
    public static double logisticcalc4(double x, double a, double b, double c, double d, alglib.xparams _params)
    {
    
        return lsfit.logisticcalc4(x, a, b, c, d, _params);
    }
    
    /*************************************************************************
    This function calculates value of five-parameter logistic (5PL)  model  at
    specified point X. 5PL model has following form:

        F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

    INPUT PARAMETERS:
        X       -   current point, X>=0:
                    * zero X is correctly handled even for B<=0
                    * negative X results in exception.
        A, B, C, D, G- parameters of 5PL model:
                    * A is unconstrained
                    * B is unconstrained; zero or negative values are handled
                      correctly.
                    * C>0, non-positive value results in exception
                    * D is unconstrained
                    * G>0, non-positive value results in exception

    RESULT:
        model value at X

    NOTE: if B=0, denominator is assumed to be equal to Power(2.0,G) even  for
          zero X (strictly speaking, 0^0 is undefined).

    NOTE: this function also throws exception  if  all  input  parameters  are
          correct, but overflow was detected during calculations.

    NOTE: this function performs a lot of checks;  if  you  need  really  high
          performance, consider evaluating model  yourself,  without  checking
          for degenerate cases.


      -- ALGLIB PROJECT --
         Copyright 14.05.2014 by Bochkanov Sergey
    *************************************************************************/
    public static double logisticcalc5(double x, double a, double b, double c, double d, double g)
    {
    
        return lsfit.logisticcalc5(x, a, b, c, d, g, null);
    }
    
    public static double logisticcalc5(double x, double a, double b, double c, double d, double g, alglib.xparams _params)
    {
    
        return lsfit.logisticcalc5(x, a, b, c, d, g, _params);
    }
    
    /*************************************************************************
    This function fits four-parameter logistic (4PL) model  to  data  provided
    by user. 4PL model has following form:

        F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

    Here:
        * A, D - unconstrained (see LogisticFit4EC() for constrained 4PL)
        * B>=0
        * C>0

    IMPORTANT: output of this function is constrained in  such  way that  B>0.
               Because 4PL model is symmetric with respect to B, there  is  no
               need to explore  B<0.  Constraining  B  makes  algorithm easier
               to stabilize and debug.
               Users  who  for  some  reason  prefer to work with negative B's
               should transform output themselves (swap A and D, replace B  by
               -B).

    4PL fitting is implemented as follows:
    * we perform small number of restarts from random locations which helps to
      solve problem of bad local extrema. Locations are only partially  random
      - we use input data to determine good  initial  guess,  but  we  include
      controlled amount of randomness.
    * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
      parameters B and C - it allows us to find good  initial  guess  for  the
      second stage without risk of running into "flat spot".
    * second  Levenberg-Marquardt  round  is   performed   without   excessive
      constraints. Results from the previous round are used as initial guess.
    * after fitting is done, we compare results with best values found so far,
      rewrite "best solution" if needed, and move to next random location.

    Overall algorithm is very stable and is not prone to  bad  local  extrema.
    Furthermore, it automatically scales when input data have  very  large  or
    very small range.

    INPUT PARAMETERS:
        X       -   array[N], stores X-values.
                    MUST include only non-negative numbers  (but  may  include
                    zero values). Can be unsorted.
        Y       -   array[N], values to fit.
        N       -   number of points. If N is less than  length  of  X/Y, only
                    leading N elements are used.

    OUTPUT PARAMETERS:
        A, B, C, D- parameters of 4PL model
        Rep     -   fitting report. This structure has many fields,  but  ONLY
                    ONES LISTED BELOW ARE SET:
                    * Rep.IterationsCount - number of iterations performed
                    * Rep.RMSError - root-mean-square error
                    * Rep.AvgError - average absolute error
                    * Rep.AvgRelError - average relative error (calculated for
                      non-zero Y-values)
                    * Rep.MaxError - maximum absolute error
                    * Rep.R2 - coefficient of determination,  R-squared.  This
                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                      of nonlinear  regression  there  are  multiple  ways  to
                      define R2, each of them giving different results).

    NOTE: for stability reasons the B parameter is restricted by [1/1000,1000]
          range. It prevents  algorithm from making trial steps  deep into the
          area of bad parameters.

    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
          LogisticCalc4() function.

    NOTE: if you need better control over fitting process than provided by this
          function, you may use LogisticFit45X().

    NOTE: step is automatically scaled according to scale of parameters  being
          fitted before we compare its length with EpsX. Thus,  this  function
          can be used to fit data with very small or very large values without
          changing EpsX.


      -- ALGLIB PROJECT --
         Copyright 14.02.2014 by Bochkanov Sergey
    *************************************************************************/
    public static void logisticfit4(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out lsfitreport rep)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        rep = new lsfitreport();
        lsfit.logisticfit4(x, y, n, ref a, ref b, ref c, ref d, rep.innerobj, null);
    }
    
    public static void logisticfit4(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out lsfitreport rep, alglib.xparams _params)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        rep = new lsfitreport();
        lsfit.logisticfit4(x, y, n, ref a, ref b, ref c, ref d, rep.innerobj, _params);
    }
    
    /*************************************************************************
    This function fits four-parameter logistic (4PL) model  to  data  provided
    by user, with optional constraints on parameters A and D.  4PL  model  has
    following form:

        F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

    Here:
        * A, D - with optional equality constraints
        * B>=0
        * C>0

    IMPORTANT: output of this function is constrained in  such  way that  B>0.
               Because 4PL model is symmetric with respect to B, there  is  no
               need to explore  B<0.  Constraining  B  makes  algorithm easier
               to stabilize and debug.
               Users  who  for  some  reason  prefer to work with negative B's
               should transform output themselves (swap A and D, replace B  by
               -B).

    4PL fitting is implemented as follows:
    * we perform small number of restarts from random locations which helps to
      solve problem of bad local extrema. Locations are only partially  random
      - we use input data to determine good  initial  guess,  but  we  include
      controlled amount of randomness.
    * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
      parameters B and C - it allows us to find good  initial  guess  for  the
      second stage without risk of running into "flat spot".
    * second  Levenberg-Marquardt  round  is   performed   without   excessive
      constraints. Results from the previous round are used as initial guess.
    * after fitting is done, we compare results with best values found so far,
      rewrite "best solution" if needed, and move to next random location.

    Overall algorithm is very stable and is not prone to  bad  local  extrema.
    Furthermore, it automatically scales when input data have  very  large  or
    very small range.

    INPUT PARAMETERS:
        X       -   array[N], stores X-values.
                    MUST include only non-negative numbers  (but  may  include
                    zero values). Can be unsorted.
        Y       -   array[N], values to fit.
        N       -   number of points. If N is less than  length  of  X/Y, only
                    leading N elements are used.
        CnstrLeft-  optional equality constraint for model value at the   left
                    boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                    not need constraint on the model value at X=0 (in C++  you
                    can pass alglib::fp_nan as parameter, in  C#  it  will  be
                    Double.NaN).
                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                    information about constraints.
        CnstrRight- optional equality constraint for model value at X=infinity.
                    Specify NAN (Not-a-Number) if you do not  need  constraint
                    on the model value (in C++  you can pass alglib::fp_nan as
                    parameter, in  C# it will  be Double.NaN).
                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                    information about constraints.

    OUTPUT PARAMETERS:
        A, B, C, D- parameters of 4PL model
        Rep     -   fitting report. This structure has many fields,  but  ONLY
                    ONES LISTED BELOW ARE SET:
                    * Rep.IterationsCount - number of iterations performed
                    * Rep.RMSError - root-mean-square error
                    * Rep.AvgError - average absolute error
                    * Rep.AvgRelError - average relative error (calculated for
                      non-zero Y-values)
                    * Rep.MaxError - maximum absolute error
                    * Rep.R2 - coefficient of determination,  R-squared.  This
                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                      of nonlinear  regression  there  are  multiple  ways  to
                      define R2, each of them giving different results).

    NOTE: for stability reasons the B parameter is restricted by [1/1000,1000]
          range. It prevents  algorithm from making trial steps  deep into the
          area of bad parameters.

    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
          LogisticCalc4() function.

    NOTE: if you need better control over fitting process than provided by this
          function, you may use LogisticFit45X().

    NOTE: step is automatically scaled according to scale of parameters  being
          fitted before we compare its length with EpsX. Thus,  this  function
          can be used to fit data with very small or very large values without
          changing EpsX.

    EQUALITY CONSTRAINTS ON PARAMETERS

    4PL/5PL solver supports equality constraints on model values at  the  left
    boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
    completely optional and you can specify both of them, only  one  -  or  no
    constraints at all.

    Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
    fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
    ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
    D. That's because 4PL model is normalized in such way that B>=0.


      -- ALGLIB PROJECT --
         Copyright 14.02.2014 by Bochkanov Sergey
    *************************************************************************/
    public static void logisticfit4ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out lsfitreport rep)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        rep = new lsfitreport();
        lsfit.logisticfit4ec(x, y, n, cnstrleft, cnstrright, ref a, ref b, ref c, ref d, rep.innerobj, null);
    }
    
    public static void logisticfit4ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out lsfitreport rep, alglib.xparams _params)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        rep = new lsfitreport();
        lsfit.logisticfit4ec(x, y, n, cnstrleft, cnstrright, ref a, ref b, ref c, ref d, rep.innerobj, _params);
    }
    
    /*************************************************************************
    This function fits five-parameter logistic (5PL) model  to  data  provided
    by user. 5PL model has following form:

        F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

    Here:
        * A, D - unconstrained
        * B - unconstrained
        * C>0
        * G>0

    IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
               constrained in  such  way that B is guaranteed to be  positive.
               Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
               respect to B, so you can NOT transform model to equivalent one,
               with B having desired sign (>0 or <0).

    5PL fitting is implemented as follows:
    * we perform small number of restarts from random locations which helps to
      solve problem of bad local extrema. Locations are only partially  random
      - we use input data to determine good  initial  guess,  but  we  include
      controlled amount of randomness.
    * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
      parameters B and C - it allows us to find good  initial  guess  for  the
      second stage without risk of running into "flat spot".  Parameter  G  is
      fixed at G=1.
    * second  Levenberg-Marquardt  round  is   performed   without   excessive
      constraints on B and C, but with G still equal to 1.  Results  from  the
      previous round are used as initial guess.
    * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
      different models - one with B>0 and one with B<0.
    * after fitting is done, we compare results with best values found so far,
      rewrite "best solution" if needed, and move to next random location.

    Overall algorithm is very stable and is not prone to  bad  local  extrema.
    Furthermore, it automatically scales when input data have  very  large  or
    very small range.

    INPUT PARAMETERS:
        X       -   array[N], stores X-values.
                    MUST include only non-negative numbers  (but  may  include
                    zero values). Can be unsorted.
        Y       -   array[N], values to fit.
        N       -   number of points. If N is less than  length  of  X/Y, only
                    leading N elements are used.

    OUTPUT PARAMETERS:
        A,B,C,D,G-  parameters of 5PL model
        Rep     -   fitting report. This structure has many fields,  but  ONLY
                    ONES LISTED BELOW ARE SET:
                    * Rep.IterationsCount - number of iterations performed
                    * Rep.RMSError - root-mean-square error
                    * Rep.AvgError - average absolute error
                    * Rep.AvgRelError - average relative error (calculated for
                      non-zero Y-values)
                    * Rep.MaxError - maximum absolute error
                    * Rep.R2 - coefficient of determination,  R-squared.  This
                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                      of nonlinear  regression  there  are  multiple  ways  to
                      define R2, each of them giving different results).

    NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
          range, and G is restricted by [1/10,10] range. It prevents algorithm
          from making trial steps deep into the area of bad parameters.

    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
          LogisticCalc5() function.

    NOTE: if you need better control over fitting process than provided by this
          function, you may use LogisticFit45X().

    NOTE: step is automatically scaled according to scale of parameters  being
          fitted before we compare its length with EpsX. Thus,  this  function
          can be used to fit data with very small or very large values without
          changing EpsX.


      -- ALGLIB PROJECT --
         Copyright 14.02.2014 by Bochkanov Sergey
    *************************************************************************/
    public static void logisticfit5(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        g = 0;
        rep = new lsfitreport();
        lsfit.logisticfit5(x, y, n, ref a, ref b, ref c, ref d, ref g, rep.innerobj, null);
    }
    
    public static void logisticfit5(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglib.xparams _params)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        g = 0;
        rep = new lsfitreport();
        lsfit.logisticfit5(x, y, n, ref a, ref b, ref c, ref d, ref g, rep.innerobj, _params);
    }
    
    /*************************************************************************
    This function fits five-parameter logistic (5PL) model  to  data  provided
    by user, subject to optional equality constraints on parameters A  and  D.
    5PL model has following form:

        F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

    Here:
        * A, D - with optional equality constraints
        * B - unconstrained
        * C>0
        * G>0

    IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
               constrained in  such  way that B is guaranteed to be  positive.
               Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
               respect to B, so you can NOT transform model to equivalent one,
               with B having desired sign (>0 or <0).

    5PL fitting is implemented as follows:
    * we perform small number of restarts from random locations which helps to
      solve problem of bad local extrema. Locations are only partially  random
      - we use input data to determine good  initial  guess,  but  we  include
      controlled amount of randomness.
    * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
      parameters B and C - it allows us to find good  initial  guess  for  the
      second stage without risk of running into "flat spot".  Parameter  G  is
      fixed at G=1.
    * second  Levenberg-Marquardt  round  is   performed   without   excessive
      constraints on B and C, but with G still equal to 1.  Results  from  the
      previous round are used as initial guess.
    * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
      different models - one with B>0 and one with B<0.
    * after fitting is done, we compare results with best values found so far,
      rewrite "best solution" if needed, and move to next random location.

    Overall algorithm is very stable and is not prone to  bad  local  extrema.
    Furthermore, it automatically scales when input data have  very  large  or
    very small range.

    INPUT PARAMETERS:
        X       -   array[N], stores X-values.
                    MUST include only non-negative numbers  (but  may  include
                    zero values). Can be unsorted.
        Y       -   array[N], values to fit.
        N       -   number of points. If N is less than  length  of  X/Y, only
                    leading N elements are used.
        CnstrLeft-  optional equality constraint for model value at the   left
                    boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                    not need constraint on the model value at X=0 (in C++  you
                    can pass alglib::fp_nan as parameter, in  C#  it  will  be
                    Double.NaN).
                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                    information about constraints.
        CnstrRight- optional equality constraint for model value at X=infinity.
                    Specify NAN (Not-a-Number) if you do not  need  constraint
                    on the model value (in C++  you can pass alglib::fp_nan as
                    parameter, in  C# it will  be Double.NaN).
                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                    information about constraints.

    OUTPUT PARAMETERS:
        A,B,C,D,G-  parameters of 5PL model
        Rep     -   fitting report. This structure has many fields,  but  ONLY
                    ONES LISTED BELOW ARE SET:
                    * Rep.IterationsCount - number of iterations performed
                    * Rep.RMSError - root-mean-square error
                    * Rep.AvgError - average absolute error
                    * Rep.AvgRelError - average relative error (calculated for
                      non-zero Y-values)
                    * Rep.MaxError - maximum absolute error
                    * Rep.R2 - coefficient of determination,  R-squared.  This
                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                      of nonlinear  regression  there  are  multiple  ways  to
                      define R2, each of them giving different results).

    NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
          range, and G is restricted by [1/10,10] range. It prevents algorithm
          from making trial steps deep into the area of bad parameters.

    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
          LogisticCalc5() function.

    NOTE: if you need better control over fitting process than provided by this
          function, you may use LogisticFit45X().

    NOTE: step is automatically scaled according to scale of parameters  being
          fitted before we compare its length with EpsX. Thus,  this  function
          can be used to fit data with very small or very large values without
          changing EpsX.

    EQUALITY CONSTRAINTS ON PARAMETERS

    5PL solver supports equality constraints on model  values  at   the   left
    boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
    completely optional and you can specify both of them, only  one  -  or  no
    constraints at all.

    Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
    fitting), and CnstrRight contains right  one.

    Unlike 4PL one, 5PL model is NOT symmetric with respect to  change in sign
    of B. Thus, negative B's are possible, and left constraint  may  constrain
    parameter A (for positive B's)  -  or  parameter  D  (for  negative  B's).
    Similarly changes meaning of right constraint.

    You do not have to decide what parameter to  constrain  -  algorithm  will
    automatically determine correct parameters as fitting progresses. However,
    question highlighted above is important when you interpret fitting results.


      -- ALGLIB PROJECT --
         Copyright 14.02.2014 by Bochkanov Sergey
    *************************************************************************/
    public static void logisticfit5ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        g = 0;
        rep = new lsfitreport();
        lsfit.logisticfit5ec(x, y, n, cnstrleft, cnstrright, ref a, ref b, ref c, ref d, ref g, rep.innerobj, null);
    }
    
    public static void logisticfit5ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglib.xparams _params)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        g = 0;
        rep = new lsfitreport();
        lsfit.logisticfit5ec(x, y, n, cnstrleft, cnstrright, ref a, ref b, ref c, ref d, ref g, rep.innerobj, _params);
    }
    
    /*************************************************************************
    This is "expert" 4PL/5PL fitting function, which can be used if  you  need
    better control over fitting process than provided  by  LogisticFit4()  or
    LogisticFit5().

    This function fits model of the form

        F(x|A,B,C,D)   = D+(A-D)/(1+Power(x/C,B))           (4PL model)

    or

        F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)    (5PL model)

    Here:
        * A, D - unconstrained
        * B>=0 for 4PL, unconstrained for 5PL
        * C>0
        * G>0 (if present)

    INPUT PARAMETERS:
        X       -   array[N], stores X-values.
                    MUST include only non-negative numbers  (but  may  include
                    zero values). Can be unsorted.
        Y       -   array[N], values to fit.
        N       -   number of points. If N is less than  length  of  X/Y, only
                    leading N elements are used.
        CnstrLeft-  optional equality constraint for model value at the   left
                    boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                    not need constraint on the model value at X=0 (in C++  you
                    can pass alglib::fp_nan as parameter, in  C#  it  will  be
                    Double.NaN).
                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                    information about constraints.
        CnstrRight- optional equality constraint for model value at X=infinity.
                    Specify NAN (Not-a-Number) if you do not  need  constraint
                    on the model value (in C++  you can pass alglib::fp_nan as
                    parameter, in  C# it will  be Double.NaN).
                    See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                    information about constraints.
        Is4PL   -   whether 4PL or 5PL models are fitted
        LambdaV -   regularization coefficient, LambdaV>=0.
                    Set it to zero unless you know what you are doing.
        EpsX    -   stopping condition (step size), EpsX>=0.
                    Zero value means that small step is automatically chosen.
                    See notes below for more information.
        RsCnt   -   number of repeated restarts from  random  points.  4PL/5PL
                    models are prone to problem of bad local extrema. Utilizing
                    multiple random restarts allows  us  to  improve algorithm
                    convergence.
                    RsCnt>=0.
                    Zero value means that function automatically choose  small
                    amount of restarts (recommended).

    OUTPUT PARAMETERS:
        A, B, C, D- parameters of 4PL model
        G       -   parameter of 5PL model; for Is4PL=True, G=1 is returned.
        Rep     -   fitting report. This structure has many fields,  but  ONLY
                    ONES LISTED BELOW ARE SET:
                    * Rep.IterationsCount - number of iterations performed
                    * Rep.RMSError - root-mean-square error
                    * Rep.AvgError - average absolute error
                    * Rep.AvgRelError - average relative error (calculated for
                      non-zero Y-values)
                    * Rep.MaxError - maximum absolute error
                    * Rep.R2 - coefficient of determination,  R-squared.  This
                      coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                      of nonlinear  regression  there  are  multiple  ways  to
                      define R2, each of them giving different results).

    NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
          range, and G is restricted by [1/10,10] range. It prevents algorithm
          from making trial steps deep into the area of bad parameters.

    NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
          LogisticCalc5() function.

    NOTE: step is automatically scaled according to scale of parameters  being
          fitted before we compare its length with EpsX. Thus,  this  function
          can be used to fit data with very small or very large values without
          changing EpsX.

    EQUALITY CONSTRAINTS ON PARAMETERS

    4PL/5PL solver supports equality constraints on model values at  the  left
    boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
    completely optional and you can specify both of them, only  one  -  or  no
    constraints at all.

    Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
    fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
    ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
    D. That's because 4PL model is normalized in such way that B>=0.

    For 5PL model things are different. Unlike  4PL  one,  5PL  model  is  NOT
    symmetric with respect to  change  in  sign  of  B. Thus, negative B's are
    possible, and left constraint may constrain parameter A (for positive B's)
    - or parameter D (for negative B's). Similarly changes  meaning  of  right
    constraint.

    You do not have to decide what parameter to  constrain  -  algorithm  will
    automatically determine correct parameters as fitting progresses. However,
    question highlighted above is important when you interpret fitting results.


      -- ALGLIB PROJECT --
         Copyright 14.02.2014 by Bochkanov Sergey
    *************************************************************************/
    public static void logisticfit45x(double[] x, double[] y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        g = 0;
        rep = new lsfitreport();
        lsfit.logisticfit45x(x, y, n, cnstrleft, cnstrright, is4pl, lambdav, epsx, rscnt, ref a, ref b, ref c, ref d, ref g, rep.innerobj, null);
    }
    
    public static void logisticfit45x(double[] x, double[] y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglib.xparams _params)
    {
        a = 0;
        b = 0;
        c = 0;
        d = 0;
        g = 0;
        rep = new lsfitreport();
        lsfit.logisticfit45x(x, y, n, cnstrleft, cnstrright, is4pl, lambdav, epsx, rscnt, ref a, ref b, ref c, ref d, ref g, rep.innerobj, _params);
    }
    
    /*************************************************************************
    Weghted rational least  squares  fitting  using  Floater-Hormann  rational
    functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
    individual weights.

    Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
    functions. Different values of D are tried, optimal D (least WEIGHTED root
    mean square error) is chosen.  Task  is  linear,  so  linear least squares
    solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
    (mostly dominated by the least squares solver).

    SEE ALSO
    * BarycentricFitFloaterHormann(), "lightweight" fitting without invididual
      weights and constraints.

    INPUT PARAMETERS:
        X   -   points, array[0..N-1].
        Y   -   function values, array[0..N-1].
        W   -   weights, array[0..N-1]
                Each summand in square  sum  of  approximation deviations from
                given  values  is  multiplied  by  the square of corresponding
                weight. Fill it by 1's if you don't  want  to  solve  weighted
                task.
        N   -   number of points, N>0.
        XC  -   points where function values/derivatives are constrained,
                array[0..K-1].
        YC  -   values of constraints, array[0..K-1]
        DC  -   array[0..K-1], types of constraints:
                * DC[i]=0   means that S(XC[i])=YC[i]
                * DC[i]=1   means that S'(XC[i])=YC[i]
                SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
        K   -   number of constraints, 0<=K<M.
                K=0 means no constraints (XC/YC/DC are not used in such cases)
        M   -   number of basis functions ( = number_of_nodes), M>=2.

    OUTPUT PARAMETERS:
        Info-   same format as in LSFitLinearWC() subroutine.
                * Info>0    task is solved
                * Info<=0   an error occured:
                            -4 means inconvergence of internal SVD
                            -3 means inconsistent constraints
                            -1 means another errors in parameters passed
                               (N<=0, for example)
        B   -   barycentric interpolant.
        Rep -   report, same format as in LSFitLinearWC() subroutine.
                Following fields are set:
                * DBest         best value of the D parameter
                * RMSError      rms error on the (X,Y).
                * AvgError      average error on the (X,Y).
                * AvgRelError   average relative error on the non-zero Y
                * MaxError      maximum error
                                NON-WEIGHTED ERRORS ARE CALCULATED

    IMPORTANT:
        this subroutine doesn't calculate task's condition number for K<>0.

    SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

    Setting constraints can lead  to undesired  results,  like ill-conditioned
    behavior, or inconsistency being detected. From the other side,  it allows
    us to improve quality of the fit. Here we summarize  our  experience  with
    constrained barycentric interpolants:
    * excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
      functions aren't as flexible as splines (although they are very smooth).
    * the more evenly constraints are spread across [min(x),max(x)],  the more
      chances that they will be consistent
    * the  greater  is  M (given  fixed  constraints),  the  more chances that
      constraints will be consistent
    * in the general case, consistency of constraints IS NOT GUARANTEED.
    * in the several special cases, however, we CAN guarantee consistency.
    * one of this cases is constraints on the function  VALUES at the interval
      boundaries. Note that consustency of the  constraints  on  the  function
      DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
      which are more flexible).
    * another  special  case  is ONE constraint on the function value (OR, but
      not AND, derivative) anywhere in the interval

    Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
    can't solve your task without them. Anything beyond  special  cases  given
    above is not guaranteed and may result in inconsistency.

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB PROJECT --
         Copyright 18.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentricfitfloaterhormannwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep)
    {
        info = 0;
        b = new barycentricinterpolant();
        rep = new barycentricfitreport();
        lsfit.barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, dc, k, m, ref info, b.innerobj, rep.innerobj, null);
    }
    
    public static void barycentricfitfloaterhormannwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep, alglib.xparams _params)
    {
        info = 0;
        b = new barycentricinterpolant();
        rep = new barycentricfitreport();
        lsfit.barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, dc, k, m, ref info, b.innerobj, rep.innerobj, _params);
    }
    
    /*************************************************************************
    Rational least squares fitting using  Floater-Hormann  rational  functions
    with optimal D chosen from [0,9].

    Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
    functions. Different values of D are tried, optimal  D  (least  root  mean
    square error) is chosen.  Task  is  linear, so linear least squares solver
    is used. Complexity  of  this  computational  scheme is  O(N*M^2)  (mostly
    dominated by the least squares solver).

    INPUT PARAMETERS:
        X   -   points, array[0..N-1].
        Y   -   function values, array[0..N-1].
        N   -   number of points, N>0.
        M   -   number of basis functions ( = number_of_nodes), M>=2.

    OUTPUT PARAMETERS:
        Info-   same format as in LSFitLinearWC() subroutine.
                * Info>0    task is solved
                * Info<=0   an error occured:
                            -4 means inconvergence of internal SVD
                            -3 means inconsistent constraints
        B   -   barycentric interpolant.
        Rep -   report, same format as in LSFitLinearWC() subroutine.
                Following fields are set:
                * DBest         best value of the D parameter
                * RMSError      rms error on the (X,Y).
                * AvgError      average error on the (X,Y).
                * AvgRelError   average relative error on the non-zero Y
                * MaxError      maximum error
                                NON-WEIGHTED ERRORS ARE CALCULATED

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB PROJECT --
         Copyright 18.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void barycentricfitfloaterhormann(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep)
    {
        info = 0;
        b = new barycentricinterpolant();
        rep = new barycentricfitreport();
        lsfit.barycentricfitfloaterhormann(x, y, n, m, ref info, b.innerobj, rep.innerobj, null);
    }
    
    public static void barycentricfitfloaterhormann(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep, alglib.xparams _params)
    {
        info = 0;
        b = new barycentricinterpolant();
        rep = new barycentricfitreport();
        lsfit.barycentricfitfloaterhormann(x, y, n, m, ref info, b.innerobj, rep.innerobj, _params);
    }
    
    /*************************************************************************
    Weighted fitting by cubic  spline,  with constraints on function values or
    derivatives.

    Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
    basis functions. Basis functions are cubic splines with continuous  second
    derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
    regularizing term is used  when  solving  constrained  tasks  (to  improve
    stability).

    Task is linear, so linear least squares solver is used. Complexity of this
    computational scheme is O(N*M^2), mostly dominated by least squares solver

    SEE ALSO
        Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
                                    less smooth)
        Spline1DFitCubic()      -   "lightweight" fitting  by  cubic  splines,
                                    without invididual weights and constraints

    INPUT PARAMETERS:
        X   -   points, array[0..N-1].
        Y   -   function values, array[0..N-1].
        W   -   weights, array[0..N-1]
                Each summand in square  sum  of  approximation deviations from
                given  values  is  multiplied  by  the square of corresponding
                weight. Fill it by 1's if you don't  want  to  solve  weighted
                task.
        N   -   number of points (optional):
                * N>0
                * if given, only first N elements of X/Y/W are processed
                * if not given, automatically determined from X/Y/W sizes
        XC  -   points where spline values/derivatives are constrained,
                array[0..K-1].
        YC  -   values of constraints, array[0..K-1]
        DC  -   array[0..K-1], types of constraints:
                * DC[i]=0   means that S(XC[i])=YC[i]
                * DC[i]=1   means that S'(XC[i])=YC[i]
                SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
        K   -   number of constraints (optional):
                * 0<=K<M.
                * K=0 means no constraints (XC/YC/DC are not used)
                * if given, only first K elements of XC/YC/DC are used
                * if not given, automatically determined from XC/YC/DC
        M   -   number of basis functions ( = number_of_nodes+2), M>=4.

    OUTPUT PARAMETERS:
        Info-   same format as in LSFitLinearWC() subroutine.
                * Info>0    task is solved
                * Info<=0   an error occured:
                            -4 means inconvergence of internal SVD
                            -3 means inconsistent constraints
        S   -   spline interpolant.
        Rep -   report, same format as in LSFitLinearWC() subroutine.
                Following fields are set:
                * RMSError      rms error on the (X,Y).
                * AvgError      average error on the (X,Y).
                * AvgRelError   average relative error on the non-zero Y
                * MaxError      maximum error
                                NON-WEIGHTED ERRORS ARE CALCULATED

    IMPORTANT:
        this subroitine doesn't calculate task's condition number for K<>0.


    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.

    SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

    Setting constraints can lead  to undesired  results,  like ill-conditioned
    behavior, or inconsistency being detected. From the other side,  it allows
    us to improve quality of the fit. Here we summarize  our  experience  with
    constrained regression splines:
    * excessive constraints can be inconsistent. Splines are  piecewise  cubic
      functions, and it is easy to create an example, where  large  number  of
      constraints  concentrated  in  small  area will result in inconsistency.
      Just because spline is not flexible enough to satisfy all of  them.  And
      same constraints spread across the  [min(x),max(x)]  will  be  perfectly
      consistent.
    * the more evenly constraints are spread across [min(x),max(x)],  the more
      chances that they will be consistent
    * the  greater  is  M (given  fixed  constraints),  the  more chances that
      constraints will be consistent
    * in the general case, consistency of constraints IS NOT GUARANTEED.
    * in the several special cases, however, we CAN guarantee consistency.
    * one of this cases is constraints  on  the  function  values  AND/OR  its
      derivatives at the interval boundaries.
    * another  special  case  is ONE constraint on the function value (OR, but
      not AND, derivative) anywhere in the interval

    Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
    can't solve your task without them. Anything beyond  special  cases  given
    above is not guaranteed and may result in inconsistency.

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB PROJECT --
         Copyright 18.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        lsfit.spline1dfitcubicwc(x, y, w, n, xc, yc, dc, k, m, ref info, s.innerobj, rep.innerobj, null);
    }
    
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        lsfit.spline1dfitcubicwc(x, y, w, n, xc, yc, dc, k, m, ref info, s.innerobj, rep.innerobj, _params);
    }
            
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        k = ap.len(xc);
        lsfit.spline1dfitcubicwc(x, y, w, n, xc, yc, dc, k, m, ref info, s.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        k = ap.len(xc);
        lsfit.spline1dfitcubicwc(x, y, w, n, xc, yc, dc, k, m, ref info, s.innerobj, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Weighted  fitting  by Hermite spline,  with constraints on function values
    or first derivatives.

    Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
    basis functions. Basis functions are Hermite splines.  Small  regularizing
    term is used when solving constrained tasks (to improve stability).

    Task is linear, so linear least squares solver is used. Complexity of this
    computational scheme is O(N*M^2), mostly dominated by least squares solver

    SEE ALSO
        Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
                                    more smooth)
        Spline1DFitHermite()    -   "lightweight" Hermite fitting, without
                                    invididual weights and constraints

    INPUT PARAMETERS:
        X   -   points, array[0..N-1].
        Y   -   function values, array[0..N-1].
        W   -   weights, array[0..N-1]
                Each summand in square  sum  of  approximation deviations from
                given  values  is  multiplied  by  the square of corresponding
                weight. Fill it by 1's if you don't  want  to  solve  weighted
                task.
        N   -   number of points (optional):
                * N>0
                * if given, only first N elements of X/Y/W are processed
                * if not given, automatically determined from X/Y/W sizes
        XC  -   points where spline values/derivatives are constrained,
                array[0..K-1].
        YC  -   values of constraints, array[0..K-1]
        DC  -   array[0..K-1], types of constraints:
                * DC[i]=0   means that S(XC[i])=YC[i]
                * DC[i]=1   means that S'(XC[i])=YC[i]
                SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
        K   -   number of constraints (optional):
                * 0<=K<M.
                * K=0 means no constraints (XC/YC/DC are not used)
                * if given, only first K elements of XC/YC/DC are used
                * if not given, automatically determined from XC/YC/DC
        M   -   number of basis functions (= 2 * number of nodes),
                M>=4,
                M IS EVEN!

    OUTPUT PARAMETERS:
        Info-   same format as in LSFitLinearW() subroutine:
                * Info>0    task is solved
                * Info<=0   an error occured:
                            -4 means inconvergence of internal SVD
                            -3 means inconsistent constraints
                            -2 means odd M was passed (which is not supported)
                            -1 means another errors in parameters passed
                               (N<=0, for example)
        S   -   spline interpolant.
        Rep -   report, same format as in LSFitLinearW() subroutine.
                Following fields are set:
                * RMSError      rms error on the (X,Y).
                * AvgError      average error on the (X,Y).
                * AvgRelError   average relative error on the non-zero Y
                * MaxError      maximum error
                                NON-WEIGHTED ERRORS ARE CALCULATED

    IMPORTANT:
        this subroitine doesn't calculate task's condition number for K<>0.

    IMPORTANT:
        this subroitine supports only even M's


    ORDER OF POINTS

    Subroutine automatically sorts points, so caller may pass unsorted array.

    SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

    Setting constraints can lead  to undesired  results,  like ill-conditioned
    behavior, or inconsistency being detected. From the other side,  it allows
    us to improve quality of the fit. Here we summarize  our  experience  with
    constrained regression splines:
    * excessive constraints can be inconsistent. Splines are  piecewise  cubic
      functions, and it is easy to create an example, where  large  number  of
      constraints  concentrated  in  small  area will result in inconsistency.
      Just because spline is not flexible enough to satisfy all of  them.  And
      same constraints spread across the  [min(x),max(x)]  will  be  perfectly
      consistent.
    * the more evenly constraints are spread across [min(x),max(x)],  the more
      chances that they will be consistent
    * the  greater  is  M (given  fixed  constraints),  the  more chances that
      constraints will be consistent
    * in the general case, consistency of constraints is NOT GUARANTEED.
    * in the several special cases, however, we can guarantee consistency.
    * one of this cases is  M>=4  and   constraints  on   the  function  value
      (AND/OR its derivative) at the interval boundaries.
    * another special case is M>=4  and  ONE  constraint on the function value
      (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]

    Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
    can't solve your task without them. Anything beyond  special  cases  given
    above is not guaranteed and may result in inconsistency.

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB PROJECT --
         Copyright 18.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        lsfit.spline1dfithermitewc(x, y, w, n, xc, yc, dc, k, m, ref info, s.innerobj, rep.innerobj, null);
    }
    
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        lsfit.spline1dfithermitewc(x, y, w, n, xc, yc, dc, k, m, ref info, s.innerobj, rep.innerobj, _params);
    }
            
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        k = ap.len(xc);
        lsfit.spline1dfithermitewc(x, y, w, n, xc, yc, dc, k, m, ref info, s.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        int n;
        int k;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
        if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
            throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        k = ap.len(xc);
        lsfit.spline1dfithermitewc(x, y, w, n, xc, yc, dc, k, m, ref info, s.innerobj, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Least squares fitting by cubic spline.

    This subroutine is "lightweight" alternative for more complex and feature-
    rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
    about subroutine parameters (we don't duplicate it here because of length)

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB PROJECT --
         Copyright 18.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dfitcubic(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        lsfit.spline1dfitcubic(x, y, n, m, ref info, s.innerobj, rep.innerobj, null);
    }
    
    public static void spline1dfitcubic(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        lsfit.spline1dfitcubic(x, y, n, m, ref info, s.innerobj, rep.innerobj, _params);
    }
            
    public static void spline1dfitcubic(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        lsfit.spline1dfitcubic(x, y, n, m, ref info, s.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void spline1dfitcubic(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        lsfit.spline1dfitcubic(x, y, n, m, ref info, s.innerobj, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Least squares fitting by Hermite spline.

    This subroutine is "lightweight" alternative for more complex and feature-
    rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
    more information about subroutine parameters (we don't duplicate  it  here
    because of length).

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB PROJECT --
         Copyright 18.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dfithermite(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        lsfit.spline1dfithermite(x, y, n, m, ref info, s.innerobj, rep.innerobj, null);
    }
    
    public static void spline1dfithermite(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        lsfit.spline1dfithermite(x, y, n, m, ref info, s.innerobj, rep.innerobj, _params);
    }
            
    public static void spline1dfithermite(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        lsfit.spline1dfithermite(x, y, n, m, ref info, s.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void spline1dfithermite(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        lsfit.spline1dfithermite(x, y, n, m, ref info, s.innerobj, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Weighted linear least squares fitting.

    QR decomposition is used to reduce task to MxM, then triangular solver  or
    SVD-based solver is used depending on condition number of the  system.  It
    allows to maximize speed and retain decent accuracy.

    IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
               convenient to use PolynomialFit() function. This function gives
               best  results  on  polynomial  problems  and  solves  numerical
               stability  issues  which  arise  when   you   fit   high-degree
               polynomials to your data.

    INPUT PARAMETERS:
        Y       -   array[0..N-1] Function values in  N  points.
        W       -   array[0..N-1]  Weights  corresponding to function  values.
                    Each summand in square  sum  of  approximation  deviations
                    from  given  values  is  multiplied  by  the   square   of
                    corresponding weight.
        FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                    FMatrix[I, J] - value of J-th basis function in I-th point.
        N       -   number of points used. N>=1.
        M       -   number of basis functions, M>=1.

    OUTPUT PARAMETERS:
        Info    -   error code:
                    * -4    internal SVD decomposition subroutine failed (very
                            rare and for degenerate systems only)
                    * -1    incorrect N/M were specified
                    *  1    task is solved
        C       -   decomposition coefficients, array[0..M-1]
        Rep     -   fitting report. Following fields are set:
                    * Rep.TaskRCond     reciprocal of condition number
                    * R2                non-adjusted coefficient of determination
                                        (non-weighted)
                    * RMSError          rms error on the (X,Y).
                    * AvgError          average error on the (X,Y).
                    * AvgRelError       average relative error on the non-zero Y
                    * MaxError          maximum error
                                        NON-WEIGHTED ERRORS ARE CALCULATED

    ERRORS IN PARAMETERS

    This  solver  also  calculates different kinds of errors in parameters and
    fills corresponding fields of report:
    * Rep.CovPar        covariance matrix for parameters, array[K,K].
    * Rep.ErrPar        errors in parameters, array[K],
                        errpar = sqrt(diag(CovPar))
    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                        best-fit curve from "ideal" best-fit curve built  with
                        infinite number of samples, array[N].
                        errcurve = sqrt(diag(F*CovPar*F')),
                        where F is functions matrix.
    * Rep.Noise         vector of per-point estimates of noise, array[N]

    NOTE:       noise in the data is estimated as follows:
                * for fitting without user-supplied  weights  all  points  are
                  assumed to have same level of noise, which is estimated from
                  the data
                * for fitting with user-supplied weights we assume that  noise
                  level in I-th point is inversely proportional to Ith weight.
                  Coefficient of proportionality is estimated from the data.

    NOTE:       we apply small amount of regularization when we invert squared
                Jacobian and calculate covariance matrix. It  guarantees  that
                algorithm won't divide by zero  during  inversion,  but  skews
                error estimates a bit (fractional error is about 10^-9).

                However, we believe that this difference is insignificant  for
                all practical purposes except for the situation when you  want
                to compare ALGLIB results with "reference"  implementation  up
                to the last significant digit.

    NOTE:       covariance matrix is estimated using  correction  for  degrees
                of freedom (covariances are divided by N-M instead of dividing
                by N).

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitlinearw(y, w, fmatrix, n, m, ref info, ref c, rep.innerobj, null);
    }
    
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitlinearw(y, w, fmatrix, n, m, ref info, ref c, rep.innerobj, _params);
    }
            
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep)
    {
        int n;
        int m;
        if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size");
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        n = ap.len(y);
        m = ap.cols(fmatrix);
        lsfit.lsfitlinearw(y, w, fmatrix, n, m, ref info, ref c, rep.innerobj, null);
    
        return;
    }
            
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        int n;
        int m;
        if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size");
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        n = ap.len(y);
        m = ap.cols(fmatrix);
        lsfit.lsfitlinearw(y, w, fmatrix, n, m, ref info, ref c, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Weighted constained linear least squares fitting.

    This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
    that  K  additional  constaints  C*x=bc are satisfied. It reduces original
    task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
    is called.

    IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
               convenient to use PolynomialFit() function. This function gives
               best  results  on  polynomial  problems  and  solves  numerical
               stability  issues  which  arise  when   you   fit   high-degree
               polynomials to your data.

    INPUT PARAMETERS:
        Y       -   array[0..N-1] Function values in  N  points.
        W       -   array[0..N-1]  Weights  corresponding to function  values.
                    Each summand in square  sum  of  approximation  deviations
                    from  given  values  is  multiplied  by  the   square   of
                    corresponding weight.
        FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                    FMatrix[I,J] - value of J-th basis function in I-th point.
        CMatrix -   a table of constaints, array[0..K-1,0..M].
                    I-th row of CMatrix corresponds to I-th linear constraint:
                    CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
        N       -   number of points used. N>=1.
        M       -   number of basis functions, M>=1.
        K       -   number of constraints, 0 <= K < M
                    K=0 corresponds to absence of constraints.

    OUTPUT PARAMETERS:
        Info    -   error code:
                    * -4    internal SVD decomposition subroutine failed (very
                            rare and for degenerate systems only)
                    * -3    either   too   many  constraints  (M   or   more),
                            degenerate  constraints   (some   constraints  are
                            repetead twice) or inconsistent  constraints  were
                            specified.
                    *  1    task is solved
        C       -   decomposition coefficients, array[0..M-1]
        Rep     -   fitting report. Following fields are set:
                    * R2                non-adjusted coefficient of determination
                                        (non-weighted)
                    * RMSError          rms error on the (X,Y).
                    * AvgError          average error on the (X,Y).
                    * AvgRelError       average relative error on the non-zero Y
                    * MaxError          maximum error
                                        NON-WEIGHTED ERRORS ARE CALCULATED

    IMPORTANT:
        this subroitine doesn't calculate task's condition number for K<>0.

    ERRORS IN PARAMETERS

    This  solver  also  calculates different kinds of errors in parameters and
    fills corresponding fields of report:
    * Rep.CovPar        covariance matrix for parameters, array[K,K].
    * Rep.ErrPar        errors in parameters, array[K],
                        errpar = sqrt(diag(CovPar))
    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                        best-fit curve from "ideal" best-fit curve built  with
                        infinite number of samples, array[N].
                        errcurve = sqrt(diag(F*CovPar*F')),
                        where F is functions matrix.
    * Rep.Noise         vector of per-point estimates of noise, array[N]

    IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
                account boundary/linear constraints! Presence  of  constraints
                changes distribution of errors, but there is no  easy  way  to
                account for constraints when you calculate covariance matrix.

    NOTE:       noise in the data is estimated as follows:
                * for fitting without user-supplied  weights  all  points  are
                  assumed to have same level of noise, which is estimated from
                  the data
                * for fitting with user-supplied weights we assume that  noise
                  level in I-th point is inversely proportional to Ith weight.
                  Coefficient of proportionality is estimated from the data.

    NOTE:       we apply small amount of regularization when we invert squared
                Jacobian and calculate covariance matrix. It  guarantees  that
                algorithm won't divide by zero  during  inversion,  but  skews
                error estimates a bit (fractional error is about 10^-9).

                However, we believe that this difference is insignificant  for
                all practical purposes except for the situation when you  want
                to compare ALGLIB results with "reference"  implementation  up
                to the last significant digit.

    NOTE:       covariance matrix is estimated using  correction  for  degrees
                of freedom (covariances are divided by N-M instead of dividing
                by N).

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB --
         Copyright 07.09.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, ref info, ref c, rep.innerobj, null);
    }
    
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, ref info, ref c, rep.innerobj, _params);
    }
            
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep)
    {
        int n;
        int m;
        int k;
        if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
        if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
            throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        n = ap.len(y);
        m = ap.cols(fmatrix);
        k = ap.rows(cmatrix);
        lsfit.lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, ref info, ref c, rep.innerobj, null);
    
        return;
    }
            
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        int n;
        int m;
        int k;
        if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
        if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
            throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        n = ap.len(y);
        m = ap.cols(fmatrix);
        k = ap.rows(cmatrix);
        lsfit.lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, ref info, ref c, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Linear least squares fitting.

    QR decomposition is used to reduce task to MxM, then triangular solver  or
    SVD-based solver is used depending on condition number of the  system.  It
    allows to maximize speed and retain decent accuracy.

    IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
               convenient to use PolynomialFit() function. This function gives
               best  results  on  polynomial  problems  and  solves  numerical
               stability  issues  which  arise  when   you   fit   high-degree
               polynomials to your data.

    INPUT PARAMETERS:
        Y       -   array[0..N-1] Function values in  N  points.
        FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                    FMatrix[I, J] - value of J-th basis function in I-th point.
        N       -   number of points used. N>=1.
        M       -   number of basis functions, M>=1.

    OUTPUT PARAMETERS:
        Info    -   error code:
                    * -4    internal SVD decomposition subroutine failed (very
                            rare and for degenerate systems only)
                    *  1    task is solved
        C       -   decomposition coefficients, array[0..M-1]
        Rep     -   fitting report. Following fields are set:
                    * Rep.TaskRCond     reciprocal of condition number
                    * R2                non-adjusted coefficient of determination
                                        (non-weighted)
                    * RMSError          rms error on the (X,Y).
                    * AvgError          average error on the (X,Y).
                    * AvgRelError       average relative error on the non-zero Y
                    * MaxError          maximum error
                                        NON-WEIGHTED ERRORS ARE CALCULATED

    ERRORS IN PARAMETERS

    This  solver  also  calculates different kinds of errors in parameters and
    fills corresponding fields of report:
    * Rep.CovPar        covariance matrix for parameters, array[K,K].
    * Rep.ErrPar        errors in parameters, array[K],
                        errpar = sqrt(diag(CovPar))
    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                        best-fit curve from "ideal" best-fit curve built  with
                        infinite number of samples, array[N].
                        errcurve = sqrt(diag(F*CovPar*F')),
                        where F is functions matrix.
    * Rep.Noise         vector of per-point estimates of noise, array[N]

    NOTE:       noise in the data is estimated as follows:
                * for fitting without user-supplied  weights  all  points  are
                  assumed to have same level of noise, which is estimated from
                  the data
                * for fitting with user-supplied weights we assume that  noise
                  level in I-th point is inversely proportional to Ith weight.
                  Coefficient of proportionality is estimated from the data.

    NOTE:       we apply small amount of regularization when we invert squared
                Jacobian and calculate covariance matrix. It  guarantees  that
                algorithm won't divide by zero  during  inversion,  but  skews
                error estimates a bit (fractional error is about 10^-9).

                However, we believe that this difference is insignificant  for
                all practical purposes except for the situation when you  want
                to compare ALGLIB results with "reference"  implementation  up
                to the last significant digit.

    NOTE:       covariance matrix is estimated using  correction  for  degrees
                of freedom (covariances are divided by N-M instead of dividing
                by N).

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitlinear(double[] y, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitlinear(y, fmatrix, n, m, ref info, ref c, rep.innerobj, null);
    }
    
    public static void lsfitlinear(double[] y, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitlinear(y, fmatrix, n, m, ref info, ref c, rep.innerobj, _params);
    }
            
    public static void lsfitlinear(double[] y, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep)
    {
        int n;
        int m;
        if( (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinear': looks like one of arguments has wrong size");
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        n = ap.len(y);
        m = ap.cols(fmatrix);
        lsfit.lsfitlinear(y, fmatrix, n, m, ref info, ref c, rep.innerobj, null);
    
        return;
    }
            
    public static void lsfitlinear(double[] y, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        int n;
        int m;
        if( (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinear': looks like one of arguments has wrong size");
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        n = ap.len(y);
        m = ap.cols(fmatrix);
        lsfit.lsfitlinear(y, fmatrix, n, m, ref info, ref c, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Constained linear least squares fitting.

    This  is  variation  of LSFitLinear(),  which searchs for min|A*x=b| given
    that  K  additional  constaints  C*x=bc are satisfied. It reduces original
    task to modified one: min|B*y-d| WITHOUT constraints,  then  LSFitLinear()
    is called.

    IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
               convenient to use PolynomialFit() function. This function gives
               best  results  on  polynomial  problems  and  solves  numerical
               stability  issues  which  arise  when   you   fit   high-degree
               polynomials to your data.

    INPUT PARAMETERS:
        Y       -   array[0..N-1] Function values in  N  points.
        FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                    FMatrix[I,J] - value of J-th basis function in I-th point.
        CMatrix -   a table of constaints, array[0..K-1,0..M].
                    I-th row of CMatrix corresponds to I-th linear constraint:
                    CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
        N       -   number of points used. N>=1.
        M       -   number of basis functions, M>=1.
        K       -   number of constraints, 0 <= K < M
                    K=0 corresponds to absence of constraints.

    OUTPUT PARAMETERS:
        Info    -   error code:
                    * -4    internal SVD decomposition subroutine failed (very
                            rare and for degenerate systems only)
                    * -3    either   too   many  constraints  (M   or   more),
                            degenerate  constraints   (some   constraints  are
                            repetead twice) or inconsistent  constraints  were
                            specified.
                    *  1    task is solved
        C       -   decomposition coefficients, array[0..M-1]
        Rep     -   fitting report. Following fields are set:
                    * R2                non-adjusted coefficient of determination
                                        (non-weighted)
                    * RMSError          rms error on the (X,Y).
                    * AvgError          average error on the (X,Y).
                    * AvgRelError       average relative error on the non-zero Y
                    * MaxError          maximum error
                                        NON-WEIGHTED ERRORS ARE CALCULATED

    IMPORTANT:
        this subroitine doesn't calculate task's condition number for K<>0.

    ERRORS IN PARAMETERS

    This  solver  also  calculates different kinds of errors in parameters and
    fills corresponding fields of report:
    * Rep.CovPar        covariance matrix for parameters, array[K,K].
    * Rep.ErrPar        errors in parameters, array[K],
                        errpar = sqrt(diag(CovPar))
    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                        best-fit curve from "ideal" best-fit curve built  with
                        infinite number of samples, array[N].
                        errcurve = sqrt(diag(F*CovPar*F')),
                        where F is functions matrix.
    * Rep.Noise         vector of per-point estimates of noise, array[N]

    IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
                account boundary/linear constraints! Presence  of  constraints
                changes distribution of errors, but there is no  easy  way  to
                account for constraints when you calculate covariance matrix.

    NOTE:       noise in the data is estimated as follows:
                * for fitting without user-supplied  weights  all  points  are
                  assumed to have same level of noise, which is estimated from
                  the data
                * for fitting with user-supplied weights we assume that  noise
                  level in I-th point is inversely proportional to Ith weight.
                  Coefficient of proportionality is estimated from the data.

    NOTE:       we apply small amount of regularization when we invert squared
                Jacobian and calculate covariance matrix. It  guarantees  that
                algorithm won't divide by zero  during  inversion,  but  skews
                error estimates a bit (fractional error is about 10^-9).

                However, we believe that this difference is insignificant  for
                all practical purposes except for the situation when you  want
                to compare ALGLIB results with "reference"  implementation  up
                to the last significant digit.

    NOTE:       covariance matrix is estimated using  correction  for  degrees
                of freedom (covariances are divided by N-M instead of dividing
                by N).

      ! FREE EDITION OF ALGLIB:
      !
      ! Free Edition of ALGLIB supports following important features for  this
      ! function:
      ! * C++ version: x64 SIMD support using C++ intrinsics
      ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
      !
      ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
      ! Reference Manual in order  to  find  out  how to activate SIMD support
      ! in ALGLIB.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

      -- ALGLIB --
         Copyright 07.09.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitlinearc(y, fmatrix, cmatrix, n, m, k, ref info, ref c, rep.innerobj, null);
    }
    
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitlinearc(y, fmatrix, cmatrix, n, m, k, ref info, ref c, rep.innerobj, _params);
    }
            
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep)
    {
        int n;
        int m;
        int k;
        if( (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
        if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
            throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        n = ap.len(y);
        m = ap.cols(fmatrix);
        k = ap.rows(cmatrix);
        lsfit.lsfitlinearc(y, fmatrix, cmatrix, n, m, k, ref info, ref c, rep.innerobj, null);
    
        return;
    }
            
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        int n;
        int m;
        int k;
        if( (ap.len(y)!=ap.rows(fmatrix)))
            throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
        if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
            throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        n = ap.len(y);
        m = ap.cols(fmatrix);
        k = ap.rows(cmatrix);
        lsfit.lsfitlinearc(y, fmatrix, cmatrix, n, m, k, ref info, ref c, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Weighted nonlinear least squares fitting using function values only.

    Combination of numerical differentiation and secant updates is used to
    obtain function Jacobian.

    Nonlinear task min(F(c)) is solved, where

        F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,

        * N is a number of points,
        * M is a dimension of a space points belong to,
        * K is a dimension of a space of parameters being fitted,
        * w is an N-dimensional vector of weight coefficients,
        * x is a set of N points, each of them is an M-dimensional vector,
        * c is a K-dimensional vector of parameters being fitted

    This subroutine uses only f(c,x[i]).

    INPUT PARAMETERS:
        X       -   array[0..N-1,0..M-1], points (one row = one point)
        Y       -   array[0..N-1], function values.
        W       -   weights, array[0..N-1]
        C       -   array[0..K-1], initial approximation to the solution,
        N       -   number of points, N>1
        M       -   dimension of space
        K       -   number of parameters being fitted
        DiffStep-   numerical differentiation step;
                    should not be very small or large;
                    large = loss of accuracy
                    small = growth of round-off errors

    OUTPUT PARAMETERS:
        State   -   structure which stores algorithm state

      -- ALGLIB --
         Copyright 18.10.2008 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, double diffstep, out lsfitstate state)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatewf(x, y, w, c, n, m, k, diffstep, state.innerobj, null);
    }
    
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, double diffstep, out lsfitstate state, alglib.xparams _params)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatewf(x, y, w, c, n, m, k, diffstep, state.innerobj, _params);
    }
            
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, double diffstep, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewf': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatewf(x, y, w, c, n, m, k, diffstep, state.innerobj, null);
    
        return;
    }
            
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, double diffstep, out lsfitstate state, alglib.xparams _params)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewf': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatewf(x, y, w, c, n, m, k, diffstep, state.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Nonlinear least squares fitting using function values only.

    Combination of numerical differentiation and secant updates is used to
    obtain function Jacobian.

    Nonlinear task min(F(c)) is solved, where

        F(c) = (f(c,x[0])-y[0])^2 + ... + (f(c,x[n-1])-y[n-1])^2,

        * N is a number of points,
        * M is a dimension of a space points belong to,
        * K is a dimension of a space of parameters being fitted,
        * w is an N-dimensional vector of weight coefficients,
        * x is a set of N points, each of them is an M-dimensional vector,
        * c is a K-dimensional vector of parameters being fitted

    This subroutine uses only f(c,x[i]).

    INPUT PARAMETERS:
        X       -   array[0..N-1,0..M-1], points (one row = one point)
        Y       -   array[0..N-1], function values.
        C       -   array[0..K-1], initial approximation to the solution,
        N       -   number of points, N>1
        M       -   dimension of space
        K       -   number of parameters being fitted
        DiffStep-   numerical differentiation step;
                    should not be very small or large;
                    large = loss of accuracy
                    small = growth of round-off errors

    OUTPUT PARAMETERS:
        State   -   structure which stores algorithm state

      -- ALGLIB --
         Copyright 18.10.2008 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, int n, int m, int k, double diffstep, out lsfitstate state)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatef(x, y, c, n, m, k, diffstep, state.innerobj, null);
    }
    
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, int n, int m, int k, double diffstep, out lsfitstate state, alglib.xparams _params)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatef(x, y, c, n, m, k, diffstep, state.innerobj, _params);
    }
            
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, double diffstep, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatef': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatef(x, y, c, n, m, k, diffstep, state.innerobj, null);
    
        return;
    }
            
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, double diffstep, out lsfitstate state, alglib.xparams _params)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatef': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatef(x, y, c, n, m, k, diffstep, state.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Weighted nonlinear least squares fitting using gradient only.

    Nonlinear task min(F(c)) is solved, where

        F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,

        * N is a number of points,
        * M is a dimension of a space points belong to,
        * K is a dimension of a space of parameters being fitted,
        * w is an N-dimensional vector of weight coefficients,
        * x is a set of N points, each of them is an M-dimensional vector,
        * c is a K-dimensional vector of parameters being fitted

    This subroutine uses only f(c,x[i]) and its gradient.

    INPUT PARAMETERS:
        X       -   array[0..N-1,0..M-1], points (one row = one point)
        Y       -   array[0..N-1], function values.
        W       -   weights, array[0..N-1]
        C       -   array[0..K-1], initial approximation to the solution,
        N       -   number of points, N>1
        M       -   dimension of space
        K       -   number of parameters being fitted
        CheapFG -   boolean flag, which is:
                    * True  if both function and gradient calculation complexity
                            are less than O(M^2).  An improved  algorithm  can
                            be  used  which corresponds  to  FGJ  scheme  from
                            MINLM unit.
                    * False otherwise.
                            Standard Jacibian-bases  Levenberg-Marquardt  algo
                            will be used (FJ scheme).

    OUTPUT PARAMETERS:
        State   -   structure which stores algorithm state

    See also:
        LSFitResults
        LSFitCreateFG (fitting without weights)
        LSFitCreateWFGH (fitting using Hessian)
        LSFitCreateFGH (fitting using Hessian, without weights)

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatewfg(x, y, w, c, n, m, k, cheapfg, state.innerobj, null);
    }
    
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state, alglib.xparams _params)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatewfg(x, y, w, c, n, m, k, cheapfg, state.innerobj, _params);
    }
            
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, bool cheapfg, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewfg': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatewfg(x, y, w, c, n, m, k, cheapfg, state.innerobj, null);
    
        return;
    }
            
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, bool cheapfg, out lsfitstate state, alglib.xparams _params)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewfg': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatewfg(x, y, w, c, n, m, k, cheapfg, state.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Nonlinear least squares fitting using gradient only, without individual
    weights.

    Nonlinear task min(F(c)) is solved, where

        F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,

        * N is a number of points,
        * M is a dimension of a space points belong to,
        * K is a dimension of a space of parameters being fitted,
        * x is a set of N points, each of them is an M-dimensional vector,
        * c is a K-dimensional vector of parameters being fitted

    This subroutine uses only f(c,x[i]) and its gradient.

    INPUT PARAMETERS:
        X       -   array[0..N-1,0..M-1], points (one row = one point)
        Y       -   array[0..N-1], function values.
        C       -   array[0..K-1], initial approximation to the solution,
        N       -   number of points, N>1
        M       -   dimension of space
        K       -   number of parameters being fitted
        CheapFG -   boolean flag, which is:
                    * True  if both function and gradient calculation complexity
                            are less than O(M^2).  An improved  algorithm  can
                            be  used  which corresponds  to  FGJ  scheme  from
                            MINLM unit.
                    * False otherwise.
                            Standard Jacibian-bases  Levenberg-Marquardt  algo
                            will be used (FJ scheme).

    OUTPUT PARAMETERS:
        State   -   structure which stores algorithm state

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatefg(x, y, c, n, m, k, cheapfg, state.innerobj, null);
    }
    
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state, alglib.xparams _params)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatefg(x, y, c, n, m, k, cheapfg, state.innerobj, _params);
    }
            
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, bool cheapfg, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatefg': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatefg(x, y, c, n, m, k, cheapfg, state.innerobj, null);
    
        return;
    }
            
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, bool cheapfg, out lsfitstate state, alglib.xparams _params)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatefg': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatefg(x, y, c, n, m, k, cheapfg, state.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Weighted nonlinear least squares fitting using gradient/Hessian.

    Nonlinear task min(F(c)) is solved, where

        F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,

        * N is a number of points,
        * M is a dimension of a space points belong to,
        * K is a dimension of a space of parameters being fitted,
        * w is an N-dimensional vector of weight coefficients,
        * x is a set of N points, each of them is an M-dimensional vector,
        * c is a K-dimensional vector of parameters being fitted

    This subroutine uses f(c,x[i]), its gradient and its Hessian.

    INPUT PARAMETERS:
        X       -   array[0..N-1,0..M-1], points (one row = one point)
        Y       -   array[0..N-1], function values.
        W       -   weights, array[0..N-1]
        C       -   array[0..K-1], initial approximation to the solution,
        N       -   number of points, N>1
        M       -   dimension of space
        K       -   number of parameters being fitted

    OUTPUT PARAMETERS:
        State   -   structure which stores algorithm state

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, out lsfitstate state)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatewfgh(x, y, w, c, n, m, k, state.innerobj, null);
    }
    
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, out lsfitstate state, alglib.xparams _params)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatewfgh(x, y, w, c, n, m, k, state.innerobj, _params);
    }
            
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewfgh': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatewfgh(x, y, w, c, n, m, k, state.innerobj, null);
    
        return;
    }
            
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, out lsfitstate state, alglib.xparams _params)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'lsfitcreatewfgh': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatewfgh(x, y, w, c, n, m, k, state.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Nonlinear least squares fitting using gradient/Hessian, without individial
    weights.

    Nonlinear task min(F(c)) is solved, where

        F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,

        * N is a number of points,
        * M is a dimension of a space points belong to,
        * K is a dimension of a space of parameters being fitted,
        * x is a set of N points, each of them is an M-dimensional vector,
        * c is a K-dimensional vector of parameters being fitted

    This subroutine uses f(c,x[i]), its gradient and its Hessian.

    INPUT PARAMETERS:
        X       -   array[0..N-1,0..M-1], points (one row = one point)
        Y       -   array[0..N-1], function values.
        C       -   array[0..K-1], initial approximation to the solution,
        N       -   number of points, N>1
        M       -   dimension of space
        K       -   number of parameters being fitted

    OUTPUT PARAMETERS:
        State   -   structure which stores algorithm state


      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, int n, int m, int k, out lsfitstate state)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatefgh(x, y, c, n, m, k, state.innerobj, null);
    }
    
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, int n, int m, int k, out lsfitstate state, alglib.xparams _params)
    {
        state = new lsfitstate();
        lsfit.lsfitcreatefgh(x, y, c, n, m, k, state.innerobj, _params);
    }
            
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, out lsfitstate state)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatefgh': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatefgh(x, y, c, n, m, k, state.innerobj, null);
    
        return;
    }
            
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, out lsfitstate state, alglib.xparams _params)
    {
        int n;
        int m;
        int k;
        if( (ap.rows(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'lsfitcreatefgh': looks like one of arguments has wrong size");
        state = new lsfitstate();
        n = ap.rows(x);
        m = ap.cols(x);
        k = ap.len(c);
        lsfit.lsfitcreatefgh(x, y, c, n, m, k, state.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    Stopping conditions for nonlinear least squares fitting.

    INPUT PARAMETERS:
        State   -   structure which stores algorithm state
        EpsX    -   >=0
                    The subroutine finishes its work if  on  k+1-th  iteration
                    the condition |v|<=EpsX is fulfilled, where:
                    * |.| means Euclidian norm
                    * v - scaled step vector, v[i]=dx[i]/s[i]
                    * dx - ste pvector, dx=X(k+1)-X(k)
                    * s - scaling coefficients set by LSFitSetScale()
        MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                    iterations   is    unlimited.   Only   Levenberg-Marquardt
                    iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
                    counted because their cost is very low compared to that of
                    LM).

    NOTE

    Passing EpsX=0  and  MaxIts=0  (simultaneously)  will  lead  to  automatic
    stopping criterion selection (according to the scheme used by MINLM unit).


      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitsetcond(lsfitstate state, double epsx, int maxits)
    {
    
        lsfit.lsfitsetcond(state.innerobj, epsx, maxits, null);
    }
    
    public static void lsfitsetcond(lsfitstate state, double epsx, int maxits, alglib.xparams _params)
    {
    
        lsfit.lsfitsetcond(state.innerobj, epsx, maxits, _params);
    }
    
    /*************************************************************************
    This function sets maximum step length

    INPUT PARAMETERS:
        State   -   structure which stores algorithm state
        StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
                    want to limit step length.

    Use this subroutine when you optimize target function which contains exp()
    or  other  fast  growing  functions,  and optimization algorithm makes too
    large  steps  which  leads  to overflow. This function allows us to reject
    steps  that  are  too  large  (and  therefore  expose  us  to the possible
    overflow) without actually calculating function value at the x+stp*d.

    NOTE: non-zero StpMax leads to moderate  performance  degradation  because
    intermediate  step  of  preconditioned L-BFGS optimization is incompatible
    with limits on step size.

      -- ALGLIB --
         Copyright 02.04.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitsetstpmax(lsfitstate state, double stpmax)
    {
    
        lsfit.lsfitsetstpmax(state.innerobj, stpmax, null);
    }
    
    public static void lsfitsetstpmax(lsfitstate state, double stpmax, alglib.xparams _params)
    {
    
        lsfit.lsfitsetstpmax(state.innerobj, stpmax, _params);
    }
    
    /*************************************************************************
    This function turns on/off reporting.

    INPUT PARAMETERS:
        State   -   structure which stores algorithm state
        NeedXRep-   whether iteration reports are needed or not

    When reports are needed, State.C (current parameters) and State.F (current
    value of fitting function) are reported.


      -- ALGLIB --
         Copyright 15.08.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitsetxrep(lsfitstate state, bool needxrep)
    {
    
        lsfit.lsfitsetxrep(state.innerobj, needxrep, null);
    }
    
    public static void lsfitsetxrep(lsfitstate state, bool needxrep, alglib.xparams _params)
    {
    
        lsfit.lsfitsetxrep(state.innerobj, needxrep, _params);
    }
    
    /*************************************************************************
    This function sets scaling coefficients for underlying optimizer.

    ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
    size and gradient are scaled before comparison with tolerances).  Scale of
    the I-th variable is a translation invariant measure of:
    a) "how large" the variable is
    b) how large the step should be to make significant changes in the function

    Generally, scale is NOT considered to be a form of preconditioner.  But LM
    optimizer is unique in that it uses scaling matrix both  in  the  stopping
    condition tests and as Marquardt damping factor.

    Proper scaling is very important for the algorithm performance. It is less
    important for the quality of results, but still has some influence (it  is
    easier  to  converge  when  variables  are  properly  scaled, so premature
    stopping is possible when very badly scalled variables are  combined  with
    relaxed stopping conditions).

    INPUT PARAMETERS:
        State   -   structure stores algorithm state
        S       -   array[N], non-zero scaling coefficients
                    S[i] may be negative, sign doesn't matter.

      -- ALGLIB --
         Copyright 14.01.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitsetscale(lsfitstate state, double[] s)
    {
    
        lsfit.lsfitsetscale(state.innerobj, s, null);
    }
    
    public static void lsfitsetscale(lsfitstate state, double[] s, alglib.xparams _params)
    {
    
        lsfit.lsfitsetscale(state.innerobj, s, _params);
    }
    
    /*************************************************************************
    This function sets boundary constraints for underlying optimizer

    Boundary constraints are inactive by default (after initial creation).
    They are preserved until explicitly turned off with another SetBC() call.

    INPUT PARAMETERS:
        State   -   structure stores algorithm state
        BndL    -   lower bounds, array[K].
                    If some (all) variables are unbounded, you may specify
                    very small number or -INF (latter is recommended because
                    it will allow solver to use better algorithm).
        BndU    -   upper bounds, array[K].
                    If some (all) variables are unbounded, you may specify
                    very large number or +INF (latter is recommended because
                    it will allow solver to use better algorithm).

    NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
    variable will be "frozen" at X[i]=BndL[i]=BndU[i].

    NOTE 2: unlike other constrained optimization algorithms, this solver  has
    following useful properties:
    * bound constraints are always satisfied exactly
    * function is evaluated only INSIDE area specified by bound constraints

      -- ALGLIB --
         Copyright 14.01.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitsetbc(lsfitstate state, double[] bndl, double[] bndu)
    {
    
        lsfit.lsfitsetbc(state.innerobj, bndl, bndu, null);
    }
    
    public static void lsfitsetbc(lsfitstate state, double[] bndl, double[] bndu, alglib.xparams _params)
    {
    
        lsfit.lsfitsetbc(state.innerobj, bndl, bndu, _params);
    }
    
    /*************************************************************************
    This function sets linear constraints for underlying optimizer

    Linear constraints are inactive by default (after initial creation).
    They are preserved until explicitly turned off with another SetLC() call.

    INPUT PARAMETERS:
        State   -   structure stores algorithm state
        C       -   linear constraints, array[K,N+1].
                    Each row of C represents one constraint, either equality
                    or inequality (see below):
                    * first N elements correspond to coefficients,
                    * last element corresponds to the right part.
                    All elements of C (including right part) must be finite.
        CT      -   type of constraints, array[K]:
                    * if CT[i]>0, then I-th constraint is C[i,*]*x >= C[i,n+1]
                    * if CT[i]=0, then I-th constraint is C[i,*]*x  = C[i,n+1]
                    * if CT[i]<0, then I-th constraint is C[i,*]*x <= C[i,n+1]
        K       -   number of equality/inequality constraints, K>=0:
                    * if given, only leading K elements of C/CT are used
                    * if not given, automatically determined from sizes of C/CT

    IMPORTANT: if you have linear constraints, it is strongly  recommended  to
               set scale of variables with lsfitsetscale(). QP solver which is
               used to calculate linearly constrained steps heavily relies  on
               good scaling of input problems.

    NOTE: linear  (non-box)  constraints  are  satisfied only approximately  -
          there  always  exists some violation due  to  numerical  errors  and
          algorithmic limitations.

    NOTE: general linear constraints  add  significant  overhead  to  solution
          process. Although solver performs roughly same amount of  iterations
          (when compared  with  similar  box-only  constrained  problem), each
          iteration   now    involves  solution  of  linearly  constrained  QP
          subproblem, which requires ~3-5 times more Cholesky  decompositions.
          Thus, if you can reformulate your problem in such way  this  it  has
          only box constraints, it may be beneficial to do so.

      -- ALGLIB --
         Copyright 29.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitsetlc(lsfitstate state, double[,] c, int[] ct, int k)
    {
    
        lsfit.lsfitsetlc(state.innerobj, c, ct, k, null);
    }
    
    public static void lsfitsetlc(lsfitstate state, double[,] c, int[] ct, int k, alglib.xparams _params)
    {
    
        lsfit.lsfitsetlc(state.innerobj, c, ct, k, _params);
    }
            
    public static void lsfitsetlc(lsfitstate state, double[,] c, int[] ct)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'lsfitsetlc': looks like one of arguments has wrong size");
    
        k = ap.rows(c);
        lsfit.lsfitsetlc(state.innerobj, c, ct, k, null);
    
        return;
    }
            
    public static void lsfitsetlc(lsfitstate state, double[,] c, int[] ct, alglib.xparams _params)
    {
        int k;
        if( (ap.rows(c)!=ap.len(ct)))
            throw new alglibexception("Error while calling 'lsfitsetlc': looks like one of arguments has wrong size");
    
        k = ap.rows(c);
        lsfit.lsfitsetlc(state.innerobj, c, ct, k, _params);
    
        return;
    }
    
    /*************************************************************************
    This function provides reverse communication interface
    Reverse communication interface is not documented or recommended to use.
    See below for functions which provide better documented API
    *************************************************************************/
    public static bool lsfititeration(lsfitstate state)
    {
    
        return lsfit.lsfititeration(state.innerobj, null);
    }
    
    public static bool lsfititeration(lsfitstate state, alglib.xparams _params)
    {
    
        return lsfit.lsfititeration(state.innerobj, _params);
    }
    /*************************************************************************
    This family of functions is used to launcn iterations of nonlinear fitter

    These functions accept following parameters:
        func    -   callback which calculates function (or merit function)
                    value func at given point x
        grad    -   callback which calculates function (or merit function)
                    value func and gradient grad at given point x
        hess    -   callback which calculates function (or merit function)
                    value func, gradient grad and Hessian hess at given point x
        rep     -   optional callback which is called after each iteration
                    can be null
        obj     -   optional object which is passed to func/grad/hess/jac/rep
                    can be null

    NOTES:

    1. this algorithm is somewhat unusual because it works with  parameterized
       function f(C,X), where X is a function argument (we  have  many  points
       which are characterized by different  argument  values),  and  C  is  a
       parameter to fit.

       For example, if we want to do linear fit by f(c0,c1,x) = c0*x+c1,  then
       x will be argument, and {c0,c1} will be parameters.

       It is important to understand that this algorithm finds minimum in  the
       space of function PARAMETERS (not arguments), so it  needs  derivatives
       of f() with respect to C, not X.

       In the example above it will need f=c0*x+c1 and {df/dc0,df/dc1} = {x,1}
       instead of {df/dx} = {c0}.

    2. Callback functions accept C as the first parameter, and X as the second

    3. If  state  was  created  with  LSFitCreateFG(),  algorithm  needs  just
       function   and   its   gradient,   but   if   state   was  created with
       LSFitCreateFGH(), algorithm will need function, gradient and Hessian.

       According  to  the  said  above,  there  ase  several  versions of this
       function, which accept different sets of callbacks.

       This flexibility opens way to subtle errors - you may create state with
       LSFitCreateFGH() (optimization using Hessian), but call function  which
       does not accept Hessian. So when algorithm will request Hessian,  there
       will be no callback to call. In this case exception will be thrown.

       Be careful to avoid such errors because there is no way to find them at
       compile time - you can see them at runtime only.

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey

    *************************************************************************/
    public static void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_rep rep, object obj)
    {
        lsfitfit(state, func, rep, obj, null);
    }
    
    public static void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_rep rep, object obj, alglib.xparams _params)
    {
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
        while( alglib.lsfititeration(state, _params) )
        {
            if( state.needf )
            {
                func(state.c, state.x, ref state.innerobj.f, obj);
                continue;
            }
            if( state.innerobj.xupdated )
            {
                if( rep!=null )
                    rep(state.innerobj.c, state.innerobj.f, obj);
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
    }


    public static void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_rep rep, object obj)
    {
        lsfitfit(state, func, grad, rep, obj, null);
    }
    
    public static void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_rep rep, object obj, alglib.xparams _params)
    {
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (grad is null)");
        while( alglib.lsfititeration(state, _params) )
        {
            if( state.needf )
            {
                func(state.c, state.x, ref state.innerobj.f, obj);
                continue;
            }
            if( state.needfg )
            {
                grad(state.c, state.x, ref state.innerobj.f, state.innerobj.g, obj);
                continue;
            }
            if( state.innerobj.xupdated )
            {
                if( rep!=null )
                    rep(state.innerobj.c, state.innerobj.f, obj);
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
    }


    public static void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_phess hess, ndimensional_rep rep, object obj)
    {
        lsfitfit(state, func, grad, hess, rep, obj, null);
    }
    
    public static void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_phess hess, ndimensional_rep rep, object obj, alglib.xparams _params)
    {
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (grad is null)");
        if( hess==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (hess is null)");
        while( alglib.lsfititeration(state, _params) )
        {
            if( state.needf )
            {
                func(state.c, state.x, ref state.innerobj.f, obj);
                continue;
            }
            if( state.needfg )
            {
                grad(state.c, state.x, ref state.innerobj.f, state.innerobj.g, obj);
                continue;
            }
            if( state.needfgh )
            {
                hess(state.c, state.x, ref state.innerobj.f, state.innerobj.g, state.innerobj.h, obj);
                continue;
            }
            if( state.innerobj.xupdated )
            {
                if( rep!=null )
                    rep(state.innerobj.c, state.innerobj.f, obj);
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
    }


    
    /*************************************************************************
    Nonlinear least squares fitting results.

    Called after return from LSFitFit().

    INPUT PARAMETERS:
        State   -   algorithm state

    OUTPUT PARAMETERS:
        Info    -   completion code:
                        * -8    optimizer   detected  NAN/INF  in  the  target
                                function and/or gradient
                        * -7    gradient verification failed.
                                See LSFitSetGradientCheck() for more information.
                        * -3    inconsistent constraints
                        *  2    relative step is no more than EpsX.
                        *  5    MaxIts steps was taken
                        *  7    stopping conditions are too stringent,
                                further improvement is impossible
        C       -   array[0..K-1], solution
        Rep     -   optimization report. On success following fields are set:
                    * R2                non-adjusted coefficient of determination
                                        (non-weighted)
                    * RMSError          rms error on the (X,Y).
                    * AvgError          average error on the (X,Y).
                    * AvgRelError       average relative error on the non-zero Y
                    * MaxError          maximum error
                                        NON-WEIGHTED ERRORS ARE CALCULATED
                    * WRMSError         weighted rms error on the (X,Y).

    ERRORS IN PARAMETERS

    This  solver  also  calculates different kinds of errors in parameters and
    fills corresponding fields of report:
    * Rep.CovPar        covariance matrix for parameters, array[K,K].
    * Rep.ErrPar        errors in parameters, array[K],
                        errpar = sqrt(diag(CovPar))
    * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                        best-fit curve from "ideal" best-fit curve built  with
                        infinite number of samples, array[N].
                        errcurve = sqrt(diag(J*CovPar*J')),
                        where J is Jacobian matrix.
    * Rep.Noise         vector of per-point estimates of noise, array[N]

    IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
                account boundary/linear constraints! Presence  of  constraints
                changes distribution of errors, but there is no  easy  way  to
                account for constraints when you calculate covariance matrix.

    NOTE:       noise in the data is estimated as follows:
                * for fitting without user-supplied  weights  all  points  are
                  assumed to have same level of noise, which is estimated from
                  the data
                * for fitting with user-supplied weights we assume that  noise
                  level in I-th point is inversely proportional to Ith weight.
                  Coefficient of proportionality is estimated from the data.

    NOTE:       we apply small amount of regularization when we invert squared
                Jacobian and calculate covariance matrix. It  guarantees  that
                algorithm won't divide by zero  during  inversion,  but  skews
                error estimates a bit (fractional error is about 10^-9).

                However, we believe that this difference is insignificant  for
                all practical purposes except for the situation when you  want
                to compare ALGLIB results with "reference"  implementation  up
                to the last significant digit.

    NOTE:       covariance matrix is estimated using  correction  for  degrees
                of freedom (covariances are divided by N-M instead of dividing
                by N).

      -- ALGLIB --
         Copyright 17.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitresults(lsfitstate state, out int info, out double[] c, out lsfitreport rep)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitresults(state.innerobj, ref info, ref c, rep.innerobj, null);
    }
    
    public static void lsfitresults(lsfitstate state, out int info, out double[] c, out lsfitreport rep, alglib.xparams _params)
    {
        info = 0;
        c = new double[0];
        rep = new lsfitreport();
        lsfit.lsfitresults(state.innerobj, ref info, ref c, rep.innerobj, _params);
    }
    
    /*************************************************************************
    This  subroutine  turns  on  verification  of  the  user-supplied analytic
    gradient:
    * user calls this subroutine before fitting begins
    * LSFitFit() is called
    * prior to actual fitting, for  each  point  in  data  set  X_i  and  each
      component  of  parameters  being  fited C_j algorithm performs following
      steps:
      * two trial steps are made to C_j-TestStep*S[j] and C_j+TestStep*S[j],
        where C_j is j-th parameter and S[j] is a scale of j-th parameter
      * if needed, steps are bounded with respect to constraints on C[]
      * F(X_i|C) is evaluated at these trial points
      * we perform one more evaluation in the middle point of the interval
      * we  build  cubic  model using function values and derivatives at trial
        points and we compare its prediction with actual value in  the  middle
        point
      * in case difference between prediction and actual value is higher  than
        some predetermined threshold, algorithm stops with completion code -7;
        Rep.VarIdx is set to index of the parameter with incorrect derivative.
    * after verification is over, algorithm proceeds to the actual optimization.

    NOTE 1: verification needs N*K (points count * parameters count)  gradient
            evaluations. It is very costly and you should use it only for  low
            dimensional  problems,  when  you  want  to  be  sure  that you've
            correctly calculated analytic derivatives. You should not  use  it
            in the production code  (unless  you  want  to  check  derivatives
            provided by some third party).

    NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
            (so large that function behaviour is significantly non-cubic) will
            lead to false alarms. You may use  different  step  for  different
            parameters by means of setting scale with LSFitSetScale().

    NOTE 3: this function may lead to false positives. In case it reports that
            I-th  derivative was calculated incorrectly, you may decrease test
            step  and  try  one  more  time  - maybe your function changes too
            sharply  and  your  step  is  too  large for such rapidly chanding
            function.

    NOTE 4: this function works only for optimizers created with LSFitCreateWFG()
            or LSFitCreateFG() constructors.

    INPUT PARAMETERS:
        State       -   structure used to store algorithm state
        TestStep    -   verification step:
                        * TestStep=0 turns verification off
                        * TestStep>0 activates verification

      -- ALGLIB --
         Copyright 15.06.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void lsfitsetgradientcheck(lsfitstate state, double teststep)
    {
    
        lsfit.lsfitsetgradientcheck(state.innerobj, teststep, null);
    }
    
    public static void lsfitsetgradientcheck(lsfitstate state, double teststep, alglib.xparams _params)
    {
    
        lsfit.lsfitsetgradientcheck(state.innerobj, teststep, _params);
    }

}
public partial class alglib
{

    
    /*************************************************************************
    Fits least squares (LS) circle (or NX-dimensional sphere) to data  (a  set
    of points in NX-dimensional space).

    Least squares circle minimizes sum of squared deviations between distances
    from points to the center and  some  "candidate"  radius,  which  is  also
    fitted to the data.

    INPUT PARAMETERS:
        XY      -   array[NPoints,NX] (or larger), contains dataset.
                    One row = one point in NX-dimensional space.
        NPoints -   dataset size, NPoints>0
        NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)

    OUTPUT PARAMETERS:
        CX      -   central point for a sphere
        R       -   radius

      -- ALGLIB --
         Copyright 07.05.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void fitspherels(double[,] xy, int npoints, int nx, out double[] cx, out double r)
    {
        cx = new double[0];
        r = 0;
        fitsphere.fitspherels(xy, npoints, nx, ref cx, ref r, null);
    }
    
    public static void fitspherels(double[,] xy, int npoints, int nx, out double[] cx, out double r, alglib.xparams _params)
    {
        cx = new double[0];
        r = 0;
        fitsphere.fitspherels(xy, npoints, nx, ref cx, ref r, _params);
    }
    
    /*************************************************************************
    Fits minimum circumscribed (MC) circle (or NX-dimensional sphere) to  data
    (a set of points in NX-dimensional space).

    INPUT PARAMETERS:
        XY      -   array[NPoints,NX] (or larger), contains dataset.
                    One row = one point in NX-dimensional space.
        NPoints -   dataset size, NPoints>0
        NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)

    OUTPUT PARAMETERS:
        CX      -   central point for a sphere
        RHi     -   radius

    NOTE: this function is an easy-to-use wrapper around more powerful "expert"
          function fitspherex().

          This  wrapper  is optimized  for  ease of use and stability - at the
          cost of somewhat lower  performance  (we  have  to  use  very  tight
          stopping criteria for inner optimizer because we want to  make  sure
          that it will converge on any dataset).

          If you are ready to experiment with settings of  "expert"  function,
          you can achieve ~2-4x speedup over standard "bulletproof" settings.


      -- ALGLIB --
         Copyright 14.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void fitspheremc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi)
    {
        cx = new double[0];
        rhi = 0;
        fitsphere.fitspheremc(xy, npoints, nx, ref cx, ref rhi, null);
    }
    
    public static void fitspheremc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi, alglib.xparams _params)
    {
        cx = new double[0];
        rhi = 0;
        fitsphere.fitspheremc(xy, npoints, nx, ref cx, ref rhi, _params);
    }
    
    /*************************************************************************
    Fits maximum inscribed circle (or NX-dimensional sphere) to data (a set of
    points in NX-dimensional space).

    INPUT PARAMETERS:
        XY      -   array[NPoints,NX] (or larger), contains dataset.
                    One row = one point in NX-dimensional space.
        NPoints -   dataset size, NPoints>0
        NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)

    OUTPUT PARAMETERS:
        CX      -   central point for a sphere
        RLo     -   radius

    NOTE: this function is an easy-to-use wrapper around more powerful "expert"
          function fitspherex().

          This  wrapper  is optimized  for  ease of use and stability - at the
          cost of somewhat lower  performance  (we  have  to  use  very  tight
          stopping criteria for inner optimizer because we want to  make  sure
          that it will converge on any dataset).

          If you are ready to experiment with settings of  "expert"  function,
          you can achieve ~2-4x speedup over standard "bulletproof" settings.


      -- ALGLIB --
         Copyright 14.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void fitspheremi(double[,] xy, int npoints, int nx, out double[] cx, out double rlo)
    {
        cx = new double[0];
        rlo = 0;
        fitsphere.fitspheremi(xy, npoints, nx, ref cx, ref rlo, null);
    }
    
    public static void fitspheremi(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, alglib.xparams _params)
    {
        cx = new double[0];
        rlo = 0;
        fitsphere.fitspheremi(xy, npoints, nx, ref cx, ref rlo, _params);
    }
    
    /*************************************************************************
    Fits minimum zone circle (or NX-dimensional sphere)  to  data  (a  set  of
    points in NX-dimensional space).

    INPUT PARAMETERS:
        XY      -   array[NPoints,NX] (or larger), contains dataset.
                    One row = one point in NX-dimensional space.
        NPoints -   dataset size, NPoints>0
        NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)

    OUTPUT PARAMETERS:
        CX      -   central point for a sphere
        RLo     -   radius of inscribed circle
        RHo     -   radius of circumscribed circle

    NOTE: this function is an easy-to-use wrapper around more powerful "expert"
          function fitspherex().

          This  wrapper  is optimized  for  ease of use and stability - at the
          cost of somewhat lower  performance  (we  have  to  use  very  tight
          stopping criteria for inner optimizer because we want to  make  sure
          that it will converge on any dataset).

          If you are ready to experiment with settings of  "expert"  function,
          you can achieve ~2-4x speedup over standard "bulletproof" settings.


      -- ALGLIB --
         Copyright 14.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void fitspheremz(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi)
    {
        cx = new double[0];
        rlo = 0;
        rhi = 0;
        fitsphere.fitspheremz(xy, npoints, nx, ref cx, ref rlo, ref rhi, null);
    }
    
    public static void fitspheremz(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi, alglib.xparams _params)
    {
        cx = new double[0];
        rlo = 0;
        rhi = 0;
        fitsphere.fitspheremz(xy, npoints, nx, ref cx, ref rlo, ref rhi, _params);
    }
    
    /*************************************************************************
    Fitting minimum circumscribed, maximum inscribed or minimum  zone  circles
    (or NX-dimensional spheres)  to  data  (a  set of points in NX-dimensional
    space).

    This  is  expert  function  which  allows  to  tweak  many  parameters  of
    underlying nonlinear solver:
    * stopping criteria for inner iterations
    * number of outer iterations
    * penalty coefficient used to handle  nonlinear  constraints  (we  convert
      unconstrained nonsmooth optimization problem ivolving max() and/or min()
      operations to quadratically constrained smooth one).

    You may tweak all these parameters or only some  of  them,  leaving  other
    ones at their default state - just specify zero  value,  and  solver  will
    fill it with appropriate default one.

    These comments also include some discussion of  approach  used  to  handle
    such unusual fitting problem,  its  stability,  drawbacks  of  alternative
    methods, and convergence properties.

    INPUT PARAMETERS:
        XY      -   array[NPoints,NX] (or larger), contains dataset.
                    One row = one point in NX-dimensional space.
        NPoints -   dataset size, NPoints>0
        NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
        ProblemType-used to encode problem type:
                    * 0 for least squares circle
                    * 1 for minimum circumscribed circle/sphere fitting (MC)
                    * 2 for  maximum inscribed circle/sphere fitting (MI)
                    * 3 for minimum zone circle fitting (difference between
                        Rhi and Rlo is minimized), denoted as MZ
        EpsX    -   stopping condition for NLC optimizer:
                    * must be non-negative
                    * use 0 to choose default value (1.0E-12 is used by default)
                    * you may specify larger values, up to 1.0E-6, if you want
                      to   speed-up   solver;   NLC   solver  performs several
                      preconditioned  outer  iterations,   so   final   result
                      typically has precision much better than EpsX.
        AULIts  -   number of outer iterations performed by NLC optimizer:
                    * must be non-negative
                    * use 0 to choose default value (20 is used by default)
                    * you may specify values smaller than 20 if you want to
                      speed up solver; 10 often results in good combination of
                      precision and speed; sometimes you may get good results
                      with just 6 outer iterations.
                    Ignored for ProblemType=0.
        Penalty -   penalty coefficient for NLC optimizer:
                    * must be non-negative
                    * use 0 to choose default value (1.0E6 in current version)
                    * it should be really large, 1.0E6...1.0E7 is a good value
                      to start from;
                    * generally, default value is good enough
                    Ignored for ProblemType=0.

    OUTPUT PARAMETERS:
        CX      -   central point for a sphere
        RLo     -   radius:
                    * for ProblemType=2,3, radius of the inscribed sphere
                    * for ProblemType=0 - radius of the least squares sphere
                    * for ProblemType=1 - zero
        RHo     -   radius:
                    * for ProblemType=1,3, radius of the circumscribed sphere
                    * for ProblemType=0 - radius of the least squares sphere
                    * for ProblemType=2 - zero

    NOTE: ON THE UNIQUENESS OF SOLUTIONS

    ALGLIB provides solution to several related circle fitting  problems:   MC
    (minimum circumscribed), MI (maximum inscribed)   and   MZ  (minimum zone)
    fitting, LS (least squares) fitting.

    It  is  important  to  note  that  among these problems only MC and LS are
    convex and have unique solution independently from starting point.

    As  for MI,  it  may (or  may  not, depending on dataset properties)  have
    multiple solutions, and it always  has  one degenerate solution C=infinity
    which corresponds to infinitely large radius. Thus, there are no guarantees
    that solution to  MI returned by this solver will be the best one (and  no
    one can provide you with such guarantee because problem is  NP-hard).  The
    only guarantee you have is that this solution is locally optimal, i.e.  it
    can not be improved by infinitesimally small tweaks in the parameters.

    It  is  also  possible  to "run away" to infinity when  started  from  bad
    initial point located outside of point cloud (or when point cloud does not
    span entire circumference/surface of the sphere).

    Finally,  MZ (minimum zone circle) stands somewhere between MC  and  MI in
    stability. It is somewhat regularized by "circumscribed" term of the merit
    function; however, solutions to  MZ may be non-unique, and in some unlucky
    cases it is also possible to "run away to infinity".


    NOTE: ON THE NONLINEARLY CONSTRAINED PROGRAMMING APPROACH

    The problem formulation for MC  (minimum circumscribed   circle;  for  the
    sake of simplicity we omit MZ and MI here) is:

            [     [         ]2 ]
        min [ max [ XY[i]-C ]  ]
         C  [  i  [         ]  ]

    i.e. it is unconstrained nonsmooth optimization problem of finding  "best"
    central point, with radius R being unambiguously  determined  from  C.  In
    order to move away from non-smoothness we use following reformulation:

            [   ]                  [         ]2
        min [ R ] subject to R>=0, [ XY[i]-C ]  <= R^2
        C,R [   ]                  [         ]

    i.e. it becomes smooth quadratically constrained optimization problem with
    linear target function. Such problem statement is 100% equivalent  to  the
    original nonsmooth one, but much easier  to  approach.  We solve  it  with
    MinNLC solver provided by ALGLIB.


    NOTE: ON INSTABILITY OF SEQUENTIAL LINEARIZATION APPROACH

    ALGLIB  has  nonlinearly  constrained  solver which proved to be stable on
    such problems. However, some authors proposed to linearize constraints  in
    the vicinity of current approximation (Ci,Ri) and to get next  approximate
    solution (Ci+1,Ri+1) as solution to linear programming problem. Obviously,
    LP problems are easier than nonlinearly constrained ones.

    Indeed,  such approach  to   MC/MI/MZ   resulted   in  ~10-20x increase in
    performance (when compared with NLC solver). However, it turned  out  that
    in some cases linearized model fails to predict correct direction for next
    step and tells us that we converged to solution even when we are still 2-4
    digits of precision away from it.

    It is important that it is not failure of LP solver - it is failure of the
    linear model;  even  when  solved  exactly,  it  fails  to  handle  subtle
    nonlinearities which arise near the solution. We validated it by comparing
    results returned by ALGLIB linear solver with that of MATLAB.

    In our experiments with linearization:
    * MC failed most often, at both realistic and synthetic datasets
    * MI sometimes failed, but sometimes succeeded
    * MZ often  succeeded; our guess is that presence of two independent  sets
      of constraints (one set for Rlo and another one for Rhi) and  two  terms
      in the target function (Rlo and Rhi) regularizes task,  so  when  linear
      model fails to handle nonlinearities from Rlo, it uses  Rhi  as  a  hint
      (and vice versa).

    Because linearization approach failed to achieve stable results, we do not
    include it in ALGLIB.


      -- ALGLIB --
         Copyright 14.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void fitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi)
    {
        cx = new double[0];
        rlo = 0;
        rhi = 0;
        fitsphere.fitspherex(xy, npoints, nx, problemtype, epsx, aulits, penalty, ref cx, ref rlo, ref rhi, null);
    }
    
    public static void fitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi, alglib.xparams _params)
    {
        cx = new double[0];
        rlo = 0;
        rhi = 0;
        fitsphere.fitspherex(xy, npoints, nx, problemtype, epsx, aulits, penalty, ref cx, ref rlo, ref rhi, _params);
    }

}
public partial class alglib
{


    /*************************************************************************
    Parametric spline inteprolant: 2-dimensional curve.

    You should not try to access its members directly - use PSpline2XXXXXXXX()
    functions instead.
    *************************************************************************/
    public class pspline2interpolant : alglibobject
    {
        //
        // Public declarations
        //
    
        public pspline2interpolant()
        {
            _innerobj = new parametric.pspline2interpolant();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new pspline2interpolant((parametric.pspline2interpolant)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private parametric.pspline2interpolant _innerobj;
        public parametric.pspline2interpolant innerobj { get { return _innerobj; } }
        public pspline2interpolant(parametric.pspline2interpolant obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    Parametric spline inteprolant: 3-dimensional curve.

    You should not try to access its members directly - use PSpline3XXXXXXXX()
    functions instead.
    *************************************************************************/
    public class pspline3interpolant : alglibobject
    {
        //
        // Public declarations
        //
    
        public pspline3interpolant()
        {
            _innerobj = new parametric.pspline3interpolant();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new pspline3interpolant((parametric.pspline3interpolant)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private parametric.pspline3interpolant _innerobj;
        public parametric.pspline3interpolant innerobj { get { return _innerobj; } }
        public pspline3interpolant(parametric.pspline3interpolant obj)
        {
            _innerobj = obj;
        }
    }
    
    /*************************************************************************
    This function  builds  non-periodic 2-dimensional parametric spline  which
    starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).

    INPUT PARAMETERS:
        XY  -   points, array[0..N-1,0..1].
                XY[I,0:1] corresponds to the Ith point.
                Order of points is important!
        N   -   points count, N>=5 for Akima splines, N>=2 for other types  of
                splines.
        ST  -   spline type:
                * 0     Akima spline
                * 1     parabolically terminated Catmull-Rom spline (Tension=0)
                * 2     parabolically terminated cubic spline
        PT  -   parameterization type:
                * 0     uniform
                * 1     chord length
                * 2     centripetal

    OUTPUT PARAMETERS:
        P   -   parametric spline interpolant


    NOTES:
    * this function  assumes  that  there all consequent points  are distinct.
      I.e. (x0,y0)<>(x1,y1),  (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so on.
      However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
      =(x2,y2).

      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline2build(double[,] xy, int n, int st, int pt, out pspline2interpolant p)
    {
        p = new pspline2interpolant();
        parametric.pspline2build(xy, n, st, pt, p.innerobj, null);
    }
    
    public static void pspline2build(double[,] xy, int n, int st, int pt, out pspline2interpolant p, alglib.xparams _params)
    {
        p = new pspline2interpolant();
        parametric.pspline2build(xy, n, st, pt, p.innerobj, _params);
    }
    
    /*************************************************************************
    This function  builds  non-periodic 3-dimensional parametric spline  which
    starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).

    Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
    description here.

      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline3build(double[,] xy, int n, int st, int pt, out pspline3interpolant p)
    {
        p = new pspline3interpolant();
        parametric.pspline3build(xy, n, st, pt, p.innerobj, null);
    }
    
    public static void pspline3build(double[,] xy, int n, int st, int pt, out pspline3interpolant p, alglib.xparams _params)
    {
        p = new pspline3interpolant();
        parametric.pspline3build(xy, n, st, pt, p.innerobj, _params);
    }
    
    /*************************************************************************
    This  function  builds  periodic  2-dimensional  parametric  spline  which
    starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
    back to (X[0],Y[0]).

    INPUT PARAMETERS:
        XY  -   points, array[0..N-1,0..1].
                XY[I,0:1] corresponds to the Ith point.
                XY[N-1,0:1] must be different from XY[0,0:1].
                Order of points is important!
        N   -   points count, N>=3 for other types of splines.
        ST  -   spline type:
                * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
                * 2     cubic spline with cyclic boundary conditions
        PT  -   parameterization type:
                * 0     uniform
                * 1     chord length
                * 2     centripetal

    OUTPUT PARAMETERS:
        P   -   parametric spline interpolant


    NOTES:
    * this function  assumes  that there all consequent points  are  distinct.
      I.e. (x0,y0)<>(x1,y1), (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so  on.
      However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
      =(x2,y2).
    * last point of sequence is NOT equal to the first  point.  You  shouldn't
      make curve "explicitly periodic" by making them equal.

      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline2buildperiodic(double[,] xy, int n, int st, int pt, out pspline2interpolant p)
    {
        p = new pspline2interpolant();
        parametric.pspline2buildperiodic(xy, n, st, pt, p.innerobj, null);
    }
    
    public static void pspline2buildperiodic(double[,] xy, int n, int st, int pt, out pspline2interpolant p, alglib.xparams _params)
    {
        p = new pspline2interpolant();
        parametric.pspline2buildperiodic(xy, n, st, pt, p.innerobj, _params);
    }
    
    /*************************************************************************
    This  function  builds  periodic  3-dimensional  parametric  spline  which
    starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
    and then back to (X[0],Y[0],Z[0]).

    Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
    description here.

      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline3buildperiodic(double[,] xy, int n, int st, int pt, out pspline3interpolant p)
    {
        p = new pspline3interpolant();
        parametric.pspline3buildperiodic(xy, n, st, pt, p.innerobj, null);
    }
    
    public static void pspline3buildperiodic(double[,] xy, int n, int st, int pt, out pspline3interpolant p, alglib.xparams _params)
    {
        p = new pspline3interpolant();
        parametric.pspline3buildperiodic(xy, n, st, pt, p.innerobj, _params);
    }
    
    /*************************************************************************
    This function returns vector of parameter values correspoding to points.

    I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
    have
        (X[0],Y[0]) = PSpline2Calc(P,U[0]),
        (X[1],Y[1]) = PSpline2Calc(P,U[1]),
        (X[2],Y[2]) = PSpline2Calc(P,U[2]),
        ...

    INPUT PARAMETERS:
        P   -   parametric spline interpolant

    OUTPUT PARAMETERS:
        N   -   array size
        T   -   array[0..N-1]


    NOTES:
    * for non-periodic splines U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]=1
    * for periodic splines     U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]<1

      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline2parametervalues(pspline2interpolant p, out int n, out double[] t)
    {
        n = 0;
        t = new double[0];
        parametric.pspline2parametervalues(p.innerobj, ref n, ref t, null);
    }
    
    public static void pspline2parametervalues(pspline2interpolant p, out int n, out double[] t, alglib.xparams _params)
    {
        n = 0;
        t = new double[0];
        parametric.pspline2parametervalues(p.innerobj, ref n, ref t, _params);
    }
    
    /*************************************************************************
    This function returns vector of parameter values correspoding to points.

    Same as PSpline2ParameterValues(), but for 3D.

      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline3parametervalues(pspline3interpolant p, out int n, out double[] t)
    {
        n = 0;
        t = new double[0];
        parametric.pspline3parametervalues(p.innerobj, ref n, ref t, null);
    }
    
    public static void pspline3parametervalues(pspline3interpolant p, out int n, out double[] t, alglib.xparams _params)
    {
        n = 0;
        t = new double[0];
        parametric.pspline3parametervalues(p.innerobj, ref n, ref t, _params);
    }
    
    /*************************************************************************
    This function  calculates  the value of the parametric spline for a  given
    value of parameter T

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        T   -   point:
                * T in [0,1] corresponds to interval spanned by points
                * for non-periodic splines T<0 (or T>1) correspond to parts of
                  the curve before the first (after the last) point
                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                  by making T=T-floor(T).

    OUTPUT PARAMETERS:
        X   -   X-position
        Y   -   Y-position


      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline2calc(pspline2interpolant p, double t, out double x, out double y)
    {
        x = 0;
        y = 0;
        parametric.pspline2calc(p.innerobj, t, ref x, ref y, null);
    }
    
    public static void pspline2calc(pspline2interpolant p, double t, out double x, out double y, alglib.xparams _params)
    {
        x = 0;
        y = 0;
        parametric.pspline2calc(p.innerobj, t, ref x, ref y, _params);
    }
    
    /*************************************************************************
    This function  calculates  the value of the parametric spline for a  given
    value of parameter T.

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        T   -   point:
                * T in [0,1] corresponds to interval spanned by points
                * for non-periodic splines T<0 (or T>1) correspond to parts of
                  the curve before the first (after the last) point
                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                  by making T=T-floor(T).

    OUTPUT PARAMETERS:
        X   -   X-position
        Y   -   Y-position
        Z   -   Z-position


      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline3calc(pspline3interpolant p, double t, out double x, out double y, out double z)
    {
        x = 0;
        y = 0;
        z = 0;
        parametric.pspline3calc(p.innerobj, t, ref x, ref y, ref z, null);
    }
    
    public static void pspline3calc(pspline3interpolant p, double t, out double x, out double y, out double z, alglib.xparams _params)
    {
        x = 0;
        y = 0;
        z = 0;
        parametric.pspline3calc(p.innerobj, t, ref x, ref y, ref z, _params);
    }
    
    /*************************************************************************
    This function  calculates  tangent vector for a given value of parameter T

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        T   -   point:
                * T in [0,1] corresponds to interval spanned by points
                * for non-periodic splines T<0 (or T>1) correspond to parts of
                  the curve before the first (after the last) point
                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                  by making T=T-floor(T).

    OUTPUT PARAMETERS:
        X    -   X-component of tangent vector (normalized)
        Y    -   Y-component of tangent vector (normalized)

    NOTE:
        X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.


      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline2tangent(pspline2interpolant p, double t, out double x, out double y)
    {
        x = 0;
        y = 0;
        parametric.pspline2tangent(p.innerobj, t, ref x, ref y, null);
    }
    
    public static void pspline2tangent(pspline2interpolant p, double t, out double x, out double y, alglib.xparams _params)
    {
        x = 0;
        y = 0;
        parametric.pspline2tangent(p.innerobj, t, ref x, ref y, _params);
    }
    
    /*************************************************************************
    This function  calculates  tangent vector for a given value of parameter T

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        T   -   point:
                * T in [0,1] corresponds to interval spanned by points
                * for non-periodic splines T<0 (or T>1) correspond to parts of
                  the curve before the first (after the last) point
                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                  by making T=T-floor(T).

    OUTPUT PARAMETERS:
        X    -   X-component of tangent vector (normalized)
        Y    -   Y-component of tangent vector (normalized)
        Z    -   Z-component of tangent vector (normalized)

    NOTE:
        X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.


      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline3tangent(pspline3interpolant p, double t, out double x, out double y, out double z)
    {
        x = 0;
        y = 0;
        z = 0;
        parametric.pspline3tangent(p.innerobj, t, ref x, ref y, ref z, null);
    }
    
    public static void pspline3tangent(pspline3interpolant p, double t, out double x, out double y, out double z, alglib.xparams _params)
    {
        x = 0;
        y = 0;
        z = 0;
        parametric.pspline3tangent(p.innerobj, t, ref x, ref y, ref z, _params);
    }
    
    /*************************************************************************
    This function calculates derivative, i.e. it returns (dX/dT,dY/dT).

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        T   -   point:
                * T in [0,1] corresponds to interval spanned by points
                * for non-periodic splines T<0 (or T>1) correspond to parts of
                  the curve before the first (after the last) point
                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                  by making T=T-floor(T).

    OUTPUT PARAMETERS:
        X   -   X-value
        DX  -   X-derivative
        Y   -   Y-value
        DY  -   Y-derivative


      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline2diff(pspline2interpolant p, double t, out double x, out double dx, out double y, out double dy)
    {
        x = 0;
        dx = 0;
        y = 0;
        dy = 0;
        parametric.pspline2diff(p.innerobj, t, ref x, ref dx, ref y, ref dy, null);
    }
    
    public static void pspline2diff(pspline2interpolant p, double t, out double x, out double dx, out double y, out double dy, alglib.xparams _params)
    {
        x = 0;
        dx = 0;
        y = 0;
        dy = 0;
        parametric.pspline2diff(p.innerobj, t, ref x, ref dx, ref y, ref dy, _params);
    }
    
    /*************************************************************************
    This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        T   -   point:
                * T in [0,1] corresponds to interval spanned by points
                * for non-periodic splines T<0 (or T>1) correspond to parts of
                  the curve before the first (after the last) point
                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                  by making T=T-floor(T).

    OUTPUT PARAMETERS:
        X   -   X-value
        DX  -   X-derivative
        Y   -   Y-value
        DY  -   Y-derivative
        Z   -   Z-value
        DZ  -   Z-derivative


      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline3diff(pspline3interpolant p, double t, out double x, out double dx, out double y, out double dy, out double z, out double dz)
    {
        x = 0;
        dx = 0;
        y = 0;
        dy = 0;
        z = 0;
        dz = 0;
        parametric.pspline3diff(p.innerobj, t, ref x, ref dx, ref y, ref dy, ref z, ref dz, null);
    }
    
    public static void pspline3diff(pspline3interpolant p, double t, out double x, out double dx, out double y, out double dy, out double z, out double dz, alglib.xparams _params)
    {
        x = 0;
        dx = 0;
        y = 0;
        dy = 0;
        z = 0;
        dz = 0;
        parametric.pspline3diff(p.innerobj, t, ref x, ref dx, ref y, ref dy, ref z, ref dz, _params);
    }
    
    /*************************************************************************
    This function calculates first and second derivative with respect to T.

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        T   -   point:
                * T in [0,1] corresponds to interval spanned by points
                * for non-periodic splines T<0 (or T>1) correspond to parts of
                  the curve before the first (after the last) point
                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                  by making T=T-floor(T).

    OUTPUT PARAMETERS:
        X   -   X-value
        DX  -   derivative
        D2X -   second derivative
        Y   -   Y-value
        DY  -   derivative
        D2Y -   second derivative


      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline2diff2(pspline2interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y)
    {
        x = 0;
        dx = 0;
        d2x = 0;
        y = 0;
        dy = 0;
        d2y = 0;
        parametric.pspline2diff2(p.innerobj, t, ref x, ref dx, ref d2x, ref y, ref dy, ref d2y, null);
    }
    
    public static void pspline2diff2(pspline2interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, alglib.xparams _params)
    {
        x = 0;
        dx = 0;
        d2x = 0;
        y = 0;
        dy = 0;
        d2y = 0;
        parametric.pspline2diff2(p.innerobj, t, ref x, ref dx, ref d2x, ref y, ref dy, ref d2y, _params);
    }
    
    /*************************************************************************
    This function calculates first and second derivative with respect to T.

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        T   -   point:
                * T in [0,1] corresponds to interval spanned by points
                * for non-periodic splines T<0 (or T>1) correspond to parts of
                  the curve before the first (after the last) point
                * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                  by making T=T-floor(T).

    OUTPUT PARAMETERS:
        X   -   X-value
        DX  -   derivative
        D2X -   second derivative
        Y   -   Y-value
        DY  -   derivative
        D2Y -   second derivative
        Z   -   Z-value
        DZ  -   derivative
        D2Z -   second derivative


      -- ALGLIB PROJECT --
         Copyright 28.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void pspline3diff2(pspline3interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, out double z, out double dz, out double d2z)
    {
        x = 0;
        dx = 0;
        d2x = 0;
        y = 0;
        dy = 0;
        d2y = 0;
        z = 0;
        dz = 0;
        d2z = 0;
        parametric.pspline3diff2(p.innerobj, t, ref x, ref dx, ref d2x, ref y, ref dy, ref d2y, ref z, ref dz, ref d2z, null);
    }
    
    public static void pspline3diff2(pspline3interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, out double z, out double dz, out double d2z, alglib.xparams _params)
    {
        x = 0;
        dx = 0;
        d2x = 0;
        y = 0;
        dy = 0;
        d2y = 0;
        z = 0;
        dz = 0;
        d2z = 0;
        parametric.pspline3diff2(p.innerobj, t, ref x, ref dx, ref d2x, ref y, ref dy, ref d2y, ref z, ref dz, ref d2z, _params);
    }
    
    /*************************************************************************
    This function  calculates  arc length, i.e. length of  curve  between  t=a
    and t=b.

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        A,B -   parameter values corresponding to arc ends:
                * B>A will result in positive length returned
                * B<A will result in negative length returned

    RESULT:
        length of arc starting at T=A and ending at T=B.


      -- ALGLIB PROJECT --
         Copyright 30.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static double pspline2arclength(pspline2interpolant p, double a, double b)
    {
    
        return parametric.pspline2arclength(p.innerobj, a, b, null);
    }
    
    public static double pspline2arclength(pspline2interpolant p, double a, double b, alglib.xparams _params)
    {
    
        return parametric.pspline2arclength(p.innerobj, a, b, _params);
    }
    
    /*************************************************************************
    This function  calculates  arc length, i.e. length of  curve  between  t=a
    and t=b.

    INPUT PARAMETERS:
        P   -   parametric spline interpolant
        A,B -   parameter values corresponding to arc ends:
                * B>A will result in positive length returned
                * B<A will result in negative length returned

    RESULT:
        length of arc starting at T=A and ending at T=B.


      -- ALGLIB PROJECT --
         Copyright 30.05.2010 by Bochkanov Sergey
    *************************************************************************/
    public static double pspline3arclength(pspline3interpolant p, double a, double b)
    {
    
        return parametric.pspline3arclength(p.innerobj, a, b, null);
    }
    
    public static double pspline3arclength(pspline3interpolant p, double a, double b, alglib.xparams _params)
    {
    
        return parametric.pspline3arclength(p.innerobj, a, b, _params);
    }
    
    /*************************************************************************
    This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
    Peucker algorithm. This  function  performs PARAMETRIC fit, i.e. it can be
    used to fit curves like circles.

    On  input  it  accepts dataset which describes parametric multidimensional
    curve X(t), with X being vector, and t taking values in [0,N), where N  is
    a number of points in dataset. As result, it returns reduced  dataset  X2,
    which can be used to build  parametric  curve  X2(t),  which  approximates
    X(t) with desired precision (or has specified number of sections).


    INPUT PARAMETERS:
        X       -   array of multidimensional points:
                    * at least N elements, leading N elements are used if more
                      than N elements were specified
                    * order of points is IMPORTANT because  it  is  parametric
                      fit
                    * each row of array is one point which has D coordinates
        N       -   number of elements in X
        D       -   number of dimensions (elements per row of X)
        StopM   -   stopping condition - desired number of sections:
                    * at most M sections are generated by this function
                    * less than M sections can be generated if we have N<M
                      (or some X are non-distinct).
                    * zero StopM means that algorithm does not stop after
                      achieving some pre-specified section count
        StopEps -   stopping condition - desired precision:
                    * algorithm stops after error in each section is at most Eps
                    * zero Eps means that algorithm does not stop after
                      achieving some pre-specified precision

    OUTPUT PARAMETERS:
        X2      -   array of corner points for piecewise approximation,
                    has length NSections+1 or zero (for NSections=0).
        Idx2    -   array of indexes (parameter values):
                    * has length NSections+1 or zero (for NSections=0).
                    * each element of Idx2 corresponds to same-numbered
                      element of X2
                    * each element of Idx2 is index of  corresponding  element
                      of X2 at original array X, i.e. I-th  row  of  X2  is
                      Idx2[I]-th row of X.
                    * elements of Idx2 can be treated as parameter values
                      which should be used when building new parametric curve
                    * Idx2[0]=0, Idx2[NSections]=N-1
        NSections-  number of sections found by algorithm, NSections<=M,
                    NSections can be zero for degenerate datasets
                    (N<=1 or all X[] are non-distinct).

    NOTE: algorithm stops after:
          a) dividing curve into StopM sections
          b) achieving required precision StopEps
          c) dividing curve into N-1 sections
          If both StopM and StopEps are non-zero, algorithm is stopped by  the
          FIRST criterion which is satisfied. In case both StopM  and  StopEps
          are zero, algorithm stops because of (c).

      -- ALGLIB --
         Copyright 02.10.2014 by Bochkanov Sergey
    *************************************************************************/
    public static void parametricrdpfixed(double[,] x, int n, int d, int stopm, double stopeps, out double[,] x2, out int[] idx2, out int nsections)
    {
        x2 = new double[0,0];
        idx2 = new int[0];
        nsections = 0;
        parametric.parametricrdpfixed(x, n, d, stopm, stopeps, ref x2, ref idx2, ref nsections, null);
    }
    
    public static void parametricrdpfixed(double[,] x, int n, int d, int stopm, double stopeps, out double[,] x2, out int[] idx2, out int nsections, alglib.xparams _params)
    {
        x2 = new double[0,0];
        idx2 = new int[0];
        nsections = 0;
        parametric.parametricrdpfixed(x, n, d, stopm, stopeps, ref x2, ref idx2, ref nsections, _params);
    }

}
public partial class alglib
{



}
public partial class alglib
{



}
public partial class alglib
{


    /*************************************************************************
    2-dimensional spline inteprolant
    *************************************************************************/
    public class spline2dinterpolant : alglibobject
    {
        //
        // Public declarations
        //
    
        public spline2dinterpolant()
        {
            _innerobj = new spline2d.spline2dinterpolant();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new spline2dinterpolant((spline2d.spline2dinterpolant)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private spline2d.spline2dinterpolant _innerobj;
        public spline2d.spline2dinterpolant innerobj { get { return _innerobj; } }
        public spline2dinterpolant(spline2d.spline2dinterpolant obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    Nonlinear least squares solver used to fit 2D splines to data
    *************************************************************************/
    public class spline2dbuilder : alglibobject
    {
        //
        // Public declarations
        //
    
        public spline2dbuilder()
        {
            _innerobj = new spline2d.spline2dbuilder();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new spline2dbuilder((spline2d.spline2dbuilder)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private spline2d.spline2dbuilder _innerobj;
        public spline2d.spline2dbuilder innerobj { get { return _innerobj; } }
        public spline2dbuilder(spline2d.spline2dbuilder obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    Spline 2D fitting report:
        rmserror        RMS error
        avgerror        average error
        maxerror        maximum error
        r2              coefficient of determination,  R-squared, 1-RSS/TSS
    *************************************************************************/
    public class spline2dfitreport : alglibobject
    {
        //
        // Public declarations
        //
        public double rmserror { get { return _innerobj.rmserror; } set { _innerobj.rmserror = value; } }
        public double avgerror { get { return _innerobj.avgerror; } set { _innerobj.avgerror = value; } }
        public double maxerror { get { return _innerobj.maxerror; } set { _innerobj.maxerror = value; } }
        public double r2 { get { return _innerobj.r2; } set { _innerobj.r2 = value; } }
    
        public spline2dfitreport()
        {
            _innerobj = new spline2d.spline2dfitreport();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new spline2dfitreport((spline2d.spline2dfitreport)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private spline2d.spline2dfitreport _innerobj;
        public spline2d.spline2dfitreport innerobj { get { return _innerobj; } }
        public spline2dfitreport(spline2d.spline2dfitreport obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    This function serializes data structure to string.
    
    Important properties of s_out:
    * it contains alphanumeric characters, dots, underscores, minus signs
    * these symbols are grouped into words, which are separated by spaces
      and Windows-style (CR+LF) newlines
    * although  serializer  uses  spaces and CR+LF as separators, you can 
      replace any separator character by arbitrary combination of spaces,
      tabs, Windows or Unix newlines. It allows flexible reformatting  of
      the  string  in  case you want to include it into text or XML file. 
      But you should not insert separators into the middle of the "words"
      nor you should change case of letters.
    * s_out can be freely moved between 32-bit and 64-bit systems, little
      and big endian machines, and so on. You can serialize structure  on
      32-bit machine and unserialize it on 64-bit one (or vice versa), or
      serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
      serialize  it  in  C# version of ALGLIB and unserialize in C++ one, 
      and vice versa.
    *************************************************************************/
    public static void spline2dserialize(spline2dinterpolant obj, out string s_out)
    {
        alglib.serializer s = new alglib.serializer();
        s.alloc_start();
        spline2d.spline2dalloc(s, obj.innerobj, null);
        s.sstart_str();
        spline2d.spline2dserialize(s, obj.innerobj, null);
        s.stop();
        s_out = s.get_string();
    }


    /*************************************************************************
    This function unserializes data structure from string.
    *************************************************************************/
    public static void spline2dunserialize(string s_in, out spline2dinterpolant obj)
    {
        alglib.serializer s = new alglib.serializer();
        obj = new spline2dinterpolant();
        s.ustart_str(s_in);
        spline2d.spline2dunserialize(s, obj.innerobj, null);
        s.stop();
    }


    /*************************************************************************
    This function serializes data structure to stream.
    
    Data stream generated by this function is same as  string  representation
    generated  by  string  version  of  serializer - alphanumeric characters,
    dots, underscores, minus signs, which are grouped into words separated by
    spaces and CR+LF.
    
    We recommend you to read comments on string version of serializer to find
    out more about serialization of AlGLIB objects.
    *************************************************************************/
    public static void spline2dserialize(spline2dinterpolant obj, System.IO.Stream stream_out)
    {
        alglib.serializer s = new alglib.serializer();
        s.alloc_start();
        spline2d.spline2dalloc(s, obj.innerobj, null);
        s.sstart_stream(stream_out);
        spline2d.spline2dserialize(s, obj.innerobj, null);
        s.stop();
    }


    /*************************************************************************
    This function unserializes data structure from stream.
    *************************************************************************/
    public static void spline2dunserialize(System.IO.Stream stream_in, out spline2dinterpolant obj)
    {
        alglib.serializer s = new alglib.serializer();
        obj = new spline2dinterpolant();
        s.ustart_stream(stream_in);
        spline2d.spline2dunserialize(s, obj.innerobj, null);
        s.stop();
    }
    
    /*************************************************************************
    This subroutine calculates the value of the bilinear or bicubic spline  at
    the given point X.

    Input parameters:
        C   -   2D spline object.
                Built by spline2dbuildbilinearv or spline2dbuildbicubicv.
        X, Y-   point

    Result:
        S(x,y)

      -- ALGLIB PROJECT --
         Copyright 05.07.2007 by Bochkanov Sergey
    *************************************************************************/
    public static double spline2dcalc(spline2dinterpolant c, double x, double y)
    {
    
        return spline2d.spline2dcalc(c.innerobj, x, y, null);
    }
    
    public static double spline2dcalc(spline2dinterpolant c, double x, double y, alglib.xparams _params)
    {
    
        return spline2d.spline2dcalc(c.innerobj, x, y, _params);
    }
    
    /*************************************************************************
    This subroutine calculates the value of the bilinear or bicubic spline  at
    the given point X and its derivatives.

    Input parameters:
        C   -   spline interpolant.
        X, Y-   point

    Output parameters:
        F   -   S(x,y)
        FX  -   dS(x,y)/dX
        FY  -   dS(x,y)/dY
        FXY -   d2S(x,y)/dXdY

      -- ALGLIB PROJECT --
         Copyright 05.07.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2ddiff(spline2dinterpolant c, double x, double y, out double f, out double fx, out double fy, out double fxy)
    {
        f = 0;
        fx = 0;
        fy = 0;
        fxy = 0;
        spline2d.spline2ddiff(c.innerobj, x, y, ref f, ref fx, ref fy, ref fxy, null);
    }
    
    public static void spline2ddiff(spline2dinterpolant c, double x, double y, out double f, out double fx, out double fy, out double fxy, alglib.xparams _params)
    {
        f = 0;
        fx = 0;
        fy = 0;
        fxy = 0;
        spline2d.spline2ddiff(c.innerobj, x, y, ref f, ref fx, ref fy, ref fxy, _params);
    }
    
    /*************************************************************************
    This subroutine calculates bilinear or bicubic vector-valued spline at the
    given point (X,Y).

    If you need just some specific component of vector-valued spline, you  can
    use spline2dcalcvi() function.

    INPUT PARAMETERS:
        C   -   spline interpolant.
        X, Y-   point
        F   -   output buffer, possibly preallocated array. In case array size
                is large enough to store result, it is not reallocated.  Array
                which is too short will be reallocated

    OUTPUT PARAMETERS:
        F   -   array[D] (or larger) which stores function values

      -- ALGLIB PROJECT --
         Copyright 01.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dcalcvbuf(spline2dinterpolant c, double x, double y, ref double[] f)
    {
    
        spline2d.spline2dcalcvbuf(c.innerobj, x, y, ref f, null);
    }
    
    public static void spline2dcalcvbuf(spline2dinterpolant c, double x, double y, ref double[] f, alglib.xparams _params)
    {
    
        spline2d.spline2dcalcvbuf(c.innerobj, x, y, ref f, _params);
    }
    
    /*************************************************************************
    This subroutine calculates specific component of vector-valued bilinear or
    bicubic spline at the given point (X,Y).

    INPUT PARAMETERS:
        C   -   spline interpolant.
        X, Y-   point
        I   -   component index, in [0,D). An exception is generated for out
                of range values.

    RESULT:
        value of I-th component

      -- ALGLIB PROJECT --
         Copyright 01.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static double spline2dcalcvi(spline2dinterpolant c, double x, double y, int i)
    {
    
        return spline2d.spline2dcalcvi(c.innerobj, x, y, i, null);
    }
    
    public static double spline2dcalcvi(spline2dinterpolant c, double x, double y, int i, alglib.xparams _params)
    {
    
        return spline2d.spline2dcalcvi(c.innerobj, x, y, i, _params);
    }
    
    /*************************************************************************
    This subroutine calculates bilinear or bicubic vector-valued spline at the
    given point (X,Y).

    INPUT PARAMETERS:
        C   -   spline interpolant.
        X, Y-   point

    OUTPUT PARAMETERS:
        F   -   array[D] which stores function values.  F is out-parameter and
                it  is  reallocated  after  call to this function. In case you
                want  to    reuse  previously  allocated  F,   you   may   use
                Spline2DCalcVBuf(),  which  reallocates  F only when it is too
                small.

      -- ALGLIB PROJECT --
         Copyright 16.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dcalcv(spline2dinterpolant c, double x, double y, out double[] f)
    {
        f = new double[0];
        spline2d.spline2dcalcv(c.innerobj, x, y, ref f, null);
    }
    
    public static void spline2dcalcv(spline2dinterpolant c, double x, double y, out double[] f, alglib.xparams _params)
    {
        f = new double[0];
        spline2d.spline2dcalcv(c.innerobj, x, y, ref f, _params);
    }
    
    /*************************************************************************
    This subroutine calculates value of  specific  component  of  bilinear  or
    bicubic vector-valued spline and its derivatives.

    Input parameters:
        C   -   spline interpolant.
        X, Y-   point
        I   -   component index, in [0,D)

    Output parameters:
        F   -   S(x,y)
        FX  -   dS(x,y)/dX
        FY  -   dS(x,y)/dY
        FXY -   d2S(x,y)/dXdY

      -- ALGLIB PROJECT --
         Copyright 05.07.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2ddiffvi(spline2dinterpolant c, double x, double y, int i, out double f, out double fx, out double fy, out double fxy)
    {
        f = 0;
        fx = 0;
        fy = 0;
        fxy = 0;
        spline2d.spline2ddiffvi(c.innerobj, x, y, i, ref f, ref fx, ref fy, ref fxy, null);
    }
    
    public static void spline2ddiffvi(spline2dinterpolant c, double x, double y, int i, out double f, out double fx, out double fy, out double fxy, alglib.xparams _params)
    {
        f = 0;
        fx = 0;
        fy = 0;
        fxy = 0;
        spline2d.spline2ddiffvi(c.innerobj, x, y, i, ref f, ref fx, ref fy, ref fxy, _params);
    }
    
    /*************************************************************************
    This subroutine performs linear transformation of the spline argument.

    Input parameters:
        C       -   spline interpolant
        AX, BX  -   transformation coefficients: x = A*t + B
        AY, BY  -   transformation coefficients: y = A*u + B
    Result:
        C   -   transformed spline

      -- ALGLIB PROJECT --
         Copyright 30.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dlintransxy(spline2dinterpolant c, double ax, double bx, double ay, double by)
    {
    
        spline2d.spline2dlintransxy(c.innerobj, ax, bx, ay, by, null);
    }
    
    public static void spline2dlintransxy(spline2dinterpolant c, double ax, double bx, double ay, double by, alglib.xparams _params)
    {
    
        spline2d.spline2dlintransxy(c.innerobj, ax, bx, ay, by, _params);
    }
    
    /*************************************************************************
    This subroutine performs linear transformation of the spline.

    Input parameters:
        C   -   spline interpolant.
        A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B

    Output parameters:
        C   -   transformed spline

      -- ALGLIB PROJECT --
         Copyright 30.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dlintransf(spline2dinterpolant c, double a, double b)
    {
    
        spline2d.spline2dlintransf(c.innerobj, a, b, null);
    }
    
    public static void spline2dlintransf(spline2dinterpolant c, double a, double b, alglib.xparams _params)
    {
    
        spline2d.spline2dlintransf(c.innerobj, a, b, _params);
    }
    
    /*************************************************************************
    This subroutine makes the copy of the spline model.

    Input parameters:
        C   -   spline interpolant

    Output parameters:
        CC  -   spline copy

      -- ALGLIB PROJECT --
         Copyright 29.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dcopy(spline2dinterpolant c, out spline2dinterpolant cc)
    {
        cc = new spline2dinterpolant();
        spline2d.spline2dcopy(c.innerobj, cc.innerobj, null);
    }
    
    public static void spline2dcopy(spline2dinterpolant c, out spline2dinterpolant cc, alglib.xparams _params)
    {
        cc = new spline2dinterpolant();
        spline2d.spline2dcopy(c.innerobj, cc.innerobj, _params);
    }
    
    /*************************************************************************
    Bicubic spline resampling

    Input parameters:
        A           -   function values at the old grid,
                        array[0..OldHeight-1, 0..OldWidth-1]
        OldHeight   -   old grid height, OldHeight>1
        OldWidth    -   old grid width, OldWidth>1
        NewHeight   -   new grid height, NewHeight>1
        NewWidth    -   new grid width, NewWidth>1

    Output parameters:
        B           -   function values at the new grid,
                        array[0..NewHeight-1, 0..NewWidth-1]

      -- ALGLIB routine --
         15 May, 2007
         Copyright by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dresamplebicubic(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth)
    {
        b = new double[0,0];
        spline2d.spline2dresamplebicubic(a, oldheight, oldwidth, ref b, newheight, newwidth, null);
    }
    
    public static void spline2dresamplebicubic(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth, alglib.xparams _params)
    {
        b = new double[0,0];
        spline2d.spline2dresamplebicubic(a, oldheight, oldwidth, ref b, newheight, newwidth, _params);
    }
    
    /*************************************************************************
    Bilinear spline resampling

    Input parameters:
        A           -   function values at the old grid,
                        array[0..OldHeight-1, 0..OldWidth-1]
        OldHeight   -   old grid height, OldHeight>1
        OldWidth    -   old grid width, OldWidth>1
        NewHeight   -   new grid height, NewHeight>1
        NewWidth    -   new grid width, NewWidth>1

    Output parameters:
        B           -   function values at the new grid,
                        array[0..NewHeight-1, 0..NewWidth-1]

      -- ALGLIB routine --
         09.07.2007
         Copyright by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dresamplebilinear(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth)
    {
        b = new double[0,0];
        spline2d.spline2dresamplebilinear(a, oldheight, oldwidth, ref b, newheight, newwidth, null);
    }
    
    public static void spline2dresamplebilinear(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth, alglib.xparams _params)
    {
        b = new double[0,0];
        spline2d.spline2dresamplebilinear(a, oldheight, oldwidth, ref b, newheight, newwidth, _params);
    }
    
    /*************************************************************************
    This subroutine builds bilinear vector-valued spline.

    Input parameters:
        X   -   spline abscissas, array[0..N-1]
        Y   -   spline ordinates, array[0..M-1]
        F   -   function values, array[0..M*N*D-1]:
                * first D elements store D values at (X[0],Y[0])
                * next D elements store D values at (X[1],Y[0])
                * general form - D function values at (X[i],Y[j]) are stored
                  at F[D*(J*N+I)...D*(J*N+I)+D-1].
        M,N -   grid size, M>=2, N>=2
        D   -   vector dimension, D>=1

    Output parameters:
        C   -   spline interpolant

      -- ALGLIB PROJECT --
         Copyright 16.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildbilinearv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c)
    {
        c = new spline2dinterpolant();
        spline2d.spline2dbuildbilinearv(x, n, y, m, f, d, c.innerobj, null);
    }
    
    public static void spline2dbuildbilinearv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c, alglib.xparams _params)
    {
        c = new spline2dinterpolant();
        spline2d.spline2dbuildbilinearv(x, n, y, m, f, d, c.innerobj, _params);
    }
    
    /*************************************************************************
    This subroutine builds bicubic vector-valued spline.

    Input parameters:
        X   -   spline abscissas, array[0..N-1]
        Y   -   spline ordinates, array[0..M-1]
        F   -   function values, array[0..M*N*D-1]:
                * first D elements store D values at (X[0],Y[0])
                * next D elements store D values at (X[1],Y[0])
                * general form - D function values at (X[i],Y[j]) are stored
                  at F[D*(J*N+I)...D*(J*N+I)+D-1].
        M,N -   grid size, M>=2, N>=2
        D   -   vector dimension, D>=1

    Output parameters:
        C   -   spline interpolant

      -- ALGLIB PROJECT --
         Copyright 16.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildbicubicv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c)
    {
        c = new spline2dinterpolant();
        spline2d.spline2dbuildbicubicv(x, n, y, m, f, d, c.innerobj, null);
    }
    
    public static void spline2dbuildbicubicv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c, alglib.xparams _params)
    {
        c = new spline2dinterpolant();
        spline2d.spline2dbuildbicubicv(x, n, y, m, f, d, c.innerobj, _params);
    }
    
    /*************************************************************************
    This subroutine unpacks two-dimensional spline into the coefficients table

    Input parameters:
        C   -   spline interpolant.

    Result:
        M, N-   grid size (x-axis and y-axis)
        D   -   number of components
        Tbl -   coefficients table, unpacked format,
                D - components: [0..(N-1)*(M-1)*D-1, 0..19].
                For T=0..D-1 (component index), I = 0...N-2 (x index),
                J=0..M-2 (y index):
                    K :=  T + I*D + J*D*(N-1)

                    K-th row stores decomposition for T-th component of the
                    vector-valued function

                    Tbl[K,0] = X[i]
                    Tbl[K,1] = X[i+1]
                    Tbl[K,2] = Y[j]
                    Tbl[K,3] = Y[j+1]
                    Tbl[K,4] = C00
                    Tbl[K,5] = C01
                    Tbl[K,6] = C02
                    Tbl[K,7] = C03
                    Tbl[K,8] = C10
                    Tbl[K,9] = C11
                    ...
                    Tbl[K,19] = C33
                On each grid square spline is equals to:
                    S(x) = SUM(c[i,j]*(t^i)*(u^j), i=0..3, j=0..3)
                    t = x-x[j]
                    u = y-y[i]

      -- ALGLIB PROJECT --
         Copyright 16.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dunpackv(spline2dinterpolant c, out int m, out int n, out int d, out double[,] tbl)
    {
        m = 0;
        n = 0;
        d = 0;
        tbl = new double[0,0];
        spline2d.spline2dunpackv(c.innerobj, ref m, ref n, ref d, ref tbl, null);
    }
    
    public static void spline2dunpackv(spline2dinterpolant c, out int m, out int n, out int d, out double[,] tbl, alglib.xparams _params)
    {
        m = 0;
        n = 0;
        d = 0;
        tbl = new double[0,0];
        spline2d.spline2dunpackv(c.innerobj, ref m, ref n, ref d, ref tbl, _params);
    }
    
    /*************************************************************************
    This subroutine was deprecated in ALGLIB 3.6.0

    We recommend you to switch  to  Spline2DBuildBilinearV(),  which  is  more
    flexible and accepts its arguments in more convenient order.

      -- ALGLIB PROJECT --
         Copyright 05.07.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildbilinear(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c)
    {
        c = new spline2dinterpolant();
        spline2d.spline2dbuildbilinear(x, y, f, m, n, c.innerobj, null);
    }
    
    public static void spline2dbuildbilinear(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c, alglib.xparams _params)
    {
        c = new spline2dinterpolant();
        spline2d.spline2dbuildbilinear(x, y, f, m, n, c.innerobj, _params);
    }
    
    /*************************************************************************
    This subroutine was deprecated in ALGLIB 3.6.0

    We recommend you to switch  to  Spline2DBuildBicubicV(),  which  is  more
    flexible and accepts its arguments in more convenient order.

      -- ALGLIB PROJECT --
         Copyright 05.07.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildbicubic(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c)
    {
        c = new spline2dinterpolant();
        spline2d.spline2dbuildbicubic(x, y, f, m, n, c.innerobj, null);
    }
    
    public static void spline2dbuildbicubic(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c, alglib.xparams _params)
    {
        c = new spline2dinterpolant();
        spline2d.spline2dbuildbicubic(x, y, f, m, n, c.innerobj, _params);
    }
    
    /*************************************************************************
    This subroutine was deprecated in ALGLIB 3.6.0

    We recommend you to switch  to  Spline2DUnpackV(),  which is more flexible
    and accepts its arguments in more convenient order.

      -- ALGLIB PROJECT --
         Copyright 29.06.2007 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dunpack(spline2dinterpolant c, out int m, out int n, out double[,] tbl)
    {
        m = 0;
        n = 0;
        tbl = new double[0,0];
        spline2d.spline2dunpack(c.innerobj, ref m, ref n, ref tbl, null);
    }
    
    public static void spline2dunpack(spline2dinterpolant c, out int m, out int n, out double[,] tbl, alglib.xparams _params)
    {
        m = 0;
        n = 0;
        tbl = new double[0,0];
        spline2d.spline2dunpack(c.innerobj, ref m, ref n, ref tbl, _params);
    }
    
    /*************************************************************************
    This subroutine creates least squares solver used to  fit  2D  splines  to
    irregularly sampled (scattered) data.

    Solver object is used to perform spline fits as follows:
    * solver object is created with spline2dbuildercreate() function
    * dataset is added with spline2dbuildersetpoints() function
    * fit area is chosen:
      * spline2dbuildersetarea()     - for user-defined area
      * spline2dbuildersetareaauto() - for automatically chosen area
    * number of grid nodes is chosen with spline2dbuildersetgrid()
    * prior term is chosen with one of the following functions:
      * spline2dbuildersetlinterm()   to set linear prior
      * spline2dbuildersetconstterm() to set constant prior
      * spline2dbuildersetzeroterm()  to set zero prior
      * spline2dbuildersetuserterm()  to set user-defined constant prior
    * solver algorithm is chosen with either:
      * spline2dbuildersetalgoblocklls() - BlockLLS algorithm, medium-scale problems
      * spline2dbuildersetalgofastddm()  - FastDDM algorithm, large-scale problems
    * finally, fitting itself is performed with spline2dfit() function.

    Most of the steps above can be omitted,  solver  is  configured with  good
    defaults. The minimum is to call:
    * spline2dbuildercreate() to create solver object
    * spline2dbuildersetpoints() to specify dataset
    * spline2dbuildersetgrid() to tell how many nodes you need
    * spline2dfit() to perform fit

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    INPUT PARAMETERS:
        D   -   positive number, number of Y-components: D=1 for simple scalar
                fit, D>1 for vector-valued spline fitting.

    OUTPUT PARAMETERS:
        S   -   solver object

      -- ALGLIB PROJECT --
         Copyright 29.01.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildercreate(int d, out spline2dbuilder state)
    {
        state = new spline2dbuilder();
        spline2d.spline2dbuildercreate(d, state.innerobj, null);
    }
    
    public static void spline2dbuildercreate(int d, out spline2dbuilder state, alglib.xparams _params)
    {
        state = new spline2dbuilder();
        spline2d.spline2dbuildercreate(d, state.innerobj, _params);
    }
    
    /*************************************************************************
    This function sets constant prior term (model is a sum of  bicubic  spline
    and global prior, which can be linear, constant, user-defined  constant or
    zero).

    Constant prior term is determined by least squares fitting.

    INPUT PARAMETERS:
        S       -   spline builder
        V       -   value for user-defined prior

      -- ALGLIB --
         Copyright 01.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetuserterm(spline2dbuilder state, double v)
    {
    
        spline2d.spline2dbuildersetuserterm(state.innerobj, v, null);
    }
    
    public static void spline2dbuildersetuserterm(spline2dbuilder state, double v, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetuserterm(state.innerobj, v, _params);
    }
    
    /*************************************************************************
    This function sets linear prior term (model is a sum of bicubic spline and
    global  prior,  which  can  be  linear, constant, user-defined constant or
    zero).

    Linear prior term is determined by least squares fitting.

    INPUT PARAMETERS:
        S       -   spline builder

      -- ALGLIB --
         Copyright 01.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetlinterm(spline2dbuilder state)
    {
    
        spline2d.spline2dbuildersetlinterm(state.innerobj, null);
    }
    
    public static void spline2dbuildersetlinterm(spline2dbuilder state, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetlinterm(state.innerobj, _params);
    }
    
    /*************************************************************************
    This function sets constant prior term (model is a sum of  bicubic  spline
    and global prior, which can be linear, constant, user-defined  constant or
    zero).

    Constant prior term is determined by least squares fitting.

    INPUT PARAMETERS:
        S       -   spline builder

      -- ALGLIB --
         Copyright 01.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetconstterm(spline2dbuilder state)
    {
    
        spline2d.spline2dbuildersetconstterm(state.innerobj, null);
    }
    
    public static void spline2dbuildersetconstterm(spline2dbuilder state, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetconstterm(state.innerobj, _params);
    }
    
    /*************************************************************************
    This function sets zero prior term (model is a sum of bicubic  spline  and
    global  prior,  which  can  be  linear, constant, user-defined constant or
    zero).

    INPUT PARAMETERS:
        S       -   spline builder

      -- ALGLIB --
         Copyright 01.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetzeroterm(spline2dbuilder state)
    {
    
        spline2d.spline2dbuildersetzeroterm(state.innerobj, null);
    }
    
    public static void spline2dbuildersetzeroterm(spline2dbuilder state, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetzeroterm(state.innerobj, _params);
    }
    
    /*************************************************************************
    This function adds dataset to the builder object.

    This function overrides results of the previous calls, i.e. multiple calls
    of this function will result in only the last set being added.

    INPUT PARAMETERS:
        S       -   spline 2D builder object
        XY      -   points, array[N,2+D]. One  row  corresponds to  one  point
                    in the dataset. First 2  elements  are  coordinates,  next
                    D  elements are function values. Array may  be larger than
                    specified, in  this  case  only leading [N,NX+NY] elements
                    will be used.
        N       -   number of points in the dataset

      -- ALGLIB --
         Copyright 05.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetpoints(spline2dbuilder state, double[,] xy, int n)
    {
    
        spline2d.spline2dbuildersetpoints(state.innerobj, xy, n, null);
    }
    
    public static void spline2dbuildersetpoints(spline2dbuilder state, double[,] xy, int n, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetpoints(state.innerobj, xy, n, _params);
    }
    
    /*************************************************************************
    This function sets area where 2D spline interpolant is built. "Auto" means
    that area extent is determined automatically from dataset extent.

    INPUT PARAMETERS:
        S       -   spline 2D builder object

      -- ALGLIB --
         Copyright 05.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetareaauto(spline2dbuilder state)
    {
    
        spline2d.spline2dbuildersetareaauto(state.innerobj, null);
    }
    
    public static void spline2dbuildersetareaauto(spline2dbuilder state, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetareaauto(state.innerobj, _params);
    }
    
    /*************************************************************************
    This  function  sets  area  where  2D  spline  interpolant  is   built  to
    user-defined one: [XA,XB]*[YA,YB]

    INPUT PARAMETERS:
        S       -   spline 2D builder object
        XA,XB   -   spatial extent in the first (X) dimension, XA<XB
        YA,YB   -   spatial extent in the second (Y) dimension, YA<YB

      -- ALGLIB --
         Copyright 05.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetarea(spline2dbuilder state, double xa, double xb, double ya, double yb)
    {
    
        spline2d.spline2dbuildersetarea(state.innerobj, xa, xb, ya, yb, null);
    }
    
    public static void spline2dbuildersetarea(spline2dbuilder state, double xa, double xb, double ya, double yb, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetarea(state.innerobj, xa, xb, ya, yb, _params);
    }
    
    /*************************************************************************
    This  function  sets  nodes  count  for  2D spline interpolant. Fitting is
    performed on area defined with one of the "setarea"  functions;  this  one
    sets number of nodes placed upon the fitting area.

    INPUT PARAMETERS:
        S       -   spline 2D builder object
        KX      -   nodes count for the first (X) dimension; fitting  interval
                    [XA,XB] is separated into KX-1 subintervals, with KX nodes
                    created at the boundaries.
        KY      -   nodes count for the first (Y) dimension; fitting  interval
                    [YA,YB] is separated into KY-1 subintervals, with KY nodes
                    created at the boundaries.

    NOTE: at  least  4  nodes  is  created in each dimension, so KX and KY are
          silently increased if needed.

      -- ALGLIB --
         Copyright 05.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetgrid(spline2dbuilder state, int kx, int ky)
    {
    
        spline2d.spline2dbuildersetgrid(state.innerobj, kx, ky, null);
    }
    
    public static void spline2dbuildersetgrid(spline2dbuilder state, int kx, int ky, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetgrid(state.innerobj, kx, ky, _params);
    }
    
    /*************************************************************************
    This  function  allows  you to choose least squares solver used to perform
    fitting. This function sets solver algorithm to "FastDDM", which  performs
    fast parallel fitting by splitting problem into smaller chunks and merging
    results together.

    This solver is optimized for large-scale problems, starting  from  256x256
    grids, and up to 10000x10000 grids. Of course, it will  work  for  smaller
    grids too.

    More detailed description of the algorithm is given below:
    * algorithm generates hierarchy  of  nested  grids,  ranging  from  ~16x16
      (topmost "layer" of the model) to ~KX*KY one (final layer). Upper layers
      model global behavior of the function, lower layers are  used  to  model
      fine details. Moving from layer to layer doubles grid density.
    * fitting  is  started  from  topmost  layer, subsequent layers are fitted
      using residuals from previous ones.
    * user may choose to skip generation of upper layers and generate  only  a
      few bottom ones, which  will  result  in  much  better  performance  and
      parallelization efficiency, at the cost of algorithm inability to "patch"
      large holes in the dataset.
    * every layer is regularized using progressively increasing regularization
      coefficient; thus, increasing  LambdaV  penalizes  fine  details  first,
      leaving lower frequencies almost intact for a while.
    * after fitting is done, all layers are merged together into  one  bicubic
      spline

    IMPORTANT: regularization coefficient used by  this  solver  is  different
               from the one used by  BlockLLS.  Latter  utilizes  nonlinearity
               penalty,  which  is  global  in  nature  (large  regularization
               results in global linear trend being  extracted);  this  solver
               uses another, localized form of penalty, which is suitable  for
               parallel processing.

    Notes on memory and performance:
    * memory requirements: most memory is consumed  during  modeling   of  the
      higher layers; ~[512*NPoints] bytes is required for a  model  with  full
      hierarchy of grids being generated. However, if you skip a  few  topmost
      layers, you will get nearly constant (wrt. points count and  grid  size)
      memory consumption.
    * serial running time: O(K*K)+O(NPoints) for a KxK grid
    * parallelism potential: good. You may get  nearly  linear  speed-up  when
      performing fitting with just a few layers. Adding more layers results in
      model becoming more global, which somewhat  reduces  efficiency  of  the
      parallel code.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    INPUT PARAMETERS:
        S       -   spline 2D builder object
        NLayers -   number of layers in the model:
                    * NLayers>=1 means that up  to  chosen  number  of  bottom
                      layers is fitted
                    * NLayers=0 means that maximum number of layers is  chosen
                      (according to current grid size)
                    * NLayers<=-1 means that up to |NLayers| topmost layers is
                      skipped
                    Recommendations:
                    * good "default" value is 2 layers
                    * you may need  more  layers,  if  your  dataset  is  very
                      irregular and you want to "patch"  large  holes.  For  a
                      grid step H (equal to AreaWidth/GridSize) you may expect
                      that last layer reproduces variations at distance H (and
                      can patch holes that wide); that higher  layers  operate
                      at distances 2*H, 4*H, 8*H and so on.
                    * good value for "bullletproof" mode is  NLayers=0,  which
                      results in complete hierarchy of layers being generated.
        LambdaV -   regularization coefficient, chosen in such a way  that  it
                    penalizes bottom layers (fine details) first.
                    LambdaV>=0, zero value means that no penalty is applied.

      -- ALGLIB --
         Copyright 05.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetalgofastddm(spline2dbuilder state, int nlayers, double lambdav)
    {
    
        spline2d.spline2dbuildersetalgofastddm(state.innerobj, nlayers, lambdav, null);
    }
    
    public static void spline2dbuildersetalgofastddm(spline2dbuilder state, int nlayers, double lambdav, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetalgofastddm(state.innerobj, nlayers, lambdav, _params);
    }
    
    /*************************************************************************
    This  function  allows  you to choose least squares solver used to perform
    fitting. This function sets solver algorithm to "BlockLLS", which performs
    least squares fitting  with  fast  sparse  direct  solver,  with  optional
    nonsmoothness penalty being applied.

    Nonlinearity penalty has the following form:

                              [                                            ]
        P() ~ Lambda* integral[ (d2S/dx2)^2 + 2*(d2S/dxdy)^2 + (d2S/dy2)^2 ]dxdy
                              [                                            ]

    here integral is calculated over entire grid, and "~" means "proportional"
    because integral is normalized after calcilation. Extremely  large  values
    of Lambda result in linear fit being performed.

    NOTE: this algorithm is the most robust and controllable one,  but  it  is
          limited by 512x512 grids and (say) up to 1.000.000 points.  However,
          ALGLIB has one more  spline  solver:  FastDDM  algorithm,  which  is
          intended for really large-scale problems (in 10M-100M range). FastDDM
          algorithm also has better parallelism properties.

    More information on BlockLLS solver:
    * memory requirements: ~[32*K^3+256*NPoints]  bytes  for  KxK  grid   with
      NPoints-sized dataset
    * serial running time: O(K^4+NPoints)
    * parallelism potential: limited. You may get some sublinear gain when
      working with large grids (K's in 256..512 range)

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    INPUT PARAMETERS:
        S       -   spline 2D builder object
        LambdaNS-   non-negative value:
                    * positive value means that some smoothing is applied
                    * zero value means  that  no  smoothing  is  applied,  and
                      corresponding entries of design matrix  are  numerically
                      zero and dropped from consideration.

      -- ALGLIB --
         Copyright 05.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetalgoblocklls(spline2dbuilder state, double lambdans)
    {
    
        spline2d.spline2dbuildersetalgoblocklls(state.innerobj, lambdans, null);
    }
    
    public static void spline2dbuildersetalgoblocklls(spline2dbuilder state, double lambdans, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetalgoblocklls(state.innerobj, lambdans, _params);
    }
    
    /*************************************************************************
    This  function  allows  you to choose least squares solver used to perform
    fitting. This function sets solver algorithm to "NaiveLLS".

    IMPORTANT: NaiveLLS is NOT intended to be used in  real  life  code!  This
               algorithm solves problem by generated dense (K^2)x(K^2+NPoints)
               matrix and solves  linear  least  squares  problem  with  dense
               solver.

               It is here just  to  test  BlockLLS  against  reference  solver
               (and maybe for someone trying to compare well optimized  solver
               against straightforward approach to the LLS problem).

    More information on naive LLS solver:
    * memory requirements: ~[8*K^4+256*NPoints] bytes for KxK grid.
    * serial running time: O(K^6+NPoints) for KxK grid
    * when compared with BlockLLS,  NaiveLLS  has ~K  larger memory demand and
      ~K^2  larger running time.

    INPUT PARAMETERS:
        S       -   spline 2D builder object
        LambdaNS-   nonsmoothness penalty

      -- ALGLIB --
         Copyright 05.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dbuildersetalgonaivells(spline2dbuilder state, double lambdans)
    {
    
        spline2d.spline2dbuildersetalgonaivells(state.innerobj, lambdans, null);
    }
    
    public static void spline2dbuildersetalgonaivells(spline2dbuilder state, double lambdans, alglib.xparams _params)
    {
    
        spline2d.spline2dbuildersetalgonaivells(state.innerobj, lambdans, _params);
    }
    
    /*************************************************************************
    This function fits bicubic spline to current dataset, using current  area/
    grid and current LLS solver.

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      ! * hardware vendor (Intel) implementations of linear algebra primitives
      !   (C++ and C# versions, x86/x64 platform)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    INPUT PARAMETERS:
        State   -   spline 2D builder object

    OUTPUT PARAMETERS:
        S       -   2D spline, fit result
        Rep     -   fitting report, which provides some additional info  about
                    errors, R2 coefficient and so on.

      -- ALGLIB --
         Copyright 05.02.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void spline2dfit(spline2dbuilder state, out spline2dinterpolant s, out spline2dfitreport rep)
    {
        s = new spline2dinterpolant();
        rep = new spline2dfitreport();
        spline2d.spline2dfit(state.innerobj, s.innerobj, rep.innerobj, null);
    }
    
    public static void spline2dfit(spline2dbuilder state, out spline2dinterpolant s, out spline2dfitreport rep, alglib.xparams _params)
    {
        s = new spline2dinterpolant();
        rep = new spline2dfitreport();
        spline2d.spline2dfit(state.innerobj, s.innerobj, rep.innerobj, _params);
    }

}
public partial class alglib
{



}
public partial class alglib
{


    /*************************************************************************
    3-dimensional spline inteprolant
    *************************************************************************/
    public class spline3dinterpolant : alglibobject
    {
        //
        // Public declarations
        //
    
        public spline3dinterpolant()
        {
            _innerobj = new spline3d.spline3dinterpolant();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new spline3dinterpolant((spline3d.spline3dinterpolant)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private spline3d.spline3dinterpolant _innerobj;
        public spline3d.spline3dinterpolant innerobj { get { return _innerobj; } }
        public spline3dinterpolant(spline3d.spline3dinterpolant obj)
        {
            _innerobj = obj;
        }
    }
    
    /*************************************************************************
    This subroutine calculates the value of the trilinear or tricubic spline at
    the given point (X,Y,Z).

    INPUT PARAMETERS:
        C   -   coefficients table.
                Built by BuildBilinearSpline or BuildBicubicSpline.
        X, Y,
        Z   -   point

    Result:
        S(x,y,z)

      -- ALGLIB PROJECT --
         Copyright 26.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static double spline3dcalc(spline3dinterpolant c, double x, double y, double z)
    {
    
        return spline3d.spline3dcalc(c.innerobj, x, y, z, null);
    }
    
    public static double spline3dcalc(spline3dinterpolant c, double x, double y, double z, alglib.xparams _params)
    {
    
        return spline3d.spline3dcalc(c.innerobj, x, y, z, _params);
    }
    
    /*************************************************************************
    This subroutine performs linear transformation of the spline argument.

    INPUT PARAMETERS:
        C       -   spline interpolant
        AX, BX  -   transformation coefficients: x = A*u + B
        AY, BY  -   transformation coefficients: y = A*v + B
        AZ, BZ  -   transformation coefficients: z = A*w + B

    OUTPUT PARAMETERS:
        C   -   transformed spline

      -- ALGLIB PROJECT --
         Copyright 26.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline3dlintransxyz(spline3dinterpolant c, double ax, double bx, double ay, double by, double az, double bz)
    {
    
        spline3d.spline3dlintransxyz(c.innerobj, ax, bx, ay, by, az, bz, null);
    }
    
    public static void spline3dlintransxyz(spline3dinterpolant c, double ax, double bx, double ay, double by, double az, double bz, alglib.xparams _params)
    {
    
        spline3d.spline3dlintransxyz(c.innerobj, ax, bx, ay, by, az, bz, _params);
    }
    
    /*************************************************************************
    This subroutine performs linear transformation of the spline.

    INPUT PARAMETERS:
        C   -   spline interpolant.
        A, B-   transformation coefficients: S2(x,y) = A*S(x,y,z) + B

    OUTPUT PARAMETERS:
        C   -   transformed spline

      -- ALGLIB PROJECT --
         Copyright 26.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline3dlintransf(spline3dinterpolant c, double a, double b)
    {
    
        spline3d.spline3dlintransf(c.innerobj, a, b, null);
    }
    
    public static void spline3dlintransf(spline3dinterpolant c, double a, double b, alglib.xparams _params)
    {
    
        spline3d.spline3dlintransf(c.innerobj, a, b, _params);
    }
    
    /*************************************************************************
    Trilinear spline resampling

    INPUT PARAMETERS:
        A           -   array[0..OldXCount*OldYCount*OldZCount-1], function
                        values at the old grid, :
                            A[0]        x=0,y=0,z=0
                            A[1]        x=1,y=0,z=0
                            A[..]       ...
                            A[..]       x=oldxcount-1,y=0,z=0
                            A[..]       x=0,y=1,z=0
                            A[..]       ...
                            ...
        OldZCount   -   old Z-count, OldZCount>1
        OldYCount   -   old Y-count, OldYCount>1
        OldXCount   -   old X-count, OldXCount>1
        NewZCount   -   new Z-count, NewZCount>1
        NewYCount   -   new Y-count, NewYCount>1
        NewXCount   -   new X-count, NewXCount>1

    OUTPUT PARAMETERS:
        B           -   array[0..NewXCount*NewYCount*NewZCount-1], function
                        values at the new grid:
                            B[0]        x=0,y=0,z=0
                            B[1]        x=1,y=0,z=0
                            B[..]       ...
                            B[..]       x=newxcount-1,y=0,z=0
                            B[..]       x=0,y=1,z=0
                            B[..]       ...
                            ...

      -- ALGLIB routine --
         26.04.2012
         Copyright by Bochkanov Sergey
    *************************************************************************/
    public static void spline3dresampletrilinear(double[] a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, out double[] b)
    {
        b = new double[0];
        spline3d.spline3dresampletrilinear(a, oldzcount, oldycount, oldxcount, newzcount, newycount, newxcount, ref b, null);
    }
    
    public static void spline3dresampletrilinear(double[] a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, out double[] b, alglib.xparams _params)
    {
        b = new double[0];
        spline3d.spline3dresampletrilinear(a, oldzcount, oldycount, oldxcount, newzcount, newycount, newxcount, ref b, _params);
    }
    
    /*************************************************************************
    This subroutine builds trilinear vector-valued spline.

    INPUT PARAMETERS:
        X   -   spline abscissas,  array[0..N-1]
        Y   -   spline ordinates,  array[0..M-1]
        Z   -   spline applicates, array[0..L-1]
        F   -   function values, array[0..M*N*L*D-1]:
                * first D elements store D values at (X[0],Y[0],Z[0])
                * next D elements store D values at (X[1],Y[0],Z[0])
                * next D elements store D values at (X[2],Y[0],Z[0])
                * ...
                * next D elements store D values at (X[0],Y[1],Z[0])
                * next D elements store D values at (X[1],Y[1],Z[0])
                * next D elements store D values at (X[2],Y[1],Z[0])
                * ...
                * next D elements store D values at (X[0],Y[0],Z[1])
                * next D elements store D values at (X[1],Y[0],Z[1])
                * next D elements store D values at (X[2],Y[0],Z[1])
                * ...
                * general form - D function values at (X[i],Y[j]) are stored
                  at F[D*(N*(M*K+J)+I)...D*(N*(M*K+J)+I)+D-1].
        M,N,
        L   -   grid size, M>=2, N>=2, L>=2
        D   -   vector dimension, D>=1

    OUTPUT PARAMETERS:
        C   -   spline interpolant

      -- ALGLIB PROJECT --
         Copyright 26.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline3dbuildtrilinearv(double[] x, int n, double[] y, int m, double[] z, int l, double[] f, int d, out spline3dinterpolant c)
    {
        c = new spline3dinterpolant();
        spline3d.spline3dbuildtrilinearv(x, n, y, m, z, l, f, d, c.innerobj, null);
    }
    
    public static void spline3dbuildtrilinearv(double[] x, int n, double[] y, int m, double[] z, int l, double[] f, int d, out spline3dinterpolant c, alglib.xparams _params)
    {
        c = new spline3dinterpolant();
        spline3d.spline3dbuildtrilinearv(x, n, y, m, z, l, f, d, c.innerobj, _params);
    }
    
    /*************************************************************************
    This subroutine calculates bilinear or bicubic vector-valued spline at the
    given point (X,Y,Z).

    INPUT PARAMETERS:
        C   -   spline interpolant.
        X, Y,
        Z   -   point
        F   -   output buffer, possibly preallocated array. In case array size
                is large enough to store result, it is not reallocated.  Array
                which is too short will be reallocated

    OUTPUT PARAMETERS:
        F   -   array[D] (or larger) which stores function values

      -- ALGLIB PROJECT --
         Copyright 26.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline3dcalcvbuf(spline3dinterpolant c, double x, double y, double z, ref double[] f)
    {
    
        spline3d.spline3dcalcvbuf(c.innerobj, x, y, z, ref f, null);
    }
    
    public static void spline3dcalcvbuf(spline3dinterpolant c, double x, double y, double z, ref double[] f, alglib.xparams _params)
    {
    
        spline3d.spline3dcalcvbuf(c.innerobj, x, y, z, ref f, _params);
    }
    
    /*************************************************************************
    This subroutine calculates trilinear or tricubic vector-valued spline at the
    given point (X,Y,Z).

    INPUT PARAMETERS:
        C   -   spline interpolant.
        X, Y,
        Z   -   point

    OUTPUT PARAMETERS:
        F   -   array[D] which stores function values.  F is out-parameter and
                it  is  reallocated  after  call to this function. In case you
                want  to    reuse  previously  allocated  F,   you   may   use
                Spline2DCalcVBuf(),  which  reallocates  F only when it is too
                small.

      -- ALGLIB PROJECT --
         Copyright 26.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline3dcalcv(spline3dinterpolant c, double x, double y, double z, out double[] f)
    {
        f = new double[0];
        spline3d.spline3dcalcv(c.innerobj, x, y, z, ref f, null);
    }
    
    public static void spline3dcalcv(spline3dinterpolant c, double x, double y, double z, out double[] f, alglib.xparams _params)
    {
        f = new double[0];
        spline3d.spline3dcalcv(c.innerobj, x, y, z, ref f, _params);
    }
    
    /*************************************************************************
    This subroutine unpacks tri-dimensional spline into the coefficients table

    INPUT PARAMETERS:
        C   -   spline interpolant.

    Result:
        N   -   grid size (X)
        M   -   grid size (Y)
        L   -   grid size (Z)
        D   -   number of components
        SType-  spline type. Currently, only one spline type is supported:
                trilinear spline, as indicated by SType=1.
        Tbl -   spline coefficients: [0..(N-1)*(M-1)*(L-1)*D-1, 0..13].
                For T=0..D-1 (component index), I = 0...N-2 (x index),
                J=0..M-2 (y index), K=0..L-2 (z index):
                    Q := T + I*D + J*D*(N-1) + K*D*(N-1)*(M-1),

                    Q-th row stores decomposition for T-th component of the
                    vector-valued function

                    Tbl[Q,0] = X[i]
                    Tbl[Q,1] = X[i+1]
                    Tbl[Q,2] = Y[j]
                    Tbl[Q,3] = Y[j+1]
                    Tbl[Q,4] = Z[k]
                    Tbl[Q,5] = Z[k+1]

                    Tbl[Q,6] = C000
                    Tbl[Q,7] = C100
                    Tbl[Q,8] = C010
                    Tbl[Q,9] = C110
                    Tbl[Q,10]= C001
                    Tbl[Q,11]= C101
                    Tbl[Q,12]= C011
                    Tbl[Q,13]= C111
                On each grid square spline is equals to:
                    S(x) = SUM(c[i,j,k]*(x^i)*(y^j)*(z^k), i=0..1, j=0..1, k=0..1)
                    t = x-x[j]
                    u = y-y[i]
                    v = z-z[k]

                NOTE: format of Tbl is given for SType=1. Future versions of
                      ALGLIB can use different formats for different values of
                      SType.

      -- ALGLIB PROJECT --
         Copyright 26.04.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void spline3dunpackv(spline3dinterpolant c, out int n, out int m, out int l, out int d, out int stype, out double[,] tbl)
    {
        n = 0;
        m = 0;
        l = 0;
        d = 0;
        stype = 0;
        tbl = new double[0,0];
        spline3d.spline3dunpackv(c.innerobj, ref n, ref m, ref l, ref d, ref stype, ref tbl, null);
    }
    
    public static void spline3dunpackv(spline3dinterpolant c, out int n, out int m, out int l, out int d, out int stype, out double[,] tbl, alglib.xparams _params)
    {
        n = 0;
        m = 0;
        l = 0;
        d = 0;
        stype = 0;
        tbl = new double[0,0];
        spline3d.spline3dunpackv(c.innerobj, ref n, ref m, ref l, ref d, ref stype, ref tbl, _params);
    }

}
public partial class alglib
{

    
    /*************************************************************************
    This function is left for backward compatibility.
    Use fitspheremc() instead.


      -- ALGLIB --
         Copyright 14.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void nsfitspheremcc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi)
    {
        cx = new double[0];
        rhi = 0;
        intcomp.nsfitspheremcc(xy, npoints, nx, ref cx, ref rhi, null);
    }
    
    public static void nsfitspheremcc(double[,] xy, int npoints, int nx, out double[] cx, out double rhi, alglib.xparams _params)
    {
        cx = new double[0];
        rhi = 0;
        intcomp.nsfitspheremcc(xy, npoints, nx, ref cx, ref rhi, _params);
    }
    
    /*************************************************************************
    This function is left for backward compatibility.
    Use fitspheremi() instead.

      -- ALGLIB --
         Copyright 14.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void nsfitspheremic(double[,] xy, int npoints, int nx, out double[] cx, out double rlo)
    {
        cx = new double[0];
        rlo = 0;
        intcomp.nsfitspheremic(xy, npoints, nx, ref cx, ref rlo, null);
    }
    
    public static void nsfitspheremic(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, alglib.xparams _params)
    {
        cx = new double[0];
        rlo = 0;
        intcomp.nsfitspheremic(xy, npoints, nx, ref cx, ref rlo, _params);
    }
    
    /*************************************************************************
    This function is left for backward compatibility.
    Use fitspheremz() instead.

      -- ALGLIB --
         Copyright 14.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void nsfitspheremzc(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi)
    {
        cx = new double[0];
        rlo = 0;
        rhi = 0;
        intcomp.nsfitspheremzc(xy, npoints, nx, ref cx, ref rlo, ref rhi, null);
    }
    
    public static void nsfitspheremzc(double[,] xy, int npoints, int nx, out double[] cx, out double rlo, out double rhi, alglib.xparams _params)
    {
        cx = new double[0];
        rlo = 0;
        rhi = 0;
        intcomp.nsfitspheremzc(xy, npoints, nx, ref cx, ref rlo, ref rhi, _params);
    }
    
    /*************************************************************************
    This function is left for backward compatibility.
    Use fitspherex() instead.

      -- ALGLIB --
         Copyright 14.04.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void nsfitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi)
    {
        cx = new double[0];
        rlo = 0;
        rhi = 0;
        intcomp.nsfitspherex(xy, npoints, nx, problemtype, epsx, aulits, penalty, ref cx, ref rlo, ref rhi, null);
    }
    
    public static void nsfitspherex(double[,] xy, int npoints, int nx, int problemtype, double epsx, int aulits, double penalty, out double[] cx, out double rlo, out double rhi, alglib.xparams _params)
    {
        cx = new double[0];
        rlo = 0;
        rhi = 0;
        intcomp.nsfitspherex(xy, npoints, nx, problemtype, epsx, aulits, penalty, ref cx, ref rlo, ref rhi, _params);
    }
    
    /*************************************************************************
    This function is an obsolete and deprecated version of fitting by
    penalized cubic spline.

    It was superseded by spline1dfit(), which is an orders of magnitude faster
    and more memory-efficient implementation.

    Do NOT use this function in the new code!

      -- ALGLIB PROJECT --
         Copyright 18.08.2009 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dfitpenalized(double[] x, double[] y, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        intcomp.spline1dfitpenalized(x, y, n, m, rho, ref info, s.innerobj, rep.innerobj, null);
    }
    
    public static void spline1dfitpenalized(double[] x, double[] y, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        intcomp.spline1dfitpenalized(x, y, n, m, rho, ref info, s.innerobj, rep.innerobj, _params);
    }
            
    public static void spline1dfitpenalized(double[] x, double[] y, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        intcomp.spline1dfitpenalized(x, y, n, m, rho, ref info, s.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void spline1dfitpenalized(double[] x, double[] y, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)))
            throw new alglibexception("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        intcomp.spline1dfitpenalized(x, y, n, m, rho, ref info, s.innerobj, rep.innerobj, _params);
    
        return;
    }
    
    /*************************************************************************
    This function is an obsolete and deprecated version of fitting by
    penalized cubic spline.

    It was superseded by spline1dfit(), which is an orders of magnitude faster
    and more memory-efficient implementation.

    Do NOT use this function in the new code!

      -- ALGLIB PROJECT --
         Copyright 19.10.2010 by Bochkanov Sergey
    *************************************************************************/
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        intcomp.spline1dfitpenalizedw(x, y, w, n, m, rho, ref info, s.innerobj, rep.innerobj, null);
    }
    
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        intcomp.spline1dfitpenalizedw(x, y, w, n, m, rho, ref info, s.innerobj, rep.innerobj, _params);
    }
            
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        intcomp.spline1dfitpenalizedw(x, y, w, n, m, rho, ref info, s.innerobj, rep.innerobj, null);
    
        return;
    }
            
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglib.xparams _params)
    {
        int n;
        if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
            throw new alglibexception("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size");
        info = 0;
        s = new spline1dinterpolant();
        rep = new spline1dfitreport();
        n = ap.len(x);
        intcomp.spline1dfitpenalizedw(x, y, w, n, m, rho, ref info, s.innerobj, rep.innerobj, _params);
    
        return;
    }

}
public partial class alglib
{


    /*************************************************************************
    Buffer object which is used  to  perform  RBF  model  calculation  in  the
    multithreaded mode (multiple threads working with same RBF object).

    This object should be created with RBFCreateCalcBuffer().
    *************************************************************************/
    public class rbfcalcbuffer : alglibobject
    {
        //
        // Public declarations
        //
    
        public rbfcalcbuffer()
        {
            _innerobj = new rbf.rbfcalcbuffer();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new rbfcalcbuffer((rbf.rbfcalcbuffer)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private rbf.rbfcalcbuffer _innerobj;
        public rbf.rbfcalcbuffer innerobj { get { return _innerobj; } }
        public rbfcalcbuffer(rbf.rbfcalcbuffer obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    RBF model.

    Never try to directly work with fields of this object - always use  ALGLIB
    functions to use this object.
    *************************************************************************/
    public class rbfmodel : alglibobject
    {
        //
        // Public declarations
        //
    
        public rbfmodel()
        {
            _innerobj = new rbf.rbfmodel();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new rbfmodel((rbf.rbfmodel)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private rbf.rbfmodel _innerobj;
        public rbf.rbfmodel innerobj { get { return _innerobj; } }
        public rbfmodel(rbf.rbfmodel obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    RBF solution report:
    * TerminationType   -   termination type, positive values - success,
                            non-positive - failure.

    Fields which are set by modern RBF solvers (hierarchical):
    * RMSError          -   root-mean-square error; NAN for old solvers (ML, QNN)
    * MaxError          -   maximum error; NAN for old solvers (ML, QNN)
    *************************************************************************/
    public class rbfreport : alglibobject
    {
        //
        // Public declarations
        //
        public double rmserror { get { return _innerobj.rmserror; } set { _innerobj.rmserror = value; } }
        public double maxerror { get { return _innerobj.maxerror; } set { _innerobj.maxerror = value; } }
        public int arows { get { return _innerobj.arows; } set { _innerobj.arows = value; } }
        public int acols { get { return _innerobj.acols; } set { _innerobj.acols = value; } }
        public int annz { get { return _innerobj.annz; } set { _innerobj.annz = value; } }
        public int iterationscount { get { return _innerobj.iterationscount; } set { _innerobj.iterationscount = value; } }
        public int nmv { get { return _innerobj.nmv; } set { _innerobj.nmv = value; } }
        public int terminationtype { get { return _innerobj.terminationtype; } set { _innerobj.terminationtype = value; } }
    
        public rbfreport()
        {
            _innerobj = new rbf.rbfreport();
        }
        
        public override alglib.alglibobject make_copy()
        {
            return new rbfreport((rbf.rbfreport)_innerobj.make_copy());
        }
    
        //
        // Although some of declarations below are public, you should not use them
        // They are intended for internal use only
        //
        private rbf.rbfreport _innerobj;
        public rbf.rbfreport innerobj { get { return _innerobj; } }
        public rbfreport(rbf.rbfreport obj)
        {
            _innerobj = obj;
        }
    }


    /*************************************************************************
    This function serializes data structure to string.
    
    Important properties of s_out:
    * it contains alphanumeric characters, dots, underscores, minus signs
    * these symbols are grouped into words, which are separated by spaces
      and Windows-style (CR+LF) newlines
    * although  serializer  uses  spaces and CR+LF as separators, you can 
      replace any separator character by arbitrary combination of spaces,
      tabs, Windows or Unix newlines. It allows flexible reformatting  of
      the  string  in  case you want to include it into text or XML file. 
      But you should not insert separators into the middle of the "words"
      nor you should change case of letters.
    * s_out can be freely moved between 32-bit and 64-bit systems, little
      and big endian machines, and so on. You can serialize structure  on
      32-bit machine and unserialize it on 64-bit one (or vice versa), or
      serialize  it  on  SPARC  and  unserialize  on  x86.  You  can also 
      serialize  it  in  C# version of ALGLIB and unserialize in C++ one, 
      and vice versa.
    *************************************************************************/
    public static void rbfserialize(rbfmodel obj, out string s_out)
    {
        alglib.serializer s = new alglib.serializer();
        s.alloc_start();
        rbf.rbfalloc(s, obj.innerobj, null);
        s.sstart_str();
        rbf.rbfserialize(s, obj.innerobj, null);
        s.stop();
        s_out = s.get_string();
    }


    /*************************************************************************
    This function unserializes data structure from string.
    *************************************************************************/
    public static void rbfunserialize(string s_in, out rbfmodel obj)
    {
        alglib.serializer s = new alglib.serializer();
        obj = new rbfmodel();
        s.ustart_str(s_in);
        rbf.rbfunserialize(s, obj.innerobj, null);
        s.stop();
    }


    /*************************************************************************
    This function serializes data structure to stream.
    
    Data stream generated by this function is same as  string  representation
    generated  by  string  version  of  serializer - alphanumeric characters,
    dots, underscores, minus signs, which are grouped into words separated by
    spaces and CR+LF.
    
    We recommend you to read comments on string version of serializer to find
    out more about serialization of AlGLIB objects.
    *************************************************************************/
    public static void rbfserialize(rbfmodel obj, System.IO.Stream stream_out)
    {
        alglib.serializer s = new alglib.serializer();
        s.alloc_start();
        rbf.rbfalloc(s, obj.innerobj, null);
        s.sstart_stream(stream_out);
        rbf.rbfserialize(s, obj.innerobj, null);
        s.stop();
    }


    /*************************************************************************
    This function unserializes data structure from stream.
    *************************************************************************/
    public static void rbfunserialize(System.IO.Stream stream_in, out rbfmodel obj)
    {
        alglib.serializer s = new alglib.serializer();
        obj = new rbfmodel();
        s.ustart_stream(stream_in);
        rbf.rbfunserialize(s, obj.innerobj, null);
        s.stop();
    }
    
    /*************************************************************************
    This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
    function in a NX-dimensional space (NX>=1).

    Newly created model is empty. It can be used for interpolation right after
    creation, but it just returns zeros. You have to add points to the  model,
    tune interpolation settings, and then  call  model  construction  function
    rbfbuildmodel() which will update model according to your specification.

    USAGE:
    1. User creates model with rbfcreate()
    2. User adds dataset with rbfsetpoints() or rbfsetpointsandscales()
    3. User selects RBF solver by calling:
       * rbfsetalgohierarchical() - for a HRBF solver,  a  hierarchical large-
         scale Gaussian RBFs  (works  well  for  uniformly  distributed  point
         clouds, but may fail when the data are non-uniform; use other solvers
         below in such cases)
       * rbfsetalgothinplatespline() - for a large-scale DDM-RBF  solver  with
         thin plate spline basis function being used
       * rbfsetalgobiharmonic() -  for  a  large-scale  DDM-RBF  solver   with
         biharmonic basis function being used
       * rbfsetalgomultiquadricauto() -  for a large-scale DDM-RBF solver with
         multiquadric basis function being used (automatic  selection  of  the
         scale parameter Alpha)
       * rbfsetalgomultiquadricmanual() -  for a  large-scale  DDM-RBF  solver
         with multiquadric basis function being used (manual selection  of the
         scale parameter Alpha)
    4. (OPTIONAL) User chooses polynomial term by calling:
       * rbflinterm() to set linear term (default)
       * rbfconstterm() to set constant term
       * rbfzeroterm() to set zero term
    5. User calls rbfbuildmodel() function which rebuilds model  according  to
       the specification

    INPUT PARAMETERS:
        NX      -   dimension of the space, NX>=1
        NY      -   function dimension, NY>=1

    OUTPUT PARAMETERS:
        S       -   RBF model (initially equals to zero)

    NOTE 1: memory requirements. RBF models require amount of memory  which is
            proportional  to the number of data points. Some additional memory
            is allocated during model construction, but most of this memory is
            freed after the model  coefficients  are   calculated.  Amount  of
            this additional memory depends  on  model  construction  algorithm
            being used.

      -- ALGLIB --
         Copyright 13.12.2011, 20.06.2016 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfcreate(int nx, int ny, out rbfmodel s)
    {
        s = new rbfmodel();
        rbf.rbfcreate(nx, ny, s.innerobj, null);
    }
    
    public static void rbfcreate(int nx, int ny, out rbfmodel s, alglib.xparams _params)
    {
        s = new rbfmodel();
        rbf.rbfcreate(nx, ny, s.innerobj, _params);
    }
    
    /*************************************************************************
    This function creates buffer  structure  which  can  be  used  to  perform
    parallel  RBF  model  evaluations  (with  one  RBF  model  instance  being
    used from multiple threads, as long as  different  threads  use  different
    instances of the buffer).

    This buffer object can be used with  rbftscalcbuf()  function  (here  "ts"
    stands for "thread-safe", "buf" is a suffix which denotes  function  which
    reuses previously allocated output space).

    A buffer creation function (this function) is also thread-safe.  I.e.  you
    may safely create multiple buffers for the same  RBF  model  from multiple
    threads.

    NOTE: the  buffer  object  is  just  a  collection of several preallocated
          dynamic arrays and precomputed values. If you  delete  its  "parent"
          RBF model when the buffer is still alive, nothing  bad  will  happen
          (no dangling pointers or resource leaks).  The  buffer  will  simply
          become useless.

    How to use it:
    * create RBF model structure with rbfcreate()
    * load data, tune parameters
    * call rbfbuildmodel()
    * call rbfcreatecalcbuffer(), once per thread working with RBF model  (you
      should call this function only AFTER call to rbfbuildmodel(), see  below
      for more information)
    * call rbftscalcbuf() from different threads,  with  each  thread  working
      with its own copy of buffer object.
    * it is recommended to reuse buffer as much  as  possible  because  buffer
      creation involves allocation of several large dynamic arrays.  It  is  a
      huge waste of resource to use it just once.

    INPUT PARAMETERS
        S           -   RBF model

    OUTPUT PARAMETERS
        Buf         -   external buffer.

    IMPORTANT: buffer object should be used only with  RBF model object  which
               was used to initialize buffer. Any attempt to use buffer   with
               different object is dangerous - you may  get  memory  violation
               error because sizes of internal arrays do not fit to dimensions
               of RBF structure.

    IMPORTANT: you  should  call  this function only for model which was built
               with rbfbuildmodel() function, after successful  invocation  of
               rbfbuildmodel().  Sizes   of   some   internal  structures  are
               determined only after model is built, so buffer object  created
               before model  construction  stage  will  be  useless  (and  any
               attempt to use it will result in exception).

      -- ALGLIB --
         Copyright 02.04.2016 by Sergey Bochkanov
    *************************************************************************/
    public static void rbfcreatecalcbuffer(rbfmodel s, out rbfcalcbuffer buf)
    {
        buf = new rbfcalcbuffer();
        rbf.rbfcreatecalcbuffer(s.innerobj, buf.innerobj, null);
    }
    
    public static void rbfcreatecalcbuffer(rbfmodel s, out rbfcalcbuffer buf, alglib.xparams _params)
    {
        buf = new rbfcalcbuffer();
        rbf.rbfcreatecalcbuffer(s.innerobj, buf.innerobj, _params);
    }
    
    /*************************************************************************
    This function adds dataset.

    This function overrides results of the previous calls, i.e. multiple calls
    of this function will result in only the last set being added.

    IMPORTANT: ALGLIB version 3.11 and later allows you to specify  a  set  of
               per-dimension scales. Interpolation radii are multiplied by the
               scale vector. It may be useful if you have mixed spatio-temporal
               data (say, a set of 3D slices recorded at different times).
               You should call rbfsetpointsandscales() function  to  use  this
               feature.

    INPUT PARAMETERS:
        S       -   RBF model, initialized by rbfcreate() call.
        XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
                    in the dataset. First NX elements  are  coordinates,  next
                    NY elements are function values. Array may  be larger than
                    specified, in  this  case  only leading [N,NX+NY] elements
                    will be used.
        N       -   number of points in the dataset

    After you've added dataset and (optionally) tuned algorithm  settings  you
    should call rbfbuildmodel() in order to build a model for you.

    NOTE: dataset added by this function is not saved during model serialization.
          MODEL ITSELF is serialized, but data used to build it are not.

          So, if you 1) add dataset to  empty  RBF  model,  2)  serialize  and
          unserialize it, then you will get an empty RBF model with no dataset
          being attached.

          From the other side, if you call rbfbuildmodel() between (1) and (2),
          then after (2) you will get your fully constructed RBF model  -  but
          again with no dataset attached, so subsequent calls to rbfbuildmodel()
          will produce empty model.


      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetpoints(rbfmodel s, double[,] xy, int n)
    {
    
        rbf.rbfsetpoints(s.innerobj, xy, n, null);
    }
    
    public static void rbfsetpoints(rbfmodel s, double[,] xy, int n, alglib.xparams _params)
    {
    
        rbf.rbfsetpoints(s.innerobj, xy, n, _params);
    }
            
    public static void rbfsetpoints(rbfmodel s, double[,] xy)
    {
        int n;
    
    
        n = ap.rows(xy);
        rbf.rbfsetpoints(s.innerobj, xy, n, null);
    
        return;
    }
            
    public static void rbfsetpoints(rbfmodel s, double[,] xy, alglib.xparams _params)
    {
        int n;
    
    
        n = ap.rows(xy);
        rbf.rbfsetpoints(s.innerobj, xy, n, _params);
    
        return;
    }
    
    /*************************************************************************
    This function adds dataset and a vector of per-dimension scales.

    It may be useful if you have mixed spatio-temporal data - say, a set of 3D
    slices recorded at different times. Such data typically require  different
    RBF radii for spatial and temporal dimensions. ALGLIB solves this  problem
    by specifying single RBF radius, which is (optionally) multiplied  by  the
    scale vector.

    This function overrides results of the previous calls, i.e. multiple calls
    of this function will result in only the last set being added.

    IMPORTANT: only modern RBF algorithms  support  variable  scaling.  Legacy
               algorithms like RBF-ML or QNN algorithms  will  result  in   -3
               completion code being returned (incorrect algorithm).

    INPUT PARAMETERS:
        R       -   RBF model, initialized by rbfcreate() call.
        XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
                    in the dataset. First NX elements  are  coordinates,  next
                    NY elements are function values. Array may  be larger than
                    specified, in  this  case  only leading [N,NX+NY] elements
                    will be used.
        N       -   number of points in the dataset
        S       -   array[NX], scale vector, S[i]>0.

    After you've added dataset and (optionally) tuned algorithm  settings  you
    should call rbfbuildmodel() in order to build a model for you.

    NOTE: dataset added by this function is not saved during model serialization.
          MODEL ITSELF is serialized, but data used to build it are not.

          So, if you 1) add dataset to  empty  RBF  model,  2)  serialize  and
          unserialize it, then you will get an empty RBF model with no dataset
          being attached.

          From the other side, if you call rbfbuildmodel() between (1) and (2),
          then after (2) you will get your fully constructed RBF model  -  but
          again with no dataset attached, so subsequent calls to rbfbuildmodel()
          will produce empty model.


      -- ALGLIB --
         Copyright 20.06.2016 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetpointsandscales(rbfmodel r, double[,] xy, int n, double[] s)
    {
    
        rbf.rbfsetpointsandscales(r.innerobj, xy, n, s, null);
    }
    
    public static void rbfsetpointsandscales(rbfmodel r, double[,] xy, int n, double[] s, alglib.xparams _params)
    {
    
        rbf.rbfsetpointsandscales(r.innerobj, xy, n, s, _params);
    }
            
    public static void rbfsetpointsandscales(rbfmodel r, double[,] xy, double[] s)
    {
        int n;
    
    
        n = ap.rows(xy);
        rbf.rbfsetpointsandscales(r.innerobj, xy, n, s, null);
    
        return;
    }
            
    public static void rbfsetpointsandscales(rbfmodel r, double[,] xy, double[] s, alglib.xparams _params)
    {
        int n;
    
    
        n = ap.rows(xy);
        rbf.rbfsetpointsandscales(r.innerobj, xy, n, s, _params);
    
        return;
    }
    
    /*************************************************************************
    DEPRECATED: this function is deprecated. ALGLIB  includes  new  RBF  model
                construction algorithms: DDM-RBF (since version 3.19) and HRBF
                (since version 3.11).

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetalgoqnn(rbfmodel s, double q, double z)
    {
    
        rbf.rbfsetalgoqnn(s.innerobj, q, z, null);
    }
    
    public static void rbfsetalgoqnn(rbfmodel s, double q, double z, alglib.xparams _params)
    {
    
        rbf.rbfsetalgoqnn(s.innerobj, q, z, _params);
    }
            
    public static void rbfsetalgoqnn(rbfmodel s)
    {
        double q;
        double z;
    
    
        q = 1.0;
        z = 5.0;
        rbf.rbfsetalgoqnn(s.innerobj, q, z, null);
    
        return;
    }
            
    public static void rbfsetalgoqnn(rbfmodel s, alglib.xparams _params)
    {
        double q;
        double z;
    
    
        q = 1.0;
        z = 5.0;
        rbf.rbfsetalgoqnn(s.innerobj, q, z, _params);
    
        return;
    }
    
    /*************************************************************************
    DEPRECATED: this function is deprecated. ALGLIB  includes  new  RBF  model
                construction algorithms: DDM-RBF (since version 3.19) and HRBF
                (since version 3.11).

      -- ALGLIB --
         Copyright 02.03.2012 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, double lambdav)
    {
    
        rbf.rbfsetalgomultilayer(s.innerobj, rbase, nlayers, lambdav, null);
    }
    
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, double lambdav, alglib.xparams _params)
    {
    
        rbf.rbfsetalgomultilayer(s.innerobj, rbase, nlayers, lambdav, _params);
    }
            
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers)
    {
        double lambdav;
    
    
        lambdav = 0.01;
        rbf.rbfsetalgomultilayer(s.innerobj, rbase, nlayers, lambdav, null);
    
        return;
    }
            
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, alglib.xparams _params)
    {
        double lambdav;
    
    
        lambdav = 0.01;
        rbf.rbfsetalgomultilayer(s.innerobj, rbase, nlayers, lambdav, _params);
    
        return;
    }
    
    /*************************************************************************
    This function chooses HRBF solver, a 2nd version of ALGLIB RBFs.

    This  algorithm is called Hierarchical RBF. It  similar  to  its  previous
    incarnation, RBF-ML, i.e.  it  also  builds  a  sequence  of  models  with
    decreasing radii. However, it uses more economical way of  building  upper
    layers (ones with large radii), which results in faster model construction
    and evaluation, as well as smaller memory footprint during construction.

    This algorithm has following important features:
    * ability to handle millions of points
    * controllable smoothing via nonlinearity penalization
    * support for specification of per-dimensional  radii  via  scale  vector,
      which is set by means of rbfsetpointsandscales() function. This  feature
      is useful if you solve  spatio-temporal  interpolation  problems,  where
      different radii are required for spatial and temporal dimensions.

    Running times are roughly proportional to:
    * N*log(N)*NLayers - for the model construction
    * N*NLayers - for the model evaluation
    You may see that running time does not depend on search radius  or  points
    density, just on the number of layers in the hierarchy.

    INPUT PARAMETERS:
        S       -   RBF model, initialized by rbfcreate() call
        RBase   -   RBase parameter, RBase>0
        NLayers -   NLayers parameter, NLayers>0, recommended value  to  start
                    with - about 5.
        LambdaNS-   >=0, nonlinearity penalty coefficient, negative values are
                    not allowed. This parameter adds controllable smoothing to
                    the problem, which may reduce noise. Specification of non-
                    zero lambda means that in addition to fitting error solver
                    will  also  minimize   LambdaNS*|S''(x)|^2  (appropriately
                    generalized to multiple dimensions.

                    Specification of exactly zero value means that no  penalty
                    is added  (we  do  not  even  evaluate  matrix  of  second
                    derivatives which is necessary for smoothing).

                    Calculation of nonlinearity penalty is costly - it results
                    in  several-fold  increase  of  model  construction  time.
                    Evaluation time remains the same.

                    Optimal  lambda  is  problem-dependent and requires  trial
                    and  error.  Good  value to  start  from  is  1e-5...1e-6,
                    which corresponds to slightly noticeable smoothing  of the
                    function.  Value  1e-2  usually  means  that  quite  heavy
                    smoothing is applied.

    TUNING ALGORITHM

    In order to use this algorithm you have to choose three parameters:
    * initial radius RBase
    * number of layers in the model NLayers
    * penalty coefficient LambdaNS

    Initial radius is easy to choose - you can pick any number  several  times
    larger  than  the  average  distance between points. Algorithm won't break
    down if you choose radius which is too large (model construction time will
    increase, but model will be built correctly).

    Choose such number of layers that RLast=RBase/2^(NLayers-1)  (radius  used
    by  the  last  layer)  will  be  smaller than the typical distance between
    points.  In  case  model  error  is  too large, you can increase number of
    layers.  Having  more  layers  will make model construction and evaluation
    proportionally slower, but it will allow you to have model which precisely
    fits your data. From the other side, if you want to  suppress  noise,  you
    can DECREASE number of layers to make your model less flexible (or specify
    non-zero LambdaNS).

    TYPICAL ERRORS

    1. Using too small number of layers - RBF models with large radius are not
       flexible enough to reproduce small variations in the  target  function.
       You  need  many  layers  with  different radii, from large to small, in
       order to have good model.

    2. Using  initial  radius  which  is  too  small.  You will get model with
       "holes" in the areas which are too far away from interpolation centers.
       However, algorithm will work correctly (and quickly) in this case.

      -- ALGLIB --
         Copyright 20.06.2016 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetalgohierarchical(rbfmodel s, double rbase, int nlayers, double lambdans)
    {
    
        rbf.rbfsetalgohierarchical(s.innerobj, rbase, nlayers, lambdans, null);
    }
    
    public static void rbfsetalgohierarchical(rbfmodel s, double rbase, int nlayers, double lambdans, alglib.xparams _params)
    {
    
        rbf.rbfsetalgohierarchical(s.innerobj, rbase, nlayers, lambdans, _params);
    }
    
    /*************************************************************************
    This function chooses a thin plate  spline  DDM-RBF  solver,  a  fast  RBF
    solver with f(r)=r^2*ln(r) basis function.

    This algorithm has following important features:
    * easy setup - no tunable parameters
    * C1 continuous RBF model (gradient is defined everywhere, but Hessian  is
      undefined at nodes), high-quality interpolation
    * fast  model construction algorithm with O(N) memory and  O(N^2)  running
      time requirements. Hundreds of thousands of points can be  handled  with
      this algorithm.
    * controllable smoothing via optional nonlinearity penalty

    INPUT PARAMETERS:
        S       -   RBF model, initialized by rbfcreate() call
        LambdaV -   smoothing parameter, LambdaV>=0, defaults to 0.0:
                    * LambdaV=0 means that no smoothing is applied,  i.e.  the
                      spline tries to pass through all dataset points exactly
                    * LambdaV>0 means that a smoothing thin  plate  spline  is
                      built, with larger LambdaV corresponding to models  with
                      less nonlinearities. Smoothing spline reproduces  target
                      values at nodes with small error; from the  other  side,
                      it is much more stable.
                      Recommended values:
                      * 1.0E-6 for minimal stability improving smoothing
                      * 1.0E-3 a good value to start experiments; first results
                        are visible
                      * 1.0 for strong smoothing

    IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.19
               and  produces  models  which  are  INCOMPATIBLE  with  previous
               versions of ALGLIB. You can  not  unserialize  models  produced
               with this function in ALGLIB 3.18 or earlier.

    NOTE:      polyharmonic RBFs, including thin plate splines,  are  somewhat
               slower than compactly supported RBFs built with  HRBF algorithm
               due to the fact that non-compact basis function does not vanish
               far away from the nodes. From the other side, polyharmonic RBFs
               often produce much better results than HRBFs.

    NOTE:      this algorithm supports specification of per-dimensional  radii
               via scale vector, which is set by means of rbfsetpointsandscales()
               function. This feature is useful if  you solve  spatio-temporal
               interpolation problems where different radii are  required  for
               spatial and temporal dimensions.

      -- ALGLIB --
         Copyright 12.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetalgothinplatespline(rbfmodel s, double lambdav)
    {
    
        rbf.rbfsetalgothinplatespline(s.innerobj, lambdav, null);
    }
    
    public static void rbfsetalgothinplatespline(rbfmodel s, double lambdav, alglib.xparams _params)
    {
    
        rbf.rbfsetalgothinplatespline(s.innerobj, lambdav, _params);
    }
            
    public static void rbfsetalgothinplatespline(rbfmodel s)
    {
        double lambdav;
    
    
        lambdav = 0.0;
        rbf.rbfsetalgothinplatespline(s.innerobj, lambdav, null);
    
        return;
    }
            
    public static void rbfsetalgothinplatespline(rbfmodel s, alglib.xparams _params)
    {
        double lambdav;
    
    
        lambdav = 0.0;
        rbf.rbfsetalgothinplatespline(s.innerobj, lambdav, _params);
    
        return;
    }
    
    /*************************************************************************
    This function chooses a multiquadric DDM-RBF solver,  a  fast  RBF  solver
    with f(r)=sqrt(r^2+Alpha^2) as a basis function,  with  manual  choice  of
    the scale parameter Alpha.

    This algorithm has following important features:
    * C2 continuous RBF model (when Alpha>0 is used; for Alpha=0 the model  is
      merely C0 continuous)
    * fast  model construction algorithm with O(N) memory and  O(N^2)  running
      time requirements. Hundreds of thousands of points can be  handled  with
      this algorithm.
    * controllable smoothing via optional nonlinearity penalty

    One important point is that  this  algorithm  includes  tunable  parameter
    Alpha, which should be carefully chosen. Selecting too  large  value  will
    result in extremely badly  conditioned  problems  (interpolation  accuracy
    may degrade up to complete breakdown) whilst selecting too small value may
    produce models that are precise but nearly nonsmooth at the nodes.

    Good value to  start  from  is  mean  distance  between  nodes. Generally,
    choosing too small Alpha is better than choosing too large - in the former
    case you still have model that reproduces target values at the nodes.

    In most cases, better option is to choose good Alpha automatically - it is
    done by another version of the same algorithm that is activated by calling
    rbfsetalgomultiquadricauto() method.

    INPUT PARAMETERS:
        S       -   RBF model, initialized by rbfcreate() call
        Alpha   -   basis function parameter, Alpha>=0:
                    * Alpha>0  means that multiquadric algorithm is used which
                      produces C2-continuous RBF model
                    * Alpha=0  means that the multiquadric kernel  effectively
                      becomes a biharmonic one: f=r. As a  result,  the  model
                      becomes nonsmooth at nodes, and hence is C0 continuous
        LambdaV -   smoothing parameter, LambdaV>=0, defaults to 0.0:
                    * LambdaV=0 means that no smoothing is applied,  i.e.  the
                      spline tries to pass through all dataset points exactly
                    * LambdaV>0 means that a multiquadric spline is built with
                      larger  LambdaV   corresponding   to  models  with  less
                      nonlinearities.  Smoothing   spline   reproduces  target
                      values at nodes with small error; from the  other  side,
                      it is much more stable.
                      Recommended values:
                      * 1.0E-6 for minimal stability improving smoothing
                      * 1.0E-3 a good value to start experiments; first results
                        are visible
                      * 1.0 for strong smoothing

    IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.19
               and  produces  models  which  are  INCOMPATIBLE  with  previous
               versions of ALGLIB. You can  not  unserialize  models  produced
               with this function in ALGLIB 3.18 or earlier.

    NOTE:      polyharmonic RBFs, including thin plate splines,  are  somewhat
               slower than compactly supported RBFs built with  HRBF algorithm
               due to the fact that non-compact basis function does not vanish
               far away from the nodes. From the other side, polyharmonic RBFs
               often produce much better results than HRBFs.

    NOTE:      this algorithm supports specification of per-dimensional  radii
               via scale vector, which is set by means of rbfsetpointsandscales()
               function. This feature is useful if  you solve  spatio-temporal
               interpolation problems where different radii are  required  for
               spatial and temporal dimensions.

      -- ALGLIB --
         Copyright 12.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetalgomultiquadricmanual(rbfmodel s, double alpha, double lambdav)
    {
    
        rbf.rbfsetalgomultiquadricmanual(s.innerobj, alpha, lambdav, null);
    }
    
    public static void rbfsetalgomultiquadricmanual(rbfmodel s, double alpha, double lambdav, alglib.xparams _params)
    {
    
        rbf.rbfsetalgomultiquadricmanual(s.innerobj, alpha, lambdav, _params);
    }
            
    public static void rbfsetalgomultiquadricmanual(rbfmodel s, double alpha)
    {
        double lambdav;
    
    
        lambdav = 0.0;
        rbf.rbfsetalgomultiquadricmanual(s.innerobj, alpha, lambdav, null);
    
        return;
    }
            
    public static void rbfsetalgomultiquadricmanual(rbfmodel s, double alpha, alglib.xparams _params)
    {
        double lambdav;
    
    
        lambdav = 0.0;
        rbf.rbfsetalgomultiquadricmanual(s.innerobj, alpha, lambdav, _params);
    
        return;
    }
    
    /*************************************************************************
    This function chooses a multiquadric DDM-RBF solver,  a  fast  RBF  solver
    with f(r)=sqrt(r^2+Alpha^2)  as  a  basis  function,  with   Alpha   being
    automatically determined.

    This algorithm has following important features:
    * easy setup - no need to tune Alpha, good value is automatically assigned
    * C2 continuous RBF model
    * fast  model construction algorithm with O(N) memory and  O(N^2)  running
      time requirements. Hundreds of thousands of points can be  handled  with
      this algorithm.
    * controllable smoothing via optional nonlinearity penalty

    This algorithm automatically selects Alpha  as  a  mean  distance  to  the
    nearest neighbor (ignoring neighbors that are too close).

    INPUT PARAMETERS:
        S       -   RBF model, initialized by rbfcreate() call
        LambdaV -   smoothing parameter, LambdaV>=0, defaults to 0.0:
                    * LambdaV=0 means that no smoothing is applied,  i.e.  the
                      spline tries to pass through all dataset points exactly
                    * LambdaV>0 means that a multiquadric spline is built with
                      larger  LambdaV   corresponding   to  models  with  less
                      nonlinearities.  Smoothing   spline   reproduces  target
                      values at nodes with small error; from the  other  side,
                      it is much more stable.
                      Recommended values:
                      * 1.0E-6 for minimal stability improving smoothing
                      * 1.0E-3 a good value to start experiments; first results
                        are visible
                      * 1.0 for strong smoothing

    IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.19
               and  produces  models  which  are  INCOMPATIBLE  with  previous
               versions of ALGLIB. You can  not  unserialize  models  produced
               with this function in ALGLIB 3.18 or earlier.

    NOTE:      polyharmonic RBFs, including thin plate splines,  are  somewhat
               slower than compactly supported RBFs built with  HRBF algorithm
               due to the fact that non-compact basis function does not vanish
               far away from the nodes. From the other side, polyharmonic RBFs
               often produce much better results than HRBFs.

    NOTE:      this algorithm supports specification of per-dimensional  radii
               via scale vector, which is set by means of rbfsetpointsandscales()
               function. This feature is useful if  you solve  spatio-temporal
               interpolation problems where different radii are  required  for
               spatial and temporal dimensions.

      -- ALGLIB --
         Copyright 12.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetalgomultiquadricauto(rbfmodel s, double lambdav)
    {
    
        rbf.rbfsetalgomultiquadricauto(s.innerobj, lambdav, null);
    }
    
    public static void rbfsetalgomultiquadricauto(rbfmodel s, double lambdav, alglib.xparams _params)
    {
    
        rbf.rbfsetalgomultiquadricauto(s.innerobj, lambdav, _params);
    }
            
    public static void rbfsetalgomultiquadricauto(rbfmodel s)
    {
        double lambdav;
    
    
        lambdav = 0.0;
        rbf.rbfsetalgomultiquadricauto(s.innerobj, lambdav, null);
    
        return;
    }
            
    public static void rbfsetalgomultiquadricauto(rbfmodel s, alglib.xparams _params)
    {
        double lambdav;
    
    
        lambdav = 0.0;
        rbf.rbfsetalgomultiquadricauto(s.innerobj, lambdav, _params);
    
        return;
    }
    
    /*************************************************************************
    This  function  chooses  a  biharmonic DDM-RBF solver, a fast  RBF  solver
    with f(r)=r as a basis function.

    This algorithm has following important features:
    * no tunable parameters
    * C0 continuous RBF model (the model has discontinuous derivatives at  the
      interpolation nodes)
    * fast  model construction algorithm with O(N) memory and  O(N^2)  running
      time requirements. Hundreds of thousands of points can be  handled  with
      this algorithm.
    * controllable smoothing via optional nonlinearity penalty

    INPUT PARAMETERS:
        S       -   RBF model, initialized by rbfcreate() call
        LambdaV -   smoothing parameter, LambdaV>=0, defaults to 0.0:
                    * LambdaV=0 means that no smoothing is applied,  i.e.  the
                      spline tries to pass through all dataset points exactly
                    * LambdaV>0 means that a multiquadric spline is built with
                      larger  LambdaV   corresponding   to  models  with  less
                      nonlinearities.  Smoothing   spline   reproduces  target
                      values at nodes with small error; from the  other  side,
                      it is much more stable.
                      Recommended values:
                      * 1.0E-6 for minimal stability improving smoothing
                      * 1.0E-3 a good value to start experiments; first results
                        are visible
                      * 1.0 for strong smoothing

    IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.19
               and  produces  models  which  are  INCOMPATIBLE  with  previous
               versions of ALGLIB. You can  not  unserialize  models  produced
               with this function in ALGLIB 3.18 or earlier.

    NOTE:      polyharmonic RBFs, including thin plate splines,  are  somewhat
               slower than compactly supported RBFs built with  HRBF algorithm
               due to the fact that non-compact basis function does not vanish
               far away from the nodes. From the other side, polyharmonic RBFs
               often produce much better results than HRBFs.

    NOTE:      this algorithm supports specification of per-dimensional  radii
               via scale vector, which is set by means of rbfsetpointsandscales()
               function. This feature is useful if  you solve  spatio-temporal
               interpolation problems where different radii are  required  for
               spatial and temporal dimensions.

      -- ALGLIB --
         Copyright 12.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetalgobiharmonic(rbfmodel s, double lambdav)
    {
    
        rbf.rbfsetalgobiharmonic(s.innerobj, lambdav, null);
    }
    
    public static void rbfsetalgobiharmonic(rbfmodel s, double lambdav, alglib.xparams _params)
    {
    
        rbf.rbfsetalgobiharmonic(s.innerobj, lambdav, _params);
    }
            
    public static void rbfsetalgobiharmonic(rbfmodel s)
    {
        double lambdav;
    
    
        lambdav = 0.0;
        rbf.rbfsetalgobiharmonic(s.innerobj, lambdav, null);
    
        return;
    }
            
    public static void rbfsetalgobiharmonic(rbfmodel s, alglib.xparams _params)
    {
        double lambdav;
    
    
        lambdav = 0.0;
        rbf.rbfsetalgobiharmonic(s.innerobj, lambdav, _params);
    
        return;
    }
    
    /*************************************************************************
    This function sets linear term (model is a sum of radial  basis  functions
    plus linear polynomial). This function won't have effect until  next  call
    to RBFBuildModel().

    Using linear term is a default option and it is the best one - it provides
    best convergence guarantees for all RBF model  types: legacy  RBF-QNN  and
    RBF-ML, Gaussian HRBFs and all types of DDM-RBF models.

    Other options, like constant or zero term, work for HRBFs,  almost  always
    work for DDM-RBFs but provide no stability  guarantees  in the latter case
    (e.g. the solver may fail on some carefully prepared problems).

    INPUT PARAMETERS:
        S       -   RBF model, initialized by RBFCreate() call

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetlinterm(rbfmodel s)
    {
    
        rbf.rbfsetlinterm(s.innerobj, null);
    }
    
    public static void rbfsetlinterm(rbfmodel s, alglib.xparams _params)
    {
    
        rbf.rbfsetlinterm(s.innerobj, _params);
    }
    
    /*************************************************************************
    This function sets constant term (model is a sum of radial basis functions
    plus constant).  This  function  won't  have  effect  until  next  call to
    RBFBuildModel().

    IMPORTANT: thin plate splines require  polynomial term to be  linear,  not
               constant,  in  order  to  provide   interpolation   guarantees.
               Although  failures  are  exceptionally  rare,  some  small  toy
               problems may result in degenerate linear systems. Thus,  it  is
               advised to use linear term when one fits data with TPS.

    INPUT PARAMETERS:
        S       -   RBF model, initialized by RBFCreate() call

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetconstterm(rbfmodel s)
    {
    
        rbf.rbfsetconstterm(s.innerobj, null);
    }
    
    public static void rbfsetconstterm(rbfmodel s, alglib.xparams _params)
    {
    
        rbf.rbfsetconstterm(s.innerobj, _params);
    }
    
    /*************************************************************************
    This  function  sets  zero  term (model is a sum of radial basis functions
    without polynomial term). This function won't have effect until next  call
    to RBFBuildModel().

    IMPORTANT: only  Gaussian  RBFs  (HRBF  algorithm)  provide  interpolation
               guarantees when no polynomial term is used.  Most  other  RBFs,
               including   biharmonic  splines,   thin   plate   splines   and
               multiquadrics, require at least constant term  (biharmonic  and
               multiquadric) or linear one (thin plate splines)  in  order  to
               guarantee non-degeneracy of linear systems being solved.

               Although  failures  are  exceptionally  rare,  some  small  toy
               problems still may result in degenerate linear systems. Thus,it
               is advised to use constant/linear term, unless one is 100% sure
               that he needs zero term.

    INPUT PARAMETERS:
        S       -   RBF model, initialized by RBFCreate() call

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetzeroterm(rbfmodel s)
    {
    
        rbf.rbfsetzeroterm(s.innerobj, null);
    }
    
    public static void rbfsetzeroterm(rbfmodel s, alglib.xparams _params)
    {
    
        rbf.rbfsetzeroterm(s.innerobj, _params);
    }
    
    /*************************************************************************
    This function sets basis function type, which can be:
    * 0 for classic Gaussian
    * 1 for fast and compact bell-like basis function, which  becomes  exactly
      zero at distance equal to 3*R (default option).

    INPUT PARAMETERS:
        S       -   RBF model, initialized by RBFCreate() call
        BF      -   basis function type:
                    * 0 - classic Gaussian
                    * 1 - fast and compact one

      -- ALGLIB --
         Copyright 01.02.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetv2bf(rbfmodel s, int bf)
    {
    
        rbf.rbfsetv2bf(s.innerobj, bf, null);
    }
    
    public static void rbfsetv2bf(rbfmodel s, int bf, alglib.xparams _params)
    {
    
        rbf.rbfsetv2bf(s.innerobj, bf, _params);
    }
    
    /*************************************************************************
    This function sets stopping criteria of the underlying linear  solver  for
    hierarchical (version 2) RBF constructor.

    INPUT PARAMETERS:
        S       -   RBF model, initialized by RBFCreate() call
        MaxIts  -   this criterion will stop algorithm after MaxIts iterations.
                    Typically a few hundreds iterations is required,  with 400
                    being a good default value to start experimentation.
                    Zero value means that default value will be selected.

      -- ALGLIB --
         Copyright 01.02.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetv2its(rbfmodel s, int maxits)
    {
    
        rbf.rbfsetv2its(s.innerobj, maxits, null);
    }
    
    public static void rbfsetv2its(rbfmodel s, int maxits, alglib.xparams _params)
    {
    
        rbf.rbfsetv2its(s.innerobj, maxits, _params);
    }
    
    /*************************************************************************
    This function sets support radius parameter  of  hierarchical  (version 2)
    RBF constructor.

    Hierarchical RBF model achieves great speed-up  by removing from the model
    excessive (too dense) nodes. Say, if you have RBF radius equal to 1 meter,
    and two nodes are just 1 millimeter apart, you  may  remove  one  of  them
    without reducing model quality.

    Support radius parameter is used to justify which points need removal, and
    which do not. If two points are less than  SUPPORT_R*CUR_RADIUS  units  of
    distance apart, one of them is removed from the model. The larger  support
    radius  is, the faster model  construction  AND  evaluation are.  However,
    too large values result in "bumpy" models.

    INPUT PARAMETERS:
        S       -   RBF model, initialized by RBFCreate() call
        R       -   support radius coefficient, >=0.
                    Recommended values are [0.1,0.4] range, with 0.1 being
                    default value.

      -- ALGLIB --
         Copyright 01.02.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfsetv2supportr(rbfmodel s, double r)
    {
    
        rbf.rbfsetv2supportr(s.innerobj, r, null);
    }
    
    public static void rbfsetv2supportr(rbfmodel s, double r, alglib.xparams _params)
    {
    
        rbf.rbfsetv2supportr(s.innerobj, r, _params);
    }
    
    /*************************************************************************
    This   function  builds  RBF  model  and  returns  report  (contains  some
    information which can be used for evaluation of the algorithm properties).

    Call to this function modifies RBF model by calculating its centers/radii/
    weights  and  saving  them  into  RBFModel  structure.  Initially RBFModel
    contain zero coefficients, but after call to this function  we  will  have
    coefficients which were calculated in order to fit our dataset.

    After you called this function you can call RBFCalc(),  RBFGridCalc()  and
    other model calculation functions.

    INPUT PARAMETERS:
        S       -   RBF model, initialized by RBFCreate() call
        Rep     -   report:
                    * Rep.TerminationType:
                      * -5 - non-distinct basis function centers were detected,
                             interpolation  aborted;  only  QNN  returns  this
                             error   code, other  algorithms  can  handle non-
                             distinct nodes.
                      * -4 - nonconvergence of the internal SVD solver
                      * -3   incorrect model construction algorithm was chosen:
                             QNN or RBF-ML, combined with one of the incompatible
                             features:
                             * NX=1 or NX>3
                             * points with per-dimension scales.
                      *  1 - successful termination
                      *  8 - a termination request was submitted via
                             rbfrequesttermination() function.

                    Fields which are set only by modern RBF solvers (hierarchical
                    or nonnegative; older solvers like QNN and ML initialize these
                    fields by NANs):
                    * rep.rmserror - root-mean-square error at nodes
                    * rep.maxerror - maximum error at nodes

                    Fields are used for debugging purposes:
                    * Rep.IterationsCount - iterations count of the LSQR solver
                    * Rep.NMV - number of matrix-vector products
                    * Rep.ARows - rows count for the system matrix
                    * Rep.ACols - columns count for the system matrix
                    * Rep.ANNZ - number of significantly non-zero elements
                      (elements above some algorithm-determined threshold)

    NOTE:  failure  to  build  model will leave current state of the structure
    unchanged.

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfbuildmodel(rbfmodel s, out rbfreport rep)
    {
        rep = new rbfreport();
        rbf.rbfbuildmodel(s.innerobj, rep.innerobj, null);
    }
    
    public static void rbfbuildmodel(rbfmodel s, out rbfreport rep, alglib.xparams _params)
    {
        rep = new rbfreport();
        rbf.rbfbuildmodel(s.innerobj, rep.innerobj, _params);
    }
    
    /*************************************************************************
    This function calculates values of the 1-dimensional RBF model with scalar
    output (NY=1) at the given point.

    IMPORTANT: this function works only with modern  (hierarchical)  RBFs.  It
               can not be used with legacy (version 1) RBFs because older  RBF
               code does not support 1-dimensional models.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).
               If you want to perform parallel model evaluation  from multiple
               threads, use rbftscalcbuf() with per-thread buffer object.

    This function returns 0.0 when:
    * the model is not initialized
    * NX<>1
    * NY<>1

    INPUT PARAMETERS:
        S       -   RBF model
        X0      -   X-coordinate, finite number

    RESULT:
        value of the model or 0.0 (as defined above)

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static double rbfcalc1(rbfmodel s, double x0)
    {
    
        return rbf.rbfcalc1(s.innerobj, x0, null);
    }
    
    public static double rbfcalc1(rbfmodel s, double x0, alglib.xparams _params)
    {
    
        return rbf.rbfcalc1(s.innerobj, x0, _params);
    }
    
    /*************************************************************************
    This function calculates values of the 2-dimensional RBF model with scalar
    output (NY=1) at the given point.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).
               If you want to perform parallel model evaluation  from multiple
               threads, use rbftscalcbuf() with per-thread buffer object.

    This function returns 0.0 when:
    * model is not initialized
    * NX<>2
     *NY<>1

    INPUT PARAMETERS:
        S       -   RBF model
        X0      -   first coordinate, finite number
        X1      -   second coordinate, finite number

    RESULT:
        value of the model or 0.0 (as defined above)

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static double rbfcalc2(rbfmodel s, double x0, double x1)
    {
    
        return rbf.rbfcalc2(s.innerobj, x0, x1, null);
    }
    
    public static double rbfcalc2(rbfmodel s, double x0, double x1, alglib.xparams _params)
    {
    
        return rbf.rbfcalc2(s.innerobj, x0, x1, _params);
    }
    
    /*************************************************************************
    This function calculates values of the 3-dimensional RBF model with scalar
    output (NY=1) at the given point.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).
               If you want to perform parallel model evaluation  from multiple
               threads, use rbftscalcbuf() with per-thread buffer object.

    This function returns 0.0 when:
    * model is not initialized
    * NX<>3
     *NY<>1

    INPUT PARAMETERS:
        S       -   RBF model
        X0      -   first coordinate, finite number
        X1      -   second coordinate, finite number
        X2      -   third coordinate, finite number

    RESULT:
        value of the model or 0.0 (as defined above)

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static double rbfcalc3(rbfmodel s, double x0, double x1, double x2)
    {
    
        return rbf.rbfcalc3(s.innerobj, x0, x1, x2, null);
    }
    
    public static double rbfcalc3(rbfmodel s, double x0, double x1, double x2, alglib.xparams _params)
    {
    
        return rbf.rbfcalc3(s.innerobj, x0, x1, x2, _params);
    }
    
    /*************************************************************************
    This function calculates value and derivatives of  the  1-dimensional  RBF
    model with scalar output (NY=1) at the given point.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).
               If you want to perform parallel model evaluation  from multiple
               threads, use rbftscalcbuf() with per-thread buffer object.

    This function returns 0.0 in Y and/or DY in the following cases:
    * the model is not initialized (Y=0, DY=0)
    * NX<>1 or NY<>1 (Y=0, DY=0)
    * the gradient is undefined at the trial point. Some basis  functions have
      discontinuous derivatives at the interpolation nodes:
      * biharmonic splines f=r have no Hessian and no gradient at the nodes
      In these cases only DY is set to zero (Y is still returned)

    INPUT PARAMETERS:
        S       -   RBF model
        X0      -   first coordinate, finite number

    OUTPUT PARAMETERS:
        Y       -   value of the model or 0.0 (as defined above)
        DY0     -   derivative with respect to X0

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfdiff1(rbfmodel s, double x0, out double y, out double dy0)
    {
        y = 0;
        dy0 = 0;
        rbf.rbfdiff1(s.innerobj, x0, ref y, ref dy0, null);
    }
    
    public static void rbfdiff1(rbfmodel s, double x0, out double y, out double dy0, alglib.xparams _params)
    {
        y = 0;
        dy0 = 0;
        rbf.rbfdiff1(s.innerobj, x0, ref y, ref dy0, _params);
    }
    
    /*************************************************************************
    This function calculates value and derivatives of  the  2-dimensional  RBF
    model with scalar output (NY=1) at the given point.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).
               If you want to perform parallel model evaluation  from multiple
               threads, use rbftscalcbuf() with per-thread buffer object.

    This function returns 0.0 in Y and/or DY in the following cases:
    * the model is not initialized (Y=0, DY=0)
    * NX<>2 or NY<>1 (Y=0, DY=0)
    * the gradient is undefined at the trial point. Some basis  functions have
      discontinuous derivatives at the interpolation nodes:
      * biharmonic splines f=r have no Hessian and no gradient at the nodes
      In these cases only DY is set to zero (Y is still returned)

    INPUT PARAMETERS:
        S       -   RBF model
        X0      -   first coordinate, finite number
        X1      -   second coordinate, finite number

    OUTPUT PARAMETERS:
        Y       -   value of the model or 0.0 (as defined above)
        DY0     -   derivative with respect to X0
        DY1     -   derivative with respect to X1

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfdiff2(rbfmodel s, double x0, double x1, out double y, out double dy0, out double dy1)
    {
        y = 0;
        dy0 = 0;
        dy1 = 0;
        rbf.rbfdiff2(s.innerobj, x0, x1, ref y, ref dy0, ref dy1, null);
    }
    
    public static void rbfdiff2(rbfmodel s, double x0, double x1, out double y, out double dy0, out double dy1, alglib.xparams _params)
    {
        y = 0;
        dy0 = 0;
        dy1 = 0;
        rbf.rbfdiff2(s.innerobj, x0, x1, ref y, ref dy0, ref dy1, _params);
    }
    
    /*************************************************************************
    This function calculates value and derivatives of  the  3-dimensional  RBF
    model with scalar output (NY=1) at the given point.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).
               If you want to perform parallel model evaluation  from multiple
               threads, use rbftscalcbuf() with per-thread buffer object.

    This function returns 0.0 in Y and/or DY in the following cases:
    * the model is not initialized (Y=0, DY=0)
    * NX<>3 or NY<>1 (Y=0, DY=0)
    * the gradient is undefined at the trial point. Some basis  functions have
      discontinuous derivatives at the interpolation nodes:
      * biharmonic splines f=r have no Hessian and no gradient at the nodes
      In these cases only DY is set to zero (Y is still returned)

    INPUT PARAMETERS:
        S       -   RBF model
        X0      -   first coordinate, finite number
        X1      -   second coordinate, finite number
        X2      -   third coordinate, finite number

    OUTPUT PARAMETERS:
        Y       -   value of the model or 0.0 (as defined above)
        DY0     -   derivative with respect to X0
        DY1     -   derivative with respect to X1
        DY2     -   derivative with respect to X2

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfdiff3(rbfmodel s, double x0, double x1, double x2, out double y, out double dy0, out double dy1, out double dy2)
    {
        y = 0;
        dy0 = 0;
        dy1 = 0;
        dy2 = 0;
        rbf.rbfdiff3(s.innerobj, x0, x1, x2, ref y, ref dy0, ref dy1, ref dy2, null);
    }
    
    public static void rbfdiff3(rbfmodel s, double x0, double x1, double x2, out double y, out double dy0, out double dy1, out double dy2, alglib.xparams _params)
    {
        y = 0;
        dy0 = 0;
        dy1 = 0;
        dy2 = 0;
        rbf.rbfdiff3(s.innerobj, x0, x1, x2, ref y, ref dy0, ref dy1, ref dy2, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model at the given point.

    This is general function which can be used for arbitrary NX (dimension  of
    the space of arguments) and NY (dimension of the function itself). However
    when  you  have  NY=1  you  may  find more convenient to use rbfcalc2() or
    rbfcalc3().

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).
               If you want to perform parallel model evaluation  from multiple
               threads, use rbftscalcbuf() with per-thread buffer object.

    This function returns 0.0 when model is not initialized.

    INPUT PARAMETERS:
        S       -   RBF model
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY]. Y is out-parameter and
                    reallocated after call to this function. In case you  want
                    to reuse previously allocated Y, you may use RBFCalcBuf(),
                    which reallocates Y only when it is too small.

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfcalc(rbfmodel s, double[] x, out double[] y)
    {
        y = new double[0];
        rbf.rbfcalc(s.innerobj, x, ref y, null);
    }
    
    public static void rbfcalc(rbfmodel s, double[] x, out double[] y, alglib.xparams _params)
    {
        y = new double[0];
        rbf.rbfcalc(s.innerobj, x, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model and  its  derivatives  at
    the given point.

    This is general function which can be used for arbitrary NX (dimension  of
    the space of arguments) and NY (dimension of the function itself). However
    if you have NX=3 and NY=1, you may find more convenient to use rbfdiff3().

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).

               If you want to perform parallel model evaluation  from multiple
               threads, use rbftsdiffbuf() with per-thread buffer object.

    This function returns 0.0 in Y and/or DY in the following cases:
    * the model is not initialized (Y=0, DY=0)
    * the gradient is undefined at the trial point. Some basis  functions have
      discontinuous derivatives at the interpolation nodes:
      * biharmonic splines f=r have no Hessian and no gradient at the nodes
      In these cases only DY is set to zero (Y is still returned)

    INPUT PARAMETERS:
        S       -   RBF model
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY]. Y is out-parameter and
                    reallocated after call to this function. In case you  want
                    to reuse previously allocated Y, you may use RBFDiffBuf(),
                    which reallocates Y only when it is too small.
        DY      -   derivatives, array[NX*NY]:
                    * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                      function component I with respect to input J.
                    * for NY=1 it is simply NX-dimensional gradient of the
                      scalar NX-dimensional function
                    DY is out-parameter and reallocated  after  call  to  this
                    function. In case you want to reuse  previously  allocated
                    DY, you may use RBFDiffBuf(), which  reallocates  DY  only
                    when it is too small to store the result.

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfdiff(rbfmodel s, double[] x, out double[] y, out double[] dy)
    {
        y = new double[0];
        dy = new double[0];
        rbf.rbfdiff(s.innerobj, x, ref y, ref dy, null);
    }
    
    public static void rbfdiff(rbfmodel s, double[] x, out double[] y, out double[] dy, alglib.xparams _params)
    {
        y = new double[0];
        dy = new double[0];
        rbf.rbfdiff(s.innerobj, x, ref y, ref dy, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model and  its first and second
    derivatives (Hessian matrix) at the given point.

    This function supports both scalar (NY=1) and vector-valued (NY>1) RBFs.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).

               If you want to perform parallel model evaluation  from multiple
               threads, use rbftshessbuf() with per-thread buffer object.

    This function returns 0 in Y and/or DY and/or D2Y in the following cases:
    * the model is not initialized (Y=0, DY=0, D2Y=0)
    * the gradient and/or Hessian is undefined at the trial point.  Some basis
      functions have discontinuous derivatives at the interpolation nodes:
      * thin plate splines have no Hessian at the nodes
      * biharmonic splines f=r have no Hessian and no gradient at the  nodes
      In these cases only corresponding derivative is set  to  zero,  and  the
      rest of the derivatives is still returned.

    INPUT PARAMETERS:
        S       -   RBF model
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY].
                    Y is out-parameter and  reallocated  after  call  to  this
                    function. In case you  want to reuse previously  allocated
                    Y, you may use RBFHessBuf(), which reallocates Y only when
                    it is too small.
        DY      -   first derivatives, array[NY*NX]:
                    * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                      function component I with respect to input J.
                    * for NY=1 it is simply NX-dimensional gradient of the
                      scalar NX-dimensional function
                    DY is out-parameter and reallocated  after  call  to  this
                    function. In case you want to reuse  previously  allocated
                    DY, you may use RBFHessBuf(), which  reallocates  DY  only
                    when it is too small to store the result.
        D2Y     -   second derivatives, array[NY*NX*NX]:
                    * for NY=1 it is NX*NX array that stores  Hessian  matrix,
                      with Y[I*NX+J]=Y[J*NX+I].
                    * for  a  vector-valued  RBF  with  NY>1  it  contains  NY
                      subsequently stored Hessians: an element Y[K*NX*NX+I*NX+J]
                      with  0<=K<NY,  0<=I<NX  and  0<=J<NX    stores   second
                      derivative of the function #K  with  respect  to  inputs
                      #I and #J.
                    D2Y is out-parameter and reallocated  after  call  to this
                    function. In case you want to reuse  previously  allocated
                    D2Y, you may use RBFHessBuf(), which  reallocates D2Y only
                    when it is too small to store the result.

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfhess(rbfmodel s, double[] x, out double[] y, out double[] dy, out double[] d2y)
    {
        y = new double[0];
        dy = new double[0];
        d2y = new double[0];
        rbf.rbfhess(s.innerobj, x, ref y, ref dy, ref d2y, null);
    }
    
    public static void rbfhess(rbfmodel s, double[] x, out double[] y, out double[] dy, out double[] d2y, alglib.xparams _params)
    {
        y = new double[0];
        dy = new double[0];
        d2y = new double[0];
        rbf.rbfhess(s.innerobj, x, ref y, ref dy, ref d2y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model at the given point.

    Same as rbfcalc(), but does not reallocate Y when in is large enough to
    store function values.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).
               If you want to perform parallel model evaluation  from multiple
               threads, use rbftscalcbuf() with per-thread buffer object.

    INPUT PARAMETERS:
        S       -   RBF model
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.
        Y       -   possibly preallocated array

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY]. Y is not reallocated when it
                    is larger than NY.

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfcalcbuf(rbfmodel s, double[] x, ref double[] y)
    {
    
        rbf.rbfcalcbuf(s.innerobj, x, ref y, null);
    }
    
    public static void rbfcalcbuf(rbfmodel s, double[] x, ref double[] y, alglib.xparams _params)
    {
    
        rbf.rbfcalcbuf(s.innerobj, x, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model and  its  derivatives  at
    the given point. It is a buffered version of the RBFDiff() which tries  to
    reuse possibly preallocated output arrays Y/DY as much as possible.

    This is general function which can be used for arbitrary NX (dimension  of
    the space of arguments) and NY (dimension of the function itself). However
    if you have NX=1, 2 or 3 and NY=1, you may find  more  convenient  to  use
    rbfdiff1(), rbfdiff2() or rbfdiff3().

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).

               If you want to perform parallel model evaluation  from multiple
               threads, use rbftsdiffbuf() with per-thread buffer object.

    This function returns 0.0 in Y and/or DY in the following cases:
    * the model is not initialized (Y=0, DY=0)
    * the gradient is undefined at the trial point. Some basis  functions have
      discontinuous derivatives at the interpolation nodes:
      * biharmonic splines f=r have no Hessian and no gradient at the nodes
      In these cases only DY is set to zero (Y is still returned)

    INPUT PARAMETERS:
        S       -   RBF model
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.
        Y, DY   -   possibly preallocated arrays; if array size is large enough
                    to store results, this function does not  reallocate  array
                    to fit output size exactly.

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY].
        DY      -   derivatives, array[NX*NY]:
                    * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                      function component I with respect to input J.
                    * for NY=1 it is simply NX-dimensional gradient of the
                      scalar NX-dimensional function

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfdiffbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy)
    {
    
        rbf.rbfdiffbuf(s.innerobj, x, ref y, ref dy, null);
    }
    
    public static void rbfdiffbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy, alglib.xparams _params)
    {
    
        rbf.rbfdiffbuf(s.innerobj, x, ref y, ref dy, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model and  its first and second
    derivatives (Hessian matrix) at the given point. It is a buffered  version
    that reuses memory  allocated  in  output  buffers  Y/DY/D2Y  as  much  as
    possible.

    This function supports both scalar (NY=1) and vector-valued (NY>1) RBFs.

    IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
               temporary arrays, i.e. it is  impossible  to  perform  parallel
               evaluation on the same rbfmodel object (parallel calls of  this
               function for independent rbfmodel objects are safe).

               If you want to perform parallel model evaluation  from multiple
               threads, use rbftshessbuf() with per-thread buffer object.

    This function returns 0 in Y and/or DY and/or D2Y in the following cases:
    * the model is not initialized (Y=0, DY=0, D2Y=0)
    * the gradient and/or Hessian is undefined at the trial point.  Some basis
      functions have discontinuous derivatives at the interpolation nodes:
      * thin plate splines have no Hessian at the nodes
      * biharmonic splines f=r have no Hessian and no gradient at the  nodes
      In these cases only corresponding derivative is set  to  zero,  and  the
      rest of the derivatives is still returned.

    INPUT PARAMETERS:
        S       -   RBF model
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.
        Y,DY,D2Y-   possible preallocated output arrays. If these  arrays  are
                    smaller than  required  to  store  the  result,  they  are
                    automatically reallocated. If array is large enough, it is
                    not resized.

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY].
        DY      -   first derivatives, array[NY*NX]:
                    * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                      function component I with respect to input J.
                    * for NY=1 it is simply NX-dimensional gradient of the
                      scalar NX-dimensional function
        D2Y     -   second derivatives, array[NY*NX*NX]:
                    * for NY=1 it is NX*NX array that stores  Hessian  matrix,
                      with Y[I*NX+J]=Y[J*NX+I].
                    * for  a  vector-valued  RBF  with  NY>1  it  contains  NY
                      subsequently stored Hessians: an element Y[K*NX*NX+I*NX+J]
                      with  0<=K<NY,  0<=I<NX  and  0<=J<NX    stores   second
                      derivative of the function #K  with  respect  to  inputs
                      #I and #J.

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfhessbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy, ref double[] d2y)
    {
    
        rbf.rbfhessbuf(s.innerobj, x, ref y, ref dy, ref d2y, null);
    }
    
    public static void rbfhessbuf(rbfmodel s, double[] x, ref double[] y, ref double[] dy, ref double[] d2y, alglib.xparams _params)
    {
    
        rbf.rbfhessbuf(s.innerobj, x, ref y, ref dy, ref d2y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model at the given point, using
    external  buffer  object  (internal  temporaries  of  RBF  model  are  not
    modified).

    This function allows to use same RBF model object  in  different  threads,
    assuming  that  different   threads  use  different  instances  of  buffer
    structure.

    INPUT PARAMETERS:
        S       -   RBF model, may be shared between different threads
        Buf     -   buffer object created for this particular instance of  RBF
                    model with rbfcreatecalcbuffer().
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.
        Y       -   possibly preallocated array

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY]. Y is not reallocated when it
                    is larger than NY.

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbftscalcbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y)
    {
    
        rbf.rbftscalcbuf(s.innerobj, buf.innerobj, x, ref y, null);
    }
    
    public static void rbftscalcbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, alglib.xparams _params)
    {
    
        rbf.rbftscalcbuf(s.innerobj, buf.innerobj, x, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model and  its  derivatives  at
    the given point, using external buffer object (internal temporaries of the
    RBF model are not modified).

    This function allows to use same RBF model object  in  different  threads,
    assuming  that  different   threads  use different instances of the buffer
    structure.

    This function returns 0.0 in Y and/or DY in the following cases:
    * the model is not initialized (Y=0, DY=0)
    * the gradient is undefined at the trial point. Some basis  functions have
      discontinuous derivatives at the interpolation nodes:
      * biharmonic splines f=r have no Hessian and no gradient at the nodes
      In these cases only DY is set to zero (Y is still returned)

    INPUT PARAMETERS:
        S       -   RBF model, may be shared between different threads
        Buf     -   buffer object created for this particular instance of  RBF
                    model with rbfcreatecalcbuffer().
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.
        Y, DY   -   possibly preallocated arrays; if array size is large enough
                    to store results, this function does not  reallocate  array
                    to fit output size exactly.

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY].
        DY      -   derivatives, array[NX*NY]:
                    * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                      function component I with respect to input J.
                    * for NY=1 it is simply NX-dimensional gradient of the
                      scalar NX-dimensional function
                    Zero is returned when the first derivative is undefined.

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbftsdiffbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy)
    {
    
        rbf.rbftsdiffbuf(s.innerobj, buf.innerobj, x, ref y, ref dy, null);
    }
    
    public static void rbftsdiffbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy, alglib.xparams _params)
    {
    
        rbf.rbftsdiffbuf(s.innerobj, buf.innerobj, x, ref y, ref dy, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model and  its first and second
    derivatives (Hessian matrix) at the given  point,  using  external  buffer
    object (internal temporaries of the RBF  model  are  not  modified).

    This function allows to use same RBF model object  in  different  threads,
    assuming  that  different   threads  use different instances of the buffer
    structure.

    This function returns 0 in Y and/or DY and/or D2Y in the following cases:
    * the model is not initialized (Y=0, DY=0, D2Y=0)
    * the gradient and/or Hessian is undefined at the trial point.  Some basis
      functions have discontinuous derivatives at the interpolation nodes:
      * thin plate splines have no Hessian at the nodes
      * biharmonic splines f=r have no Hessian and no gradient at the  nodes
      In these cases only corresponding derivative is set  to  zero,  and  the
      rest of the derivatives is still returned.

    INPUT PARAMETERS:
        S       -   RBF model, may be shared between different threads
        Buf     -   buffer object created for this particular instance of  RBF
                    model with rbfcreatecalcbuffer().
        X       -   coordinates, array[NX].
                    X may have more than NX elements, in this case only
                    leading NX will be used.
        Y,DY,D2Y-   possible preallocated output arrays. If these  arrays  are
                    smaller than  required  to  store  the  result,  they  are
                    automatically reallocated. If array is large enough, it is
                    not resized.

    OUTPUT PARAMETERS:
        Y       -   function value, array[NY].
        DY      -   first derivatives, array[NY*NX]:
                    * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                      function component I with respect to input J.
                    * for NY=1 it is simply NX-dimensional gradient of the
                      scalar NX-dimensional function
                    Zero is returned when the first derivative is undefined.
        D2Y     -   second derivatives, array[NY*NX*NX]:
                    * for NY=1 it is NX*NX array that stores  Hessian  matrix,
                      with Y[I*NX+J]=Y[J*NX+I].
                    * for  a  vector-valued  RBF  with  NY>1  it  contains  NY
                      subsequently stored Hessians: an element Y[K*NX*NX+I*NX+J]
                      with  0<=K<NY,  0<=I<NX  and  0<=J<NX    stores   second
                      derivative of the function #K  with  respect  to  inputs
                      #I and #J.
                    Zero is returned when the second derivative is undefined.

      -- ALGLIB --
         Copyright 13.12.2021 by Bochkanov Sergey
    *************************************************************************/
    public static void rbftshessbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy, ref double[] d2y)
    {
    
        rbf.rbftshessbuf(s.innerobj, buf.innerobj, x, ref y, ref dy, ref d2y, null);
    }
    
    public static void rbftshessbuf(rbfmodel s, rbfcalcbuffer buf, double[] x, ref double[] y, ref double[] dy, ref double[] d2y, alglib.xparams _params)
    {
    
        rbf.rbftshessbuf(s.innerobj, buf.innerobj, x, ref y, ref dy, ref d2y, _params);
    }
    
    /*************************************************************************
    This is legacy function for gridded calculation of RBF model.

    It is superseded by rbfgridcalc2v() and  rbfgridcalc2vsubset()  functions.

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfgridcalc2(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[,] y)
    {
        y = new double[0,0];
        rbf.rbfgridcalc2(s.innerobj, x0, n0, x1, n1, ref y, null);
    }
    
    public static void rbfgridcalc2(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[,] y, alglib.xparams _params)
    {
        y = new double[0,0];
        rbf.rbfgridcalc2(s.innerobj, x0, n0, x1, n1, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF  model  at  the  regular  grid,
    which  has  N0*N1 points, with Point[I,J] = (X0[I], X1[J]).  Vector-valued
    RBF models are supported.

    This function returns 0.0 when:
    * model is not initialized
    * NX<>2

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
          RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
          processed serially.

    INPUT PARAMETERS:
        S       -   RBF model, used in read-only mode, can be  shared  between
                    multiple   invocations  of  this  function  from  multiple
                    threads.

        X0      -   array of grid nodes, first coordinates, array[N0].
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N0      -   grid size (number of nodes) in the first dimension

        X1      -   array of grid nodes, second coordinates, array[N1]
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N1      -   grid size (number of nodes) in the second dimension

    OUTPUT PARAMETERS:
        Y       -   function values, array[NY*N0*N1], where NY is a  number of
                    "output" vector values (this  function   supports  vector-
                    valued RBF models). Y is out-variable and  is  reallocated
                    by this function.
                    Y[K+NY*(I0+I1*N0)]=F_k(X0[I0],X1[I1]), for:
                    *  K=0...NY-1
                    * I0=0...N0-1
                    * I1=0...N1-1

    NOTE: this function supports weakly ordered grid nodes, i.e. you may  have
          X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
          benefits  due  to   duplication  of  points,  just  convenience  and
          flexibility.

    NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
          structure in multiple threads calling  this function  for  different
          grids.

    NOTE: if you need function values on some subset  of  regular  grid, which
          may be described as "several compact and  dense  islands",  you  may
          use rbfgridcalc2vsubset().

      -- ALGLIB --
         Copyright 27.01.2017 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfgridcalc2v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[] y)
    {
        y = new double[0];
        rbf.rbfgridcalc2v(s.innerobj, x0, n0, x1, n1, ref y, null);
    }
    
    public static void rbfgridcalc2v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[] y, alglib.xparams _params)
    {
        y = new double[0];
        rbf.rbfgridcalc2v(s.innerobj, x0, n0, x1, n1, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model at some subset of regular
    grid:
    * grid has N0*N1 points, with Point[I,J] = (X0[I], X1[J])
    * only values at some subset of this grid are required
    Vector-valued RBF models are supported.

    This function returns 0.0 when:
    * model is not initialized
    * NX<>2

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
          RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
          processed serially.

    INPUT PARAMETERS:
        S       -   RBF model, used in read-only mode, can be  shared  between
                    multiple   invocations  of  this  function  from  multiple
                    threads.

        X0      -   array of grid nodes, first coordinates, array[N0].
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N0      -   grid size (number of nodes) in the first dimension

        X1      -   array of grid nodes, second coordinates, array[N1]
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N1      -   grid size (number of nodes) in the second dimension

        FlagY   -   array[N0*N1]:
                    * Y[I0+I1*N0] corresponds to node (X0[I0],X1[I1])
                    * it is a "bitmap" array which contains  False  for  nodes
                      which are NOT calculated, and True for nodes  which  are
                      required.

    OUTPUT PARAMETERS:
        Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
                    of "output" vector values (this function  supports vector-
                    valued RBF models):
                    * Y[K+NY*(I0+I1*N0)]=F_k(X0[I0],X1[I1]),
                      for K=0...NY-1, I0=0...N0-1, I1=0...N1-1.
                    * elements of Y[] which correspond  to  FlagY[]=True   are
                      loaded by model values (which may be  exactly  zero  for
                      some nodes).
                    * elements of Y[] which correspond to FlagY[]=False MAY be
                      initialized by zeros OR may be calculated. This function
                      processes  grid  as  a  hierarchy  of  nested blocks and
                      micro-rows. If just one element of micro-row is required,
                      entire micro-row (up to 8 nodes in the current  version,
                      but no promises) is calculated.

    NOTE: this function supports weakly ordered grid nodes, i.e. you may  have
          X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
          benefits  due  to   duplication  of  points,  just  convenience  and
          flexibility.

    NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
          structure in multiple threads calling  this function  for  different
          grids.

      -- ALGLIB --
         Copyright 04.03.2016 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfgridcalc2vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, bool[] flagy, out double[] y)
    {
        y = new double[0];
        rbf.rbfgridcalc2vsubset(s.innerobj, x0, n0, x1, n1, flagy, ref y, null);
    }
    
    public static void rbfgridcalc2vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, bool[] flagy, out double[] y, alglib.xparams _params)
    {
        y = new double[0];
        rbf.rbfgridcalc2vsubset(s.innerobj, x0, n0, x1, n1, flagy, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF  model  at  the  regular  grid,
    which  has  N0*N1*N2  points,  with  Point[I,J,K] = (X0[I], X1[J], X2[K]).
    Vector-valued RBF models are supported.

    This function returns 0.0 when:
    * model is not initialized
    * NX<>3

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
          RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
          processed serially.

    INPUT PARAMETERS:
        S       -   RBF model, used in read-only mode, can be  shared  between
                    multiple   invocations  of  this  function  from  multiple
                    threads.

        X0      -   array of grid nodes, first coordinates, array[N0].
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N0      -   grid size (number of nodes) in the first dimension

        X1      -   array of grid nodes, second coordinates, array[N1]
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N1      -   grid size (number of nodes) in the second dimension

        X2      -   array of grid nodes, third coordinates, array[N2]
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N2      -   grid size (number of nodes) in the third dimension

    OUTPUT PARAMETERS:
        Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
                    of "output" vector values (this function  supports vector-
                    valued RBF models). Y is out-variable and  is  reallocated
                    by this function.
                    Y[K+NY*(I0+I1*N0+I2*N0*N1)]=F_k(X0[I0],X1[I1],X2[I2]), for:
                    *  K=0...NY-1
                    * I0=0...N0-1
                    * I1=0...N1-1
                    * I2=0...N2-1

    NOTE: this function supports weakly ordered grid nodes, i.e. you may  have
          X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
          benefits  due  to   duplication  of  points,  just  convenience  and
          flexibility.

    NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
          structure in multiple threads calling  this function  for  different
          grids.

    NOTE: if you need function values on some subset  of  regular  grid, which
          may be described as "several compact and  dense  islands",  you  may
          use rbfgridcalc3vsubset().

      -- ALGLIB --
         Copyright 04.03.2016 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfgridcalc3v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, out double[] y)
    {
        y = new double[0];
        rbf.rbfgridcalc3v(s.innerobj, x0, n0, x1, n1, x2, n2, ref y, null);
    }
    
    public static void rbfgridcalc3v(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, out double[] y, alglib.xparams _params)
    {
        y = new double[0];
        rbf.rbfgridcalc3v(s.innerobj, x0, n0, x1, n1, x2, n2, ref y, _params);
    }
    
    /*************************************************************************
    This function calculates values of the RBF model at some subset of regular
    grid:
    * grid has N0*N1*N2 points, with Point[I,J,K] = (X0[I], X1[J], X2[K])
    * only values at some subset of this grid are required
    Vector-valued RBF models are supported.

    This function returns 0.0 when:
    * model is not initialized
    * NX<>3

      ! COMMERCIAL EDITION OF ALGLIB:
      !
      ! Commercial Edition of ALGLIB includes following important improvements
      ! of this function:
      ! * high-performance native backend with same C# interface (C# version)
      ! * multithreading support (C++ and C# versions)
      !
      ! We recommend you to read 'Working with commercial version' section  of
      ! ALGLIB Reference Manual in order to find out how to  use  performance-
      ! related features provided by commercial edition of ALGLIB.

    NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
          RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
          processed serially.

    INPUT PARAMETERS:
        S       -   RBF model, used in read-only mode, can be  shared  between
                    multiple   invocations  of  this  function  from  multiple
                    threads.

        X0      -   array of grid nodes, first coordinates, array[N0].
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N0      -   grid size (number of nodes) in the first dimension

        X1      -   array of grid nodes, second coordinates, array[N1]
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N1      -   grid size (number of nodes) in the second dimension

        X2      -   array of grid nodes, third coordinates, array[N2]
                    Must be ordered by ascending. Exception is generated
                    if the array is not correctly ordered.
        N2      -   grid size (number of nodes) in the third dimension

        FlagY   -   array[N0*N1*N2]:
                    * Y[I0+I1*N0+I2*N0*N1] corresponds to node (X0[I0],X1[I1],X2[I2])
                    * it is a "bitmap" array which contains  False  for  nodes
                      which are NOT calculated, and True for nodes  which  are
                      required.

    OUTPUT PARAMETERS:
        Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
                    of "output" vector values (this function  supports vector-
                    valued RBF models):
                    * Y[K+NY*(I0+I1*N0+I2*N0*N1)]=F_k(X0[I0],X1[I1],X2[I2]),
                      for K=0...NY-1, I0=0...N0-1, I1=0...N1-1, I2=0...N2-1.
                    * elements of Y[] which correspond  to  FlagY[]=True   are
                      loaded by model values (which may be  exactly  zero  for
                      some nodes).
                    * elements of Y[] which correspond to FlagY[]=False MAY be
                      initialized by zeros OR may be calculated. This function
                      processes  grid  as  a  hierarchy  of  nested blocks and
                      micro-rows. If just one element of micro-row is required,
                      entire micro-row (up to 8 nodes in the current  version,
                      but no promises) is calculated.

    NOTE: this function supports weakly ordered grid nodes, i.e. you may  have
          X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
          benefits  due  to   duplication  of  points,  just  convenience  and
          flexibility.

    NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
          structure in multiple threads calling  this function  for  different
          grids.

      -- ALGLIB --
         Copyright 04.03.2016 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfgridcalc3vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, bool[] flagy, out double[] y)
    {
        y = new double[0];
        rbf.rbfgridcalc3vsubset(s.innerobj, x0, n0, x1, n1, x2, n2, flagy, ref y, null);
    }
    
    public static void rbfgridcalc3vsubset(rbfmodel s, double[] x0, int n0, double[] x1, int n1, double[] x2, int n2, bool[] flagy, out double[] y, alglib.xparams _params)
    {
        y = new double[0];
        rbf.rbfgridcalc3vsubset(s.innerobj, x0, n0, x1, n1, x2, n2, flagy, ref y, _params);
    }
    
    /*************************************************************************
    This function "unpacks" RBF model by extracting its coefficients.

    INPUT PARAMETERS:
        S       -   RBF model

    OUTPUT PARAMETERS:
        NX      -   dimensionality of argument
        NY      -   dimensionality of the target function
        XWR     -   model  information ,  2D  array.  One  row  of  the  array
                    corresponds to one basis function.

                    For ModelVersion=1 we have NX+NY+1 columns:
                    * first NX columns  - coordinates of the center
                    * next  NY columns  - weights, one per dimension of the
                                          function being modeled
                    * last column       - radius, same for all dimensions of
                                          the function being modeled

                    For ModelVersion=2 we have NX+NY+NX columns:
                    * first NX columns  - coordinates of the center
                    * next  NY columns  - weights, one per dimension of the
                                          function being modeled
                    * last NX columns   - radii, one per dimension

                    For ModelVersion=3 we have NX+NY+NX+3 columns:
                    * first NX columns  - coordinates of the center
                    * next  NY columns  - weights, one per dimension of the
                                          function being modeled
                    * next NX columns   - radii, one per dimension
                    * next column       - basis function type:
                                          * 1  for f=r
                                          * 2  for f=r^2*ln(r)
                                          * 10 for multiquadric f=sqrt(r^2+alpha^2)
                    * next column       - basis function parameter:
                                          * alpha, for basis function type 10
                                          * ignored (zero) for other basis function types
                    * next column       - point index in the original dataset,
                                          or -1 for an artificial node created
                                          by the solver. The algorithm may reorder
                                          the nodes, drop some nodes or add
                                          artificial nodes. Thus, one parsing
                                          this column should expect all these
                                          kinds of alterations in the dataset.

        NC      -   number of the centers
        V       -   polynomial  term , array[NY,NX+1]. One row per one
                    dimension of the function being modelled. First NX
                    elements are linear coefficients, V[NX] is equal to the
                    constant part.
        ModelVersion-version of the RBF model:
                    * 1 - for models created by QNN and RBF-ML algorithms,
                      compatible with ALGLIB 3.10 or earlier.
                    * 2 - for models created by HierarchicalRBF, requires
                      ALGLIB 3.11 or later
                    * 3 - for models created by DDM-RBF, requires
                      ALGLIB 3.19 or later

      -- ALGLIB --
         Copyright 13.12.2011 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfunpack(rbfmodel s, out int nx, out int ny, out double[,] xwr, out int nc, out double[,] v, out int modelversion)
    {
        nx = 0;
        ny = 0;
        xwr = new double[0,0];
        nc = 0;
        v = new double[0,0];
        modelversion = 0;
        rbf.rbfunpack(s.innerobj, ref nx, ref ny, ref xwr, ref nc, ref v, ref modelversion, null);
    }
    
    public static void rbfunpack(rbfmodel s, out int nx, out int ny, out double[,] xwr, out int nc, out double[,] v, out int modelversion, alglib.xparams _params)
    {
        nx = 0;
        ny = 0;
        xwr = new double[0,0];
        nc = 0;
        v = new double[0,0];
        modelversion = 0;
        rbf.rbfunpack(s.innerobj, ref nx, ref ny, ref xwr, ref nc, ref v, ref modelversion, _params);
    }
    
    /*************************************************************************
    This function returns model version.

    INPUT PARAMETERS:
        S       -   RBF model

    RESULT:
        * 1 - for models created by QNN and RBF-ML algorithms,
          compatible with ALGLIB 3.10 or earlier.
        * 2 - for models created by HierarchicalRBF, requires
          ALGLIB 3.11 or later

      -- ALGLIB --
         Copyright 06.07.2016 by Bochkanov Sergey
    *************************************************************************/
    public static int rbfgetmodelversion(rbfmodel s)
    {
    
        return rbf.rbfgetmodelversion(s.innerobj, null);
    }
    
    public static int rbfgetmodelversion(rbfmodel s, alglib.xparams _params)
    {
    
        return rbf.rbfgetmodelversion(s.innerobj, _params);
    }
    
    /*************************************************************************
    This function is used to peek into hierarchical RBF  construction  process
    from  some  other  thread  and  get current progress indicator. It returns
    value in [0,1].

    IMPORTANT: only HRBFs (hierarchical RBFs) support  peeking  into  progress
               indicator. Legacy RBF-ML and RBF-QNN do  not  support  it.  You
               will always get 0 value.

    INPUT PARAMETERS:
        S           -   RBF model object

    RESULT:
        progress value, in [0,1]

      -- ALGLIB --
         Copyright 17.11.2018 by Bochkanov Sergey
    *************************************************************************/
    public static double rbfpeekprogress(rbfmodel s)
    {
    
        return rbf.rbfpeekprogress(s.innerobj, null);
    }
    
    public static double rbfpeekprogress(rbfmodel s, alglib.xparams _params)
    {
    
        return rbf.rbfpeekprogress(s.innerobj, _params);
    }
    
    /*************************************************************************
    This function  is  used  to  submit  a  request  for  termination  of  the
    hierarchical RBF construction process from some other thread.  As  result,
    RBF construction is terminated smoothly (with proper deallocation  of  all
    necessary resources) and resultant model is filled by zeros.

    A rep.terminationtype=8 will be returned upon receiving such request.

    IMPORTANT: only  HRBFs  (hierarchical  RBFs) support termination requests.
               Legacy RBF-ML and RBF-QNN do not  support  it.  An  attempt  to
               terminate their construction will be ignored.

    IMPORTANT: termination request flag is cleared when the model construction
               starts. Thus, any pre-construction termination requests will be
               silently ignored - only ones submitted AFTER  construction  has
               actually began will be handled.

    INPUT PARAMETERS:
        S           -   RBF model object

      -- ALGLIB --
         Copyright 17.11.2018 by Bochkanov Sergey
    *************************************************************************/
    public static void rbfrequesttermination(rbfmodel s)
    {
    
        rbf.rbfrequesttermination(s.innerobj, null);
    }
    
    public static void rbfrequesttermination(rbfmodel s, alglib.xparams _params)
    {
    
        rbf.rbfrequesttermination(s.innerobj, _params);
    }

}
public partial class alglib
{
    public class ratint
    {
        /*************************************************************************
        Barycentric interpolant.
        *************************************************************************/
        public class barycentricinterpolant : apobject
        {
            public int n;
            public double sy;
            public double[] x;
            public double[] y;
            public double[] w;
            public barycentricinterpolant()
            {
                init();
            }
            public override void init()
            {
                x = new double[0];
                y = new double[0];
                w = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                barycentricinterpolant _result = new barycentricinterpolant();
                _result.n = n;
                _result.sy = sy;
                _result.x = (double[])x.Clone();
                _result.y = (double[])y.Clone();
                _result.w = (double[])w.Clone();
                return _result;
            }
        };




        /*************************************************************************
        Rational interpolation using barycentric formula

        F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))

        Input parameters:
            B   -   barycentric interpolant built with one of model building
                    subroutines.
            T   -   interpolation point

        Result:
            barycentric interpolant F(t)

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static double barycentriccalc(barycentricinterpolant b,
            double t,
            alglib.xparams _params)
        {
            double result = 0;
            double s1 = 0;
            double s2 = 0;
            double s = 0;
            double v = 0;
            int i = 0;

            alglib.ap.assert(!Double.IsInfinity(t), "BarycentricCalc: infinite T!");
            
            //
            // special case: NaN
            //
            if( Double.IsNaN(t) )
            {
                result = Double.NaN;
                return result;
            }
            
            //
            // special case: N=1
            //
            if( b.n==1 )
            {
                result = b.sy*b.y[0];
                return result;
            }
            
            //
            // Here we assume that task is normalized, i.e.:
            // 1. abs(Y[i])<=1
            // 2. abs(W[i])<=1
            // 3. X[] is ordered
            //
            s = Math.Abs(t-b.x[0]);
            for(i=0; i<=b.n-1; i++)
            {
                v = b.x[i];
                if( (double)(v)==(double)(t) )
                {
                    result = b.sy*b.y[i];
                    return result;
                }
                v = Math.Abs(t-v);
                if( (double)(v)<(double)(s) )
                {
                    s = v;
                }
            }
            s1 = 0;
            s2 = 0;
            for(i=0; i<=b.n-1; i++)
            {
                v = s/(t-b.x[i]);
                v = v*b.w[i];
                s1 = s1+v*b.y[i];
                s2 = s2+v;
            }
            result = b.sy*s1/s2;
            return result;
        }


        /*************************************************************************
        Differentiation of barycentric interpolant: first derivative.

        Algorithm used in this subroutine is very robust and should not fail until
        provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
        or greater will overflow).

        INPUT PARAMETERS:
            B   -   barycentric interpolant built with one of model building
                    subroutines.
            T   -   interpolation point

        OUTPUT PARAMETERS:
            F   -   barycentric interpolant at T
            DF  -   first derivative
            
        NOTE


          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentricdiff1(barycentricinterpolant b,
            double t,
            ref double f,
            ref double df,
            alglib.xparams _params)
        {
            double v = 0;
            double vv = 0;
            int i = 0;
            int k = 0;
            double n0 = 0;
            double n1 = 0;
            double d0 = 0;
            double d1 = 0;
            double s0 = 0;
            double s1 = 0;
            double xk = 0;
            double xi = 0;
            double xmin = 0;
            double xmax = 0;
            double xscale1 = 0;
            double xoffs1 = 0;
            double xscale2 = 0;
            double xoffs2 = 0;
            double xprev = 0;

            f = 0;
            df = 0;

            alglib.ap.assert(!Double.IsInfinity(t), "BarycentricDiff1: infinite T!");
            
            //
            // special case: NaN
            //
            if( Double.IsNaN(t) )
            {
                f = Double.NaN;
                df = Double.NaN;
                return;
            }
            
            //
            // special case: N=1
            //
            if( b.n==1 )
            {
                f = b.sy*b.y[0];
                df = 0;
                return;
            }
            if( (double)(b.sy)==(double)(0) )
            {
                f = 0;
                df = 0;
                return;
            }
            alglib.ap.assert((double)(b.sy)>(double)(0), "BarycentricDiff1: internal error");
            
            //
            // We assume than N>1 and B.SY>0. Find:
            // 1. pivot point (X[i] closest to T)
            // 2. width of interval containing X[i]
            //
            v = Math.Abs(b.x[0]-t);
            k = 0;
            xmin = b.x[0];
            xmax = b.x[0];
            for(i=1; i<=b.n-1; i++)
            {
                vv = b.x[i];
                if( (double)(Math.Abs(vv-t))<(double)(v) )
                {
                    v = Math.Abs(vv-t);
                    k = i;
                }
                xmin = Math.Min(xmin, vv);
                xmax = Math.Max(xmax, vv);
            }
            
            //
            // pivot point found, calculate dNumerator and dDenominator
            //
            xscale1 = 1/(xmax-xmin);
            xoffs1 = -(xmin/(xmax-xmin))+1;
            xscale2 = 2;
            xoffs2 = -3;
            t = t*xscale1+xoffs1;
            t = t*xscale2+xoffs2;
            xk = b.x[k];
            xk = xk*xscale1+xoffs1;
            xk = xk*xscale2+xoffs2;
            v = t-xk;
            n0 = 0;
            n1 = 0;
            d0 = 0;
            d1 = 0;
            xprev = -2;
            for(i=0; i<=b.n-1; i++)
            {
                xi = b.x[i];
                xi = xi*xscale1+xoffs1;
                xi = xi*xscale2+xoffs2;
                alglib.ap.assert((double)(xi)>(double)(xprev), "BarycentricDiff1: points are too close!");
                xprev = xi;
                if( i!=k )
                {
                    vv = math.sqr(t-xi);
                    s0 = (t-xk)/(t-xi);
                    s1 = (xk-xi)/vv;
                }
                else
                {
                    s0 = 1;
                    s1 = 0;
                }
                vv = b.w[i]*b.y[i];
                n0 = n0+s0*vv;
                n1 = n1+s1*vv;
                vv = b.w[i];
                d0 = d0+s0*vv;
                d1 = d1+s1*vv;
            }
            f = b.sy*n0/d0;
            df = (n1*d0-n0*d1)/math.sqr(d0);
            if( (double)(df)!=(double)(0) )
            {
                df = Math.Sign(df)*Math.Exp(Math.Log(Math.Abs(df))+Math.Log(b.sy)+Math.Log(xscale1)+Math.Log(xscale2));
            }
        }


        /*************************************************************************
        Differentiation of barycentric interpolant: first/second derivatives.

        INPUT PARAMETERS:
            B   -   barycentric interpolant built with one of model building
                    subroutines.
            T   -   interpolation point

        OUTPUT PARAMETERS:
            F   -   barycentric interpolant at T
            DF  -   first derivative
            D2F -   second derivative

        NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
        whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
        BarycentricDiff1() subroutine in such cases.


          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentricdiff2(barycentricinterpolant b,
            double t,
            ref double f,
            ref double df,
            ref double d2f,
            alglib.xparams _params)
        {
            double v = 0;
            double vv = 0;
            int i = 0;
            int k = 0;
            double n0 = 0;
            double n1 = 0;
            double n2 = 0;
            double d0 = 0;
            double d1 = 0;
            double d2 = 0;
            double s0 = 0;
            double s1 = 0;
            double s2 = 0;
            double xk = 0;
            double xi = 0;

            f = 0;
            df = 0;
            d2f = 0;

            alglib.ap.assert(!Double.IsInfinity(t), "BarycentricDiff1: infinite T!");
            
            //
            // special case: NaN
            //
            if( Double.IsNaN(t) )
            {
                f = Double.NaN;
                df = Double.NaN;
                d2f = Double.NaN;
                return;
            }
            
            //
            // special case: N=1
            //
            if( b.n==1 )
            {
                f = b.sy*b.y[0];
                df = 0;
                d2f = 0;
                return;
            }
            if( (double)(b.sy)==(double)(0) )
            {
                f = 0;
                df = 0;
                d2f = 0;
                return;
            }
            
            //
            // We assume than N>1 and B.SY>0. Find:
            // 1. pivot point (X[i] closest to T)
            // 2. width of interval containing X[i]
            //
            alglib.ap.assert((double)(b.sy)>(double)(0), "BarycentricDiff: internal error");
            f = 0;
            df = 0;
            d2f = 0;
            v = Math.Abs(b.x[0]-t);
            k = 0;
            for(i=1; i<=b.n-1; i++)
            {
                vv = b.x[i];
                if( (double)(Math.Abs(vv-t))<(double)(v) )
                {
                    v = Math.Abs(vv-t);
                    k = i;
                }
            }
            
            //
            // pivot point found, calculate dNumerator and dDenominator
            //
            xk = b.x[k];
            v = t-xk;
            n0 = 0;
            n1 = 0;
            n2 = 0;
            d0 = 0;
            d1 = 0;
            d2 = 0;
            for(i=0; i<=b.n-1; i++)
            {
                if( i!=k )
                {
                    xi = b.x[i];
                    vv = math.sqr(t-xi);
                    s0 = (t-xk)/(t-xi);
                    s1 = (xk-xi)/vv;
                    s2 = -(2*(xk-xi)/(vv*(t-xi)));
                }
                else
                {
                    s0 = 1;
                    s1 = 0;
                    s2 = 0;
                }
                vv = b.w[i]*b.y[i];
                n0 = n0+s0*vv;
                n1 = n1+s1*vv;
                n2 = n2+s2*vv;
                vv = b.w[i];
                d0 = d0+s0*vv;
                d1 = d1+s1*vv;
                d2 = d2+s2*vv;
            }
            f = b.sy*n0/d0;
            df = b.sy*(n1*d0-n0*d1)/math.sqr(d0);
            d2f = b.sy*((n2*d0-n0*d2)*math.sqr(d0)-(n1*d0-n0*d1)*2*d0*d1)/math.sqr(math.sqr(d0));
        }


        /*************************************************************************
        This subroutine performs linear transformation of the argument.

        INPUT PARAMETERS:
            B       -   rational interpolant in barycentric form
            CA, CB  -   transformation coefficients: x = CA*t + CB

        OUTPUT PARAMETERS:
            B       -   transformed interpolant with X replaced by T

          -- ALGLIB PROJECT --
             Copyright 19.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentriclintransx(barycentricinterpolant b,
            double ca,
            double cb,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double v = 0;

            
            //
            // special case, replace by constant F(CB)
            //
            if( (double)(ca)==(double)(0) )
            {
                b.sy = barycentriccalc(b, cb, _params);
                v = 1;
                for(i=0; i<=b.n-1; i++)
                {
                    b.y[i] = 1;
                    b.w[i] = v;
                    v = -v;
                }
                return;
            }
            
            //
            // general case: CA<>0
            //
            for(i=0; i<=b.n-1; i++)
            {
                b.x[i] = (b.x[i]-cb)/ca;
            }
            if( (double)(ca)<(double)(0) )
            {
                for(i=0; i<=b.n-1; i++)
                {
                    if( i<b.n-1-i )
                    {
                        j = b.n-1-i;
                        v = b.x[i];
                        b.x[i] = b.x[j];
                        b.x[j] = v;
                        v = b.y[i];
                        b.y[i] = b.y[j];
                        b.y[j] = v;
                        v = b.w[i];
                        b.w[i] = b.w[j];
                        b.w[j] = v;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }


        /*************************************************************************
        This  subroutine   performs   linear  transformation  of  the  barycentric
        interpolant.

        INPUT PARAMETERS:
            B       -   rational interpolant in barycentric form
            CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB

        OUTPUT PARAMETERS:
            B       -   transformed interpolant

          -- ALGLIB PROJECT --
             Copyright 19.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentriclintransy(barycentricinterpolant b,
            double ca,
            double cb,
            alglib.xparams _params)
        {
            int i = 0;
            double v = 0;
            int i_ = 0;

            for(i=0; i<=b.n-1; i++)
            {
                b.y[i] = ca*b.sy*b.y[i]+cb;
            }
            b.sy = 0;
            for(i=0; i<=b.n-1; i++)
            {
                b.sy = Math.Max(b.sy, Math.Abs(b.y[i]));
            }
            if( (double)(b.sy)>(double)(0) )
            {
                v = 1/b.sy;
                for(i_=0; i_<=b.n-1;i_++)
                {
                    b.y[i_] = v*b.y[i_];
                }
            }
        }


        /*************************************************************************
        Extracts X/Y/W arrays from rational interpolant

        INPUT PARAMETERS:
            B   -   barycentric interpolant

        OUTPUT PARAMETERS:
            N   -   nodes count, N>0
            X   -   interpolation nodes, array[0..N-1]
            F   -   function values, array[0..N-1]
            W   -   barycentric weights, array[0..N-1]

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentricunpack(barycentricinterpolant b,
            ref int n,
            ref double[] x,
            ref double[] y,
            ref double[] w,
            alglib.xparams _params)
        {
            double v = 0;
            int i_ = 0;

            n = 0;
            x = new double[0];
            y = new double[0];
            w = new double[0];

            n = b.n;
            x = new double[n];
            y = new double[n];
            w = new double[n];
            v = b.sy;
            for(i_=0; i_<=n-1;i_++)
            {
                x[i_] = b.x[i_];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                y[i_] = v*b.y[i_];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                w[i_] = b.w[i_];
            }
        }


        /*************************************************************************
        Rational interpolant from X/Y/W arrays

        F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))

        INPUT PARAMETERS:
            X   -   interpolation nodes, array[0..N-1]
            F   -   function values, array[0..N-1]
            W   -   barycentric weights, array[0..N-1]
            N   -   nodes count, N>0

        OUTPUT PARAMETERS:
            B   -   barycentric interpolant built from (X, Y, W)

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentricbuildxyw(double[] x,
            double[] y,
            double[] w,
            int n,
            barycentricinterpolant b,
            alglib.xparams _params)
        {
            int i_ = 0;

            alglib.ap.assert(n>0, "BarycentricBuildXYW: incorrect N!");
            
            //
            // fill X/Y/W
            //
            b.x = new double[n];
            b.y = new double[n];
            b.w = new double[n];
            for(i_=0; i_<=n-1;i_++)
            {
                b.x[i_] = x[i_];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                b.y[i_] = y[i_];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                b.w[i_] = w[i_];
            }
            b.n = n;
            
            //
            // Normalize
            //
            barycentricnormalize(b, _params);
        }


        /*************************************************************************
        Rational interpolant without poles

        The subroutine constructs the rational interpolating function without real
        poles  (see  'Barycentric rational interpolation with no  poles  and  high
        rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
        information on this subject).

        Input parameters:
            X   -   interpolation nodes, array[0..N-1].
            Y   -   function values, array[0..N-1].
            N   -   number of nodes, N>0.
            D   -   order of the interpolation scheme, 0 <= D <= N-1.
                    D<0 will cause an error.
                    D>=N it will be replaced with D=N-1.
                    if you don't know what D to choose, use small value about 3-5.

        Output parameters:
            B   -   barycentric interpolant.

        Note:
            this algorithm always succeeds and calculates the weights  with  close
            to machine precision.

          -- ALGLIB PROJECT --
             Copyright 17.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentricbuildfloaterhormann(double[] x,
            double[] y,
            int n,
            int d,
            barycentricinterpolant b,
            alglib.xparams _params)
        {
            double s0 = 0;
            double s = 0;
            double v = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int[] perm = new int[0];
            double[] wtemp = new double[0];
            double[] sortrbuf = new double[0];
            double[] sortrbuf2 = new double[0];
            int i_ = 0;

            alglib.ap.assert(n>0, "BarycentricFloaterHormann: N<=0!");
            alglib.ap.assert(d>=0, "BarycentricFloaterHormann: incorrect D!");
            
            //
            // Prepare
            //
            if( d>n-1 )
            {
                d = n-1;
            }
            b.n = n;
            
            //
            // special case: N=1
            //
            if( n==1 )
            {
                b.x = new double[n];
                b.y = new double[n];
                b.w = new double[n];
                b.x[0] = x[0];
                b.y[0] = y[0];
                b.w[0] = 1;
                barycentricnormalize(b, _params);
                return;
            }
            
            //
            // Fill X/Y
            //
            b.x = new double[n];
            b.y = new double[n];
            for(i_=0; i_<=n-1;i_++)
            {
                b.x[i_] = x[i_];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                b.y[i_] = y[i_];
            }
            tsort.tagsortfastr(ref b.x, ref b.y, ref sortrbuf, ref sortrbuf2, n, _params);
            
            //
            // Calculate Wk
            //
            b.w = new double[n];
            s0 = 1;
            for(k=1; k<=d; k++)
            {
                s0 = -s0;
            }
            for(k=0; k<=n-1; k++)
            {
                
                //
                // Wk
                //
                s = 0;
                for(i=Math.Max(k-d, 0); i<=Math.Min(k, n-1-d); i++)
                {
                    v = 1;
                    for(j=i; j<=i+d; j++)
                    {
                        if( j!=k )
                        {
                            v = v/Math.Abs(b.x[k]-b.x[j]);
                        }
                    }
                    s = s+v;
                }
                b.w[k] = s0*s;
                
                //
                // Next S0
                //
                s0 = -s0;
            }
            
            //
            // Normalize
            //
            barycentricnormalize(b, _params);
        }


        /*************************************************************************
        Copying of the barycentric interpolant (for internal use only)

        INPUT PARAMETERS:
            B   -   barycentric interpolant

        OUTPUT PARAMETERS:
            B2  -   copy(B1)

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentriccopy(barycentricinterpolant b,
            barycentricinterpolant b2,
            alglib.xparams _params)
        {
            int i_ = 0;

            b2.n = b.n;
            b2.sy = b.sy;
            b2.x = new double[b2.n];
            b2.y = new double[b2.n];
            b2.w = new double[b2.n];
            for(i_=0; i_<=b2.n-1;i_++)
            {
                b2.x[i_] = b.x[i_];
            }
            for(i_=0; i_<=b2.n-1;i_++)
            {
                b2.y[i_] = b.y[i_];
            }
            for(i_=0; i_<=b2.n-1;i_++)
            {
                b2.w[i_] = b.w[i_];
            }
        }


        /*************************************************************************
        Normalization of barycentric interpolant:
        * B.N, B.X, B.Y and B.W are initialized
        * B.SY is NOT initialized
        * Y[] is normalized, scaling coefficient is stored in B.SY
        * W[] is normalized, no scaling coefficient is stored
        * X[] is sorted

        Internal subroutine.
        *************************************************************************/
        private static void barycentricnormalize(barycentricinterpolant b,
            alglib.xparams _params)
        {
            int[] p1 = new int[0];
            int[] p2 = new int[0];
            int i = 0;
            int j = 0;
            int j2 = 0;
            double v = 0;
            int i_ = 0;

            
            //
            // Normalize task: |Y|<=1, |W|<=1, sort X[]
            //
            b.sy = 0;
            for(i=0; i<=b.n-1; i++)
            {
                b.sy = Math.Max(b.sy, Math.Abs(b.y[i]));
            }
            if( (double)(b.sy)>(double)(0) && (double)(Math.Abs(b.sy-1))>(double)(10*math.machineepsilon) )
            {
                v = 1/b.sy;
                for(i_=0; i_<=b.n-1;i_++)
                {
                    b.y[i_] = v*b.y[i_];
                }
            }
            v = 0;
            for(i=0; i<=b.n-1; i++)
            {
                v = Math.Max(v, Math.Abs(b.w[i]));
            }
            if( (double)(v)>(double)(0) && (double)(Math.Abs(v-1))>(double)(10*math.machineepsilon) )
            {
                v = 1/v;
                for(i_=0; i_<=b.n-1;i_++)
                {
                    b.w[i_] = v*b.w[i_];
                }
            }
            for(i=0; i<=b.n-2; i++)
            {
                if( (double)(b.x[i+1])<(double)(b.x[i]) )
                {
                    tsort.tagsort(ref b.x, b.n, ref p1, ref p2, _params);
                    for(j=0; j<=b.n-1; j++)
                    {
                        j2 = p2[j];
                        v = b.y[j];
                        b.y[j] = b.y[j2];
                        b.y[j2] = v;
                        v = b.w[j];
                        b.w[j] = b.w[j2];
                        b.w[j2] = v;
                    }
                    break;
                }
            }
        }


    }
    public class idw
    {
        /*************************************************************************
        Buffer  object  which  is  used  to  perform  evaluation  requests  in  the
        multithreaded mode (multiple threads working with same IDW object).

        This object should be created with idwcreatecalcbuffer().
        *************************************************************************/
        public class idwcalcbuffer : apobject
        {
            public double[] x;
            public double[] y;
            public double[] tsyw;
            public double[] tsw;
            public double[,] tsxy;
            public double[] tsdist;
            public nearestneighbor.kdtreerequestbuffer requestbuffer;
            public idwcalcbuffer()
            {
                init();
            }
            public override void init()
            {
                x = new double[0];
                y = new double[0];
                tsyw = new double[0];
                tsw = new double[0];
                tsxy = new double[0,0];
                tsdist = new double[0];
                requestbuffer = new nearestneighbor.kdtreerequestbuffer();
            }
            public override alglib.apobject make_copy()
            {
                idwcalcbuffer _result = new idwcalcbuffer();
                _result.x = (double[])x.Clone();
                _result.y = (double[])y.Clone();
                _result.tsyw = (double[])tsyw.Clone();
                _result.tsw = (double[])tsw.Clone();
                _result.tsxy = (double[,])tsxy.Clone();
                _result.tsdist = (double[])tsdist.Clone();
                _result.requestbuffer = (nearestneighbor.kdtreerequestbuffer)requestbuffer.make_copy();
                return _result;
            }
        };


        /*************************************************************************
        IDW (Inverse Distance Weighting) model object.
        *************************************************************************/
        public class idwmodel : apobject
        {
            public int nx;
            public int ny;
            public double[] globalprior;
            public int algotype;
            public int nlayers;
            public double r0;
            public double rdecay;
            public double lambda0;
            public double lambdalast;
            public double lambdadecay;
            public double shepardp;
            public nearestneighbor.kdtree tree;
            public int npoints;
            public double[] shepardxy;
            public idwcalcbuffer buffer;
            public idwmodel()
            {
                init();
            }
            public override void init()
            {
                globalprior = new double[0];
                tree = new nearestneighbor.kdtree();
                shepardxy = new double[0];
                buffer = new idwcalcbuffer();
            }
            public override alglib.apobject make_copy()
            {
                idwmodel _result = new idwmodel();
                _result.nx = nx;
                _result.ny = ny;
                _result.globalprior = (double[])globalprior.Clone();
                _result.algotype = algotype;
                _result.nlayers = nlayers;
                _result.r0 = r0;
                _result.rdecay = rdecay;
                _result.lambda0 = lambda0;
                _result.lambdalast = lambdalast;
                _result.lambdadecay = lambdadecay;
                _result.shepardp = shepardp;
                _result.tree = (nearestneighbor.kdtree)tree.make_copy();
                _result.npoints = npoints;
                _result.shepardxy = (double[])shepardxy.Clone();
                _result.buffer = (idwcalcbuffer)buffer.make_copy();
                return _result;
            }
        };


        /*************************************************************************
        Builder object used to generate IDW (Inverse Distance Weighting) model.
        *************************************************************************/
        public class idwbuilder : apobject
        {
            public int priortermtype;
            public double[] priortermval;
            public int algotype;
            public int nlayers;
            public double r0;
            public double rdecay;
            public double lambda0;
            public double lambdalast;
            public double lambdadecay;
            public double shepardp;
            public double[] xy;
            public int npoints;
            public int nx;
            public int ny;
            public double[,] tmpxy;
            public double[,] tmplayers;
            public int[] tmptags;
            public double[] tmpdist;
            public double[] tmpx;
            public double[] tmpwy;
            public double[] tmpw;
            public nearestneighbor.kdtree tmptree;
            public double[] tmpmean;
            public idwbuilder()
            {
                init();
            }
            public override void init()
            {
                priortermval = new double[0];
                xy = new double[0];
                tmpxy = new double[0,0];
                tmplayers = new double[0,0];
                tmptags = new int[0];
                tmpdist = new double[0];
                tmpx = new double[0];
                tmpwy = new double[0];
                tmpw = new double[0];
                tmptree = new nearestneighbor.kdtree();
                tmpmean = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                idwbuilder _result = new idwbuilder();
                _result.priortermtype = priortermtype;
                _result.priortermval = (double[])priortermval.Clone();
                _result.algotype = algotype;
                _result.nlayers = nlayers;
                _result.r0 = r0;
                _result.rdecay = rdecay;
                _result.lambda0 = lambda0;
                _result.lambdalast = lambdalast;
                _result.lambdadecay = lambdadecay;
                _result.shepardp = shepardp;
                _result.xy = (double[])xy.Clone();
                _result.npoints = npoints;
                _result.nx = nx;
                _result.ny = ny;
                _result.tmpxy = (double[,])tmpxy.Clone();
                _result.tmplayers = (double[,])tmplayers.Clone();
                _result.tmptags = (int[])tmptags.Clone();
                _result.tmpdist = (double[])tmpdist.Clone();
                _result.tmpx = (double[])tmpx.Clone();
                _result.tmpwy = (double[])tmpwy.Clone();
                _result.tmpw = (double[])tmpw.Clone();
                _result.tmptree = (nearestneighbor.kdtree)tmptree.make_copy();
                _result.tmpmean = (double[])tmpmean.Clone();
                return _result;
            }
        };


        /*************************************************************************
        IDW fitting report:
            rmserror        RMS error
            avgerror        average error
            maxerror        maximum error
            r2              coefficient of determination,  R-squared, 1-RSS/TSS
        *************************************************************************/
        public class idwreport : apobject
        {
            public double rmserror;
            public double avgerror;
            public double maxerror;
            public double r2;
            public idwreport()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                idwreport _result = new idwreport();
                _result.rmserror = rmserror;
                _result.avgerror = avgerror;
                _result.maxerror = maxerror;
                _result.r2 = r2;
                return _result;
            }
        };




        public const double w0 = 1.0;
        public const double meps = 1.0E-50;
        public const int defaultnlayers = 16;
        public const double defaultlambda0 = 0.3333;


        /*************************************************************************
        This function creates buffer  structure  which  can  be  used  to  perform
        parallel  IDW  model  evaluations  (with  one  IDW  model  instance  being
        used from multiple threads, as long as  different  threads  use  different
        instances of buffer).

        This buffer object can be used with  idwtscalcbuf()  function  (here  "ts"
        stands for "thread-safe", "buf" is a suffix which denotes  function  which
        reuses previously allocated output space).

        How to use it:
        * create IDW model structure or load it from file
        * call idwcreatecalcbuffer(), once per thread working with IDW model  (you
          should call this function only AFTER model initialization, see below for
          more information)
        * call idwtscalcbuf() from different threads,  with  each  thread  working
          with its own copy of buffer object.

        INPUT PARAMETERS
            S           -   IDW model

        OUTPUT PARAMETERS
            Buf         -   external buffer.
            
            
        IMPORTANT: buffer object should be used only with  IDW model object  which
                   was used to initialize buffer. Any attempt to use buffer   with
                   different object is dangerous - you may  get  memory  violation
                   error because sizes of internal arrays do not fit to dimensions
                   of the IDW structure.
                   
        IMPORTANT: you  should  call  this function only for model which was built
                   with model builder (or unserialized from file). Sizes  of  some
                   internal structures are determined only after model  is  built,
                   so buffer object created before model construction  stage  will
                   be useless (and any attempt to use it will result in exception).

          -- ALGLIB --
             Copyright 22.10.2018 by Sergey Bochkanov
        *************************************************************************/
        public static void idwcreatecalcbuffer(idwmodel s,
            idwcalcbuffer buf,
            alglib.xparams _params)
        {
            alglib.ap.assert(s.nx>=1, "IDWCreateCalcBuffer: integrity check failed");
            alglib.ap.assert(s.ny>=1, "IDWCreateCalcBuffer: integrity check failed");
            alglib.ap.assert(s.nlayers>=0, "IDWCreateCalcBuffer: integrity check failed");
            alglib.ap.assert(s.algotype>=0, "IDWCreateCalcBuffer: integrity check failed");
            if( s.nlayers>=1 && s.algotype!=0 )
            {
                nearestneighbor.kdtreecreaterequestbuffer(s.tree, buf.requestbuffer, _params);
            }
            apserv.rvectorsetlengthatleast(ref buf.x, s.nx, _params);
            apserv.rvectorsetlengthatleast(ref buf.y, s.ny, _params);
            apserv.rvectorsetlengthatleast(ref buf.tsyw, s.ny*Math.Max(s.nlayers, 1), _params);
            apserv.rvectorsetlengthatleast(ref buf.tsw, Math.Max(s.nlayers, 1), _params);
        }


        /*************************************************************************
        This subroutine creates builder object used  to  generate IDW  model  from
        irregularly sampled (scattered) dataset.  Multidimensional  scalar/vector-
        -valued are supported.

        Builder object is used to fit model to data as follows:
        * builder object is created with idwbuildercreate() function
        * dataset is added with idwbuildersetpoints() function
        * one of the modern IDW algorithms is chosen with either:
          * idwbuildersetalgomstab()            - Multilayer STABilized algorithm (interpolation)
          Alternatively, one of the textbook algorithms can be chosen (not recommended):
          * idwbuildersetalgotextbookshepard()  - textbook Shepard algorithm
          * idwbuildersetalgotextbookmodshepard()-textbook modified Shepard algorithm
        * finally, model construction is performed with idwfit() function.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        INPUT PARAMETERS:
            NX  -   dimensionality of the argument, NX>=1
            NY  -   dimensionality of the function being modeled, NY>=1;
                    NY=1 corresponds to classic scalar function, NY>=1 corresponds
                    to vector-valued function.
            
        OUTPUT PARAMETERS:
            State-  builder object

          -- ALGLIB PROJECT --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildercreate(int nx,
            int ny,
            idwbuilder state,
            alglib.xparams _params)
        {
            alglib.ap.assert(nx>=1, "IDWBuilderCreate: NX<=0");
            alglib.ap.assert(ny>=1, "IDWBuilderCreate: NY<=0");
            
            //
            // We choose reasonable defaults for the algorithm:
            // * MSTAB algorithm
            // * 12 layers
            // * default radius
            // * default Lambda0
            //
            state.algotype = 2;
            state.priortermtype = 2;
            apserv.rvectorsetlengthatleast(ref state.priortermval, ny, _params);
            state.nlayers = defaultnlayers;
            state.r0 = 0;
            state.rdecay = 0.5;
            state.lambda0 = defaultlambda0;
            state.lambdalast = 0;
            state.lambdadecay = 1.0;
            
            //
            // Other parameters, not used but initialized
            //
            state.shepardp = 0;
            
            //
            // Initial dataset is empty
            //
            state.npoints = 0;
            state.nx = nx;
            state.ny = ny;
        }


        /*************************************************************************
        This function changes number of layers used by IDW-MSTAB algorithm.

        The more layers you have, the finer details can  be  reproduced  with  IDW
        model. The less layers you have, the less memory and CPU time is  consumed
        by the model.

        Memory consumption grows linearly with layers count,  running  time  grows
        sub-linearly.

        The default number of layers is 16, which allows you to reproduce  details
        at distance down to SRad/65536. You will rarely need to change it.

        INPUT PARAMETERS:
            State   -   builder object
            NLayers -   NLayers>=1, the number of layers used by the model.

          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildersetnlayers(idwbuilder state,
            int nlayers,
            alglib.xparams _params)
        {
            alglib.ap.assert(nlayers>=1, "IDWBuilderSetNLayers: N<1");
            state.nlayers = nlayers;
        }


        /*************************************************************************
        This function adds dataset to the builder object.

        This function overrides results of the previous calls, i.e. multiple calls
        of this function will result in only the last set being added.

        INPUT PARAMETERS:
            State   -   builder object
            XY      -   points, array[N,NX+NY]. One row  corresponds to  one point
                        in the dataset. First NX elements  are  coordinates,  next
                        NY elements are function values. Array may  be larger than 
                        specified, in  this  case  only leading [N,NX+NY] elements 
                        will be used.
            N       -   number of points in the dataset, N>=0.

          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildersetpoints(idwbuilder state,
            double[,] xy,
            int n,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int ew = 0;

            alglib.ap.assert(n>=0, "IDWBuilderSetPoints: N<0");
            alglib.ap.assert(alglib.ap.rows(xy)>=n, "IDWBuilderSetPoints: Rows(XY)<N");
            alglib.ap.assert(n==0 || alglib.ap.cols(xy)>=state.nx+state.ny, "IDWBuilderSetPoints: Cols(XY)<NX+NY");
            alglib.ap.assert(apserv.apservisfinitematrix(xy, n, state.nx+state.ny, _params), "IDWBuilderSetPoints: XY contains infinite or NaN values!");
            state.npoints = n;
            ew = state.nx+state.ny;
            apserv.rvectorsetlengthatleast(ref state.xy, n*ew, _params);
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=ew-1; j++)
                {
                    state.xy[i*ew+j] = xy[i,j];
                }
            }
        }


        /*************************************************************************
        This function sets IDW model  construction  algorithm  to  the  Multilayer
        Stabilized IDW method (IDW-MSTAB), a  latest  incarnation  of  the inverse
        distance weighting interpolation which fixes shortcomings of  the original
        and modified Shepard's variants.

        The distinctive features of IDW-MSTAB are:
        1) exact interpolation  is  pursued  (as  opposed  to  fitting  and  noise
           suppression)
        2) improved robustness when compared with that of other algorithms:
           * MSTAB shows almost no strange  fitting  artifacts  like  ripples  and
             sharp spikes (unlike N-dimensional splines and HRBFs)
           * MSTAB does not return function values far from the  interval  spanned
             by the dataset; say, if all your points have |f|<=1, you  can be sure
             that model value won't deviate too much from [-1,+1]
        3) good model construction time competing with that of HRBFs  and  bicubic
           splines
        4) ability to work with any number of dimensions, starting from NX=1

        The drawbacks of IDW-MSTAB (and all IDW algorithms in general) are:
        1) dependence of the model evaluation time on the search radius
        2) bad extrapolation properties, models built by this method  are  usually
           conservative in their predictions

        Thus, IDW-MSTAB is  a  good  "default"  option  if  you  want  to  perform
        scattered multidimensional interpolation. Although it has  its  drawbacks,
        it is easy to use and robust, which makes it a good first step.


        INPUT PARAMETERS:
            State   -   builder object
            SRad    -   initial search radius, SRad>0 is required. A model  value
                        is obtained by "smart" averaging  of  the  dataset  points
                        within search radius.

        NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
                datasets with non-distinct points. In case non-distinct points are
                found, an average value for this point will be calculated.
                
        NOTE 2: the memory requirements for model storage are O(NPoints*NLayers).
                The model construction needs twice as much memory as model storage.
          
        NOTE 3: by default 16 IDW layers are built which is enough for most cases.
                You can change this parameter with idwbuildersetnlayers()  method.
                Larger values may be necessary if you need to reproduce  extrafine
                details at distances smaller than SRad/65536.  Smaller value   may
                be necessary if you have to save memory and  computing  time,  and
                ready to sacrifice some model quality.


        ALGORITHM DESCRIPTION
          
        ALGLIB implementation of IDW is somewhat similar to the modified Shepard's
        method (one with search radius R) but overcomes several of its  drawbacks,
        namely:
        1) a tendency to show stepwise behavior for uniform datasets
        2) a tendency to show terrible interpolation properties for highly
           nonuniform datasets which often arise in geospatial tasks
          (function values are densely sampled across multiple separated
          "tracks")

        IDW-MSTAB method performs several passes over dataset and builds a sequence
        of progressively refined IDW models  (layers),  which starts from one with
        largest search radius SRad  and continues to smaller  search  radii  until
        required number of  layers  is  built.  Highest  layers  reproduce  global
        behavior of the target function at larger distances  whilst  lower  layers
        reproduce fine details at smaller distances.

        Each layer is an IDW model built with following modifications:
        * weights go to zero when distance approach to the current search radius
        * an additional regularizing term is added to the distance: w=1/(d^2+lambda)
        * an additional fictional term with unit weight and zero function value is
          added in order to promote continuity  properties  at  the  isolated  and
          boundary points
          
        By default, 16 layers is built, which is enough for most  cases.  You  can
        change this parameter with idwbuildersetnlayers() method.
           
          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildersetalgomstab(idwbuilder state,
            double srad,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(srad), "IDWBuilderSetAlgoMSTAB: SRad is not finite");
            alglib.ap.assert((double)(srad)>(double)(0), "IDWBuilderSetAlgoMSTAB: SRad<=0");
            
            //
            // Set algorithm
            //
            state.algotype = 2;
            
            //
            // Set options
            //
            state.r0 = srad;
            state.rdecay = 0.5;
            state.lambda0 = defaultlambda0;
            state.lambdalast = 0;
            state.lambdadecay = 1.0;
        }


        /*************************************************************************
        This function sets  IDW  model  construction  algorithm  to  the  textbook
        Shepard's algorithm with custom (user-specified) power parameter.

        IMPORTANT: we do NOT recommend using textbook IDW algorithms because  they
                   have terrible interpolation properties. Use MSTAB in all cases.

        INPUT PARAMETERS:
            State   -   builder object
            P       -   power parameter, P>0; good value to start with is 2.0

        NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
                datasets with non-distinct points. In case non-distinct points are
                found, an average value for this point will be calculated.
           
          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildersetalgotextbookshepard(idwbuilder state,
            double p,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(p), "IDWBuilderSetAlgoShepard: P is not finite");
            alglib.ap.assert((double)(p)>(double)(0), "IDWBuilderSetAlgoShepard: P<=0");
            
            //
            // Set algorithm and options
            //
            state.algotype = 0;
            state.shepardp = p;
        }


        /*************************************************************************
        This function sets  IDW  model  construction  algorithm  to the 'textbook'
        modified Shepard's algorithm with user-specified search radius.

        IMPORTANT: we do NOT recommend using textbook IDW algorithms because  they
                   have terrible interpolation properties. Use MSTAB in all cases.

        INPUT PARAMETERS:
            State   -   builder object
            R       -   search radius

        NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
                datasets with non-distinct points. In case non-distinct points are
                found, an average value for this point will be calculated.
           
          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildersetalgotextbookmodshepard(idwbuilder state,
            double r,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(r), "IDWBuilderSetAlgoModShepard: R is not finite");
            alglib.ap.assert((double)(r)>(double)(0), "IDWBuilderSetAlgoModShepard: R<=0");
            
            //
            // Set algorithm and options
            //
            state.algotype = 1;
            state.r0 = r;
        }


        /*************************************************************************
        This function sets prior term (model value at infinity) as  user-specified
        value.

        INPUT PARAMETERS:
            S       -   spline builder
            V       -   value for user-defined prior
            
        NOTE: for vector-valued models all components of the prior are set to same
              user-specified value

          -- ALGLIB --
             Copyright 29.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildersetuserterm(idwbuilder state,
            double v,
            alglib.xparams _params)
        {
            int j = 0;

            alglib.ap.assert(math.isfinite(v), "IDWBuilderSetUserTerm: infinite/NAN value passed");
            state.priortermtype = 0;
            for(j=0; j<=state.ny-1; j++)
            {
                state.priortermval[j] = v;
            }
        }


        /*************************************************************************
        This function sets constant prior term (model value at infinity).

        Constant prior term is determined as mean value over dataset.

        INPUT PARAMETERS:
            S       -   spline builder

          -- ALGLIB --
             Copyright 29.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildersetconstterm(idwbuilder state,
            alglib.xparams _params)
        {
            state.priortermtype = 2;
        }


        /*************************************************************************
        This function sets zero prior term (model value at infinity).

        INPUT PARAMETERS:
            S       -   spline builder

          -- ALGLIB --
             Copyright 29.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwbuildersetzeroterm(idwbuilder state,
            alglib.xparams _params)
        {
            state.priortermtype = 3;
        }


        /*************************************************************************
        IDW interpolation: scalar target, 1-dimensional argument

        NOTE: this function modifies internal temporaries of the  IDW  model, thus
              IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
              evaluation from the multiple threads, use idwtscalcbuf()  with  per-
              thread buffer object. 
              
        INPUT PARAMETERS:
            S   -   IDW interpolant built with IDW builder
            X0  -   argument value

        Result:
            IDW interpolant S(X0)

          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static double idwcalc1(idwmodel s,
            double x0,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(s.nx==1, "IDWCalc1: S.NX<>1");
            alglib.ap.assert(s.ny==1, "IDWCalc1: S.NY<>1");
            alglib.ap.assert(math.isfinite(x0), "IDWCalc1: X0 is INF or NAN");
            s.buffer.x[0] = x0;
            idwtscalcbuf(s, s.buffer, s.buffer.x, ref s.buffer.y, _params);
            result = s.buffer.y[0];
            return result;
        }


        /*************************************************************************
        IDW interpolation: scalar target, 2-dimensional argument

        NOTE: this function modifies internal temporaries of the  IDW  model, thus
              IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
              evaluation from the multiple threads, use idwtscalcbuf()  with  per-
              thread buffer object. 
              
        INPUT PARAMETERS:
            S       -   IDW interpolant built with IDW builder
            X0, X1  -   argument value

        Result:
            IDW interpolant S(X0,X1)

          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static double idwcalc2(idwmodel s,
            double x0,
            double x1,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(s.nx==2, "IDWCalc2: S.NX<>2");
            alglib.ap.assert(s.ny==1, "IDWCalc2: S.NY<>1");
            alglib.ap.assert(math.isfinite(x0), "IDWCalc2: X0 is INF or NAN");
            alglib.ap.assert(math.isfinite(x1), "IDWCalc2: X1 is INF or NAN");
            s.buffer.x[0] = x0;
            s.buffer.x[1] = x1;
            idwtscalcbuf(s, s.buffer, s.buffer.x, ref s.buffer.y, _params);
            result = s.buffer.y[0];
            return result;
        }


        /*************************************************************************
        IDW interpolation: scalar target, 3-dimensional argument

        NOTE: this function modifies internal temporaries of the  IDW  model, thus
              IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
              evaluation from the multiple threads, use idwtscalcbuf()  with  per-
              thread buffer object. 

        INPUT PARAMETERS:
            S       -   IDW interpolant built with IDW builder
            X0,X1,X2-   argument value

        Result:
            IDW interpolant S(X0,X1,X2)

          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static double idwcalc3(idwmodel s,
            double x0,
            double x1,
            double x2,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(s.nx==3, "IDWCalc3: S.NX<>3");
            alglib.ap.assert(s.ny==1, "IDWCalc3: S.NY<>1");
            alglib.ap.assert(math.isfinite(x0), "IDWCalc3: X0 is INF or NAN");
            alglib.ap.assert(math.isfinite(x1), "IDWCalc3: X1 is INF or NAN");
            alglib.ap.assert(math.isfinite(x2), "IDWCalc3: X2 is INF or NAN");
            s.buffer.x[0] = x0;
            s.buffer.x[1] = x1;
            s.buffer.x[2] = x2;
            idwtscalcbuf(s, s.buffer, s.buffer.x, ref s.buffer.y, _params);
            result = s.buffer.y[0];
            return result;
        }


        /*************************************************************************
        This function calculates values of the IDW model at the given point.

        This is general function which can be used for arbitrary NX (dimension  of 
        the space of arguments) and NY (dimension of the function itself). However
        when  you  have  NY=1  you  may  find more convenient to  use  idwcalc1(),
        idwcalc2() or idwcalc3().

        NOTE: this function modifies internal temporaries of the  IDW  model, thus
              IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
              evaluation from the multiple threads, use idwtscalcbuf()  with  per-
              thread buffer object. 
              
        INPUT PARAMETERS:
            S       -   IDW model
            X       -   coordinates, array[NX]. X may have more than NX  elements,
                        in this case only leading NX will be used.

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is out-parameter and will  be
                        reallocated after call to this function. In case you  want
                        to reuse previously allocated Y, you may use idwcalcbuf(),
                        which reallocates Y only when it is too small.

          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwcalc(idwmodel s,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            y = new double[0];

            idwtscalcbuf(s, s.buffer, x, ref y, _params);
        }


        /*************************************************************************
        This function calculates values of the IDW model at the given point.

        Same as idwcalc(), but does not reallocate Y when in is large enough to 
        store function values.

        NOTE: this function modifies internal temporaries of the  IDW  model, thus
              IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
              evaluation from the multiple threads, use idwtscalcbuf()  with  per-
              thread buffer object. 
              
        INPUT PARAMETERS:
            S       -   IDW model
            X       -   coordinates, array[NX]. X may have more than NX  elements,
                        in this case only leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwcalcbuf(idwmodel s,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            idwtscalcbuf(s, s.buffer, x, ref y, _params);
        }


        /*************************************************************************
        This function calculates values of the IDW model at the given point, using
        external  buffer  object  (internal  temporaries  of  IDW  model  are  not
        modified).

        This function allows to use same IDW model object  in  different  threads,
        assuming  that  different   threads  use different instances of the buffer
        structure.

        INPUT PARAMETERS:
            S       -   IDW model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  IDW
                        model with idwcreatecalcbuffer().
            X       -   coordinates, array[NX]. X may have more than NX  elements,
                        in this case only  leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void idwtscalcbuf(idwmodel s,
            idwcalcbuffer buf,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int ew = 0;
            int k = 0;
            int layeridx = 0;
            int nx = 0;
            int ny = 0;
            int npoints = 0;
            double v = 0;
            double vv = 0;
            double f = 0;
            double p = 0;
            double r = 0;
            double eps = 0;
            double lambdacur = 0;
            double lambdadecay = 0;
            double invrdecay = 0;
            double invr = 0;
            bool fastcalcpossible = new bool();
            double wf0 = 0;
            double ws0 = 0;
            double wf1 = 0;
            double ws1 = 0;

            nx = s.nx;
            ny = s.ny;
            alglib.ap.assert(alglib.ap.len(x)>=nx, "IDWTsCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, nx, _params), "IDWTsCalcBuf: X contains infinite or NaN values");
            
            //
            // Avoid spurious compiler warnings
            //
            wf0 = 0;
            ws0 = 0;
            wf1 = 0;
            ws1 = 0;
            
            //
            // Allocate output
            //
            if( alglib.ap.len(y)<ny )
            {
                y = new double[ny];
            }
            
            //
            // Quick exit for NLayers=0 (no dataset)
            //
            if( s.nlayers==0 )
            {
                for(j=0; j<=ny-1; j++)
                {
                    y[j] = s.globalprior[j];
                }
                return;
            }
            
            //
            // Textbook Shepard's method
            //
            if( s.algotype==0 )
            {
                npoints = s.npoints;
                alglib.ap.assert(npoints>0, "IDWTsCalcBuf: integrity check failed");
                eps = 1.0E-50;
                ew = nx+ny;
                p = s.shepardp;
                for(j=0; j<=ny-1; j++)
                {
                    y[j] = 0;
                    buf.tsyw[j] = eps;
                }
                for(i=0; i<=npoints-1; i++)
                {
                    
                    //
                    // Compute squared distance
                    //
                    v = 0;
                    for(j=0; j<=nx-1; j++)
                    {
                        vv = s.shepardxy[i*ew+j]-x[j];
                        v = v+vv*vv;
                    }
                    
                    //
                    // Compute weight (with small regularizing addition)
                    //
                    v = Math.Pow(v, p*0.5);
                    v = 1/(eps+v);
                    
                    //
                    // Accumulate
                    //
                    for(j=0; j<=ny-1; j++)
                    {
                        y[j] = y[j]+v*s.shepardxy[i*ew+nx+j];
                        buf.tsyw[j] = buf.tsyw[j]+v;
                    }
                }
                for(j=0; j<=ny-1; j++)
                {
                    y[j] = y[j]/buf.tsyw[j]+s.globalprior[j];
                }
                return;
            }
            
            //
            // Textbook modified Shepard's method
            //
            if( s.algotype==1 )
            {
                eps = 1.0E-50;
                r = s.r0;
                for(j=0; j<=ny-1; j++)
                {
                    y[j] = 0;
                    buf.tsyw[j] = eps;
                }
                k = nearestneighbor.kdtreetsqueryrnn(s.tree, buf.requestbuffer, x, r, true, _params);
                nearestneighbor.kdtreetsqueryresultsxy(s.tree, buf.requestbuffer, ref buf.tsxy, _params);
                nearestneighbor.kdtreetsqueryresultsdistances(s.tree, buf.requestbuffer, ref buf.tsdist, _params);
                for(i=0; i<=k-1; i++)
                {
                    v = buf.tsdist[i];
                    v = (r-v)/(r*v+eps);
                    v = v*v;
                    for(j=0; j<=ny-1; j++)
                    {
                        y[j] = y[j]+v*buf.tsxy[i,nx+j];
                        buf.tsyw[j] = buf.tsyw[j]+v;
                    }
                }
                for(j=0; j<=ny-1; j++)
                {
                    y[j] = y[j]/buf.tsyw[j]+s.globalprior[j];
                }
                return;
            }
            
            //
            // MSTAB
            //
            if( s.algotype==2 )
            {
                alglib.ap.assert((double)(w0)==(double)(1), "IDWTsCalcBuf: unexpected W0, integrity check failed");
                invrdecay = 1/s.rdecay;
                invr = 1/s.r0;
                lambdadecay = s.lambdadecay;
                fastcalcpossible = (ny==1 && s.nlayers>=3) && (double)(lambdadecay)==(double)(1);
                if( fastcalcpossible )
                {
                    
                    //
                    // Important special case, NY=1, no lambda-decay,
                    // we can perform optimized fast evaluation
                    //
                    wf0 = 0;
                    ws0 = w0;
                    wf1 = 0;
                    ws1 = w0;
                    for(j=0; j<=s.nlayers-1; j++)
                    {
                        buf.tsyw[j] = 0;
                        buf.tsw[j] = w0;
                    }
                }
                else
                {
                    
                    //
                    // Setup variables for generic evaluation path
                    //
                    for(j=0; j<=ny*s.nlayers-1; j++)
                    {
                        buf.tsyw[j] = 0;
                    }
                    for(j=0; j<=s.nlayers-1; j++)
                    {
                        buf.tsw[j] = w0;
                    }
                }
                k = nearestneighbor.kdtreetsqueryrnnu(s.tree, buf.requestbuffer, x, s.r0, true, _params);
                nearestneighbor.kdtreetsqueryresultsxy(s.tree, buf.requestbuffer, ref buf.tsxy, _params);
                nearestneighbor.kdtreetsqueryresultsdistances(s.tree, buf.requestbuffer, ref buf.tsdist, _params);
                for(i=0; i<=k-1; i++)
                {
                    lambdacur = s.lambda0;
                    vv = buf.tsdist[i]*invr;
                    if( fastcalcpossible )
                    {
                        
                        //
                        // Important special case, fast evaluation possible
                        //
                        v = vv*vv;
                        v = (1-v)*(1-v)/(v+lambdacur);
                        f = buf.tsxy[i,nx+0];
                        wf0 = wf0+v*f;
                        ws0 = ws0+v;
                        vv = vv*invrdecay;
                        if( vv>=1.0 )
                        {
                            continue;
                        }
                        v = vv*vv;
                        v = (1-v)*(1-v)/(v+lambdacur);
                        f = buf.tsxy[i,nx+1];
                        wf1 = wf1+v*f;
                        ws1 = ws1+v;
                        vv = vv*invrdecay;
                        if( vv>=1.0 )
                        {
                            continue;
                        }
                        for(layeridx=2; layeridx<=s.nlayers-1; layeridx++)
                        {
                            if( layeridx==s.nlayers-1 )
                            {
                                lambdacur = s.lambdalast;
                            }
                            v = vv*vv;
                            v = (1-v)*(1-v)/(v+lambdacur);
                            f = buf.tsxy[i,nx+layeridx];
                            buf.tsyw[layeridx] = buf.tsyw[layeridx]+v*f;
                            buf.tsw[layeridx] = buf.tsw[layeridx]+v;
                            vv = vv*invrdecay;
                            if( vv>=1.0 )
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        
                        //
                        // General case
                        //
                        for(layeridx=0; layeridx<=s.nlayers-1; layeridx++)
                        {
                            if( layeridx==s.nlayers-1 )
                            {
                                lambdacur = s.lambdalast;
                            }
                            if( vv>=1.0 )
                            {
                                break;
                            }
                            v = vv*vv;
                            v = (1-v)*(1-v)/(v+lambdacur);
                            for(j=0; j<=ny-1; j++)
                            {
                                f = buf.tsxy[i,nx+layeridx*ny+j];
                                buf.tsyw[layeridx*ny+j] = buf.tsyw[layeridx*ny+j]+v*f;
                            }
                            buf.tsw[layeridx] = buf.tsw[layeridx]+v;
                            lambdacur = lambdacur*lambdadecay;
                            vv = vv*invrdecay;
                        }
                    }
                }
                if( fastcalcpossible )
                {
                    
                    //
                    // Important special case, finalize evaluations
                    //
                    buf.tsyw[0] = wf0;
                    buf.tsw[0] = ws0;
                    buf.tsyw[1] = wf1;
                    buf.tsw[1] = ws1;
                }
                for(j=0; j<=ny-1; j++)
                {
                    y[j] = s.globalprior[j];
                }
                for(layeridx=0; layeridx<=s.nlayers-1; layeridx++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        y[j] = y[j]+buf.tsyw[layeridx*ny+j]/buf.tsw[layeridx];
                    }
                }
                return;
            }
            
            //
            //
            //
            alglib.ap.assert(false, "IDWTsCalcBuf: unexpected AlgoType");
        }


        /*************************************************************************
        This function fits IDW model to the dataset using current IDW construction
        algorithm. A model being built and fitting report are returned.

        INPUT PARAMETERS:
            State   -   builder object

        OUTPUT PARAMETERS:
            Model   -   an IDW model built with current algorithm
            Rep     -   model fitting report, fields of this structure contain
                        information about average fitting errors.
                        
        NOTE: although IDW-MSTAB algorithm is an  interpolation  method,  i.e.  it
              tries to fit the model exactly, it can  handle  datasets  with  non-
              distinct points which can not be fit exactly; in such  cases  least-
              squares fitting is performed.
           
          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwfit(idwbuilder state,
            idwmodel model,
            idwreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            int i0 = 0;
            int j = 0;
            int k = 0;
            int layeridx = 0;
            int srcidx = 0;
            double v = 0;
            double vv = 0;
            int npoints = 0;
            int nx = 0;
            int ny = 0;
            double rcur = 0;
            double lambdacur = 0;
            double rss = 0;
            double tss = 0;

            nx = state.nx;
            ny = state.ny;
            npoints = state.npoints;
            
            //
            // Clear report fields
            //
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.maxerror = 0;
            rep.r2 = 1.0;
            
            //
            // Quick exit for empty dataset
            //
            if( state.npoints==0 )
            {
                model.nx = nx;
                model.ny = ny;
                model.globalprior = new double[ny];
                for(i=0; i<=ny-1; i++)
                {
                    model.globalprior[i] = 0;
                }
                model.algotype = 0;
                model.nlayers = 0;
                model.r0 = 1;
                model.rdecay = 0.5;
                model.lambda0 = 0;
                model.lambdalast = 0;
                model.lambdadecay = 1;
                model.shepardp = 2;
                model.npoints = 0;
                idwcreatecalcbuffer(model, model.buffer, _params);
                return;
            }
            
            //
            // Compute temporaries which will be required later:
            // * global mean
            //
            alglib.ap.assert(state.npoints>0, "IDWFit: integrity check failed");
            apserv.rvectorsetlengthatleast(ref state.tmpmean, ny, _params);
            for(j=0; j<=ny-1; j++)
            {
                state.tmpmean[j] = 0;
            }
            for(i=0; i<=npoints-1; i++)
            {
                for(j=0; j<=ny-1; j++)
                {
                    state.tmpmean[j] = state.tmpmean[j]+state.xy[i*(nx+ny)+nx+j];
                }
            }
            for(j=0; j<=ny-1; j++)
            {
                state.tmpmean[j] = state.tmpmean[j]/npoints;
            }
            
            //
            // Compute global prior
            //
            // NOTE: for original Shepard's method it is always mean value
            //
            apserv.rvectorsetlengthatleast(ref model.globalprior, ny, _params);
            for(j=0; j<=ny-1; j++)
            {
                model.globalprior[j] = state.tmpmean[j];
            }
            if( state.algotype!=0 )
            {
                
                //
                // Algorithm is set to one of the "advanced" versions with search
                // radius which can handle non-mean prior term
                //
                if( state.priortermtype==0 )
                {
                    
                    //
                    // User-specified prior
                    //
                    for(j=0; j<=ny-1; j++)
                    {
                        model.globalprior[j] = state.priortermval[j];
                    }
                }
                if( state.priortermtype==3 )
                {
                    
                    //
                    // Zero prior
                    //
                    for(j=0; j<=ny-1; j++)
                    {
                        model.globalprior[j] = 0;
                    }
                }
            }
            
            //
            // Textbook Shepard
            //
            if( state.algotype==0 )
            {
                
                //
                // Initialize model
                //
                model.algotype = 0;
                model.nx = nx;
                model.ny = ny;
                model.nlayers = 1;
                model.r0 = 1;
                model.rdecay = 0.5;
                model.lambda0 = 0;
                model.lambdalast = 0;
                model.lambdadecay = 1;
                model.shepardp = state.shepardp;
                
                //
                // Copy dataset
                //
                apserv.rvectorsetlengthatleast(ref model.shepardxy, npoints*(nx+ny), _params);
                for(i=0; i<=npoints-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        model.shepardxy[i*(nx+ny)+j] = state.xy[i*(nx+ny)+j];
                    }
                    for(j=0; j<=ny-1; j++)
                    {
                        model.shepardxy[i*(nx+ny)+nx+j] = state.xy[i*(nx+ny)+nx+j]-model.globalprior[j];
                    }
                }
                model.npoints = npoints;
                
                //
                // Prepare internal buffer
                // Evaluate report fields
                //
                idwcreatecalcbuffer(model, model.buffer, _params);
                errormetricsviacalc(state, model, rep, _params);
                return;
            }
            
            //
            // Textbook modified Shepard's method
            //
            if( state.algotype==1 )
            {
                
                //
                // Initialize model
                //
                model.algotype = 1;
                model.nx = nx;
                model.ny = ny;
                model.nlayers = 1;
                model.r0 = state.r0;
                model.rdecay = 1;
                model.lambda0 = 0;
                model.lambdalast = 0;
                model.lambdadecay = 1;
                model.shepardp = 0;
                
                //
                // Build kd-tree search structure
                //
                apserv.rmatrixsetlengthatleast(ref state.tmpxy, npoints, nx+ny, _params);
                for(i=0; i<=npoints-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        state.tmpxy[i,j] = state.xy[i*(nx+ny)+j];
                    }
                    for(j=0; j<=ny-1; j++)
                    {
                        state.tmpxy[i,nx+j] = state.xy[i*(nx+ny)+nx+j]-model.globalprior[j];
                    }
                }
                nearestneighbor.kdtreebuild(state.tmpxy, npoints, nx, ny, 2, model.tree, _params);
                
                //
                // Prepare internal buffer
                // Evaluate report fields
                //
                idwcreatecalcbuffer(model, model.buffer, _params);
                errormetricsviacalc(state, model, rep, _params);
                return;
            }
            
            //
            // MSTAB algorithm
            //
            if( state.algotype==2 )
            {
                alglib.ap.assert(state.nlayers>=1, "IDWFit: integrity check failed");
                
                //
                // Initialize model
                //
                model.algotype = 2;
                model.nx = nx;
                model.ny = ny;
                model.nlayers = state.nlayers;
                model.r0 = state.r0;
                model.rdecay = 0.5;
                model.lambda0 = state.lambda0;
                model.lambdadecay = 1.0;
                model.lambdalast = meps;
                model.shepardp = 0;
                
                //
                // Build kd-tree search structure,
                // prepare input residuals for the first layer of the model
                //
                apserv.rmatrixsetlengthatleast(ref state.tmpxy, npoints, nx, _params);
                apserv.rmatrixsetlengthatleast(ref state.tmplayers, npoints, nx+ny*(state.nlayers+1), _params);
                apserv.ivectorsetlengthatleast(ref state.tmptags, npoints, _params);
                for(i=0; i<=npoints-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        v = state.xy[i*(nx+ny)+j];
                        state.tmpxy[i,j] = v;
                        state.tmplayers[i,j] = v;
                    }
                    state.tmptags[i] = i;
                    for(j=0; j<=ny-1; j++)
                    {
                        state.tmplayers[i,nx+j] = state.xy[i*(nx+ny)+nx+j]-model.globalprior[j];
                    }
                }
                nearestneighbor.kdtreebuildtagged(state.tmpxy, state.tmptags, npoints, nx, 0, 2, state.tmptree, _params);
                
                //
                // Iteratively build layer by layer
                //
                apserv.rvectorsetlengthatleast(ref state.tmpx, nx, _params);
                apserv.rvectorsetlengthatleast(ref state.tmpwy, ny, _params);
                apserv.rvectorsetlengthatleast(ref state.tmpw, ny, _params);
                for(layeridx=0; layeridx<=state.nlayers-1; layeridx++)
                {
                    
                    //
                    // Determine layer metrics
                    //
                    rcur = model.r0*Math.Pow(model.rdecay, layeridx);
                    lambdacur = model.lambda0*Math.Pow(model.lambdadecay, layeridx);
                    if( layeridx==state.nlayers-1 )
                    {
                        lambdacur = model.lambdalast;
                    }
                    
                    //
                    // For each point compute residual from fitting with current layer
                    //
                    for(i=0; i<=npoints-1; i++)
                    {
                        for(j=0; j<=nx-1; j++)
                        {
                            state.tmpx[j] = state.tmplayers[i,j];
                        }
                        k = nearestneighbor.kdtreequeryrnn(state.tmptree, state.tmpx, rcur, true, _params);
                        nearestneighbor.kdtreequeryresultstags(state.tmptree, ref state.tmptags, _params);
                        nearestneighbor.kdtreequeryresultsdistances(state.tmptree, ref state.tmpdist, _params);
                        for(j=0; j<=ny-1; j++)
                        {
                            state.tmpwy[j] = 0;
                            state.tmpw[j] = w0;
                        }
                        for(i0=0; i0<=k-1; i0++)
                        {
                            vv = state.tmpdist[i0]/rcur;
                            vv = vv*vv;
                            v = (1-vv)*(1-vv)/(vv+lambdacur);
                            srcidx = state.tmptags[i0];
                            for(j=0; j<=ny-1; j++)
                            {
                                state.tmpwy[j] = state.tmpwy[j]+v*state.tmplayers[srcidx,nx+layeridx*ny+j];
                                state.tmpw[j] = state.tmpw[j]+v;
                            }
                        }
                        for(j=0; j<=ny-1; j++)
                        {
                            v = state.tmplayers[i,nx+layeridx*ny+j];
                            state.tmplayers[i,nx+(layeridx+1)*ny+j] = v-state.tmpwy[j]/state.tmpw[j];
                        }
                    }
                }
                nearestneighbor.kdtreebuild(state.tmplayers, npoints, nx, ny*state.nlayers, 2, model.tree, _params);
                
                //
                // Evaluate report fields
                //
                rep.rmserror = 0;
                rep.avgerror = 0;
                rep.maxerror = 0;
                rss = 0;
                tss = 0;
                for(i=0; i<=npoints-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        v = Math.Abs(state.tmplayers[i,nx+state.nlayers*ny+j]);
                        rep.rmserror = rep.rmserror+v*v;
                        rep.avgerror = rep.avgerror+v;
                        rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v));
                        rss = rss+v*v;
                        tss = tss+math.sqr(state.xy[i*(nx+ny)+nx+j]-state.tmpmean[j]);
                    }
                }
                rep.rmserror = Math.Sqrt(rep.rmserror/(npoints*ny));
                rep.avgerror = rep.avgerror/(npoints*ny);
                rep.r2 = 1.0-rss/apserv.coalesce(tss, 1.0, _params);
                
                //
                // Prepare internal buffer
                //
                idwcreatecalcbuffer(model, model.buffer, _params);
                return;
            }
            
            //
            // Unknown algorithm
            //
            alglib.ap.assert(false, "IDWFit: integrity check failed, unexpected algorithm");
        }


        /*************************************************************************
        Serializer: allocation

          -- ALGLIB --
             Copyright 28.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwalloc(alglib.serializer s,
            idwmodel model,
            alglib.xparams _params)
        {
            bool processed = new bool();

            
            //
            // Header
            //
            s.alloc_entry();
            
            //
            // Algorithm type and fields which are set for all algorithms
            //
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            apserv.allocrealarray(s, model.globalprior, -1, _params);
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            
            //
            // Algorithm-specific fields
            //
            processed = false;
            if( model.algotype==0 )
            {
                s.alloc_entry();
                apserv.allocrealarray(s, model.shepardxy, -1, _params);
                processed = true;
            }
            if( model.algotype>0 )
            {
                nearestneighbor.kdtreealloc(s, model.tree, _params);
                processed = true;
            }
            alglib.ap.assert(processed, "IDW: integrity check failed during serialization");
        }


        /*************************************************************************
        Serializer: serialization

          -- ALGLIB --
             Copyright 28.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwserialize(alglib.serializer s,
            idwmodel model,
            alglib.xparams _params)
        {
            bool processed = new bool();

            
            //
            // Header
            //
            s.serialize_int(scodes.getidwserializationcode(_params));
            
            //
            // Algorithm type and fields which are set for all algorithms
            //
            s.serialize_int(model.algotype);
            s.serialize_int(model.nx);
            s.serialize_int(model.ny);
            apserv.serializerealarray(s, model.globalprior, -1, _params);
            s.serialize_int(model.nlayers);
            s.serialize_double(model.r0);
            s.serialize_double(model.rdecay);
            s.serialize_double(model.lambda0);
            s.serialize_double(model.lambdalast);
            s.serialize_double(model.lambdadecay);
            s.serialize_double(model.shepardp);
            
            //
            // Algorithm-specific fields
            //
            processed = false;
            if( model.algotype==0 )
            {
                s.serialize_int(model.npoints);
                apserv.serializerealarray(s, model.shepardxy, -1, _params);
                processed = true;
            }
            if( model.algotype>0 )
            {
                nearestneighbor.kdtreeserialize(s, model.tree, _params);
                processed = true;
            }
            alglib.ap.assert(processed, "IDW: integrity check failed during serialization");
        }


        /*************************************************************************
        Serializer: unserialization

          -- ALGLIB --
             Copyright 28.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void idwunserialize(alglib.serializer s,
            idwmodel model,
            alglib.xparams _params)
        {
            bool processed = new bool();
            int scode = 0;

            
            //
            // Header
            //
            scode = s.unserialize_int();
            alglib.ap.assert(scode==scodes.getidwserializationcode(_params), "IDWUnserialize: stream header corrupted");
            
            //
            // Algorithm type and fields which are set for all algorithms
            //
            model.algotype = s.unserialize_int();
            model.nx = s.unserialize_int();
            model.ny = s.unserialize_int();
            apserv.unserializerealarray(s, ref model.globalprior, _params);
            model.nlayers = s.unserialize_int();
            model.r0 = s.unserialize_double();
            model.rdecay = s.unserialize_double();
            model.lambda0 = s.unserialize_double();
            model.lambdalast = s.unserialize_double();
            model.lambdadecay = s.unserialize_double();
            model.shepardp = s.unserialize_double();
            
            //
            // Algorithm-specific fields
            //
            processed = false;
            if( model.algotype==0 )
            {
                model.npoints = s.unserialize_int();
                apserv.unserializerealarray(s, ref model.shepardxy, _params);
                processed = true;
            }
            if( model.algotype>0 )
            {
                nearestneighbor.kdtreeunserialize(s, model.tree, _params);
                processed = true;
            }
            alglib.ap.assert(processed, "IDW: integrity check failed during serialization");
            
            //
            // Temporary buffers
            //
            idwcreatecalcbuffer(model, model.buffer, _params);
        }


        /*************************************************************************
        This function evaluates error metrics for the model  using  IDWTsCalcBuf()
        to calculate model at each point.

        NOTE: modern IDW algorithms (MSTAB, MSMOOTH) can generate residuals during
              model construction, so they do not need this function  in  order  to
              evaluate error metrics.

        Following fields of Rep are filled:
        * rep.rmserror
        * rep.avgerror
        * rep.maxerror
        * rep.r2
           
          -- ALGLIB --
             Copyright 22.10.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void errormetricsviacalc(idwbuilder state,
            idwmodel model,
            idwreport rep,
            alglib.xparams _params)
        {
            int npoints = 0;
            int nx = 0;
            int ny = 0;
            int i = 0;
            int j = 0;
            double v = 0;
            double vv = 0;
            double rss = 0;
            double tss = 0;

            npoints = state.npoints;
            nx = state.nx;
            ny = state.ny;
            if( npoints==0 )
            {
                rep.rmserror = 0;
                rep.avgerror = 0;
                rep.maxerror = 0;
                rep.r2 = 1;
                return;
            }
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.maxerror = 0;
            rss = 0;
            tss = 0;
            for(i=0; i<=npoints-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    model.buffer.x[j] = state.xy[i*(nx+ny)+j];
                }
                idwtscalcbuf(model, model.buffer, model.buffer.x, ref model.buffer.y, _params);
                for(j=0; j<=ny-1; j++)
                {
                    vv = state.xy[i*(nx+ny)+nx+j];
                    v = Math.Abs(vv-model.buffer.y[j]);
                    rep.rmserror = rep.rmserror+v*v;
                    rep.avgerror = rep.avgerror+v;
                    rep.maxerror = Math.Max(rep.maxerror, v);
                    rss = rss+v*v;
                    tss = tss+math.sqr(vv-state.tmpmean[j]);
                }
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/(npoints*ny));
            rep.avgerror = rep.avgerror/(npoints*ny);
            rep.r2 = 1.0-rss/apserv.coalesce(tss, 1.0, _params);
        }


    }
    public class intfitserv
    {
        /*************************************************************************
        Internal subroutine: automatic scaling for LLS tasks.
        NEVER CALL IT DIRECTLY!

        Maps abscissas to [-1,1], standartizes ordinates and correspondingly scales
        constraints. It also scales weights so that max(W[i])=1

        Transformations performed:
        * X, XC         [XA,XB] => [-1,+1]
                        transformation makes min(X)=-1, max(X)=+1

        * Y             [SA,SB] => [0,1]
                        transformation makes mean(Y)=0, stddev(Y)=1
                        
        * YC            transformed accordingly to SA, SB, DC[I]

          -- ALGLIB PROJECT --
             Copyright 08.09.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitscalexy(ref double[] x,
            ref double[] y,
            ref double[] w,
            int n,
            ref double[] xc,
            ref double[] yc,
            int[] dc,
            int k,
            ref double xa,
            ref double xb,
            ref double sa,
            ref double sb,
            ref double[] xoriginal,
            ref double[] yoriginal,
            alglib.xparams _params)
        {
            double xmin = 0;
            double xmax = 0;
            int i = 0;
            double mx = 0;
            int i_ = 0;

            xa = 0;
            xb = 0;
            sa = 0;
            sb = 0;
            xoriginal = new double[0];
            yoriginal = new double[0];

            alglib.ap.assert(n>=1, "LSFitScaleXY: incorrect N");
            alglib.ap.assert(k>=0, "LSFitScaleXY: incorrect K");
            xmin = x[0];
            xmax = x[0];
            for(i=1; i<=n-1; i++)
            {
                xmin = Math.Min(xmin, x[i]);
                xmax = Math.Max(xmax, x[i]);
            }
            for(i=0; i<=k-1; i++)
            {
                xmin = Math.Min(xmin, xc[i]);
                xmax = Math.Max(xmax, xc[i]);
            }
            if( (double)(xmin)==(double)(xmax) )
            {
                if( (double)(xmin)==(double)(0) )
                {
                    xmin = -1;
                    xmax = 1;
                }
                else
                {
                    if( (double)(xmin)>(double)(0) )
                    {
                        xmin = 0.5*xmin;
                    }
                    else
                    {
                        xmax = 0.5*xmax;
                    }
                }
            }
            xoriginal = new double[n];
            for(i_=0; i_<=n-1;i_++)
            {
                xoriginal[i_] = x[i_];
            }
            xa = xmin;
            xb = xmax;
            for(i=0; i<=n-1; i++)
            {
                x[i] = 2*(x[i]-0.5*(xa+xb))/(xb-xa);
            }
            for(i=0; i<=k-1; i++)
            {
                alglib.ap.assert(dc[i]>=0, "LSFitScaleXY: internal error!");
                xc[i] = 2*(xc[i]-0.5*(xa+xb))/(xb-xa);
                yc[i] = yc[i]*Math.Pow(0.5*(xb-xa), dc[i]);
            }
            yoriginal = new double[n];
            for(i_=0; i_<=n-1;i_++)
            {
                yoriginal[i_] = y[i_];
            }
            sa = 0;
            for(i=0; i<=n-1; i++)
            {
                sa = sa+y[i];
            }
            sa = sa/n;
            sb = 0;
            for(i=0; i<=n-1; i++)
            {
                sb = sb+math.sqr(y[i]-sa);
            }
            sb = Math.Sqrt(sb/n)+sa;
            if( (double)(sb)==(double)(sa) )
            {
                sb = 2*sa;
            }
            if( (double)(sb)==(double)(sa) )
            {
                sb = sa+1;
            }
            for(i=0; i<=n-1; i++)
            {
                y[i] = (y[i]-sa)/(sb-sa);
            }
            for(i=0; i<=k-1; i++)
            {
                if( dc[i]==0 )
                {
                    yc[i] = (yc[i]-sa)/(sb-sa);
                }
                else
                {
                    yc[i] = yc[i]/(sb-sa);
                }
            }
            mx = 0;
            for(i=0; i<=n-1; i++)
            {
                mx = Math.Max(mx, Math.Abs(w[i]));
            }
            if( (double)(mx)!=(double)(0) )
            {
                for(i=0; i<=n-1; i++)
                {
                    w[i] = w[i]/mx;
                }
            }
        }


        public static void buildpriorterm(double[,] xy,
            int n,
            int nx,
            int ny,
            int modeltype,
            double priorval,
            ref double[,] v,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int j0 = 0;
            int j1 = 0;
            double rj = 0;
            double[,] araw = new double[0,0];
            double[,] amod = new double[0,0];
            double[,] braw = new double[0,0];
            double[] tmp0 = new double[0];
            double lambdareg = 0;
            int rfsits = 0;

            v = new double[0,0];

            alglib.ap.assert(n>=0, "BuildPriorTerm: N<0");
            alglib.ap.assert(nx>0, "BuildPriorTerm: NX<=0");
            alglib.ap.assert(ny>0, "BuildPriorTerm: NY<=0");
            v = new double[ny, nx+1];
            for(i=0; i<=alglib.ap.rows(v)-1; i++)
            {
                for(j=0; j<=alglib.ap.cols(v)-1; j++)
                {
                    v[i,j] = 0;
                }
            }
            if( n==0 )
            {
                if( modeltype==0 )
                {
                    for(i=0; i<=ny-1; i++)
                    {
                        v[i,nx] = priorval;
                    }
                    return;
                }
                if( modeltype==1 )
                {
                    return;
                }
                if( modeltype==2 )
                {
                    return;
                }
                if( modeltype==3 )
                {
                    return;
                }
                alglib.ap.assert(false, "BuildPriorTerm: unexpected model type");
            }
            if( modeltype==0 )
            {
                for(i=0; i<=ny-1; i++)
                {
                    v[i,nx] = priorval;
                }
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        xy[i,nx+j] = xy[i,nx+j]-priorval;
                    }
                }
                return;
            }
            if( modeltype==2 )
            {
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        v[j,nx] = v[j,nx]+xy[i,nx+j];
                    }
                }
                for(j=0; j<=ny-1; j++)
                {
                    v[j,nx] = v[j,nx]/apserv.coalesce(n, 1, _params);
                }
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        xy[i,nx+j] = xy[i,nx+j]-v[j,nx];
                    }
                }
                return;
            }
            if( modeltype==3 )
            {
                return;
            }
            alglib.ap.assert(modeltype==1, "BuildPriorTerm: unexpected model type");
            lambdareg = 0.0;
            araw = new double[nx+1, nx+1];
            braw = new double[nx+1, ny];
            tmp0 = new double[nx+1];
            amod = new double[nx+1, nx+1];
            for(i=0; i<=nx; i++)
            {
                for(j=0; j<=nx; j++)
                {
                    araw[i,j] = 0;
                }
            }
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    tmp0[j] = xy[i,j];
                }
                tmp0[nx] = 1.0;
                for(j0=0; j0<=nx; j0++)
                {
                    for(j1=0; j1<=nx; j1++)
                    {
                        araw[j0,j1] = araw[j0,j1]+tmp0[j0]*tmp0[j1];
                    }
                }
            }
            for(rfsits=1; rfsits<=3; rfsits++)
            {
                for(i=0; i<=nx; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        braw[i,j] = 0;
                    }
                }
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        tmp0[j] = xy[i,j];
                    }
                    tmp0[nx] = 1.0;
                    for(j=0; j<=ny-1; j++)
                    {
                        rj = xy[i,nx+j];
                        for(j0=0; j0<=nx; j0++)
                        {
                            rj = rj-tmp0[j0]*v[j,j0];
                        }
                        for(j0=0; j0<=nx; j0++)
                        {
                            braw[j0,j] = braw[j0,j]+rj*tmp0[j0];
                        }
                    }
                }
                while( true )
                {
                    for(i=0; i<=nx; i++)
                    {
                        for(j=0; j<=nx; j++)
                        {
                            amod[i,j] = araw[i,j];
                        }
                        amod[i,i] = amod[i,i]+lambdareg*apserv.coalesce(amod[i,i], 1, _params);
                    }
                    if( trfac.spdmatrixcholesky(ref amod, nx+1, true, _params) )
                    {
                        break;
                    }
                    lambdareg = apserv.coalesce(10*lambdareg, 1.0E-12, _params);
                }
                ablas.rmatrixlefttrsm(nx+1, ny, amod, 0, 0, true, false, 1, braw, 0, 0, _params);
                ablas.rmatrixlefttrsm(nx+1, ny, amod, 0, 0, true, false, 0, braw, 0, 0, _params);
                for(i=0; i<=nx; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        v[j,i] = v[j,i]+braw[i,j];
                    }
                }
            }
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    tmp0[j] = xy[i,j];
                }
                tmp0[nx] = 1.0;
                for(j=0; j<=ny-1; j++)
                {
                    rj = 0.0;
                    for(j0=0; j0<=nx; j0++)
                    {
                        rj = rj+tmp0[j0]*v[j,j0];
                    }
                    xy[i,nx+j] = xy[i,nx+j]-rj;
                }
            }
        }


        public static void buildpriorterm1(double[] xy1,
            int n,
            int nx,
            int ny,
            int modeltype,
            double priorval,
            ref double[,] v,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int j0 = 0;
            int j1 = 0;
            int ew = 0;
            double rj = 0;
            double[,] araw = new double[0,0];
            double[,] amod = new double[0,0];
            double[,] braw = new double[0,0];
            double[] tmp0 = new double[0];
            double lambdareg = 0;
            int rfsits = 0;

            v = new double[0,0];

            alglib.ap.assert(n>=0, "BuildPriorTerm: N<0");
            alglib.ap.assert(nx>0, "BuildPriorTerm: NX<=0");
            alglib.ap.assert(ny>0, "BuildPriorTerm: NY<=0");
            ew = nx+ny;
            v = new double[ny, nx+1];
            for(i=0; i<=alglib.ap.rows(v)-1; i++)
            {
                for(j=0; j<=alglib.ap.cols(v)-1; j++)
                {
                    v[i,j] = 0;
                }
            }
            if( n==0 )
            {
                if( modeltype==0 )
                {
                    for(i=0; i<=ny-1; i++)
                    {
                        v[i,nx] = priorval;
                    }
                    return;
                }
                if( modeltype==1 )
                {
                    return;
                }
                if( modeltype==2 )
                {
                    return;
                }
                if( modeltype==3 )
                {
                    return;
                }
                alglib.ap.assert(false, "BuildPriorTerm: unexpected model type");
            }
            if( modeltype==0 )
            {
                for(i=0; i<=ny-1; i++)
                {
                    v[i,nx] = priorval;
                }
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        xy1[i*ew+nx+j] = xy1[i*ew+nx+j]-priorval;
                    }
                }
                return;
            }
            if( modeltype==2 )
            {
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        v[j,nx] = v[j,nx]+xy1[i*ew+nx+j];
                    }
                }
                for(j=0; j<=ny-1; j++)
                {
                    v[j,nx] = v[j,nx]/apserv.coalesce(n, 1, _params);
                }
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        xy1[i*ew+nx+j] = xy1[i*ew+nx+j]-v[j,nx];
                    }
                }
                return;
            }
            if( modeltype==3 )
            {
                return;
            }
            alglib.ap.assert(modeltype==1, "BuildPriorTerm: unexpected model type");
            lambdareg = 0.0;
            araw = new double[nx+1, nx+1];
            braw = new double[nx+1, ny];
            tmp0 = new double[nx+1];
            amod = new double[nx+1, nx+1];
            for(i=0; i<=nx; i++)
            {
                for(j=0; j<=nx; j++)
                {
                    araw[i,j] = 0;
                }
            }
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    tmp0[j] = xy1[i*ew+j];
                }
                tmp0[nx] = 1.0;
                for(j0=0; j0<=nx; j0++)
                {
                    for(j1=0; j1<=nx; j1++)
                    {
                        araw[j0,j1] = araw[j0,j1]+tmp0[j0]*tmp0[j1];
                    }
                }
            }
            for(rfsits=1; rfsits<=3; rfsits++)
            {
                for(i=0; i<=nx; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        braw[i,j] = 0;
                    }
                }
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        tmp0[j] = xy1[i*ew+j];
                    }
                    tmp0[nx] = 1.0;
                    for(j=0; j<=ny-1; j++)
                    {
                        rj = xy1[i*ew+nx+j];
                        for(j0=0; j0<=nx; j0++)
                        {
                            rj = rj-tmp0[j0]*v[j,j0];
                        }
                        for(j0=0; j0<=nx; j0++)
                        {
                            braw[j0,j] = braw[j0,j]+rj*tmp0[j0];
                        }
                    }
                }
                while( true )
                {
                    for(i=0; i<=nx; i++)
                    {
                        for(j=0; j<=nx; j++)
                        {
                            amod[i,j] = araw[i,j];
                        }
                        amod[i,i] = amod[i,i]+lambdareg*apserv.coalesce(amod[i,i], 1, _params);
                    }
                    if( trfac.spdmatrixcholesky(ref amod, nx+1, true, _params) )
                    {
                        break;
                    }
                    lambdareg = apserv.coalesce(10*lambdareg, 1.0E-12, _params);
                }
                ablas.rmatrixlefttrsm(nx+1, ny, amod, 0, 0, true, false, 1, braw, 0, 0, _params);
                ablas.rmatrixlefttrsm(nx+1, ny, amod, 0, 0, true, false, 0, braw, 0, 0, _params);
                for(i=0; i<=nx; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        v[j,i] = v[j,i]+braw[i,j];
                    }
                }
            }
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    tmp0[j] = xy1[i*ew+j];
                }
                tmp0[nx] = 1.0;
                for(j=0; j<=ny-1; j++)
                {
                    rj = 0.0;
                    for(j0=0; j0<=nx; j0++)
                    {
                        rj = rj+tmp0[j0]*v[j,j0];
                    }
                    xy1[i*ew+nx+j] = xy1[i*ew+nx+j]-rj;
                }
            }
        }


    }
    public class polint
    {
        /*************************************************************************
        Conversion from barycentric representation to Chebyshev basis.
        This function has O(N^2) complexity.

        INPUT PARAMETERS:
            P   -   polynomial in barycentric form
            A,B -   base interval for Chebyshev polynomials (see below)
                    A<>B

        OUTPUT PARAMETERS
            T   -   coefficients of Chebyshev representation;
                    P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N-1 },
                    where Ti - I-th Chebyshev polynomial.

        NOTES:
            barycentric interpolant passed as P may be either polynomial  obtained
            from  polynomial  interpolation/ fitting or rational function which is
            NOT polynomial. We can't distinguish between these two cases, and this
            algorithm just tries to work assuming that P IS a polynomial.  If not,
            algorithm will return results, but they won't have any meaning.

          -- ALGLIB --
             Copyright 30.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialbar2cheb(ratint.barycentricinterpolant p,
            double a,
            double b,
            ref double[] t,
            alglib.xparams _params)
        {
            int i = 0;
            int k = 0;
            double[] vp = new double[0];
            double[] vx = new double[0];
            double[] tk = new double[0];
            double[] tk1 = new double[0];
            double v = 0;
            int i_ = 0;

            t = new double[0];

            alglib.ap.assert(math.isfinite(a), "PolynomialBar2Cheb: A is not finite!");
            alglib.ap.assert(math.isfinite(b), "PolynomialBar2Cheb: B is not finite!");
            alglib.ap.assert((double)(a)!=(double)(b), "PolynomialBar2Cheb: A=B!");
            alglib.ap.assert(p.n>0, "PolynomialBar2Cheb: P is not correctly initialized barycentric interpolant!");
            
            //
            // Calculate function values on a Chebyshev grid
            //
            vp = new double[p.n];
            vx = new double[p.n];
            for(i=0; i<=p.n-1; i++)
            {
                vx[i] = Math.Cos(Math.PI*(i+0.5)/p.n);
                vp[i] = ratint.barycentriccalc(p, 0.5*(vx[i]+1)*(b-a)+a, _params);
            }
            
            //
            // T[0]
            //
            t = new double[p.n];
            v = 0;
            for(i=0; i<=p.n-1; i++)
            {
                v = v+vp[i];
            }
            t[0] = v/p.n;
            
            //
            // other T's.
            //
            // NOTES:
            // 1. TK stores T{k} on VX, TK1 stores T{k-1} on VX
            // 2. we can do same calculations with fast DCT, but it
            //    * adds dependencies
            //    * still leaves us with O(N^2) algorithm because
            //      preparation of function values is O(N^2) process
            //
            if( p.n>1 )
            {
                tk = new double[p.n];
                tk1 = new double[p.n];
                for(i=0; i<=p.n-1; i++)
                {
                    tk[i] = vx[i];
                    tk1[i] = 1;
                }
                for(k=1; k<=p.n-1; k++)
                {
                    
                    //
                    // calculate discrete product of function vector and TK
                    //
                    v = 0.0;
                    for(i_=0; i_<=p.n-1;i_++)
                    {
                        v += tk[i_]*vp[i_];
                    }
                    t[k] = v/(0.5*p.n);
                    
                    //
                    // Update TK and TK1
                    //
                    for(i=0; i<=p.n-1; i++)
                    {
                        v = 2*vx[i]*tk[i]-tk1[i];
                        tk1[i] = tk[i];
                        tk[i] = v;
                    }
                }
            }
        }


        /*************************************************************************
        Conversion from Chebyshev basis to barycentric representation.
        This function has O(N^2) complexity.

        INPUT PARAMETERS:
            T   -   coefficients of Chebyshev representation;
                    P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N },
                    where Ti - I-th Chebyshev polynomial.
            N   -   number of coefficients:
                    * if given, only leading N elements of T are used
                    * if not given, automatically determined from size of T
            A,B -   base interval for Chebyshev polynomials (see above)
                    A<B

        OUTPUT PARAMETERS
            P   -   polynomial in barycentric form

          -- ALGLIB --
             Copyright 30.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialcheb2bar(double[] t,
            int n,
            double a,
            double b,
            ratint.barycentricinterpolant p,
            alglib.xparams _params)
        {
            int i = 0;
            int k = 0;
            double[] y = new double[0];
            double tk = 0;
            double tk1 = 0;
            double vx = 0;
            double vy = 0;
            double v = 0;

            alglib.ap.assert(math.isfinite(a), "PolynomialBar2Cheb: A is not finite!");
            alglib.ap.assert(math.isfinite(b), "PolynomialBar2Cheb: B is not finite!");
            alglib.ap.assert((double)(a)!=(double)(b), "PolynomialBar2Cheb: A=B!");
            alglib.ap.assert(n>=1, "PolynomialBar2Cheb: N<1");
            alglib.ap.assert(alglib.ap.len(t)>=n, "PolynomialBar2Cheb: Length(T)<N");
            alglib.ap.assert(apserv.isfinitevector(t, n, _params), "PolynomialBar2Cheb: T[] contains INF or NAN");
            
            //
            // Calculate function values on a Chebyshev grid spanning [-1,+1]
            //
            y = new double[n];
            for(i=0; i<=n-1; i++)
            {
                
                //
                // Calculate value on a grid spanning [-1,+1]
                //
                vx = Math.Cos(Math.PI*(i+0.5)/n);
                vy = t[0];
                tk1 = 1;
                tk = vx;
                for(k=1; k<=n-1; k++)
                {
                    vy = vy+t[k]*tk;
                    v = 2*vx*tk-tk1;
                    tk1 = tk;
                    tk = v;
                }
                y[i] = vy;
            }
            
            //
            // Build barycentric interpolant, map grid from [-1,+1] to [A,B]
            //
            polynomialbuildcheb1(a, b, y, n, p, _params);
        }


        /*************************************************************************
        Conversion from barycentric representation to power basis.
        This function has O(N^2) complexity.

        INPUT PARAMETERS:
            P   -   polynomial in barycentric form
            C   -   offset (see below); 0.0 is used as default value.
            S   -   scale (see below);  1.0 is used as default value. S<>0.

        OUTPUT PARAMETERS
            A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
            N   -   number of coefficients (polynomial degree plus 1)

        NOTES:
        1.  this function accepts offset and scale, which can be  set  to  improve
            numerical properties of polynomial. For example, if P was obtained  as
            result of interpolation on [-1,+1],  you  can  set  C=0  and  S=1  and
            represent  P  as sum of 1, x, x^2, x^3 and so on. In most cases you it
            is exactly what you need.

            However, if your interpolation model was built on [999,1001], you will
            see significant growth of numerical errors when using {1, x, x^2, x^3}
            as basis. Representing P as sum of 1, (x-1000), (x-1000)^2, (x-1000)^3
            will be better option. Such representation can be  obtained  by  using
            1000.0 as offset C and 1.0 as scale S.

        2.  power basis is ill-conditioned and tricks described above can't  solve
            this problem completely. This function  will  return  coefficients  in
            any  case,  but  for  N>8  they  will  become unreliable. However, N's
            less than 5 are pretty safe.
            
        3.  barycentric interpolant passed as P may be either polynomial  obtained
            from  polynomial  interpolation/ fitting or rational function which is
            NOT polynomial. We can't distinguish between these two cases, and this
            algorithm just tries to work assuming that P IS a polynomial.  If not,
            algorithm will return results, but they won't have any meaning.

          -- ALGLIB --
             Copyright 30.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialbar2pow(ratint.barycentricinterpolant p,
            double c,
            double s,
            ref double[] a,
            alglib.xparams _params)
        {
            int i = 0;
            int k = 0;
            double e = 0;
            double d = 0;
            double[] vp = new double[0];
            double[] vx = new double[0];
            double[] tk = new double[0];
            double[] tk1 = new double[0];
            double[] t = new double[0];
            double v = 0;
            double c0 = 0;
            double s0 = 0;
            double va = 0;
            double vb = 0;
            double[] vai = new double[0];
            double[] vbi = new double[0];
            double minx = 0;
            double maxx = 0;
            int i_ = 0;

            a = new double[0];

            
            //
            // We have barycentric model built using set of points X[], and we
            // want to convert it to power basis centered about point  C  with
            // scale S: I-th basis function is ((X-C)/S)^i.
            //
            // We use following three-stage algorithm:
            //
            // 1. we build Chebyshev representation of polynomial using
            //    intermediate center C0 and scale S0, which are derived from X[]:
            //    C0 = 0.5*(min(X)+max(X)), S0 = 0.5*(max(X)-min(X)). Chebyshev
            //    representation is built by sampling points around center C0,
            //    with typical distance between them proportional to S0.
            // 2. then we transform form Chebyshev basis to intermediate power
            //    basis, using same center/scale C0/S0.
            // 3. after that, we apply linear transformation to intermediate
            //    power basis which moves it to final center/scale C/S.
            //
            // The idea of such multi-stage algorithm is that it is much easier to
            // transform barycentric model to Chebyshev basis, and only later to
            // power basis, than transforming it directly to power basis. It is
            // also more numerically stable to sample points using intermediate C0/S0,
            // which are derived from user-supplied model, than using "final" C/S,
            // which may be unsuitable for sampling (say, if S=1, we may have stability
            // problems when working with models built from dataset with non-unit
            // scale of abscissas).
            //
            alglib.ap.assert(math.isfinite(c), "PolynomialBar2Pow: C is not finite!");
            alglib.ap.assert(math.isfinite(s), "PolynomialBar2Pow: S is not finite!");
            alglib.ap.assert((double)(s)!=(double)(0), "PolynomialBar2Pow: S=0!");
            alglib.ap.assert(p.n>0, "PolynomialBar2Pow: P is not correctly initialized barycentric interpolant!");
            
            //
            // Select intermediate center/scale
            //
            minx = p.x[0];
            maxx = p.x[0];
            for(i=1; i<=p.n-1; i++)
            {
                minx = Math.Min(minx, p.x[i]);
                maxx = Math.Max(maxx, p.x[i]);
            }
            if( (double)(minx)==(double)(maxx) )
            {
                c0 = minx;
                s0 = 1.0;
            }
            else
            {
                c0 = 0.5*(maxx+minx);
                s0 = 0.5*(maxx-minx);
            }
            
            //
            // Calculate function values on a Chebyshev grid using intermediate C0/S0
            //
            vp = new double[p.n+1];
            vx = new double[p.n];
            for(i=0; i<=p.n-1; i++)
            {
                vx[i] = Math.Cos(Math.PI*(i+0.5)/p.n);
                vp[i] = ratint.barycentriccalc(p, s0*vx[i]+c0, _params);
            }
            
            //
            // T[0]
            //
            t = new double[p.n];
            v = 0;
            for(i=0; i<=p.n-1; i++)
            {
                v = v+vp[i];
            }
            t[0] = v/p.n;
            
            //
            // other T's.
            //
            // NOTES:
            // 1. TK stores T{k} on VX, TK1 stores T{k-1} on VX
            // 2. we can do same calculations with fast DCT, but it
            //    * adds dependencies
            //    * still leaves us with O(N^2) algorithm because
            //      preparation of function values is O(N^2) process
            //
            if( p.n>1 )
            {
                tk = new double[p.n];
                tk1 = new double[p.n];
                for(i=0; i<=p.n-1; i++)
                {
                    tk[i] = vx[i];
                    tk1[i] = 1;
                }
                for(k=1; k<=p.n-1; k++)
                {
                    
                    //
                    // calculate discrete product of function vector and TK
                    //
                    v = 0.0;
                    for(i_=0; i_<=p.n-1;i_++)
                    {
                        v += tk[i_]*vp[i_];
                    }
                    t[k] = v/(0.5*p.n);
                    
                    //
                    // Update TK and TK1
                    //
                    for(i=0; i<=p.n-1; i++)
                    {
                        v = 2*vx[i]*tk[i]-tk1[i];
                        tk1[i] = tk[i];
                        tk[i] = v;
                    }
                }
            }
            
            //
            // Convert from Chebyshev basis to power basis
            //
            a = new double[p.n];
            for(i=0; i<=p.n-1; i++)
            {
                a[i] = 0;
            }
            d = 0;
            for(i=0; i<=p.n-1; i++)
            {
                for(k=i; k<=p.n-1; k++)
                {
                    e = a[k];
                    a[k] = 0;
                    if( i<=1 && k==i )
                    {
                        a[k] = 1;
                    }
                    else
                    {
                        if( i!=0 )
                        {
                            a[k] = 2*d;
                        }
                        if( k>i+1 )
                        {
                            a[k] = a[k]-a[k-2];
                        }
                    }
                    d = e;
                }
                d = a[i];
                e = 0;
                k = i;
                while( k<=p.n-1 )
                {
                    e = e+a[k]*t[k];
                    k = k+2;
                }
                a[i] = e;
            }
            
            //
            // Apply linear transformation which converts basis from intermediate
            // one Fi=((x-C0)/S0)^i to final one Fi=((x-C)/S)^i.
            //
            // We have y=(x-C0)/S0, z=(x-C)/S, and coefficients A[] for basis Fi(y).
            // Because we have y=A*z+B, for A=s/s0 and B=c/s0-c0/s0, we can perform
            // substitution and get coefficients A_new[] in basis Fi(z).
            //
            alglib.ap.assert(alglib.ap.len(vp)>=p.n+1, "PolynomialBar2Pow: internal error");
            alglib.ap.assert(alglib.ap.len(t)>=p.n, "PolynomialBar2Pow: internal error");
            for(i=0; i<=p.n-1; i++)
            {
                t[i] = 0.0;
            }
            va = s/s0;
            vb = c/s0-c0/s0;
            vai = new double[p.n];
            vbi = new double[p.n];
            vai[0] = 1;
            vbi[0] = 1;
            for(k=1; k<=p.n-1; k++)
            {
                vai[k] = vai[k-1]*va;
                vbi[k] = vbi[k-1]*vb;
            }
            for(k=0; k<=p.n-1; k++)
            {
                
                //
                // Generate set of binomial coefficients in VP[]
                //
                if( k>0 )
                {
                    vp[k] = 1;
                    for(i=k-1; i>=1; i--)
                    {
                        vp[i] = vp[i]+vp[i-1];
                    }
                    vp[0] = 1;
                }
                else
                {
                    vp[0] = 1;
                }
                
                //
                // Update T[] with expansion of K-th basis function
                //
                for(i=0; i<=k; i++)
                {
                    t[i] = t[i]+a[k]*vai[i]*vbi[k-i]*vp[i];
                }
            }
            for(k=0; k<=p.n-1; k++)
            {
                a[k] = t[k];
            }
        }


        /*************************************************************************
        Conversion from power basis to barycentric representation.
        This function has O(N^2) complexity.

        INPUT PARAMETERS:
            A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
            N   -   number of coefficients (polynomial degree plus 1)
                    * if given, only leading N elements of A are used
                    * if not given, automatically determined from size of A
            C   -   offset (see below); 0.0 is used as default value.
            S   -   scale (see below);  1.0 is used as default value. S<>0.

        OUTPUT PARAMETERS
            P   -   polynomial in barycentric form


        NOTES:
        1.  this function accepts offset and scale, which can be  set  to  improve
            numerical properties of polynomial. For example, if you interpolate on
            [-1,+1],  you  can  set C=0 and S=1 and convert from sum of 1, x, x^2,
            x^3 and so on. In most cases you it is exactly what you need.

            However, if your interpolation model was built on [999,1001], you will
            see significant growth of numerical errors when using {1, x, x^2, x^3}
            as  input  basis.  Converting  from  sum  of  1, (x-1000), (x-1000)^2,
            (x-1000)^3 will be better option (you have to specify 1000.0 as offset
            C and 1.0 as scale S).

        2.  power basis is ill-conditioned and tricks described above can't  solve
            this problem completely. This function  will  return barycentric model
            in any case, but for N>8 accuracy well degrade. However, N's less than
            5 are pretty safe.

          -- ALGLIB --
             Copyright 30.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialpow2bar(double[] a,
            int n,
            double c,
            double s,
            ratint.barycentricinterpolant p,
            alglib.xparams _params)
        {
            int i = 0;
            int k = 0;
            double[] y = new double[0];
            double vx = 0;
            double vy = 0;
            double px = 0;

            alglib.ap.assert(math.isfinite(c), "PolynomialPow2Bar: C is not finite!");
            alglib.ap.assert(math.isfinite(s), "PolynomialPow2Bar: S is not finite!");
            alglib.ap.assert((double)(s)!=(double)(0), "PolynomialPow2Bar: S is zero!");
            alglib.ap.assert(n>=1, "PolynomialPow2Bar: N<1");
            alglib.ap.assert(alglib.ap.len(a)>=n, "PolynomialPow2Bar: Length(A)<N");
            alglib.ap.assert(apserv.isfinitevector(a, n, _params), "PolynomialPow2Bar: A[] contains INF or NAN");
            
            //
            // Calculate function values on a Chebyshev grid spanning [-1,+1]
            //
            y = new double[n];
            for(i=0; i<=n-1; i++)
            {
                
                //
                // Calculate value on a grid spanning [-1,+1]
                //
                vx = Math.Cos(Math.PI*(i+0.5)/n);
                vy = a[0];
                px = vx;
                for(k=1; k<=n-1; k++)
                {
                    vy = vy+px*a[k];
                    px = px*vx;
                }
                y[i] = vy;
            }
            
            //
            // Build barycentric interpolant, map grid from [-1,+1] to [A,B]
            //
            polynomialbuildcheb1(c-s, c+s, y, n, p, _params);
        }


        /*************************************************************************
        Lagrange intepolant: generation of the model on the general grid.
        This function has O(N^2) complexity.

        INPUT PARAMETERS:
            X   -   abscissas, array[0..N-1]
            Y   -   function values, array[0..N-1]
            N   -   number of points, N>=1

        OUTPUT PARAMETERS
            P   -   barycentric model which represents Lagrange interpolant
                    (see ratint unit info and BarycentricCalc() description for
                    more information).

          -- ALGLIB --
             Copyright 02.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialbuild(double[] x,
            double[] y,
            int n,
            ratint.barycentricinterpolant p,
            alglib.xparams _params)
        {
            int j = 0;
            int k = 0;
            double[] w = new double[0];
            double b = 0;
            double a = 0;
            double v = 0;
            double mx = 0;
            double[] sortrbuf = new double[0];
            double[] sortrbuf2 = new double[0];
            int i_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();

            alglib.ap.assert(n>0, "PolynomialBuild: N<=0!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "PolynomialBuild: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "PolynomialBuild: Length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "PolynomialBuild: X contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "PolynomialBuild: Y contains infinite or NaN values!");
            tsort.tagsortfastr(ref x, ref y, ref sortrbuf, ref sortrbuf2, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "PolynomialBuild: at least two consequent points are too close!");
            
            //
            // calculate W[j]
            // multi-pass algorithm is used to avoid overflow
            //
            w = new double[n];
            a = x[0];
            b = x[0];
            for(j=0; j<=n-1; j++)
            {
                w[j] = 1;
                a = Math.Min(a, x[j]);
                b = Math.Max(b, x[j]);
            }
            for(k=0; k<=n-1; k++)
            {
                
                //
                // W[K] is used instead of 0.0 because
                // cycle on J does not touch K-th element
                // and we MUST get maximum from ALL elements
                //
                mx = Math.Abs(w[k]);
                for(j=0; j<=n-1; j++)
                {
                    if( j!=k )
                    {
                        v = (b-a)/(x[j]-x[k]);
                        w[j] = w[j]*v;
                        mx = Math.Max(mx, Math.Abs(w[j]));
                    }
                }
                if( k%5==0 )
                {
                    
                    //
                    // every 5-th run we renormalize W[]
                    //
                    v = 1/mx;
                    for(i_=0; i_<=n-1;i_++)
                    {
                        w[i_] = v*w[i_];
                    }
                }
            }
            ratint.barycentricbuildxyw(x, y, w, n, p, _params);
        }


        /*************************************************************************
        Lagrange intepolant: generation of the model on equidistant grid.
        This function has O(N) complexity.

        INPUT PARAMETERS:
            A   -   left boundary of [A,B]
            B   -   right boundary of [A,B]
            Y   -   function values at the nodes, array[0..N-1]
            N   -   number of points, N>=1
                    for N=1 a constant model is constructed.

        OUTPUT PARAMETERS
            P   -   barycentric model which represents Lagrange interpolant
                    (see ratint unit info and BarycentricCalc() description for
                    more information).

          -- ALGLIB --
             Copyright 03.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialbuildeqdist(double a,
            double b,
            double[] y,
            int n,
            ratint.barycentricinterpolant p,
            alglib.xparams _params)
        {
            int i = 0;
            double[] w = new double[0];
            double[] x = new double[0];
            double v = 0;

            alglib.ap.assert(n>0, "PolynomialBuildEqDist: N<=0!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "PolynomialBuildEqDist: Length(Y)<N!");
            alglib.ap.assert(math.isfinite(a), "PolynomialBuildEqDist: A is infinite or NaN!");
            alglib.ap.assert(math.isfinite(b), "PolynomialBuildEqDist: B is infinite or NaN!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "PolynomialBuildEqDist: Y contains infinite or NaN values!");
            alglib.ap.assert((double)(b)!=(double)(a), "PolynomialBuildEqDist: B=A!");
            alglib.ap.assert((double)(a+(b-a)/n)!=(double)(a), "PolynomialBuildEqDist: B is too close to A!");
            
            //
            // Special case: N=1
            //
            if( n==1 )
            {
                x = new double[1];
                w = new double[1];
                x[0] = 0.5*(b+a);
                w[0] = 1;
                ratint.barycentricbuildxyw(x, y, w, 1, p, _params);
                return;
            }
            
            //
            // general case
            //
            x = new double[n];
            w = new double[n];
            v = 1;
            for(i=0; i<=n-1; i++)
            {
                w[i] = v;
                x[i] = a+(b-a)*i/(n-1);
                v = -(v*(n-1-i));
                v = v/(i+1);
            }
            ratint.barycentricbuildxyw(x, y, w, n, p, _params);
        }


        /*************************************************************************
        Lagrange intepolant on Chebyshev grid (first kind).
        This function has O(N) complexity.

        INPUT PARAMETERS:
            A   -   left boundary of [A,B]
            B   -   right boundary of [A,B]
            Y   -   function values at the nodes, array[0..N-1],
                    Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
            N   -   number of points, N>=1
                    for N=1 a constant model is constructed.

        OUTPUT PARAMETERS
            P   -   barycentric model which represents Lagrange interpolant
                    (see ratint unit info and BarycentricCalc() description for
                    more information).

          -- ALGLIB --
             Copyright 03.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialbuildcheb1(double a,
            double b,
            double[] y,
            int n,
            ratint.barycentricinterpolant p,
            alglib.xparams _params)
        {
            int i = 0;
            double[] w = new double[0];
            double[] x = new double[0];
            double v = 0;
            double t = 0;

            alglib.ap.assert(n>0, "PolynomialBuildCheb1: N<=0!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "PolynomialBuildCheb1: Length(Y)<N!");
            alglib.ap.assert(math.isfinite(a), "PolynomialBuildCheb1: A is infinite or NaN!");
            alglib.ap.assert(math.isfinite(b), "PolynomialBuildCheb1: B is infinite or NaN!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "PolynomialBuildCheb1: Y contains infinite or NaN values!");
            alglib.ap.assert((double)(b)!=(double)(a), "PolynomialBuildCheb1: B=A!");
            
            //
            // Special case: N=1
            //
            if( n==1 )
            {
                x = new double[1];
                w = new double[1];
                x[0] = 0.5*(b+a);
                w[0] = 1;
                ratint.barycentricbuildxyw(x, y, w, 1, p, _params);
                return;
            }
            
            //
            // general case
            //
            x = new double[n];
            w = new double[n];
            v = 1;
            for(i=0; i<=n-1; i++)
            {
                t = Math.Tan(0.5*Math.PI*(2*i+1)/(2*n));
                w[i] = 2*v*t/(1+math.sqr(t));
                x[i] = 0.5*(b+a)+0.5*(b-a)*(1-math.sqr(t))/(1+math.sqr(t));
                v = -v;
            }
            ratint.barycentricbuildxyw(x, y, w, n, p, _params);
        }


        /*************************************************************************
        Lagrange intepolant on Chebyshev grid (second kind).
        This function has O(N) complexity.

        INPUT PARAMETERS:
            A   -   left boundary of [A,B]
            B   -   right boundary of [A,B]
            Y   -   function values at the nodes, array[0..N-1],
                    Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
            N   -   number of points, N>=1
                    for N=1 a constant model is constructed.

        OUTPUT PARAMETERS
            P   -   barycentric model which represents Lagrange interpolant
                    (see ratint unit info and BarycentricCalc() description for
                    more information).

          -- ALGLIB --
             Copyright 03.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialbuildcheb2(double a,
            double b,
            double[] y,
            int n,
            ratint.barycentricinterpolant p,
            alglib.xparams _params)
        {
            int i = 0;
            double[] w = new double[0];
            double[] x = new double[0];
            double v = 0;

            alglib.ap.assert(n>0, "PolynomialBuildCheb2: N<=0!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "PolynomialBuildCheb2: Length(Y)<N!");
            alglib.ap.assert(math.isfinite(a), "PolynomialBuildCheb2: A is infinite or NaN!");
            alglib.ap.assert(math.isfinite(b), "PolynomialBuildCheb2: B is infinite or NaN!");
            alglib.ap.assert((double)(b)!=(double)(a), "PolynomialBuildCheb2: B=A!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "PolynomialBuildCheb2: Y contains infinite or NaN values!");
            
            //
            // Special case: N=1
            //
            if( n==1 )
            {
                x = new double[1];
                w = new double[1];
                x[0] = 0.5*(b+a);
                w[0] = 1;
                ratint.barycentricbuildxyw(x, y, w, 1, p, _params);
                return;
            }
            
            //
            // general case
            //
            x = new double[n];
            w = new double[n];
            v = 1;
            for(i=0; i<=n-1; i++)
            {
                if( i==0 || i==n-1 )
                {
                    w[i] = v*0.5;
                }
                else
                {
                    w[i] = v;
                }
                x[i] = 0.5*(b+a)+0.5*(b-a)*Math.Cos(Math.PI*i/(n-1));
                v = -v;
            }
            ratint.barycentricbuildxyw(x, y, w, n, p, _params);
        }


        /*************************************************************************
        Fast equidistant polynomial interpolation function with O(N) complexity

        INPUT PARAMETERS:
            A   -   left boundary of [A,B]
            B   -   right boundary of [A,B]
            F   -   function values, array[0..N-1]
            N   -   number of points on equidistant grid, N>=1
                    for N=1 a constant model is constructed.
            T   -   position where P(x) is calculated

        RESULT
            value of the Lagrange interpolant at T
            
        IMPORTANT
            this function provides fast interface which is not overflow-safe
            nor it is very precise.
            the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
            subroutines unless you are pretty sure that your data will not result
            in overflow.

          -- ALGLIB --
             Copyright 02.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static double polynomialcalceqdist(double a,
            double b,
            double[] f,
            int n,
            double t,
            alglib.xparams _params)
        {
            double result = 0;
            double s1 = 0;
            double s2 = 0;
            double v = 0;
            double threshold = 0;
            double s = 0;
            double h = 0;
            int i = 0;
            int j = 0;
            double w = 0;
            double x = 0;

            alglib.ap.assert(n>0, "PolynomialCalcEqDist: N<=0!");
            alglib.ap.assert(alglib.ap.len(f)>=n, "PolynomialCalcEqDist: Length(F)<N!");
            alglib.ap.assert(math.isfinite(a), "PolynomialCalcEqDist: A is infinite or NaN!");
            alglib.ap.assert(math.isfinite(b), "PolynomialCalcEqDist: B is infinite or NaN!");
            alglib.ap.assert(apserv.isfinitevector(f, n, _params), "PolynomialCalcEqDist: F contains infinite or NaN values!");
            alglib.ap.assert((double)(b)!=(double)(a), "PolynomialCalcEqDist: B=A!");
            alglib.ap.assert(!Double.IsInfinity(t), "PolynomialCalcEqDist: T is infinite!");
            
            //
            // Special case: T is NAN
            //
            if( Double.IsNaN(t) )
            {
                result = Double.NaN;
                return result;
            }
            
            //
            // Special case: N=1
            //
            if( n==1 )
            {
                result = f[0];
                return result;
            }
            
            //
            // First, decide: should we use "safe" formula (guarded
            // against overflow) or fast one?
            //
            threshold = Math.Sqrt(math.minrealnumber);
            j = 0;
            s = t-a;
            for(i=1; i<=n-1; i++)
            {
                x = a+(double)i/(double)(n-1)*(b-a);
                if( (double)(Math.Abs(t-x))<(double)(Math.Abs(s)) )
                {
                    s = t-x;
                    j = i;
                }
            }
            if( (double)(s)==(double)(0) )
            {
                result = f[j];
                return result;
            }
            if( (double)(Math.Abs(s))>(double)(threshold) )
            {
                
                //
                // use fast formula
                //
                j = -1;
                s = 1.0;
            }
            
            //
            // Calculate using safe or fast barycentric formula
            //
            s1 = 0;
            s2 = 0;
            w = 1.0;
            h = (b-a)/(n-1);
            for(i=0; i<=n-1; i++)
            {
                if( i!=j )
                {
                    v = s*w/(t-(a+i*h));
                    s1 = s1+v*f[i];
                    s2 = s2+v;
                }
                else
                {
                    v = w;
                    s1 = s1+v*f[i];
                    s2 = s2+v;
                }
                w = -(w*(n-1-i));
                w = w/(i+1);
            }
            result = s1/s2;
            return result;
        }


        /*************************************************************************
        Fast polynomial interpolation function on Chebyshev points (first kind)
        with O(N) complexity.

        INPUT PARAMETERS:
            A   -   left boundary of [A,B]
            B   -   right boundary of [A,B]
            F   -   function values, array[0..N-1]
            N   -   number of points on Chebyshev grid (first kind),
                    X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
                    for N=1 a constant model is constructed.
            T   -   position where P(x) is calculated

        RESULT
            value of the Lagrange interpolant at T

        IMPORTANT
            this function provides fast interface which is not overflow-safe
            nor it is very precise.
            the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
            subroutines unless you are pretty sure that your data will not result
            in overflow.

          -- ALGLIB --
             Copyright 02.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static double polynomialcalccheb1(double a,
            double b,
            double[] f,
            int n,
            double t,
            alglib.xparams _params)
        {
            double result = 0;
            double s1 = 0;
            double s2 = 0;
            double v = 0;
            double threshold = 0;
            double s = 0;
            int i = 0;
            int j = 0;
            double a0 = 0;
            double delta = 0;
            double alpha = 0;
            double beta = 0;
            double ca = 0;
            double sa = 0;
            double tempc = 0;
            double temps = 0;
            double x = 0;
            double w = 0;
            double p1 = 0;

            alglib.ap.assert(n>0, "PolynomialCalcCheb1: N<=0!");
            alglib.ap.assert(alglib.ap.len(f)>=n, "PolynomialCalcCheb1: Length(F)<N!");
            alglib.ap.assert(math.isfinite(a), "PolynomialCalcCheb1: A is infinite or NaN!");
            alglib.ap.assert(math.isfinite(b), "PolynomialCalcCheb1: B is infinite or NaN!");
            alglib.ap.assert(apserv.isfinitevector(f, n, _params), "PolynomialCalcCheb1: F contains infinite or NaN values!");
            alglib.ap.assert((double)(b)!=(double)(a), "PolynomialCalcCheb1: B=A!");
            alglib.ap.assert(!Double.IsInfinity(t), "PolynomialCalcCheb1: T is infinite!");
            
            //
            // Special case: T is NAN
            //
            if( Double.IsNaN(t) )
            {
                result = Double.NaN;
                return result;
            }
            
            //
            // Special case: N=1
            //
            if( n==1 )
            {
                result = f[0];
                return result;
            }
            
            //
            // Prepare information for the recurrence formula
            // used to calculate sin(pi*(2j+1)/(2n+2)) and
            // cos(pi*(2j+1)/(2n+2)):
            //
            // A0    = pi/(2n+2)
            // Delta = pi/(n+1)
            // Alpha = 2 sin^2 (Delta/2)
            // Beta  = sin(Delta)
            //
            // so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
            // Then we use
            //
            // sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
            // cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
            //
            // to repeatedly calculate sin(..) and cos(..).
            //
            threshold = Math.Sqrt(math.minrealnumber);
            t = (t-0.5*(a+b))/(0.5*(b-a));
            a0 = Math.PI/(2*(n-1)+2);
            delta = 2*Math.PI/(2*(n-1)+2);
            alpha = 2*math.sqr(Math.Sin(delta/2));
            beta = Math.Sin(delta);
            
            //
            // First, decide: should we use "safe" formula (guarded
            // against overflow) or fast one?
            //
            ca = Math.Cos(a0);
            sa = Math.Sin(a0);
            j = 0;
            x = ca;
            s = t-x;
            for(i=1; i<=n-1; i++)
            {
                
                //
                // Next X[i]
                //
                temps = sa-(alpha*sa-beta*ca);
                tempc = ca-(alpha*ca+beta*sa);
                sa = temps;
                ca = tempc;
                x = ca;
                
                //
                // Use X[i]
                //
                if( (double)(Math.Abs(t-x))<(double)(Math.Abs(s)) )
                {
                    s = t-x;
                    j = i;
                }
            }
            if( (double)(s)==(double)(0) )
            {
                result = f[j];
                return result;
            }
            if( (double)(Math.Abs(s))>(double)(threshold) )
            {
                
                //
                // use fast formula
                //
                j = -1;
                s = 1.0;
            }
            
            //
            // Calculate using safe or fast barycentric formula
            //
            s1 = 0;
            s2 = 0;
            ca = Math.Cos(a0);
            sa = Math.Sin(a0);
            p1 = 1.0;
            for(i=0; i<=n-1; i++)
            {
                
                //
                // Calculate X[i], W[i]
                //
                x = ca;
                w = p1*sa;
                
                //
                // Proceed
                //
                if( i!=j )
                {
                    v = s*w/(t-x);
                    s1 = s1+v*f[i];
                    s2 = s2+v;
                }
                else
                {
                    v = w;
                    s1 = s1+v*f[i];
                    s2 = s2+v;
                }
                
                //
                // Next CA, SA, P1
                //
                temps = sa-(alpha*sa-beta*ca);
                tempc = ca-(alpha*ca+beta*sa);
                sa = temps;
                ca = tempc;
                p1 = -p1;
            }
            result = s1/s2;
            return result;
        }


        /*************************************************************************
        Fast polynomial interpolation function on Chebyshev points (second kind)
        with O(N) complexity.

        INPUT PARAMETERS:
            A   -   left boundary of [A,B]
            B   -   right boundary of [A,B]
            F   -   function values, array[0..N-1]
            N   -   number of points on Chebyshev grid (second kind),
                    X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
                    for N=1 a constant model is constructed.
            T   -   position where P(x) is calculated

        RESULT
            value of the Lagrange interpolant at T

        IMPORTANT
            this function provides fast interface which is not overflow-safe
            nor it is very precise.
            the best option is to use PolIntBuildCheb2()/BarycentricCalc()
            subroutines unless you are pretty sure that your data will not result
            in overflow.

          -- ALGLIB --
             Copyright 02.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static double polynomialcalccheb2(double a,
            double b,
            double[] f,
            int n,
            double t,
            alglib.xparams _params)
        {
            double result = 0;
            double s1 = 0;
            double s2 = 0;
            double v = 0;
            double threshold = 0;
            double s = 0;
            int i = 0;
            int j = 0;
            double a0 = 0;
            double delta = 0;
            double alpha = 0;
            double beta = 0;
            double ca = 0;
            double sa = 0;
            double tempc = 0;
            double temps = 0;
            double x = 0;
            double w = 0;
            double p1 = 0;

            alglib.ap.assert(n>0, "PolynomialCalcCheb2: N<=0!");
            alglib.ap.assert(alglib.ap.len(f)>=n, "PolynomialCalcCheb2: Length(F)<N!");
            alglib.ap.assert(math.isfinite(a), "PolynomialCalcCheb2: A is infinite or NaN!");
            alglib.ap.assert(math.isfinite(b), "PolynomialCalcCheb2: B is infinite or NaN!");
            alglib.ap.assert((double)(b)!=(double)(a), "PolynomialCalcCheb2: B=A!");
            alglib.ap.assert(apserv.isfinitevector(f, n, _params), "PolynomialCalcCheb2: F contains infinite or NaN values!");
            alglib.ap.assert(!Double.IsInfinity(t), "PolynomialCalcEqDist: T is infinite!");
            
            //
            // Special case: T is NAN
            //
            if( Double.IsNaN(t) )
            {
                result = Double.NaN;
                return result;
            }
            
            //
            // Special case: N=1
            //
            if( n==1 )
            {
                result = f[0];
                return result;
            }
            
            //
            // Prepare information for the recurrence formula
            // used to calculate sin(pi*i/n) and
            // cos(pi*i/n):
            //
            // A0    = 0
            // Delta = pi/n
            // Alpha = 2 sin^2 (Delta/2)
            // Beta  = sin(Delta)
            //
            // so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
            // Then we use
            //
            // sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
            // cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
            //
            // to repeatedly calculate sin(..) and cos(..).
            //
            threshold = Math.Sqrt(math.minrealnumber);
            t = (t-0.5*(a+b))/(0.5*(b-a));
            a0 = 0.0;
            delta = Math.PI/(n-1);
            alpha = 2*math.sqr(Math.Sin(delta/2));
            beta = Math.Sin(delta);
            
            //
            // First, decide: should we use "safe" formula (guarded
            // against overflow) or fast one?
            //
            ca = Math.Cos(a0);
            sa = Math.Sin(a0);
            j = 0;
            x = ca;
            s = t-x;
            for(i=1; i<=n-1; i++)
            {
                
                //
                // Next X[i]
                //
                temps = sa-(alpha*sa-beta*ca);
                tempc = ca-(alpha*ca+beta*sa);
                sa = temps;
                ca = tempc;
                x = ca;
                
                //
                // Use X[i]
                //
                if( (double)(Math.Abs(t-x))<(double)(Math.Abs(s)) )
                {
                    s = t-x;
                    j = i;
                }
            }
            if( (double)(s)==(double)(0) )
            {
                result = f[j];
                return result;
            }
            if( (double)(Math.Abs(s))>(double)(threshold) )
            {
                
                //
                // use fast formula
                //
                j = -1;
                s = 1.0;
            }
            
            //
            // Calculate using safe or fast barycentric formula
            //
            s1 = 0;
            s2 = 0;
            ca = Math.Cos(a0);
            sa = Math.Sin(a0);
            p1 = 1.0;
            for(i=0; i<=n-1; i++)
            {
                
                //
                // Calculate X[i], W[i]
                //
                x = ca;
                if( i==0 || i==n-1 )
                {
                    w = 0.5*p1;
                }
                else
                {
                    w = 1.0*p1;
                }
                
                //
                // Proceed
                //
                if( i!=j )
                {
                    v = s*w/(t-x);
                    s1 = s1+v*f[i];
                    s2 = s2+v;
                }
                else
                {
                    v = w;
                    s1 = s1+v*f[i];
                    s2 = s2+v;
                }
                
                //
                // Next CA, SA, P1
                //
                temps = sa-(alpha*sa-beta*ca);
                tempc = ca-(alpha*ca+beta*sa);
                sa = temps;
                ca = tempc;
                p1 = -p1;
            }
            result = s1/s2;
            return result;
        }


    }
    public class spline1d
    {
        /*************************************************************************
        1-dimensional spline interpolant
        *************************************************************************/
        public class spline1dinterpolant : apobject
        {
            public bool periodic;
            public int n;
            public int k;
            public int continuity;
            public double[] x;
            public double[] c;
            public spline1dinterpolant()
            {
                init();
            }
            public override void init()
            {
                x = new double[0];
                c = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                spline1dinterpolant _result = new spline1dinterpolant();
                _result.periodic = periodic;
                _result.n = n;
                _result.k = k;
                _result.continuity = continuity;
                _result.x = (double[])x.Clone();
                _result.c = (double[])c.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Spline fitting report:
            RMSError        RMS error
            AvgError        average error
            AvgRelError     average relative error (for non-zero Y[I])
            MaxError        maximum error
            
        Fields  below are  filled  by   obsolete    functions   (Spline1DFitCubic,
        Spline1DFitHermite). Modern fitting functions do NOT fill these fields:
            TaskRCond       reciprocal of task's condition number
        *************************************************************************/
        public class spline1dfitreport : apobject
        {
            public double taskrcond;
            public double rmserror;
            public double avgerror;
            public double avgrelerror;
            public double maxerror;
            public spline1dfitreport()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                spline1dfitreport _result = new spline1dfitreport();
                _result.taskrcond = taskrcond;
                _result.rmserror = rmserror;
                _result.avgerror = avgerror;
                _result.avgrelerror = avgrelerror;
                _result.maxerror = maxerror;
                return _result;
            }
        };




        public const double lambdareg = 1.0e-9;
        public const double cholreg = 1.0e-12;


        /*************************************************************************
        This subroutine builds linear spline interpolant

        INPUT PARAMETERS:
            X   -   spline nodes, array[0..N-1]
            Y   -   function values, array[0..N-1]
            N   -   points count (optional):
                    * N>=2
                    * if given, only first N points are used to build spline
                    * if not given, automatically detected from X/Y sizes
                      (len(X) must be equal to len(Y))
            
        OUTPUT PARAMETERS:
            C   -   spline interpolant


        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.

          -- ALGLIB PROJECT --
             Copyright 24.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dbuildlinear(double[] x,
            double[] y,
            int n,
            spline1dinterpolant c,
            alglib.xparams _params)
        {
            int i = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();

            alglib.ap.assert(n>1, "Spline1DBuildLinear: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DBuildLinear: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DBuildLinear: Length(Y)<N!");
            
            //
            // check and sort points
            //
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DBuildLinear: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DBuildLinear: Y contains infinite or NAN values!");
            heapsortpoints(ref x, ref y, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DBuildLinear: at least two consequent points are too close!");
            
            //
            // Build
            //
            c.periodic = false;
            c.n = n;
            c.k = 3;
            c.continuity = 0;
            c.x = new double[n];
            c.c = new double[4*(n-1)+2];
            for(i=0; i<=n-1; i++)
            {
                c.x[i] = x[i];
            }
            for(i=0; i<=n-2; i++)
            {
                c.c[4*i+0] = y[i];
                c.c[4*i+1] = (y[i+1]-y[i])/(x[i+1]-x[i]);
                c.c[4*i+2] = 0;
                c.c[4*i+3] = 0;
            }
            c.c[4*(n-1)+0] = y[n-1];
            c.c[4*(n-1)+1] = c.c[4*(n-2)+1];
        }


        /*************************************************************************
        This subroutine builds cubic spline interpolant.

        INPUT PARAMETERS:
            X           -   spline nodes, array[0..N-1].
            Y           -   function values, array[0..N-1].
            
        OPTIONAL PARAMETERS:
            N           -   points count:
                            * N>=2
                            * if given, only first N points are used to build spline
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))
            BoundLType  -   boundary condition type for the left boundary
            BoundL      -   left boundary condition (first or second derivative,
                            depending on the BoundLType)
            BoundRType  -   boundary condition type for the right boundary
            BoundR      -   right boundary condition (first or second derivative,
                            depending on the BoundRType)

        OUTPUT PARAMETERS:
            C           -   spline interpolant

        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.

        SETTING BOUNDARY VALUES:

        The BoundLType/BoundRType parameters can have the following values:
            * -1, which corresonds to the periodic (cyclic) boundary conditions.
                  In this case:
                  * both BoundLType and BoundRType must be equal to -1.
                  * BoundL/BoundR are ignored
                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
            *  0, which  corresponds  to  the  parabolically   terminated  spline
                  (BoundL and/or BoundR are ignored).
            *  1, which corresponds to the first derivative boundary condition
            *  2, which corresponds to the second derivative boundary condition
            *  by default, BoundType=0 is used

        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
        However, this subroutine doesn't require you to specify equal  values  for
        the first and last points - it automatically forces them  to  be  equal by
        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
        Y[last_point]. However it is recommended to pass consistent values of Y[],
        i.e. to make Y[first_point]=Y[last_point].

          -- ALGLIB PROJECT --
             Copyright 23.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dbuildcubic(double[] x,
            double[] y,
            int n,
            int boundltype,
            double boundl,
            int boundrtype,
            double boundr,
            spline1dinterpolant c,
            alglib.xparams _params)
        {
            double[] a1 = new double[0];
            double[] a2 = new double[0];
            double[] a3 = new double[0];
            double[] b = new double[0];
            double[] dt = new double[0];
            double[] d = new double[0];
            int[] p = new int[0];
            int ylen = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();

            
            //
            // check correctness of boundary conditions
            //
            alglib.ap.assert(((boundltype==-1 || boundltype==0) || boundltype==1) || boundltype==2, "Spline1DBuildCubic: incorrect BoundLType!");
            alglib.ap.assert(((boundrtype==-1 || boundrtype==0) || boundrtype==1) || boundrtype==2, "Spline1DBuildCubic: incorrect BoundRType!");
            alglib.ap.assert((boundrtype==-1 && boundltype==-1) || (boundrtype!=-1 && boundltype!=-1), "Spline1DBuildCubic: incorrect BoundLType/BoundRType!");
            if( boundltype==1 || boundltype==2 )
            {
                alglib.ap.assert(math.isfinite(boundl), "Spline1DBuildCubic: BoundL is infinite or NAN!");
            }
            if( boundrtype==1 || boundrtype==2 )
            {
                alglib.ap.assert(math.isfinite(boundr), "Spline1DBuildCubic: BoundR is infinite or NAN!");
            }
            
            //
            // check lengths of arguments
            //
            alglib.ap.assert(n>=2, "Spline1DBuildCubic: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DBuildCubic: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DBuildCubic: Length(Y)<N!");
            
            //
            // check and sort points
            //
            ylen = n;
            if( boundltype==-1 )
            {
                ylen = n-1;
            }
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DBuildCubic: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, ylen, _params), "Spline1DBuildCubic: Y contains infinite or NAN values!");
            heapsortppoints(ref x, ref y, ref p, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DBuildCubic: at least two consequent points are too close!");
            
            //
            // Now we've checked and preordered everything,
            // so we can call internal function to calculate derivatives,
            // and then build Hermite spline using these derivatives
            //
            if( boundltype==-1 || boundrtype==-1 )
            {
                y[n-1] = y[0];
            }
            spline1dgriddiffcubicinternal(x, ref y, n, boundltype, boundl, boundrtype, boundr, ref d, ref a1, ref a2, ref a3, ref b, ref dt, _params);
            spline1dbuildhermite(x, y, d, n, c, _params);
            c.periodic = boundltype==-1 || boundrtype==-1;
            c.continuity = 2;
        }


        /*************************************************************************
        This function solves following problem: given table y[] of function values
        at nodes x[], it calculates and returns table of function derivatives  d[]
        (calculated at the same nodes x[]).

        This function yields same result as Spline1DBuildCubic() call followed  by
        sequence of Spline1DDiff() calls, but it can be several times faster  when
        called for ordered X[] and X2[].

        INPUT PARAMETERS:
            X           -   spline nodes
            Y           -   function values

        OPTIONAL PARAMETERS:
            N           -   points count:
                            * N>=2
                            * if given, only first N points are used
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))
            BoundLType  -   boundary condition type for the left boundary
            BoundL      -   left boundary condition (first or second derivative,
                            depending on the BoundLType)
            BoundRType  -   boundary condition type for the right boundary
            BoundR      -   right boundary condition (first or second derivative,
                            depending on the BoundRType)

        OUTPUT PARAMETERS:
            D           -   derivative values at X[]

        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.
        Derivative values are correctly reordered on return, so  D[I]  is  always
        equal to S'(X[I]) independently of points order.

        SETTING BOUNDARY VALUES:

        The BoundLType/BoundRType parameters can have the following values:
            * -1, which corresonds to the periodic (cyclic) boundary conditions.
                  In this case:
                  * both BoundLType and BoundRType must be equal to -1.
                  * BoundL/BoundR are ignored
                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
            *  0, which  corresponds  to  the  parabolically   terminated  spline
                  (BoundL and/or BoundR are ignored).
            *  1, which corresponds to the first derivative boundary condition
            *  2, which corresponds to the second derivative boundary condition
            *  by default, BoundType=0 is used

        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
        However, this subroutine doesn't require you to specify equal  values  for
        the first and last points - it automatically forces them  to  be  equal by
        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
        Y[last_point]. However it is recommended to pass consistent values of Y[],
        i.e. to make Y[first_point]=Y[last_point].

          -- ALGLIB PROJECT --
             Copyright 03.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dgriddiffcubic(double[] x,
            double[] y,
            int n,
            int boundltype,
            double boundl,
            int boundrtype,
            double boundr,
            ref double[] d,
            alglib.xparams _params)
        {
            double[] a1 = new double[0];
            double[] a2 = new double[0];
            double[] a3 = new double[0];
            double[] b = new double[0];
            double[] dt = new double[0];
            int[] p = new int[0];
            int i = 0;
            int ylen = 0;
            int i_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            d = new double[0];

            
            //
            // check correctness of boundary conditions
            //
            alglib.ap.assert(((boundltype==-1 || boundltype==0) || boundltype==1) || boundltype==2, "Spline1DGridDiffCubic: incorrect BoundLType!");
            alglib.ap.assert(((boundrtype==-1 || boundrtype==0) || boundrtype==1) || boundrtype==2, "Spline1DGridDiffCubic: incorrect BoundRType!");
            alglib.ap.assert((boundrtype==-1 && boundltype==-1) || (boundrtype!=-1 && boundltype!=-1), "Spline1DGridDiffCubic: incorrect BoundLType/BoundRType!");
            if( boundltype==1 || boundltype==2 )
            {
                alglib.ap.assert(math.isfinite(boundl), "Spline1DGridDiffCubic: BoundL is infinite or NAN!");
            }
            if( boundrtype==1 || boundrtype==2 )
            {
                alglib.ap.assert(math.isfinite(boundr), "Spline1DGridDiffCubic: BoundR is infinite or NAN!");
            }
            
            //
            // check lengths of arguments
            //
            alglib.ap.assert(n>=2, "Spline1DGridDiffCubic: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DGridDiffCubic: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DGridDiffCubic: Length(Y)<N!");
            
            //
            // check and sort points
            //
            ylen = n;
            if( boundltype==-1 )
            {
                ylen = n-1;
            }
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DGridDiffCubic: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, ylen, _params), "Spline1DGridDiffCubic: Y contains infinite or NAN values!");
            heapsortppoints(ref x, ref y, ref p, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DGridDiffCubic: at least two consequent points are too close!");
            
            //
            // Now we've checked and preordered everything,
            // so we can call internal function.
            //
            spline1dgriddiffcubicinternal(x, ref y, n, boundltype, boundl, boundrtype, boundr, ref d, ref a1, ref a2, ref a3, ref b, ref dt, _params);
            
            //
            // Remember that HeapSortPPoints() call?
            // Now we have to reorder them back.
            //
            if( alglib.ap.len(dt)<n )
            {
                dt = new double[n];
            }
            for(i=0; i<=n-1; i++)
            {
                dt[p[i]] = d[i];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                d[i_] = dt[i_];
            }
        }


        /*************************************************************************
        This function solves following problem: given table y[] of function values
        at  nodes  x[],  it  calculates  and  returns  tables  of first and second
        function derivatives d1[] and d2[] (calculated at the same nodes x[]).

        This function yields same result as Spline1DBuildCubic() call followed  by
        sequence of Spline1DDiff() calls, but it can be several times faster  when
        called for ordered X[] and X2[].

        INPUT PARAMETERS:
            X           -   spline nodes
            Y           -   function values

        OPTIONAL PARAMETERS:
            N           -   points count:
                            * N>=2
                            * if given, only first N points are used
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))
            BoundLType  -   boundary condition type for the left boundary
            BoundL      -   left boundary condition (first or second derivative,
                            depending on the BoundLType)
            BoundRType  -   boundary condition type for the right boundary
            BoundR      -   right boundary condition (first or second derivative,
                            depending on the BoundRType)

        OUTPUT PARAMETERS:
            D1          -   S' values at X[]
            D2          -   S'' values at X[]

        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.
        Derivative values are correctly reordered on return, so  D[I]  is  always
        equal to S'(X[I]) independently of points order.

        SETTING BOUNDARY VALUES:

        The BoundLType/BoundRType parameters can have the following values:
            * -1, which corresonds to the periodic (cyclic) boundary conditions.
                  In this case:
                  * both BoundLType and BoundRType must be equal to -1.
                  * BoundL/BoundR are ignored
                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
            *  0, which  corresponds  to  the  parabolically   terminated  spline
                  (BoundL and/or BoundR are ignored).
            *  1, which corresponds to the first derivative boundary condition
            *  2, which corresponds to the second derivative boundary condition
            *  by default, BoundType=0 is used

        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
        However, this subroutine doesn't require you to specify equal  values  for
        the first and last points - it automatically forces them  to  be  equal by
        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
        Y[last_point]. However it is recommended to pass consistent values of Y[],
        i.e. to make Y[first_point]=Y[last_point].

          -- ALGLIB PROJECT --
             Copyright 03.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dgriddiff2cubic(double[] x,
            double[] y,
            int n,
            int boundltype,
            double boundl,
            int boundrtype,
            double boundr,
            ref double[] d1,
            ref double[] d2,
            alglib.xparams _params)
        {
            double[] a1 = new double[0];
            double[] a2 = new double[0];
            double[] a3 = new double[0];
            double[] b = new double[0];
            double[] dt = new double[0];
            int[] p = new int[0];
            int i = 0;
            int ylen = 0;
            double delta = 0;
            double delta2 = 0;
            double delta3 = 0;
            double s2 = 0;
            double s3 = 0;
            int i_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            d1 = new double[0];
            d2 = new double[0];

            
            //
            // check correctness of boundary conditions
            //
            alglib.ap.assert(((boundltype==-1 || boundltype==0) || boundltype==1) || boundltype==2, "Spline1DGridDiff2Cubic: incorrect BoundLType!");
            alglib.ap.assert(((boundrtype==-1 || boundrtype==0) || boundrtype==1) || boundrtype==2, "Spline1DGridDiff2Cubic: incorrect BoundRType!");
            alglib.ap.assert((boundrtype==-1 && boundltype==-1) || (boundrtype!=-1 && boundltype!=-1), "Spline1DGridDiff2Cubic: incorrect BoundLType/BoundRType!");
            if( boundltype==1 || boundltype==2 )
            {
                alglib.ap.assert(math.isfinite(boundl), "Spline1DGridDiff2Cubic: BoundL is infinite or NAN!");
            }
            if( boundrtype==1 || boundrtype==2 )
            {
                alglib.ap.assert(math.isfinite(boundr), "Spline1DGridDiff2Cubic: BoundR is infinite or NAN!");
            }
            
            //
            // check lengths of arguments
            //
            alglib.ap.assert(n>=2, "Spline1DGridDiff2Cubic: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DGridDiff2Cubic: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DGridDiff2Cubic: Length(Y)<N!");
            
            //
            // check and sort points
            //
            ylen = n;
            if( boundltype==-1 )
            {
                ylen = n-1;
            }
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DGridDiff2Cubic: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, ylen, _params), "Spline1DGridDiff2Cubic: Y contains infinite or NAN values!");
            heapsortppoints(ref x, ref y, ref p, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DGridDiff2Cubic: at least two consequent points are too close!");
            
            //
            // Now we've checked and preordered everything,
            // so we can call internal function.
            //
            // After this call we will calculate second derivatives
            // (manually, by converting to the power basis)
            //
            spline1dgriddiffcubicinternal(x, ref y, n, boundltype, boundl, boundrtype, boundr, ref d1, ref a1, ref a2, ref a3, ref b, ref dt, _params);
            d2 = new double[n];
            delta = 0;
            s2 = 0;
            s3 = 0;
            for(i=0; i<=n-2; i++)
            {
                
                //
                // We convert from Hermite basis to the power basis.
                // Si is coefficient before x^i.
                //
                // Inside this cycle we need just S2,
                // because we calculate S'' exactly at spline node,
                // (only x^2 matters at x=0), but after iterations
                // will be over, we will need other coefficients
                // to calculate spline value at the last node.
                //
                delta = x[i+1]-x[i];
                delta2 = math.sqr(delta);
                delta3 = delta*delta2;
                s2 = (3*(y[i+1]-y[i])-2*d1[i]*delta-d1[i+1]*delta)/delta2;
                s3 = (2*(y[i]-y[i+1])+d1[i]*delta+d1[i+1]*delta)/delta3;
                d2[i] = 2*s2;
            }
            d2[n-1] = 2*s2+6*s3*delta;
            
            //
            // Remember that HeapSortPPoints() call?
            // Now we have to reorder them back.
            //
            if( alglib.ap.len(dt)<n )
            {
                dt = new double[n];
            }
            for(i=0; i<=n-1; i++)
            {
                dt[p[i]] = d1[i];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                d1[i_] = dt[i_];
            }
            for(i=0; i<=n-1; i++)
            {
                dt[p[i]] = d2[i];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                d2[i_] = dt[i_];
            }
        }


        /*************************************************************************
        This function solves following problem: given table y[] of function values
        at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
        function values y2[] (calculated at x2[]).

        This function yields same result as Spline1DBuildCubic() call followed  by
        sequence of Spline1DDiff() calls, but it can be several times faster  when
        called for ordered X[] and X2[].

        INPUT PARAMETERS:
            X           -   old spline nodes
            Y           -   function values
            X2           -  new spline nodes

        OPTIONAL PARAMETERS:
            N           -   points count:
                            * N>=2
                            * if given, only first N points from X/Y are used
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))
            BoundLType  -   boundary condition type for the left boundary
            BoundL      -   left boundary condition (first or second derivative,
                            depending on the BoundLType)
            BoundRType  -   boundary condition type for the right boundary
            BoundR      -   right boundary condition (first or second derivative,
                            depending on the BoundRType)
            N2          -   new points count:
                            * N2>=2
                            * if given, only first N2 points from X2 are used
                            * if not given, automatically detected from X2 size

        OUTPUT PARAMETERS:
            F2          -   function values at X2[]

        ORDER OF POINTS

        Subroutine automatically sorts points, so caller  may pass unsorted array.
        Function  values  are correctly reordered on  return, so F2[I]  is  always
        equal to S(X2[I]) independently of points order.

        SETTING BOUNDARY VALUES:

        The BoundLType/BoundRType parameters can have the following values:
            * -1, which corresonds to the periodic (cyclic) boundary conditions.
                  In this case:
                  * both BoundLType and BoundRType must be equal to -1.
                  * BoundL/BoundR are ignored
                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
            *  0, which  corresponds  to  the  parabolically   terminated  spline
                  (BoundL and/or BoundR are ignored).
            *  1, which corresponds to the first derivative boundary condition
            *  2, which corresponds to the second derivative boundary condition
            *  by default, BoundType=0 is used

        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
        However, this subroutine doesn't require you to specify equal  values  for
        the first and last points - it automatically forces them  to  be  equal by
        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
        Y[last_point]. However it is recommended to pass consistent values of Y[],
        i.e. to make Y[first_point]=Y[last_point].

          -- ALGLIB PROJECT --
             Copyright 03.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dconvcubic(double[] x,
            double[] y,
            int n,
            int boundltype,
            double boundl,
            int boundrtype,
            double boundr,
            double[] x2,
            int n2,
            ref double[] y2,
            alglib.xparams _params)
        {
            double[] a1 = new double[0];
            double[] a2 = new double[0];
            double[] a3 = new double[0];
            double[] b = new double[0];
            double[] d = new double[0];
            double[] dt = new double[0];
            double[] d1 = new double[0];
            double[] d2 = new double[0];
            int[] p = new int[0];
            int[] p2 = new int[0];
            int i = 0;
            int ylen = 0;
            double t = 0;
            double t2 = 0;
            int i_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            x2 = (double[])x2.Clone();
            y2 = new double[0];

            
            //
            // check correctness of boundary conditions
            //
            alglib.ap.assert(((boundltype==-1 || boundltype==0) || boundltype==1) || boundltype==2, "Spline1DConvCubic: incorrect BoundLType!");
            alglib.ap.assert(((boundrtype==-1 || boundrtype==0) || boundrtype==1) || boundrtype==2, "Spline1DConvCubic: incorrect BoundRType!");
            alglib.ap.assert((boundrtype==-1 && boundltype==-1) || (boundrtype!=-1 && boundltype!=-1), "Spline1DConvCubic: incorrect BoundLType/BoundRType!");
            if( boundltype==1 || boundltype==2 )
            {
                alglib.ap.assert(math.isfinite(boundl), "Spline1DConvCubic: BoundL is infinite or NAN!");
            }
            if( boundrtype==1 || boundrtype==2 )
            {
                alglib.ap.assert(math.isfinite(boundr), "Spline1DConvCubic: BoundR is infinite or NAN!");
            }
            
            //
            // check lengths of arguments
            //
            alglib.ap.assert(n>=2, "Spline1DConvCubic: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DConvCubic: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DConvCubic: Length(Y)<N!");
            alglib.ap.assert(n2>=2, "Spline1DConvCubic: N2<2!");
            alglib.ap.assert(alglib.ap.len(x2)>=n2, "Spline1DConvCubic: Length(X2)<N2!");
            
            //
            // check and sort X/Y
            //
            ylen = n;
            if( boundltype==-1 )
            {
                ylen = n-1;
            }
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DConvCubic: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, ylen, _params), "Spline1DConvCubic: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(x2, n2, _params), "Spline1DConvCubic: X2 contains infinite or NAN values!");
            heapsortppoints(ref x, ref y, ref p, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DConvCubic: at least two consequent points are too close!");
            
            //
            // set up DT (we will need it below)
            //
            dt = new double[Math.Max(n, n2)];
            
            //
            // sort X2:
            // * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
            // * if we have periodic problem, wrap points
            // * sort them, store permutation at P2
            //
            if( boundrtype==-1 && boundltype==-1 )
            {
                for(i=0; i<=n2-1; i++)
                {
                    t = x2[i];
                    apserv.apperiodicmap(ref t, x[0], x[n-1], ref t2, _params);
                    x2[i] = t;
                }
            }
            heapsortppoints(ref x2, ref dt, ref p2, n2, _params);
            
            //
            // Now we've checked and preordered everything, so we:
            // * call internal GridDiff() function to get Hermite form of spline
            // * convert using internal Conv() function
            // * convert Y2 back to original order
            //
            spline1dgriddiffcubicinternal(x, ref y, n, boundltype, boundl, boundrtype, boundr, ref d, ref a1, ref a2, ref a3, ref b, ref dt, _params);
            spline1dconvdiffinternal(x, y, d, n, x2, n2, ref y2, true, ref d1, false, ref d2, false, _params);
            alglib.ap.assert(alglib.ap.len(dt)>=n2, "Spline1DConvCubic: internal error!");
            for(i=0; i<=n2-1; i++)
            {
                dt[p2[i]] = y2[i];
            }
            for(i_=0; i_<=n2-1;i_++)
            {
                y2[i_] = dt[i_];
            }
        }


        /*************************************************************************
        This function solves following problem: given table y[] of function values
        at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
        function values y2[] and derivatives d2[] (calculated at x2[]).

        This function yields same result as Spline1DBuildCubic() call followed  by
        sequence of Spline1DDiff() calls, but it can be several times faster  when
        called for ordered X[] and X2[].

        INPUT PARAMETERS:
            X           -   old spline nodes
            Y           -   function values
            X2           -  new spline nodes

        OPTIONAL PARAMETERS:
            N           -   points count:
                            * N>=2
                            * if given, only first N points from X/Y are used
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))
            BoundLType  -   boundary condition type for the left boundary
            BoundL      -   left boundary condition (first or second derivative,
                            depending on the BoundLType)
            BoundRType  -   boundary condition type for the right boundary
            BoundR      -   right boundary condition (first or second derivative,
                            depending on the BoundRType)
            N2          -   new points count:
                            * N2>=2
                            * if given, only first N2 points from X2 are used
                            * if not given, automatically detected from X2 size

        OUTPUT PARAMETERS:
            F2          -   function values at X2[]
            D2          -   first derivatives at X2[]

        ORDER OF POINTS

        Subroutine automatically sorts points, so caller  may pass unsorted array.
        Function  values  are correctly reordered on  return, so F2[I]  is  always
        equal to S(X2[I]) independently of points order.

        SETTING BOUNDARY VALUES:

        The BoundLType/BoundRType parameters can have the following values:
            * -1, which corresonds to the periodic (cyclic) boundary conditions.
                  In this case:
                  * both BoundLType and BoundRType must be equal to -1.
                  * BoundL/BoundR are ignored
                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
            *  0, which  corresponds  to  the  parabolically   terminated  spline
                  (BoundL and/or BoundR are ignored).
            *  1, which corresponds to the first derivative boundary condition
            *  2, which corresponds to the second derivative boundary condition
            *  by default, BoundType=0 is used

        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
        However, this subroutine doesn't require you to specify equal  values  for
        the first and last points - it automatically forces them  to  be  equal by
        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
        Y[last_point]. However it is recommended to pass consistent values of Y[],
        i.e. to make Y[first_point]=Y[last_point].

          -- ALGLIB PROJECT --
             Copyright 03.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dconvdiffcubic(double[] x,
            double[] y,
            int n,
            int boundltype,
            double boundl,
            int boundrtype,
            double boundr,
            double[] x2,
            int n2,
            ref double[] y2,
            ref double[] d2,
            alglib.xparams _params)
        {
            double[] a1 = new double[0];
            double[] a2 = new double[0];
            double[] a3 = new double[0];
            double[] b = new double[0];
            double[] d = new double[0];
            double[] dt = new double[0];
            double[] rt1 = new double[0];
            int[] p = new int[0];
            int[] p2 = new int[0];
            int i = 0;
            int ylen = 0;
            double t = 0;
            double t2 = 0;
            int i_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            x2 = (double[])x2.Clone();
            y2 = new double[0];
            d2 = new double[0];

            
            //
            // check correctness of boundary conditions
            //
            alglib.ap.assert(((boundltype==-1 || boundltype==0) || boundltype==1) || boundltype==2, "Spline1DConvDiffCubic: incorrect BoundLType!");
            alglib.ap.assert(((boundrtype==-1 || boundrtype==0) || boundrtype==1) || boundrtype==2, "Spline1DConvDiffCubic: incorrect BoundRType!");
            alglib.ap.assert((boundrtype==-1 && boundltype==-1) || (boundrtype!=-1 && boundltype!=-1), "Spline1DConvDiffCubic: incorrect BoundLType/BoundRType!");
            if( boundltype==1 || boundltype==2 )
            {
                alglib.ap.assert(math.isfinite(boundl), "Spline1DConvDiffCubic: BoundL is infinite or NAN!");
            }
            if( boundrtype==1 || boundrtype==2 )
            {
                alglib.ap.assert(math.isfinite(boundr), "Spline1DConvDiffCubic: BoundR is infinite or NAN!");
            }
            
            //
            // check lengths of arguments
            //
            alglib.ap.assert(n>=2, "Spline1DConvDiffCubic: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DConvDiffCubic: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DConvDiffCubic: Length(Y)<N!");
            alglib.ap.assert(n2>=2, "Spline1DConvDiffCubic: N2<2!");
            alglib.ap.assert(alglib.ap.len(x2)>=n2, "Spline1DConvDiffCubic: Length(X2)<N2!");
            
            //
            // check and sort X/Y
            //
            ylen = n;
            if( boundltype==-1 )
            {
                ylen = n-1;
            }
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DConvDiffCubic: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, ylen, _params), "Spline1DConvDiffCubic: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(x2, n2, _params), "Spline1DConvDiffCubic: X2 contains infinite or NAN values!");
            heapsortppoints(ref x, ref y, ref p, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DConvDiffCubic: at least two consequent points are too close!");
            
            //
            // set up DT (we will need it below)
            //
            dt = new double[Math.Max(n, n2)];
            
            //
            // sort X2:
            // * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
            // * if we have periodic problem, wrap points
            // * sort them, store permutation at P2
            //
            if( boundrtype==-1 && boundltype==-1 )
            {
                for(i=0; i<=n2-1; i++)
                {
                    t = x2[i];
                    apserv.apperiodicmap(ref t, x[0], x[n-1], ref t2, _params);
                    x2[i] = t;
                }
            }
            heapsortppoints(ref x2, ref dt, ref p2, n2, _params);
            
            //
            // Now we've checked and preordered everything, so we:
            // * call internal GridDiff() function to get Hermite form of spline
            // * convert using internal Conv() function
            // * convert Y2 back to original order
            //
            spline1dgriddiffcubicinternal(x, ref y, n, boundltype, boundl, boundrtype, boundr, ref d, ref a1, ref a2, ref a3, ref b, ref dt, _params);
            spline1dconvdiffinternal(x, y, d, n, x2, n2, ref y2, true, ref d2, true, ref rt1, false, _params);
            alglib.ap.assert(alglib.ap.len(dt)>=n2, "Spline1DConvDiffCubic: internal error!");
            for(i=0; i<=n2-1; i++)
            {
                dt[p2[i]] = y2[i];
            }
            for(i_=0; i_<=n2-1;i_++)
            {
                y2[i_] = dt[i_];
            }
            for(i=0; i<=n2-1; i++)
            {
                dt[p2[i]] = d2[i];
            }
            for(i_=0; i_<=n2-1;i_++)
            {
                d2[i_] = dt[i_];
            }
        }


        /*************************************************************************
        This function solves following problem: given table y[] of function values
        at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
        function  values  y2[],  first  and  second  derivatives  d2[]  and  dd2[]
        (calculated at x2[]).

        This function yields same result as Spline1DBuildCubic() call followed  by
        sequence of Spline1DDiff() calls, but it can be several times faster  when
        called for ordered X[] and X2[].

        INPUT PARAMETERS:
            X           -   old spline nodes
            Y           -   function values
            X2           -  new spline nodes

        OPTIONAL PARAMETERS:
            N           -   points count:
                            * N>=2
                            * if given, only first N points from X/Y are used
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))
            BoundLType  -   boundary condition type for the left boundary
            BoundL      -   left boundary condition (first or second derivative,
                            depending on the BoundLType)
            BoundRType  -   boundary condition type for the right boundary
            BoundR      -   right boundary condition (first or second derivative,
                            depending on the BoundRType)
            N2          -   new points count:
                            * N2>=2
                            * if given, only first N2 points from X2 are used
                            * if not given, automatically detected from X2 size

        OUTPUT PARAMETERS:
            F2          -   function values at X2[]
            D2          -   first derivatives at X2[]
            DD2         -   second derivatives at X2[]

        ORDER OF POINTS

        Subroutine automatically sorts points, so caller  may pass unsorted array.
        Function  values  are correctly reordered on  return, so F2[I]  is  always
        equal to S(X2[I]) independently of points order.

        SETTING BOUNDARY VALUES:

        The BoundLType/BoundRType parameters can have the following values:
            * -1, which corresonds to the periodic (cyclic) boundary conditions.
                  In this case:
                  * both BoundLType and BoundRType must be equal to -1.
                  * BoundL/BoundR are ignored
                  * Y[last] is ignored (it is assumed to be equal to Y[first]).
            *  0, which  corresponds  to  the  parabolically   terminated  spline
                  (BoundL and/or BoundR are ignored).
            *  1, which corresponds to the first derivative boundary condition
            *  2, which corresponds to the second derivative boundary condition
            *  by default, BoundType=0 is used

        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
        However, this subroutine doesn't require you to specify equal  values  for
        the first and last points - it automatically forces them  to  be  equal by
        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
        Y[last_point]. However it is recommended to pass consistent values of Y[],
        i.e. to make Y[first_point]=Y[last_point].

          -- ALGLIB PROJECT --
             Copyright 03.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dconvdiff2cubic(double[] x,
            double[] y,
            int n,
            int boundltype,
            double boundl,
            int boundrtype,
            double boundr,
            double[] x2,
            int n2,
            ref double[] y2,
            ref double[] d2,
            ref double[] dd2,
            alglib.xparams _params)
        {
            double[] a1 = new double[0];
            double[] a2 = new double[0];
            double[] a3 = new double[0];
            double[] b = new double[0];
            double[] d = new double[0];
            double[] dt = new double[0];
            int[] p = new int[0];
            int[] p2 = new int[0];
            int i = 0;
            int ylen = 0;
            double t = 0;
            double t2 = 0;
            int i_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            x2 = (double[])x2.Clone();
            y2 = new double[0];
            d2 = new double[0];
            dd2 = new double[0];

            
            //
            // check correctness of boundary conditions
            //
            alglib.ap.assert(((boundltype==-1 || boundltype==0) || boundltype==1) || boundltype==2, "Spline1DConvDiff2Cubic: incorrect BoundLType!");
            alglib.ap.assert(((boundrtype==-1 || boundrtype==0) || boundrtype==1) || boundrtype==2, "Spline1DConvDiff2Cubic: incorrect BoundRType!");
            alglib.ap.assert((boundrtype==-1 && boundltype==-1) || (boundrtype!=-1 && boundltype!=-1), "Spline1DConvDiff2Cubic: incorrect BoundLType/BoundRType!");
            if( boundltype==1 || boundltype==2 )
            {
                alglib.ap.assert(math.isfinite(boundl), "Spline1DConvDiff2Cubic: BoundL is infinite or NAN!");
            }
            if( boundrtype==1 || boundrtype==2 )
            {
                alglib.ap.assert(math.isfinite(boundr), "Spline1DConvDiff2Cubic: BoundR is infinite or NAN!");
            }
            
            //
            // check lengths of arguments
            //
            alglib.ap.assert(n>=2, "Spline1DConvDiff2Cubic: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DConvDiff2Cubic: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DConvDiff2Cubic: Length(Y)<N!");
            alglib.ap.assert(n2>=2, "Spline1DConvDiff2Cubic: N2<2!");
            alglib.ap.assert(alglib.ap.len(x2)>=n2, "Spline1DConvDiff2Cubic: Length(X2)<N2!");
            
            //
            // check and sort X/Y
            //
            ylen = n;
            if( boundltype==-1 )
            {
                ylen = n-1;
            }
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DConvDiff2Cubic: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, ylen, _params), "Spline1DConvDiff2Cubic: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(x2, n2, _params), "Spline1DConvDiff2Cubic: X2 contains infinite or NAN values!");
            heapsortppoints(ref x, ref y, ref p, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DConvDiff2Cubic: at least two consequent points are too close!");
            
            //
            // set up DT (we will need it below)
            //
            dt = new double[Math.Max(n, n2)];
            
            //
            // sort X2:
            // * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
            // * if we have periodic problem, wrap points
            // * sort them, store permutation at P2
            //
            if( boundrtype==-1 && boundltype==-1 )
            {
                for(i=0; i<=n2-1; i++)
                {
                    t = x2[i];
                    apserv.apperiodicmap(ref t, x[0], x[n-1], ref t2, _params);
                    x2[i] = t;
                }
            }
            heapsortppoints(ref x2, ref dt, ref p2, n2, _params);
            
            //
            // Now we've checked and preordered everything, so we:
            // * call internal GridDiff() function to get Hermite form of spline
            // * convert using internal Conv() function
            // * convert Y2 back to original order
            //
            spline1dgriddiffcubicinternal(x, ref y, n, boundltype, boundl, boundrtype, boundr, ref d, ref a1, ref a2, ref a3, ref b, ref dt, _params);
            spline1dconvdiffinternal(x, y, d, n, x2, n2, ref y2, true, ref d2, true, ref dd2, true, _params);
            alglib.ap.assert(alglib.ap.len(dt)>=n2, "Spline1DConvDiff2Cubic: internal error!");
            for(i=0; i<=n2-1; i++)
            {
                dt[p2[i]] = y2[i];
            }
            for(i_=0; i_<=n2-1;i_++)
            {
                y2[i_] = dt[i_];
            }
            for(i=0; i<=n2-1; i++)
            {
                dt[p2[i]] = d2[i];
            }
            for(i_=0; i_<=n2-1;i_++)
            {
                d2[i_] = dt[i_];
            }
            for(i=0; i<=n2-1; i++)
            {
                dt[p2[i]] = dd2[i];
            }
            for(i_=0; i_<=n2-1;i_++)
            {
                dd2[i_] = dt[i_];
            }
        }


        /*************************************************************************
        This subroutine builds Catmull-Rom spline interpolant.

        INPUT PARAMETERS:
            X           -   spline nodes, array[0..N-1].
            Y           -   function values, array[0..N-1].
            
        OPTIONAL PARAMETERS:
            N           -   points count:
                            * N>=2
                            * if given, only first N points are used to build spline
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))
            BoundType   -   boundary condition type:
                            * -1 for periodic boundary condition
                            *  0 for parabolically terminated spline (default)
            Tension     -   tension parameter:
                            * tension=0   corresponds to classic Catmull-Rom spline (default)
                            * 0<tension<1 corresponds to more general form - cardinal spline

        OUTPUT PARAMETERS:
            C           -   spline interpolant


        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.

        PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:

        Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
        However, this subroutine doesn't require you to specify equal  values  for
        the first and last points - it automatically forces them  to  be  equal by
        copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
        Y[last_point]. However it is recommended to pass consistent values of Y[],
        i.e. to make Y[first_point]=Y[last_point].

          -- ALGLIB PROJECT --
             Copyright 23.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dbuildcatmullrom(double[] x,
            double[] y,
            int n,
            int boundtype,
            double tension,
            spline1dinterpolant c,
            alglib.xparams _params)
        {
            double[] d = new double[0];
            int i = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();

            alglib.ap.assert(n>=2, "Spline1DBuildCatmullRom: N<2!");
            alglib.ap.assert(boundtype==-1 || boundtype==0, "Spline1DBuildCatmullRom: incorrect BoundType!");
            alglib.ap.assert((double)(tension)>=(double)(0), "Spline1DBuildCatmullRom: Tension<0!");
            alglib.ap.assert((double)(tension)<=(double)(1), "Spline1DBuildCatmullRom: Tension>1!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DBuildCatmullRom: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DBuildCatmullRom: Length(Y)<N!");
            
            //
            // check and sort points
            //
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DBuildCatmullRom: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DBuildCatmullRom: Y contains infinite or NAN values!");
            heapsortpoints(ref x, ref y, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DBuildCatmullRom: at least two consequent points are too close!");
            
            //
            // Special cases:
            // * N=2, parabolic terminated boundary condition on both ends
            // * N=2, periodic boundary condition
            //
            if( n==2 && boundtype==0 )
            {
                
                //
                // Just linear spline
                //
                spline1dbuildlinear(x, y, n, c, _params);
                return;
            }
            if( n==2 && boundtype==-1 )
            {
                
                //
                // Same as cubic spline with periodic conditions
                //
                spline1dbuildcubic(x, y, n, -1, 0.0, -1, 0.0, c, _params);
                return;
            }
            
            //
            // Periodic or non-periodic boundary conditions
            //
            if( boundtype==-1 )
            {
                
                //
                // Periodic boundary conditions
                //
                y[n-1] = y[0];
                d = new double[n];
                d[0] = (y[1]-y[n-2])/(2*(x[1]-x[0]+x[n-1]-x[n-2]));
                for(i=1; i<=n-2; i++)
                {
                    d[i] = (1-tension)*(y[i+1]-y[i-1])/(x[i+1]-x[i-1]);
                }
                d[n-1] = d[0];
                
                //
                // Now problem is reduced to the cubic Hermite spline
                //
                spline1dbuildhermite(x, y, d, n, c, _params);
                c.periodic = true;
            }
            else
            {
                
                //
                // Non-periodic boundary conditions
                //
                d = new double[n];
                for(i=1; i<=n-2; i++)
                {
                    d[i] = (1-tension)*(y[i+1]-y[i-1])/(x[i+1]-x[i-1]);
                }
                d[0] = 2*(y[1]-y[0])/(x[1]-x[0])-d[1];
                d[n-1] = 2*(y[n-1]-y[n-2])/(x[n-1]-x[n-2])-d[n-2];
                
                //
                // Now problem is reduced to the cubic Hermite spline
                //
                spline1dbuildhermite(x, y, d, n, c, _params);
            }
        }


        /*************************************************************************
        This subroutine builds Hermite spline interpolant.

        INPUT PARAMETERS:
            X           -   spline nodes, array[0..N-1]
            Y           -   function values, array[0..N-1]
            D           -   derivatives, array[0..N-1]
            N           -   points count (optional):
                            * N>=2
                            * if given, only first N points are used to build spline
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))

        OUTPUT PARAMETERS:
            C           -   spline interpolant.


        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.

          -- ALGLIB PROJECT --
             Copyright 23.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dbuildhermite(double[] x,
            double[] y,
            double[] d,
            int n,
            spline1dinterpolant c,
            alglib.xparams _params)
        {
            int i = 0;
            double delta = 0;
            double delta2 = 0;
            double delta3 = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            d = (double[])d.Clone();

            alglib.ap.assert(n>=2, "Spline1DBuildHermite: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DBuildHermite: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DBuildHermite: Length(Y)<N!");
            alglib.ap.assert(alglib.ap.len(d)>=n, "Spline1DBuildHermite: Length(D)<N!");
            
            //
            // check and sort points
            //
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DBuildHermite: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DBuildHermite: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(d, n, _params), "Spline1DBuildHermite: D contains infinite or NAN values!");
            heapsortdpoints(ref x, ref y, ref d, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DBuildHermite: at least two consequent points are too close!");
            
            //
            // Build
            //
            c.x = new double[n];
            c.c = new double[4*(n-1)+2];
            c.periodic = false;
            c.k = 3;
            c.n = n;
            c.continuity = 1;
            for(i=0; i<=n-1; i++)
            {
                c.x[i] = x[i];
            }
            for(i=0; i<=n-2; i++)
            {
                delta = x[i+1]-x[i];
                delta2 = math.sqr(delta);
                delta3 = delta*delta2;
                c.c[4*i+0] = y[i];
                c.c[4*i+1] = d[i];
                c.c[4*i+2] = (3*(y[i+1]-y[i])-2*d[i]*delta-d[i+1]*delta)/delta2;
                c.c[4*i+3] = (2*(y[i]-y[i+1])+d[i]*delta+d[i+1]*delta)/delta3;
            }
            c.c[4*(n-1)+0] = y[n-1];
            c.c[4*(n-1)+1] = d[n-1];
        }


        /*************************************************************************
        This subroutine builds Akima spline interpolant

        INPUT PARAMETERS:
            X           -   spline nodes, array[0..N-1]
            Y           -   function values, array[0..N-1]
            N           -   points count (optional):
                            * N>=2
                            * if given, only first N points are used to build spline
                            * if not given, automatically detected from X/Y sizes
                              (len(X) must be equal to len(Y))

        OUTPUT PARAMETERS:
            C           -   spline interpolant


        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.

          -- ALGLIB PROJECT --
             Copyright 24.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dbuildakima(double[] x,
            double[] y,
            int n,
            spline1dinterpolant c,
            alglib.xparams _params)
        {
            int i = 0;
            double[] d = new double[0];
            double[] w = new double[0];
            double[] diff = new double[0];

            x = (double[])x.Clone();
            y = (double[])y.Clone();

            alglib.ap.assert(n>=2, "Spline1DBuildAkima: N<2!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DBuildAkima: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DBuildAkima: Length(Y)<N!");
            
            //
            // check and sort points
            //
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DBuildAkima: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DBuildAkima: Y contains infinite or NAN values!");
            heapsortpoints(ref x, ref y, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DBuildAkima: at least two consequent points are too close!");
            
            //
            // Handle special cases: N=2, N=3, N=4
            //
            if( n<=4 )
            {
                spline1dbuildcubic(x, y, n, 0, 0.0, 0, 0.0, c, _params);
                return;
            }
            
            //
            // Prepare W (weights), Diff (divided differences)
            //
            w = new double[n-1];
            diff = new double[n-1];
            for(i=0; i<=n-2; i++)
            {
                diff[i] = (y[i+1]-y[i])/(x[i+1]-x[i]);
            }
            for(i=1; i<=n-2; i++)
            {
                w[i] = Math.Abs(diff[i]-diff[i-1]);
            }
            
            //
            // Prepare Hermite interpolation scheme
            //
            d = new double[n];
            for(i=2; i<=n-3; i++)
            {
                if( (double)(Math.Abs(w[i-1])+Math.Abs(w[i+1]))!=(double)(0) )
                {
                    d[i] = (w[i+1]*diff[i-1]+w[i-1]*diff[i])/(w[i+1]+w[i-1]);
                }
                else
                {
                    d[i] = ((x[i+1]-x[i])*diff[i-1]+(x[i]-x[i-1])*diff[i])/(x[i+1]-x[i-1]);
                }
            }
            d[0] = diffthreepoint(x[0], x[0], y[0], x[1], y[1], x[2], y[2], _params);
            d[1] = diffthreepoint(x[1], x[0], y[0], x[1], y[1], x[2], y[2], _params);
            d[n-2] = diffthreepoint(x[n-2], x[n-3], y[n-3], x[n-2], y[n-2], x[n-1], y[n-1], _params);
            d[n-1] = diffthreepoint(x[n-1], x[n-3], y[n-3], x[n-2], y[n-2], x[n-1], y[n-1], _params);
            
            //
            // Build Akima spline using Hermite interpolation scheme
            //
            spline1dbuildhermite(x, y, d, n, c, _params);
        }


        /*************************************************************************
        This subroutine calculates the value of the spline at the given point X.

        INPUT PARAMETERS:
            C   -   spline interpolant
            X   -   point

        Result:
            S(x)

          -- ALGLIB PROJECT --
             Copyright 23.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static double spline1dcalc(spline1dinterpolant c,
            double x,
            alglib.xparams _params)
        {
            double result = 0;
            int l = 0;
            int r = 0;
            int m = 0;
            double t = 0;

            alglib.ap.assert(c.k==3, "Spline1DCalc: internal error");
            alglib.ap.assert(!Double.IsInfinity(x), "Spline1DCalc: infinite X!");
            
            //
            // special case: NaN
            //
            if( Double.IsNaN(x) )
            {
                result = Double.NaN;
                return result;
            }
            
            //
            // correct if periodic
            //
            if( c.periodic )
            {
                apserv.apperiodicmap(ref x, c.x[0], c.x[c.n-1], ref t, _params);
            }
            
            //
            // Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
            //
            l = 0;
            r = c.n-2+1;
            while( l!=r-1 )
            {
                m = (l+r)/2;
                if( c.x[m]>=x )
                {
                    r = m;
                }
                else
                {
                    l = m;
                }
            }
            
            //
            // Interpolation
            //
            x = x-c.x[l];
            m = 4*l;
            result = c.c[m]+x*(c.c[m+1]+x*(c.c[m+2]+x*c.c[m+3]));
            return result;
        }


        /*************************************************************************
        This subroutine differentiates the spline.

        INPUT PARAMETERS:
            C   -   spline interpolant.
            X   -   point

        Result:
            S   -   S(x)
            DS  -   S'(x)
            D2S -   S''(x)

          -- ALGLIB PROJECT --
             Copyright 24.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1ddiff(spline1dinterpolant c,
            double x,
            ref double s,
            ref double ds,
            ref double d2s,
            alglib.xparams _params)
        {
            int l = 0;
            int r = 0;
            int m = 0;
            double t = 0;

            s = 0;
            ds = 0;
            d2s = 0;

            alglib.ap.assert(c.k==3, "Spline1DDiff: internal error");
            alglib.ap.assert(!Double.IsInfinity(x), "Spline1DDiff: infinite X!");
            
            //
            // special case: NaN
            //
            if( Double.IsNaN(x) )
            {
                s = Double.NaN;
                ds = Double.NaN;
                d2s = Double.NaN;
                return;
            }
            
            //
            // correct if periodic
            //
            if( c.periodic )
            {
                apserv.apperiodicmap(ref x, c.x[0], c.x[c.n-1], ref t, _params);
            }
            
            //
            // Binary search
            //
            l = 0;
            r = c.n-2+1;
            while( l!=r-1 )
            {
                m = (l+r)/2;
                if( c.x[m]>=x )
                {
                    r = m;
                }
                else
                {
                    l = m;
                }
            }
            
            //
            // Differentiation
            //
            x = x-c.x[l];
            m = 4*l;
            s = c.c[m]+x*(c.c[m+1]+x*(c.c[m+2]+x*c.c[m+3]));
            ds = c.c[m+1]+2*x*c.c[m+2]+3*math.sqr(x)*c.c[m+3];
            d2s = 2*c.c[m+2]+6*x*c.c[m+3];
        }


        /*************************************************************************
        This subroutine makes the copy of the spline.

        INPUT PARAMETERS:
            C   -   spline interpolant.

        Result:
            CC  -   spline copy

          -- ALGLIB PROJECT --
             Copyright 29.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dcopy(spline1dinterpolant c,
            spline1dinterpolant cc,
            alglib.xparams _params)
        {
            int s = 0;
            int i_ = 0;

            cc.periodic = c.periodic;
            cc.n = c.n;
            cc.k = c.k;
            cc.continuity = c.continuity;
            cc.x = new double[cc.n];
            for(i_=0; i_<=cc.n-1;i_++)
            {
                cc.x[i_] = c.x[i_];
            }
            s = alglib.ap.len(c.c);
            cc.c = new double[s];
            for(i_=0; i_<=s-1;i_++)
            {
                cc.c[i_] = c.c[i_];
            }
        }


        /*************************************************************************
        This subroutine unpacks the spline into the coefficients table.

        INPUT PARAMETERS:
            C   -   spline interpolant.
            X   -   point

        OUTPUT PARAMETERS:
            Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
                    For I = 0...N-2:
                        Tbl[I,0] = X[i]
                        Tbl[I,1] = X[i+1]
                        Tbl[I,2] = C0
                        Tbl[I,3] = C1
                        Tbl[I,4] = C2
                        Tbl[I,5] = C3
                    On [x[i], x[i+1]] spline is equals to:
                        S(x) = C0 + C1*t + C2*t^2 + C3*t^3
                        t = x-x[i]
                        
        NOTE:
            You  can rebuild spline with  Spline1DBuildHermite()  function,  which
            accepts as inputs function values and derivatives at nodes, which  are
            easy to calculate when you have coefficients.

          -- ALGLIB PROJECT --
             Copyright 29.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dunpack(spline1dinterpolant c,
            ref int n,
            ref double[,] tbl,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;

            n = 0;
            tbl = new double[0,0];

            tbl = new double[c.n-2+1, 2+c.k+1];
            n = c.n;
            
            //
            // Fill
            //
            for(i=0; i<=n-2; i++)
            {
                tbl[i,0] = c.x[i];
                tbl[i,1] = c.x[i+1];
                for(j=0; j<=c.k; j++)
                {
                    tbl[i,2+j] = c.c[(c.k+1)*i+j];
                }
            }
        }


        /*************************************************************************
        This subroutine performs linear transformation of the spline argument.

        INPUT PARAMETERS:
            C   -   spline interpolant.
            A, B-   transformation coefficients: x = A*t + B
        Result:
            C   -   transformed spline

          -- ALGLIB PROJECT --
             Copyright 30.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dlintransx(spline1dinterpolant c,
            double a,
            double b,
            alglib.xparams _params)
        {
            int i = 0;
            int n = 0;
            double v = 0;
            double dv = 0;
            double d2v = 0;
            double[] x = new double[0];
            double[] y = new double[0];
            double[] d = new double[0];
            bool isperiodic = new bool();
            int contval = 0;

            alglib.ap.assert(c.k==3, "Spline1DLinTransX: internal error");
            n = c.n;
            x = new double[n];
            y = new double[n];
            d = new double[n];
            
            //
            // Unpack, X, Y, dY/dX.
            // Scale and pack with Spline1DBuildHermite again.
            //
            if( (double)(a)==(double)(0) )
            {
                
                //
                // Special case: A=0
                //
                v = spline1dcalc(c, b, _params);
                for(i=0; i<=n-1; i++)
                {
                    x[i] = c.x[i];
                    y[i] = v;
                    d[i] = 0.0;
                }
            }
            else
            {
                
                //
                // General case, A<>0
                //
                for(i=0; i<=n-1; i++)
                {
                    x[i] = c.x[i];
                    spline1ddiff(c, x[i], ref v, ref dv, ref d2v, _params);
                    x[i] = (x[i]-b)/a;
                    y[i] = v;
                    d[i] = a*dv;
                }
            }
            isperiodic = c.periodic;
            contval = c.continuity;
            if( contval>0 )
            {
                spline1dbuildhermite(x, y, d, n, c, _params);
            }
            else
            {
                spline1dbuildlinear(x, y, n, c, _params);
            }
            c.periodic = isperiodic;
            c.continuity = contval;
        }


        /*************************************************************************
        This subroutine performs linear transformation of the spline.

        INPUT PARAMETERS:
            C   -   spline interpolant.
            A, B-   transformation coefficients: S2(x) = A*S(x) + B
        Result:
            C   -   transformed spline

          -- ALGLIB PROJECT --
             Copyright 30.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dlintransy(spline1dinterpolant c,
            double a,
            double b,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int n = 0;

            alglib.ap.assert(c.k==3, "Spline1DLinTransX: internal error");
            n = c.n;
            for(i=0; i<=n-2; i++)
            {
                c.c[4*i] = a*c.c[4*i]+b;
                for(j=1; j<=3; j++)
                {
                    c.c[4*i+j] = a*c.c[4*i+j];
                }
            }
            c.c[4*(n-1)+0] = a*c.c[4*(n-1)+0]+b;
            c.c[4*(n-1)+1] = a*c.c[4*(n-1)+1];
        }


        /*************************************************************************
        This subroutine integrates the spline.

        INPUT PARAMETERS:
            C   -   spline interpolant.
            X   -   right bound of the integration interval [a, x],
                    here 'a' denotes min(x[])
        Result:
            integral(S(t)dt,a,x)

          -- ALGLIB PROJECT --
             Copyright 23.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static double spline1dintegrate(spline1dinterpolant c,
            double x,
            alglib.xparams _params)
        {
            double result = 0;
            int n = 0;
            int i = 0;
            int j = 0;
            int l = 0;
            int r = 0;
            int m = 0;
            double w = 0;
            double v = 0;
            double t = 0;
            double intab = 0;
            double additionalterm = 0;

            n = c.n;
            
            //
            // Periodic splines require special treatment. We make
            // following transformation:
            //
            //     integral(S(t)dt,A,X) = integral(S(t)dt,A,Z)+AdditionalTerm
            //
            // here X may lie outside of [A,B], Z lies strictly in [A,B],
            // AdditionalTerm is equals to integral(S(t)dt,A,B) times some
            // integer number (may be zero).
            //
            if( c.periodic && ((double)(x)<(double)(c.x[0]) || (double)(x)>(double)(c.x[c.n-1])) )
            {
                
                //
                // compute integral(S(x)dx,A,B)
                //
                intab = 0;
                for(i=0; i<=c.n-2; i++)
                {
                    w = c.x[i+1]-c.x[i];
                    m = (c.k+1)*i;
                    intab = intab+c.c[m]*w;
                    v = w;
                    for(j=1; j<=c.k; j++)
                    {
                        v = v*w;
                        intab = intab+c.c[m+j]*v/(j+1);
                    }
                }
                
                //
                // map X into [A,B]
                //
                apserv.apperiodicmap(ref x, c.x[0], c.x[c.n-1], ref t, _params);
                additionalterm = t*intab;
            }
            else
            {
                additionalterm = 0;
            }
            
            //
            // Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
            //
            l = 0;
            r = n-2+1;
            while( l!=r-1 )
            {
                m = (l+r)/2;
                if( (double)(c.x[m])>=(double)(x) )
                {
                    r = m;
                }
                else
                {
                    l = m;
                }
            }
            
            //
            // Integration
            //
            result = 0;
            for(i=0; i<=l-1; i++)
            {
                w = c.x[i+1]-c.x[i];
                m = (c.k+1)*i;
                result = result+c.c[m]*w;
                v = w;
                for(j=1; j<=c.k; j++)
                {
                    v = v*w;
                    result = result+c.c[m+j]*v/(j+1);
                }
            }
            w = x-c.x[l];
            m = (c.k+1)*l;
            v = w;
            result = result+c.c[m]*w;
            for(j=1; j<=c.k; j++)
            {
                v = v*w;
                result = result+c.c[m+j]*v/(j+1);
            }
            result = result+additionalterm;
            return result;
        }


        /*************************************************************************
        Fitting by smoothing (penalized) cubic spline.

        This function approximates N scattered points (some of X[] may be equal to
        each other) by cubic spline with M  nodes  at  equidistant  grid  spanning
        interval [min(x,xc),max(x,xc)].

        The problem is regularized by adding nonlinearity penalty to  usual  least
        squares penalty function:

            MERIT_FUNC = F_LS + F_NL

        where F_LS is a least squares error  term,  and  F_NL  is  a  nonlinearity
        penalty which is roughly proportional to LambdaNS*integral{ S''(x)^2*dx }.
        Algorithm applies automatic renormalization of F_NL  which  makes  penalty
        term roughly invariant to scaling of X[] and changes in M.

        This function is a new edition  of  penalized  regression  spline fitting,
        a fast and compact one which needs much less resources that  its  previous
        version: just O(maxMN) memory and O(maxMN*log(maxMN)) time.

        NOTE: it is OK to run this function with both M<<N and M>>N;  say,  it  is
              possible to process 100 points with 1000-node spline.
                   
        INPUT PARAMETERS:
            X           -   points, array[0..N-1].
            Y           -   function values, array[0..N-1].
            N           -   number of points (optional):
                            * N>0
                            * if given, only first N elements of X/Y are processed
                            * if not given, automatically determined from lengths
            M           -   number of basis functions ( = number_of_nodes), M>=4.
            LambdaNS    -   LambdaNS>=0, regularization  constant  passed by user.
                            It penalizes nonlinearity in the regression spline.
                            Possible values to start from are 0.00001, 0.1, 1

        OUTPUT PARAMETERS:
            S   -   spline interpolant.
            Rep -   Following fields are set:
                    * RMSError      rms error on the (X,Y).
                    * AvgError      average error on the (X,Y).
                    * AvgRelError   average relative error on the non-zero Y
                    * MaxError      maximum error

          -- ALGLIB PROJECT --
             Copyright 27.08.2019 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dfit(double[] x,
            double[] y,
            int n,
            int m,
            double lambdans,
            spline1dinterpolant s,
            spline1dfitreport rep,
            alglib.xparams _params)
        {
            int bfrad = 0;
            double xa = 0;
            double xb = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int k0 = 0;
            int k1 = 0;
            double v = 0;
            double dv = 0;
            double d2v = 0;
            int gridexpansion = 0;
            double[] xywork = new double[0];
            double[,] vterm = new double[0,0];
            double[] sx = new double[0];
            double[] sy = new double[0];
            double[] sdy = new double[0];
            double[] tmpx = new double[0];
            double[] tmpy = new double[0];
            spline1dinterpolant basis1 = new spline1dinterpolant();
            sparse.sparsematrix av = new sparse.sparsematrix();
            sparse.sparsematrix ah = new sparse.sparsematrix();
            sparse.sparsematrix ata = new sparse.sparsematrix();
            double[] targets = new double[0];
            double meany = 0;
            int lsqrcnt = 0;
            int nrel = 0;
            double rss = 0;
            double tss = 0;
            int arows = 0;
            double[] tmp0 = new double[0];
            double[] tmp1 = new double[0];
            linlsqr.linlsqrstate solver = new linlsqr.linlsqrstate();
            linlsqr.linlsqrreport srep = new linlsqr.linlsqrreport();
            double creg = 0;
            double mxata = 0;
            int bw = 0;
            int[] nzidx = new int[0];
            double[] nzval = new double[0];
            int nzcnt = 0;
            double scaletargetsby = 0;
            double scalepenaltyby = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();

            alglib.ap.assert(n>=1, "Spline1DFit: N<1!");
            alglib.ap.assert(m>=1, "Spline1DFit: M<1!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DFit: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DFit: Length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DFit: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DFit: Y contains infinite or NAN values!");
            alglib.ap.assert(math.isfinite(lambdans), "Spline1DFit: LambdaNS is infinite!");
            alglib.ap.assert((double)(lambdans)>=(double)(0), "Spline1DFit: LambdaNS<0!");
            bfrad = 2;
            lsqrcnt = 10;
            
            //
            // Sort points.
            // Determine actual area size, make sure that XA<XB
            //
            tsort.tagsortfastr(ref x, ref y, ref tmpx, ref tmpy, n, _params);
            xa = x[0];
            xb = x[n-1];
            if( (double)(xa)==(double)(xb) )
            {
                v = xa;
                if( (double)(v)>=(double)(0) )
                {
                    xa = v/2-1;
                    xb = v*2+1;
                }
                else
                {
                    xa = v*2-1;
                    xb = v/2+1;
                }
            }
            alglib.ap.assert((double)(xa)<(double)(xb), "Spline1DFit: integrity error");
            
            //
            // Perform a grid correction according to current grid expansion size.
            //
            m = Math.Max(m, 4);
            gridexpansion = 1;
            v = (xb-xa)/m;
            xa = xa-v*gridexpansion;
            xb = xb+v*gridexpansion;
            m = m+2*gridexpansion;
            
            //
            // Convert X/Y to work representation, remove linear trend (in
            // order to improve condition number).
            //
            // Compute total-sum-of-squares (needed later for R2 coefficient).
            //
            xywork = new double[2*n];
            for(i=0; i<=n-1; i++)
            {
                xywork[2*i+0] = (x[i]-xa)/(xb-xa);
                xywork[2*i+1] = y[i];
            }
            intfitserv.buildpriorterm1(xywork, n, 1, 1, 1, 0.0, ref vterm, _params);
            meany = 0;
            for(i=0; i<=n-1; i++)
            {
                meany = meany+y[i];
            }
            meany = meany/n;
            tss = 0;
            for(i=0; i<=n-1; i++)
            {
                tss = tss+math.sqr(y[i]-meany);
            }
            
            //
            // Build 1D compact basis function
            // Generate design matrix AV ("vertical") and its transpose AH ("horizontal").
            //
            tmpx = new double[7];
            tmpy = new double[7];
            tmpx[0] = -((double)3/(double)(m-1));
            tmpx[1] = -((double)2/(double)(m-1));
            tmpx[2] = -((double)1/(double)(m-1));
            tmpx[3] = (double)0/(double)(m-1);
            tmpx[4] = (double)1/(double)(m-1);
            tmpx[5] = (double)2/(double)(m-1);
            tmpx[6] = (double)3/(double)(m-1);
            tmpy[0] = 0;
            tmpy[1] = 0;
            tmpy[2] = (double)1/(double)12;
            tmpy[3] = (double)2/(double)6;
            tmpy[4] = (double)1/(double)12;
            tmpy[5] = 0;
            tmpy[6] = 0;
            spline1dbuildcubic(tmpx, tmpy, alglib.ap.len(tmpx), 2, 0.0, 2, 0.0, basis1, _params);
            arows = n+2*m;
            sparse.sparsecreate(arows, m, 0, av, _params);
            apserv.setlengthzero(ref targets, arows, _params);
            scaletargetsby = 1/Math.Sqrt(n);
            scalepenaltyby = 1/Math.Sqrt(m);
            for(i=0; i<=n-1; i++)
            {
                
                //
                // Generate design matrix row #I which corresponds to I-th dataset point
                //
                k = (int)Math.Floor(apserv.boundval(xywork[2*i+0]*(m-1), 0, m-1, _params));
                k0 = Math.Max(k-(bfrad-1), 0);
                k1 = Math.Min(k+bfrad, m-1);
                for(j=k0; j<=k1; j++)
                {
                    sparse.sparseset(av, i, j, spline1dcalc(basis1, xywork[2*i+0]-(double)j/(double)(m-1), _params)*scaletargetsby, _params);
                }
                targets[i] = xywork[2*i+1]*scaletargetsby;
            }
            for(i=0; i<=m-1; i++)
            {
                
                //
                // Generate design matrix row #(I+N) which corresponds to nonlinearity penalty at I-th node
                //
                k0 = Math.Max(i-(bfrad-1), 0);
                k1 = Math.Min(i+(bfrad-1), m-1);
                for(j=k0; j<=k1; j++)
                {
                    spline1ddiff(basis1, (double)i/(double)(m-1)-(double)j/(double)(m-1), ref v, ref dv, ref d2v, _params);
                    sparse.sparseset(av, n+i, j, lambdans*d2v*scalepenaltyby, _params);
                }
            }
            for(i=0; i<=m-1; i++)
            {
                
                //
                // Generate design matrix row #(I+N+M) which corresponds to regularization for I-th coefficient
                //
                sparse.sparseset(av, n+m+i, i, lambdareg, _params);
            }
            sparse.sparseconverttocrs(av, _params);
            sparse.sparsecopytransposecrs(av, ah, _params);
            
            //
            // Build 7-diagonal (bandwidth=3) normal equations matrix and perform Cholesky
            // decomposition (to be used later as preconditioner for LSQR iterations).
            //
            bw = 3;
            sparse.sparsecreatesksband(m, m, bw, ata, _params);
            mxata = 0;
            for(i=0; i<=m-1; i++)
            {
                for(j=i; j<=Math.Min(i+bw, m-1); j++)
                {
                    
                    //
                    // Get pattern of nonzeros in one of the rows (let it be I-th one)
                    // and compute dot product only for nonzero entries.
                    //
                    sparse.sparsegetcompressedrow(ah, i, ref nzidx, ref nzval, ref nzcnt, _params);
                    v = 0;
                    for(k=0; k<=nzcnt-1; k++)
                    {
                        v = v+sparse.sparseget(ah, i, nzidx[k], _params)*sparse.sparseget(ah, j, nzidx[k], _params);
                    }
                    
                    //
                    // Update ATA and max(ATA)
                    //
                    sparse.sparseset(ata, i, j, v, _params);
                    if( i==j )
                    {
                        mxata = Math.Max(mxata, Math.Abs(v));
                    }
                }
            }
            mxata = apserv.coalesce(mxata, 1.0, _params);
            creg = cholreg;
            while( true )
            {
                
                //
                // Regularization
                //
                for(i=0; i<=m-1; i++)
                {
                    sparse.sparseset(ata, i, i, sparse.sparseget(ata, i, i, _params)+mxata*creg, _params);
                }
                
                //
                // Try Cholesky factorization.
                //
                if( !trfac.sparsecholeskyskyline(ata, m, true, _params) )
                {
                    
                    //
                    // Factorization failed, increase regularizer and repeat
                    //
                    creg = apserv.coalesce(10*creg, 1.0E-12, _params);
                    continue;
                }
                break;
            }
            
            //
            // Solve with preconditioned LSQR:
            //
            // use Cholesky factor U of squared design matrix A'*A to
            // transform min|A*x-b| to min|[A*inv(U)]*y-b| with y=U*x.
            //
            // Preconditioned problem is solved with LSQR solver, which
            // gives superior results to normal equations approach. Due
            // to Cholesky preconditioner being utilized we can solve
            // problem in just a few iterations.
            //
            apserv.rvectorsetlengthatleast(ref tmp0, arows, _params);
            apserv.rvectorsetlengthatleast(ref tmp1, m, _params);
            linlsqr.linlsqrcreatebuf(arows, m, solver, _params);
            linlsqr.linlsqrsetb(solver, targets, _params);
            linlsqr.linlsqrsetcond(solver, 1.0E-14, 1.0E-14, lsqrcnt, _params);
            while( linlsqr.linlsqriteration(solver, _params) )
            {
                if( solver.needmv )
                {
                    for(i=0; i<=m-1; i++)
                    {
                        tmp1[i] = solver.x[i];
                    }
                    
                    //
                    // Use Cholesky factorization of the system matrix
                    // as preconditioner: solve TRSV(U,Solver.X)
                    //
                    sparse.sparsetrsv(ata, true, false, 0, tmp1, _params);
                    
                    //
                    // After preconditioning is done, multiply by A
                    //
                    sparse.sparsemv(av, tmp1, ref solver.mv, _params);
                }
                if( solver.needmtv )
                {
                    
                    //
                    // Multiply by design matrix A
                    //
                    sparse.sparsemtv(av, solver.x, ref solver.mtv, _params);
                    
                    //
                    // Multiply by preconditioner: solve TRSV(U',A*Solver.X)
                    //
                    sparse.sparsetrsv(ata, true, false, 1, solver.mtv, _params);
                }
            }
            linlsqr.linlsqrresults(solver, ref tmp1, srep, _params);
            sparse.sparsetrsv(ata, true, false, 0, tmp1, _params);
            
            //
            // Generate output spline as a table of spline valued and first
            // derivatives at nodes (used to build Hermite spline)
            //
            sx = new double[m];
            sy = new double[m];
            sdy = new double[m];
            for(i=0; i<=m-1; i++)
            {
                sx[i] = (double)i/(double)(m-1);
                sy[i] = 0;
                sdy[i] = 0;
            }
            for(i=0; i<=m-1; i++)
            {
                k0 = Math.Max(i-(bfrad-1), 0);
                k1 = Math.Min(i+bfrad, m-1);
                for(j=k0; j<=k1; j++)
                {
                    spline1ddiff(basis1, (double)j/(double)(m-1)-(double)i/(double)(m-1), ref v, ref dv, ref d2v, _params);
                    sy[j] = sy[j]+tmp1[i]*v;
                    sdy[j] = sdy[j]+tmp1[i]*dv;
                }
            }
            
            //
            // Calculate model values
            //
            sparse.sparsemv(av, tmp1, ref tmp0, _params);
            for(i=0; i<=n-1; i++)
            {
                tmp0[i] = tmp0[i]/scaletargetsby;
            }
            rss = 0.0;
            nrel = 0;
            rep.rmserror = 0;
            rep.maxerror = 0;
            rep.avgerror = 0;
            rep.avgrelerror = 0;
            for(i=0; i<=n-1; i++)
            {
                v = xywork[2*i+1]-tmp0[i];
                rss = rss+v*v;
                rep.rmserror = rep.rmserror+math.sqr(v);
                rep.avgerror = rep.avgerror+Math.Abs(v);
                rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v));
                if( (double)(y[i])!=(double)(0) )
                {
                    rep.avgrelerror = rep.avgrelerror+Math.Abs(v/y[i]);
                    nrel = nrel+1;
                }
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/n);
            rep.avgerror = rep.avgerror/n;
            rep.avgrelerror = rep.avgrelerror/apserv.coalesce(nrel, 1.0, _params);
            
            //
            // Append prior term.
            // Transform spline to original coordinates.
            // Output.
            //
            for(i=0; i<=m-1; i++)
            {
                sy[i] = sy[i]+vterm[0,0]*sx[i]+vterm[0,1];
                sdy[i] = sdy[i]+vterm[0,0];
            }
            for(i=0; i<=m-1; i++)
            {
                sx[i] = sx[i]*(xb-xa)+xa;
                sdy[i] = sdy[i]/(xb-xa);
            }
            spline1dbuildhermite(sx, sy, sdy, m, s, _params);
        }


        /*************************************************************************
        Internal version of Spline1DConvDiff

        Converts from Hermite spline given by grid XOld to new grid X2

        INPUT PARAMETERS:
            XOld    -   old grid
            YOld    -   values at old grid
            DOld    -   first derivative at old grid
            N       -   grid size
            X2      -   new grid
            N2      -   new grid size
            Y       -   possibly preallocated output array
                        (reallocate if too small)
            NeedY   -   do we need Y?
            D1      -   possibly preallocated output array
                        (reallocate if too small)
            NeedD1  -   do we need D1?
            D2      -   possibly preallocated output array
                        (reallocate if too small)
            NeedD2  -   do we need D1?

        OUTPUT ARRAYS:
            Y       -   values, if needed
            D1      -   first derivative, if needed
            D2      -   second derivative, if needed

          -- ALGLIB PROJECT --
             Copyright 03.09.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dconvdiffinternal(double[] xold,
            double[] yold,
            double[] dold,
            int n,
            double[] x2,
            int n2,
            ref double[] y,
            bool needy,
            ref double[] d1,
            bool needd1,
            ref double[] d2,
            bool needd2,
            alglib.xparams _params)
        {
            int intervalindex = 0;
            int pointindex = 0;
            bool havetoadvance = new bool();
            double c0 = 0;
            double c1 = 0;
            double c2 = 0;
            double c3 = 0;
            double a = 0;
            double b = 0;
            double w = 0;
            double w2 = 0;
            double w3 = 0;
            double fa = 0;
            double fb = 0;
            double da = 0;
            double db = 0;
            double t = 0;

            
            //
            // Prepare space
            //
            if( needy && alglib.ap.len(y)<n2 )
            {
                y = new double[n2];
            }
            if( needd1 && alglib.ap.len(d1)<n2 )
            {
                d1 = new double[n2];
            }
            if( needd2 && alglib.ap.len(d2)<n2 )
            {
                d2 = new double[n2];
            }
            
            //
            // These assignments aren't actually needed
            // (variables are initialized in the loop below),
            // but without them compiler will complain about uninitialized locals
            //
            c0 = 0;
            c1 = 0;
            c2 = 0;
            c3 = 0;
            a = 0;
            b = 0;
            
            //
            // Cycle
            //
            intervalindex = -1;
            pointindex = 0;
            while( true )
            {
                
                //
                // are we ready to exit?
                //
                if( pointindex>=n2 )
                {
                    break;
                }
                t = x2[pointindex];
                
                //
                // do we need to advance interval?
                //
                havetoadvance = false;
                if( intervalindex==-1 )
                {
                    havetoadvance = true;
                }
                else
                {
                    if( intervalindex<n-2 )
                    {
                        havetoadvance = (double)(t)>=(double)(b);
                    }
                }
                if( havetoadvance )
                {
                    intervalindex = intervalindex+1;
                    a = xold[intervalindex];
                    b = xold[intervalindex+1];
                    w = b-a;
                    w2 = w*w;
                    w3 = w*w2;
                    fa = yold[intervalindex];
                    fb = yold[intervalindex+1];
                    da = dold[intervalindex];
                    db = dold[intervalindex+1];
                    c0 = fa;
                    c1 = da;
                    c2 = (3*(fb-fa)-2*da*w-db*w)/w2;
                    c3 = (2*(fa-fb)+da*w+db*w)/w3;
                    continue;
                }
                
                //
                // Calculate spline and its derivatives using power basis
                //
                t = t-a;
                if( needy )
                {
                    y[pointindex] = c0+t*(c1+t*(c2+t*c3));
                }
                if( needd1 )
                {
                    d1[pointindex] = c1+2*t*c2+3*t*t*c3;
                }
                if( needd2 )
                {
                    d2[pointindex] = 2*c2+6*t*c3;
                }
                pointindex = pointindex+1;
            }
        }


        /*************************************************************************
        This function finds all roots and extrema of the spline S(x)  defined  at
        [A,B] (interval which contains spline nodes).

        It  does not extrapolates function, so roots and extrema located  outside 
        of [A,B] will not be found. It returns all isolated (including  multiple)
        roots and extrema.

        INPUT PARAMETERS
            C           -   spline interpolant
            
        OUTPUT PARAMETERS
            R           -   array[NR], contains roots of the spline. 
                            In case there is no roots, this array has zero length.
            NR          -   number of roots, >=0
            DR          -   is set to True in case there is at least one interval
                            where spline is just a zero constant. Such degenerate
                            cases are not reported in the R/NR
            E           -   array[NE], contains  extrema  (maximums/minimums)  of 
                            the spline. In case there is no extrema,  this  array 
                            has zero length.
            ET          -   array[NE], extrema types:
                            * ET[i]>0 in case I-th extrema is a minimum
                            * ET[i]<0 in case I-th extrema is a maximum
            NE          -   number of extrema, >=0
            DE          -   is set to True in case there is at least one interval
                            where spline is a constant. Such degenerate cases are  
                            not reported in the E/NE.
                            
        NOTES:

        1. This function does NOT report following kinds of roots:
           * intervals where function is constantly zero
           * roots which are outside of [A,B] (note: it CAN return A or B)

        2. This function does NOT report following kinds of extrema:
           * intervals where function is a constant
           * extrema which are outside of (A,B) (note: it WON'T return A or B)
           
         -- ALGLIB PROJECT --
             Copyright 26.09.2011 by Bochkanov Sergey   
        *************************************************************************/
        public static void spline1drootsandextrema(spline1dinterpolant c,
            ref double[] r,
            ref int nr,
            ref bool dr,
            ref double[] e,
            ref int[] et,
            ref int ne,
            ref bool de,
            alglib.xparams _params)
        {
            double pl = 0;
            double ml = 0;
            double pll = 0;
            double pr = 0;
            double mr = 0;
            double[] tr = new double[0];
            double[] tmpr = new double[0];
            double[] tmpe = new double[0];
            int[] tmpet = new int[0];
            double[] tmpc = new double[0];
            double x0 = 0;
            double x1 = 0;
            double x2 = 0;
            double ex0 = 0;
            double ex1 = 0;
            int tne = 0;
            int tnr = 0;
            int i = 0;
            int j = 0;
            bool nstep = new bool();

            r = new double[0];
            nr = 0;
            dr = new bool();
            e = new double[0];
            et = new int[0];
            ne = 0;
            de = new bool();

            
            //
            //exception handling
            //
            alglib.ap.assert(c.k==3, "Spline1DRootsAndExtrema : incorrect parameter C.K!");
            alglib.ap.assert(c.continuity>=0, "Spline1DRootsAndExtrema : parameter C.Continuity must not be less than 0!");
            
            //
            //initialization of variable
            //
            nr = 0;
            ne = 0;
            dr = false;
            de = false;
            nstep = true;
            
            //
            //consider case, when C.Continuty=0
            //
            if( c.continuity==0 )
            {
                
                //
                //allocation for auxiliary arrays 
                //'TmpR ' - it stores a time value for roots
                //'TmpE ' - it stores a time value for extremums
                //'TmpET '- it stores a time value for extremums type
                //
                apserv.rvectorsetlengthatleast(ref tmpr, 3*(c.n-1), _params);
                apserv.rvectorsetlengthatleast(ref tmpe, 2*(c.n-1), _params);
                apserv.ivectorsetlengthatleast(ref tmpet, 2*(c.n-1), _params);
                
                //
                //start calculating
                //
                for(i=0; i<=c.n-2; i++)
                {
                    
                    //
                    //initialization pL, mL, pR, mR
                    //
                    pl = c.c[4*i];
                    ml = c.c[4*i+1];
                    pr = c.c[4*(i+1)];
                    mr = c.c[4*i+1]+2*c.c[4*i+2]*(c.x[i+1]-c.x[i])+3*c.c[4*i+3]*(c.x[i+1]-c.x[i])*(c.x[i+1]-c.x[i]);
                    
                    //
                    //pre-searching roots and extremums
                    //
                    solvecubicpolinom(pl, ml, pr, mr, c.x[i], c.x[i+1], ref x0, ref x1, ref x2, ref ex0, ref ex1, ref tnr, ref tne, ref tr, _params);
                    dr = dr || tnr==-1;
                    de = de || tne==-1;
                    
                    //
                    //searching of roots
                    //
                    if( tnr==1 && nstep )
                    {
                        
                        //
                        //is there roots?
                        //
                        if( nr>0 )
                        {
                            
                            //
                            //is a next root equal a previous root?
                            //if is't, then write new root
                            //
                            if( (double)(x0)!=(double)(tmpr[nr-1]) )
                            {
                                tmpr[nr] = x0;
                                nr = nr+1;
                            }
                        }
                        else
                        {
                            
                            //
                            //write a first root
                            //
                            tmpr[nr] = x0;
                            nr = nr+1;
                        }
                    }
                    else
                    {
                        
                        //
                        //case when function at a segment identically to zero
                        //then we have to clear a root, if the one located on a 
                        //constant segment
                        //
                        if( tnr==-1 )
                        {
                            
                            //
                            //safe state variable as constant
                            //
                            if( nstep )
                            {
                                nstep = false;
                            }
                            
                            //
                            //clear the root, if there is
                            //
                            if( nr>0 )
                            {
                                if( (double)(c.x[i])==(double)(tmpr[nr-1]) )
                                {
                                    nr = nr-1;
                                }
                            }
                            
                            //
                            //change state for 'DR'
                            //
                            if( !dr )
                            {
                                dr = true;
                            }
                        }
                        else
                        {
                            nstep = true;
                        }
                    }
                    
                    //
                    //searching of extremums
                    //
                    if( i>0 )
                    {
                        pll = c.c[4*(i-1)];
                        
                        //
                        //if pL=pLL or pL=pR then
                        //
                        if( tne==-1 )
                        {
                            if( !de )
                            {
                                de = true;
                            }
                        }
                        else
                        {
                            if( (double)(pl)>(double)(pll) && (double)(pl)>(double)(pr) )
                            {
                                
                                //
                                //maximum
                                //
                                tmpet[ne] = -1;
                                tmpe[ne] = c.x[i];
                                ne = ne+1;
                            }
                            else
                            {
                                if( (double)(pl)<(double)(pll) && (double)(pl)<(double)(pr) )
                                {
                                    
                                    //
                                    //minimum
                                    //
                                    tmpet[ne] = 1;
                                    tmpe[ne] = c.x[i];
                                    ne = ne+1;
                                }
                            }
                        }
                    }
                }
                
                //
                //write final result
                //
                apserv.rvectorsetlengthatleast(ref r, nr, _params);
                apserv.rvectorsetlengthatleast(ref e, ne, _params);
                apserv.ivectorsetlengthatleast(ref et, ne, _params);
                
                //
                //write roots
                //
                for(i=0; i<=nr-1; i++)
                {
                    r[i] = tmpr[i];
                }
                
                //
                //write extremums and their types
                //
                for(i=0; i<=ne-1; i++)
                {
                    e[i] = tmpe[i];
                    et[i] = tmpet[i];
                }
            }
            else
            {
                
                //
                //case, when C.Continuity>=1 
                //'TmpR ' - it stores a time value for roots
                //'TmpC' - it stores a time value for extremums and 
                //their function value (TmpC={EX0,F(EX0), EX1,F(EX1), ..., EXn,F(EXn)};)
                //'TmpE' - it stores a time value for extremums only
                //'TmpET'- it stores a time value for extremums type
                //
                apserv.rvectorsetlengthatleast(ref tmpr, 2*c.n-1, _params);
                apserv.rvectorsetlengthatleast(ref tmpc, 4*c.n, _params);
                apserv.rvectorsetlengthatleast(ref tmpe, 2*c.n, _params);
                apserv.ivectorsetlengthatleast(ref tmpet, 2*c.n, _params);
                
                //
                //start calculating
                //
                for(i=0; i<=c.n-2; i++)
                {
                    
                    //
                    //we calculate pL,mL, pR,mR as Fi+1(F'i+1) at left border
                    //
                    pl = c.c[4*i];
                    ml = c.c[4*i+1];
                    pr = c.c[4*(i+1)];
                    mr = c.c[4*(i+1)+1];
                    
                    //
                    //calculating roots and extremums at [X[i],X[i+1]]
                    //
                    solvecubicpolinom(pl, ml, pr, mr, c.x[i], c.x[i+1], ref x0, ref x1, ref x2, ref ex0, ref ex1, ref tnr, ref tne, ref tr, _params);
                    
                    //
                    //searching roots
                    //
                    if( tnr>0 )
                    {
                        
                        //
                        //re-init tR
                        //
                        if( tnr>=1 )
                        {
                            tr[0] = x0;
                        }
                        if( tnr>=2 )
                        {
                            tr[1] = x1;
                        }
                        if( tnr==3 )
                        {
                            tr[2] = x2;
                        }
                        
                        //
                        //start root selection
                        //
                        if( nr>0 )
                        {
                            if( (double)(tmpr[nr-1])!=(double)(x0) )
                            {
                                
                                //
                                //previous segment was't constant identical zero
                                //
                                if( nstep )
                                {
                                    for(j=0; j<=tnr-1; j++)
                                    {
                                        tmpr[nr+j] = tr[j];
                                    }
                                    nr = nr+tnr;
                                }
                                else
                                {
                                    
                                    //
                                    //previous segment was constant identical zero
                                    //and we must ignore [NR+j-1] root
                                    //
                                    for(j=1; j<=tnr-1; j++)
                                    {
                                        tmpr[nr+j-1] = tr[j];
                                    }
                                    nr = nr+tnr-1;
                                    nstep = true;
                                }
                            }
                            else
                            {
                                for(j=1; j<=tnr-1; j++)
                                {
                                    tmpr[nr+j-1] = tr[j];
                                }
                                nr = nr+tnr-1;
                            }
                        }
                        else
                        {
                            
                            //
                            //write first root
                            //
                            for(j=0; j<=tnr-1; j++)
                            {
                                tmpr[nr+j] = tr[j];
                            }
                            nr = nr+tnr;
                        }
                    }
                    else
                    {
                        if( tnr==-1 )
                        {
                            
                            //
                            //decrement 'NR' if at previous step was writen a root
                            //(previous segment identical zero)
                            //
                            if( nr>0 && nstep )
                            {
                                nr = nr-1;
                            }
                            
                            //
                            //previous segment is't constant
                            //
                            if( nstep )
                            {
                                nstep = false;
                            }
                            
                            //
                            //rewrite 'DR'
                            //
                            if( !dr )
                            {
                                dr = true;
                            }
                        }
                    }
                    
                    //
                    //searching extremums
                    //write all term like extremums
                    //
                    if( tne==1 )
                    {
                        if( ne>0 )
                        {
                            
                            //
                            //just ignore identical extremums
                            //because he must be one
                            //
                            if( (double)(tmpc[ne-2])!=(double)(ex0) )
                            {
                                tmpc[ne] = ex0;
                                tmpc[ne+1] = c.c[4*i]+c.c[4*i+1]*(ex0-c.x[i])+c.c[4*i+2]*(ex0-c.x[i])*(ex0-c.x[i])+c.c[4*i+3]*(ex0-c.x[i])*(ex0-c.x[i])*(ex0-c.x[i]);
                                ne = ne+2;
                            }
                        }
                        else
                        {
                            
                            //
                            //write first extremum and it function value
                            //
                            tmpc[ne] = ex0;
                            tmpc[ne+1] = c.c[4*i]+c.c[4*i+1]*(ex0-c.x[i])+c.c[4*i+2]*(ex0-c.x[i])*(ex0-c.x[i])+c.c[4*i+3]*(ex0-c.x[i])*(ex0-c.x[i])*(ex0-c.x[i]);
                            ne = ne+2;
                        }
                    }
                    else
                    {
                        if( tne==2 )
                        {
                            if( ne>0 )
                            {
                                
                                //
                                //ignore identical extremum
                                //
                                if( (double)(tmpc[ne-2])!=(double)(ex0) )
                                {
                                    tmpc[ne] = ex0;
                                    tmpc[ne+1] = c.c[4*i]+c.c[4*i+1]*(ex0-c.x[i])+c.c[4*i+2]*(ex0-c.x[i])*(ex0-c.x[i])+c.c[4*i+3]*(ex0-c.x[i])*(ex0-c.x[i])*(ex0-c.x[i]);
                                    ne = ne+2;
                                }
                            }
                            else
                            {
                                
                                //
                                //write first extremum
                                //
                                tmpc[ne] = ex0;
                                tmpc[ne+1] = c.c[4*i]+c.c[4*i+1]*(ex0-c.x[i])+c.c[4*i+2]*(ex0-c.x[i])*(ex0-c.x[i])+c.c[4*i+3]*(ex0-c.x[i])*(ex0-c.x[i])*(ex0-c.x[i]);
                                ne = ne+2;
                            }
                            
                            //
                            //write second extremum
                            //
                            tmpc[ne] = ex1;
                            tmpc[ne+1] = c.c[4*i]+c.c[4*i+1]*(ex1-c.x[i])+c.c[4*i+2]*(ex1-c.x[i])*(ex1-c.x[i])+c.c[4*i+3]*(ex1-c.x[i])*(ex1-c.x[i])*(ex1-c.x[i]);
                            ne = ne+2;
                        }
                        else
                        {
                            if( tne==-1 )
                            {
                                if( !de )
                                {
                                    de = true;
                                }
                            }
                        }
                    }
                }
                
                //
                //checking of arrays
                //get number of extremums (tNe=NE/2)
                //initialize pL as value F0(X[0]) and
                //initialize pR as value Fn-1(X[N])
                //
                tne = ne/2;
                ne = 0;
                pl = c.c[0];
                pr = c.c[4*(c.n-1)];
                for(i=0; i<=tne-1; i++)
                {
                    if( i>0 && i<tne-1 )
                    {
                        if( (double)(tmpc[2*i+1])>(double)(tmpc[2*(i-1)+1]) && (double)(tmpc[2*i+1])>(double)(tmpc[2*(i+1)+1]) )
                        {
                            
                            //
                            //maximum
                            //
                            tmpe[ne] = tmpc[2*i];
                            tmpet[ne] = -1;
                            ne = ne+1;
                        }
                        else
                        {
                            if( (double)(tmpc[2*i+1])<(double)(tmpc[2*(i-1)+1]) && (double)(tmpc[2*i+1])<(double)(tmpc[2*(i+1)+1]) )
                            {
                                
                                //
                                //minimum
                                //
                                tmpe[ne] = tmpc[2*i];
                                tmpet[ne] = 1;
                                ne = ne+1;
                            }
                        }
                    }
                    else
                    {
                        if( i==0 )
                        {
                            if( (double)(tmpc[2*i])!=(double)(c.x[0]) )
                            {
                                if( (double)(tmpc[2*i+1])>(double)(pl) && (double)(tmpc[2*i+1])>(double)(tmpc[2*(i+1)+1]) )
                                {
                                    
                                    //
                                    //maximum
                                    //
                                    tmpe[ne] = tmpc[2*i];
                                    tmpet[ne] = -1;
                                    ne = ne+1;
                                }
                                else
                                {
                                    if( (double)(tmpc[2*i+1])<(double)(pl) && (double)(tmpc[2*i+1])<(double)(tmpc[2*(i+1)+1]) )
                                    {
                                        
                                        //
                                        //minimum
                                        //
                                        tmpe[ne] = tmpc[2*i];
                                        tmpet[ne] = 1;
                                        ne = ne+1;
                                    }
                                }
                            }
                        }
                        else
                        {
                            if( i==tne-1 )
                            {
                                if( (double)(tmpc[2*i])!=(double)(c.x[c.n-1]) )
                                {
                                    if( (double)(tmpc[2*i+1])>(double)(tmpc[2*(i-1)+1]) && (double)(tmpc[2*i+1])>(double)(pr) )
                                    {
                                        
                                        //
                                        //maximum
                                        //
                                        tmpe[ne] = tmpc[2*i];
                                        tmpet[ne] = -1;
                                        ne = ne+1;
                                    }
                                    else
                                    {
                                        if( (double)(tmpc[2*i+1])<(double)(tmpc[2*(i-1)+1]) && (double)(tmpc[2*i+1])<(double)(pr) )
                                        {
                                            
                                            //
                                            //minimum
                                            //
                                            tmpe[ne] = tmpc[2*i];
                                            tmpet[ne] = 1;
                                            ne = ne+1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                //
                //final results
                //allocate R, E, ET
                //
                apserv.rvectorsetlengthatleast(ref r, nr, _params);
                apserv.rvectorsetlengthatleast(ref e, ne, _params);
                apserv.ivectorsetlengthatleast(ref et, ne, _params);
                
                //
                //write result for extremus and their types
                //
                for(i=0; i<=ne-1; i++)
                {
                    e[i] = tmpe[i];
                    et[i] = tmpet[i];
                }
                
                //
                //write result for roots
                //
                for(i=0; i<=nr-1; i++)
                {
                    r[i] = tmpr[i];
                }
            }
        }


        /*************************************************************************
        Internal subroutine. Heap sort.
        *************************************************************************/
        public static void heapsortdpoints(ref double[] x,
            ref double[] y,
            ref double[] d,
            int n,
            alglib.xparams _params)
        {
            double[] rbuf = new double[0];
            int[] ibuf = new int[0];
            double[] rbuf2 = new double[0];
            int[] ibuf2 = new int[0];
            int i = 0;
            int i_ = 0;

            ibuf = new int[n];
            rbuf = new double[n];
            for(i=0; i<=n-1; i++)
            {
                ibuf[i] = i;
            }
            tsort.tagsortfasti(ref x, ref ibuf, ref rbuf2, ref ibuf2, n, _params);
            for(i=0; i<=n-1; i++)
            {
                rbuf[i] = y[ibuf[i]];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                y[i_] = rbuf[i_];
            }
            for(i=0; i<=n-1; i++)
            {
                rbuf[i] = d[ibuf[i]];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                d[i_] = rbuf[i_];
            }
        }


        /*************************************************************************
        This procedure search roots of an quadratic equation inside [0;1] and it number of roots.

        INPUT PARAMETERS:
            P0   -   value of a function at 0
            M0   -   value of a derivative at 0
            P1   -   value of a function at 1
            M1   -   value of a derivative at 1

        OUTPUT PARAMETERS:
            X0   -  first root of an equation
            X1   -  second root of an equation
            NR   -  number of roots
            
        RESTRICTIONS OF PARAMETERS:

        Parameters for this procedure has't to be zero simultaneously. Is expected, 
        that input polinom is't degenerate or constant identicaly ZERO.


        REMARK:

        The procedure always fill value for X1 and X2, even if it is't belongs to [0;1].
        But first true root(even if existing one) is in X1.
        Number of roots is NR.

         -- ALGLIB PROJECT --
             Copyright 26.09.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void solvepolinom2(double p0,
            double m0,
            double p1,
            double m1,
            ref double x0,
            ref double x1,
            ref int nr,
            alglib.xparams _params)
        {
            double a = 0;
            double b = 0;
            double c = 0;
            double dd = 0;
            double tmp = 0;
            double exf = 0;
            double extr = 0;

            x0 = 0;
            x1 = 0;
            nr = 0;

            
            //
            //calculate parameters for equation: A, B  and C
            //
            a = 6*p0+3*m0-6*p1+3*m1;
            b = -(6*p0)-4*m0+6*p1-2*m1;
            c = m0;
            
            //
            //check case, when A=0
            //we are considering the linear equation
            //
            if( (double)(a)==(double)(0) )
            {
                
                //
                //B<>0 and root inside [0;1]
                //one root
                //
                if( ((double)(b)!=(double)(0) && Math.Sign(c)*Math.Sign(b)<=0) && (double)(Math.Abs(b))>=(double)(Math.Abs(c)) )
                {
                    x0 = -(c/b);
                    nr = 1;
                    return;
                }
                else
                {
                    nr = 0;
                    return;
                }
            }
            
            //
            //consider case, when extremumu outside (0;1)
            //exist one root only
            //
            if( (double)(Math.Abs(2*a))<=(double)(Math.Abs(b)) || Math.Sign(b)*Math.Sign(a)>=0 )
            {
                if( Math.Sign(m0)*Math.Sign(m1)>0 )
                {
                    nr = 0;
                    return;
                }
                
                //
                //consider case, when the one exist
                //same sign of derivative
                //
                if( Math.Sign(m0)*Math.Sign(m1)<0 )
                {
                    nr = 1;
                    extr = -(b/(2*a));
                    dd = b*b-4*a*c;
                    if( (double)(dd)<(double)(0) )
                    {
                        return;
                    }
                    x0 = (-b-Math.Sqrt(dd))/(2*a);
                    x1 = (-b+Math.Sqrt(dd))/(2*a);
                    if( ((double)(extr)>=(double)(1) && (double)(x1)<=(double)(extr)) || ((double)(extr)<=(double)(0) && (double)(x1)>=(double)(extr)) )
                    {
                        x0 = x1;
                    }
                    return;
                }
                
                //
                //consider case, when the one is 0
                //
                if( (double)(m0)==(double)(0) )
                {
                    x0 = 0;
                    nr = 1;
                    return;
                }
                if( (double)(m1)==(double)(0) )
                {
                    x0 = 1;
                    nr = 1;
                    return;
                }
            }
            else
            {
                
                //
                //consider case, when both of derivatives is 0
                //
                if( (double)(m0)==(double)(0) && (double)(m1)==(double)(0) )
                {
                    x0 = 0;
                    x1 = 1;
                    nr = 2;
                    return;
                }
                
                //
                //consider case, when derivative at 0 is 0, and derivative at 1 is't 0
                //
                if( (double)(m0)==(double)(0) && (double)(m1)!=(double)(0) )
                {
                    dd = b*b-4*a*c;
                    if( (double)(dd)<(double)(0) )
                    {
                        x0 = 0;
                        nr = 1;
                        return;
                    }
                    x0 = (-b-Math.Sqrt(dd))/(2*a);
                    x1 = (-b+Math.Sqrt(dd))/(2*a);
                    extr = -(b/(2*a));
                    exf = a*extr*extr+b*extr+c;
                    if( Math.Sign(exf)*Math.Sign(m1)>0 )
                    {
                        x0 = 0;
                        nr = 1;
                        return;
                    }
                    else
                    {
                        if( (double)(extr)>(double)(x0) )
                        {
                            x0 = 0;
                        }
                        else
                        {
                            x1 = 0;
                        }
                        nr = 2;
                        
                        //
                        //roots must placed ascending
                        //
                        if( (double)(x0)>(double)(x1) )
                        {
                            tmp = x0;
                            x0 = x1;
                            x1 = tmp;
                        }
                        return;
                    }
                }
                if( (double)(m1)==(double)(0) && (double)(m0)!=(double)(0) )
                {
                    dd = b*b-4*a*c;
                    if( (double)(dd)<(double)(0) )
                    {
                        x0 = 1;
                        nr = 1;
                        return;
                    }
                    x0 = (-b-Math.Sqrt(dd))/(2*a);
                    x1 = (-b+Math.Sqrt(dd))/(2*a);
                    extr = -(b/(2*a));
                    exf = a*extr*extr+b*extr+c;
                    if( Math.Sign(exf)*Math.Sign(m0)>0 )
                    {
                        x0 = 1;
                        nr = 1;
                        return;
                    }
                    else
                    {
                        if( (double)(extr)<(double)(x0) )
                        {
                            x0 = 1;
                        }
                        else
                        {
                            x1 = 1;
                        }
                        nr = 2;
                        
                        //
                        //roots must placed ascending
                        //
                        if( (double)(x0)>(double)(x1) )
                        {
                            tmp = x0;
                            x0 = x1;
                            x1 = tmp;
                        }
                        return;
                    }
                }
                else
                {
                    extr = -(b/(2*a));
                    exf = a*extr*extr+b*extr+c;
                    if( Math.Sign(exf)*Math.Sign(m0)>0 && Math.Sign(exf)*Math.Sign(m1)>0 )
                    {
                        nr = 0;
                        return;
                    }
                    dd = b*b-4*a*c;
                    if( (double)(dd)<(double)(0) )
                    {
                        nr = 0;
                        return;
                    }
                    x0 = (-b-Math.Sqrt(dd))/(2*a);
                    x1 = (-b+Math.Sqrt(dd))/(2*a);
                    
                    //
                    //if EXF and m0, EXF and m1 has different signs, then equation has two roots              
                    //
                    if( Math.Sign(exf)*Math.Sign(m0)<0 && Math.Sign(exf)*Math.Sign(m1)<0 )
                    {
                        nr = 2;
                        
                        //
                        //roots must placed ascending
                        //
                        if( (double)(x0)>(double)(x1) )
                        {
                            tmp = x0;
                            x0 = x1;
                            x1 = tmp;
                        }
                        return;
                    }
                    else
                    {
                        nr = 1;
                        if( Math.Sign(exf)*Math.Sign(m0)<0 )
                        {
                            if( (double)(x1)<(double)(extr) )
                            {
                                x0 = x1;
                            }
                            return;
                        }
                        if( Math.Sign(exf)*Math.Sign(m1)<0 )
                        {
                            if( (double)(x1)>(double)(extr) )
                            {
                                x0 = x1;
                            }
                            return;
                        }
                    }
                }
            }
        }


        /*************************************************************************
        This procedure search roots of an cubic equation inside [A;B], it number of roots 
        and number of extremums.

        INPUT PARAMETERS:
            pA   -   value of a function at A
            mA   -   value of a derivative at A
            pB   -   value of a function at B
            mB   -   value of a derivative at B
            A0   -   left border [A0;B0]
            B0   -   right border [A0;B0]

        OUTPUT PARAMETERS:
            X0   -  first root of an equation
            X1   -  second root of an equation
            X2   -  third root of an equation
            EX0  -  first extremum of a function
            EX0  -  second extremum of a function
            NR   -  number of roots
            NR   -  number of extrmums
            
        RESTRICTIONS OF PARAMETERS:

        Length of [A;B] must be positive and is't zero, i.e. A<>B and A<B.


        REMARK:

        If 'NR' is -1 it's mean, than polinom has infiniti roots.
        If 'NE' is -1 it's mean, than polinom has infiniti extremums.

         -- ALGLIB PROJECT --
             Copyright 26.09.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void solvecubicpolinom(double pa,
            double ma,
            double pb,
            double mb,
            double a,
            double b,
            ref double x0,
            ref double x1,
            ref double x2,
            ref double ex0,
            ref double ex1,
            ref int nr,
            ref int ne,
            ref double[] tempdata,
            alglib.xparams _params)
        {
            int i = 0;
            double tmpma = 0;
            double tmpmb = 0;
            double tex0 = 0;
            double tex1 = 0;

            x0 = 0;
            x1 = 0;
            x2 = 0;
            ex0 = 0;
            ex1 = 0;
            nr = 0;
            ne = 0;

            apserv.rvectorsetlengthatleast(ref tempdata, 3, _params);
            
            //
            //case, when A>B
            //
            alglib.ap.assert((double)(a)<(double)(b), "\nSolveCubicPolinom: incorrect borders for [A;B]!\n");
            
            //
            //case 1    
            //function can be identicaly to ZERO
            //
            if( (((double)(ma)==(double)(0) && (double)(mb)==(double)(0)) && (double)(pa)==(double)(pb)) && (double)(pa)==(double)(0) )
            {
                nr = -1;
                ne = -1;
                return;
            }
            if( ((double)(ma)==(double)(0) && (double)(mb)==(double)(0)) && (double)(pa)==(double)(pb) )
            {
                nr = 0;
                ne = -1;
                return;
            }
            tmpma = ma*(b-a);
            tmpmb = mb*(b-a);
            solvepolinom2(pa, tmpma, pb, tmpmb, ref ex0, ref ex1, ref ne, _params);
            ex0 = rescaleval(0, 1, a, b, ex0, _params);
            ex1 = rescaleval(0, 1, a, b, ex1, _params);
            
            //
            //case 3.1
            //no extremums at [A;B]
            //
            if( ne==0 )
            {
                nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, 1, ref x0, _params);
                if( nr==1 )
                {
                    x0 = rescaleval(0, 1, a, b, x0, _params);
                }
                return;
            }
            
            //
            //case 3.2
            //one extremum
            //
            if( ne==1 )
            {
                if( (double)(ex0)==(double)(a) || (double)(ex0)==(double)(b) )
                {
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, 1, ref x0, _params);
                    if( nr==1 )
                    {
                        x0 = rescaleval(0, 1, a, b, x0, _params);
                    }
                    return;
                }
                else
                {
                    nr = 0;
                    i = 0;
                    tex0 = rescaleval(a, b, 0, 1, ex0, _params);
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, tex0, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        tempdata[i] = rescaleval(0, tex0, a, ex0, x0, _params);
                        i = i+1;
                    }
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, tex0, 1, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        x0 = rescaleval(tex0, 1, ex0, b, x0, _params);
                        if( i>0 )
                        {
                            if( (double)(x0)!=(double)(tempdata[i-1]) )
                            {
                                tempdata[i] = x0;
                                i = i+1;
                            }
                            else
                            {
                                nr = nr-1;
                            }
                        }
                        else
                        {
                            tempdata[i] = x0;
                            i = i+1;
                        }
                    }
                    if( nr>0 )
                    {
                        x0 = tempdata[0];
                        if( nr>1 )
                        {
                            x1 = tempdata[1];
                        }
                        return;
                    }
                }
                return;
            }
            else
            {
                
                //
                //case 3.3
                //two extremums(or more, but it's impossible)
                //
                //
                //case 3.3.0
                //both extremums at the border
                //
                if( (double)(ex0)==(double)(a) && (double)(ex1)==(double)(b) )
                {
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, 1, ref x0, _params);
                    if( nr==1 )
                    {
                        x0 = rescaleval(0, 1, a, b, x0, _params);
                    }
                    return;
                }
                if( (double)(ex0)==(double)(a) && (double)(ex1)!=(double)(b) )
                {
                    nr = 0;
                    i = 0;
                    tex1 = rescaleval(a, b, 0, 1, ex1, _params);
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, tex1, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        tempdata[i] = rescaleval(0, tex1, a, ex1, x0, _params);
                        i = i+1;
                    }
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, tex1, 1, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        x0 = rescaleval(tex1, 1, ex1, b, x0, _params);
                        if( (double)(x0)!=(double)(tempdata[i-1]) )
                        {
                            tempdata[i] = x0;
                            i = i+1;
                        }
                        else
                        {
                            nr = nr-1;
                        }
                    }
                    if( nr>0 )
                    {
                        x0 = tempdata[0];
                        if( nr>1 )
                        {
                            x1 = tempdata[1];
                        }
                        return;
                    }
                }
                if( (double)(ex1)==(double)(b) && (double)(ex0)!=(double)(a) )
                {
                    nr = 0;
                    i = 0;
                    tex0 = rescaleval(a, b, 0, 1, ex0, _params);
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, tex0, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        tempdata[i] = rescaleval(0, tex0, a, ex0, x0, _params);
                        i = i+1;
                    }
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, tex0, 1, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        x0 = rescaleval(tex0, 1, ex0, b, x0, _params);
                        if( i>0 )
                        {
                            if( (double)(x0)!=(double)(tempdata[i-1]) )
                            {
                                tempdata[i] = x0;
                                i = i+1;
                            }
                            else
                            {
                                nr = nr-1;
                            }
                        }
                        else
                        {
                            tempdata[i] = x0;
                            i = i+1;
                        }
                    }
                    if( nr>0 )
                    {
                        x0 = tempdata[0];
                        if( nr>1 )
                        {
                            x1 = tempdata[1];
                        }
                        return;
                    }
                }
                else
                {
                    
                    //
                    //case 3.3.2
                    //both extremums inside (0;1)
                    //
                    nr = 0;
                    i = 0;
                    tex0 = rescaleval(a, b, 0, 1, ex0, _params);
                    tex1 = rescaleval(a, b, 0, 1, ex1, _params);
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, 0, tex0, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        tempdata[i] = rescaleval(0, tex0, a, ex0, x0, _params);
                        i = i+1;
                    }
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, tex0, tex1, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        x0 = rescaleval(tex0, tex1, ex0, ex1, x0, _params);
                        if( i>0 )
                        {
                            if( (double)(x0)!=(double)(tempdata[i-1]) )
                            {
                                tempdata[i] = x0;
                                i = i+1;
                            }
                            else
                            {
                                nr = nr-1;
                            }
                        }
                        else
                        {
                            tempdata[i] = x0;
                            i = i+1;
                        }
                    }
                    nr = bisectmethod(pa, tmpma, pb, tmpmb, tex1, 1, ref x0, _params)+nr;
                    if( nr>i )
                    {
                        x0 = rescaleval(tex1, 1, ex1, b, x0, _params);
                        if( i>0 )
                        {
                            if( (double)(x0)!=(double)(tempdata[i-1]) )
                            {
                                tempdata[i] = x0;
                                i = i+1;
                            }
                            else
                            {
                                nr = nr-1;
                            }
                        }
                        else
                        {
                            tempdata[i] = x0;
                            i = i+1;
                        }
                    }
                    
                    //
                    //write are found roots
                    //
                    if( nr>0 )
                    {
                        x0 = tempdata[0];
                        if( nr>1 )
                        {
                            x1 = tempdata[1];
                        }
                        if( nr>2 )
                        {
                            x2 = tempdata[2];
                        }
                        return;
                    }
                }
            }
        }


        /*************************************************************************
        Function for searching a root at [A;B] by bisection method and return number of roots
        (0 or 1)

        INPUT PARAMETERS:
            pA   -   value of a function at A
            mA   -   value of a derivative at A
            pB   -   value of a function at B
            mB   -   value of a derivative at B
            A0   -   left border [A0;B0] 
            B0   -   right border [A0;B0]
            
        RESTRICTIONS OF PARAMETERS:

        We assume, that B0>A0.


        REMARK:

        Assume, that exist one root only at [A;B], else 
        function may be work incorrectly.
        The function dont check value A0,B0!

         -- ALGLIB PROJECT --
             Copyright 26.09.2011 by Bochkanov Sergey
        *************************************************************************/
        public static int bisectmethod(double pa,
            double ma,
            double pb,
            double mb,
            double a,
            double b,
            ref double x,
            alglib.xparams _params)
        {
            int result = 0;
            double vacuum = 0;
            double eps = 0;
            double a0 = 0;
            double b0 = 0;
            double m = 0;
            double lf = 0;
            double rf = 0;
            double mf = 0;

            x = 0;

            
            //
            //accuracy
            //
            eps = 1000*(b-a)*math.machineepsilon;
            
            //
            //initialization left and right borders
            //
            a0 = a;
            b0 = b;
            
            //
            //initialize function value at 'A' and 'B'
            //
            hermitecalc(pa, ma, pb, mb, a, ref lf, ref vacuum, _params);
            hermitecalc(pa, ma, pb, mb, b, ref rf, ref vacuum, _params);
            
            //
            //check, that 'A' and 'B' are't roots,
            //and that root exist
            //
            if( Math.Sign(lf)*Math.Sign(rf)>0 )
            {
                result = 0;
                return result;
            }
            else
            {
                if( (double)(lf)==(double)(0) )
                {
                    x = a;
                    result = 1;
                    return result;
                }
                else
                {
                    if( (double)(rf)==(double)(0) )
                    {
                        x = b;
                        result = 1;
                        return result;
                    }
                }
            }
            
            //
            //searching a root
            //
            do
            {
                m = (b0+a0)/2;
                hermitecalc(pa, ma, pb, mb, a0, ref lf, ref vacuum, _params);
                hermitecalc(pa, ma, pb, mb, b0, ref rf, ref vacuum, _params);
                hermitecalc(pa, ma, pb, mb, m, ref mf, ref vacuum, _params);
                if( Math.Sign(mf)*Math.Sign(lf)<0 )
                {
                    b0 = m;
                }
                else
                {
                    if( Math.Sign(mf)*Math.Sign(rf)<0 )
                    {
                        a0 = m;
                    }
                    else
                    {
                        if( (double)(lf)==(double)(0) )
                        {
                            x = a0;
                            result = 1;
                            return result;
                        }
                        if( (double)(rf)==(double)(0) )
                        {
                            x = b0;
                            result = 1;
                            return result;
                        }
                        if( (double)(mf)==(double)(0) )
                        {
                            x = m;
                            result = 1;
                            return result;
                        }
                    }
                }
            }
            while( (double)(Math.Abs(b0-a0))>=(double)(eps) );
            x = m;
            result = 1;
            return result;
        }


        /*************************************************************************
        This function builds monotone cubic Hermite interpolant. This interpolant
        is monotonic in [x(0),x(n-1)] and is constant outside of this interval.

        In  case  y[]  form  non-monotonic  sequence,  interpolant  is  piecewise
        monotonic.  Say, for x=(0,1,2,3,4)  and  y=(0,1,2,1,0)  interpolant  will
        monotonically grow at [0..2] and monotonically decrease at [2..4].

        INPUT PARAMETERS:
            X           -   spline nodes, array[0..N-1]. Subroutine automatically
                            sorts points, so caller may pass unsorted array.
            Y           -   function values, array[0..N-1]
            N           -   the number of points(N>=2).

        OUTPUT PARAMETERS:
            C           -   spline interpolant.

         -- ALGLIB PROJECT --
             Copyright 21.06.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dbuildmonotone(double[] x,
            double[] y,
            int n,
            spline1dinterpolant c,
            alglib.xparams _params)
        {
            double[] d = new double[0];
            double[] ex = new double[0];
            double[] ey = new double[0];
            int[] p = new int[0];
            double delta = 0;
            double alpha = 0;
            double beta = 0;
            int tmpn = 0;
            int sn = 0;
            double ca = 0;
            double cb = 0;
            double epsilon = 0;
            int i = 0;
            int j = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();

            
            //
            // Check lengths of arguments
            //
            alglib.ap.assert(n>=2, "Spline1DBuildMonotone: N<2");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DBuildMonotone: Length(X)<N");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DBuildMonotone: Length(Y)<N");
            
            //
            // Check and sort points
            //
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DBuildMonotone: X contains infinite or NAN values");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DBuildMonotone: Y contains infinite or NAN values");
            heapsortppoints(ref x, ref y, ref p, n, _params);
            alglib.ap.assert(apserv.aredistinct(x, n, _params), "Spline1DBuildMonotone: at least two consequent points are too close");
            epsilon = math.machineepsilon;
            n = n+2;
            d = new double[n];
            ex = new double[n];
            ey = new double[n];
            ex[0] = x[0]-Math.Abs(x[1]-x[0]);
            ex[n-1] = x[n-3]+Math.Abs(x[n-3]-x[n-4]);
            ey[0] = y[0];
            ey[n-1] = y[n-3];
            for(i=1; i<=n-2; i++)
            {
                ex[i] = x[i-1];
                ey[i] = y[i-1];
            }
            
            //
            // Init sign of the function for first segment
            //
            i = 0;
            ca = 0;
            do
            {
                ca = ey[i+1]-ey[i];
                i = i+1;
            }
            while( !((double)(ca)!=(double)(0) || i>n-2) );
            if( (double)(ca)!=(double)(0) )
            {
                ca = ca/Math.Abs(ca);
            }
            i = 0;
            while( i<n-1 )
            {
                
                //
                // Partition of the segment [X0;Xn]
                //
                tmpn = 1;
                for(j=i; j<=n-2; j++)
                {
                    cb = ey[j+1]-ey[j];
                    if( (double)(ca*cb)>=(double)(0) )
                    {
                        tmpn = tmpn+1;
                    }
                    else
                    {
                        ca = cb/Math.Abs(cb);
                        break;
                    }
                }
                sn = i+tmpn;
                alglib.ap.assert(tmpn>=2, "Spline1DBuildMonotone: internal error");
                
                //
                // Calculate derivatives for current segment
                //
                d[i] = 0;
                d[sn-1] = 0;
                for(j=i+1; j<=sn-2; j++)
                {
                    d[j] = ((ey[j]-ey[j-1])/(ex[j]-ex[j-1])+(ey[j+1]-ey[j])/(ex[j+1]-ex[j]))/2;
                }
                for(j=i; j<=sn-2; j++)
                {
                    delta = (ey[j+1]-ey[j])/(ex[j+1]-ex[j]);
                    if( (double)(Math.Abs(delta))<=(double)(epsilon) )
                    {
                        d[j] = 0;
                        d[j+1] = 0;
                    }
                    else
                    {
                        alpha = d[j]/delta;
                        beta = d[j+1]/delta;
                        if( (double)(alpha)!=(double)(0) )
                        {
                            cb = alpha*Math.Sqrt(1+math.sqr(beta/alpha));
                        }
                        else
                        {
                            if( (double)(beta)!=(double)(0) )
                            {
                                cb = beta;
                            }
                            else
                            {
                                continue;
                            }
                        }
                        if( (double)(cb)>(double)(3) )
                        {
                            d[j] = 3*alpha*delta/cb;
                            d[j+1] = 3*beta*delta/cb;
                        }
                    }
                }
                
                //
                // Transition to next segment
                //
                i = sn-1;
            }
            spline1dbuildhermite(ex, ey, d, n, c, _params);
            c.continuity = 2;
        }


        /*************************************************************************
        Internal version of Spline1DGridDiffCubic.

        Accepts pre-ordered X/Y, temporary arrays (which may be  preallocated,  if
        you want to save time, or not) and output array (which may be preallocated
        too).

        Y is passed as var-parameter because we may need to force last element  to
        be equal to the first one (if periodic boundary conditions are specified).

          -- ALGLIB PROJECT --
             Copyright 03.09.2010 by Bochkanov Sergey
        *************************************************************************/
        private static void spline1dgriddiffcubicinternal(double[] x,
            ref double[] y,
            int n,
            int boundltype,
            double boundl,
            int boundrtype,
            double boundr,
            ref double[] d,
            ref double[] a1,
            ref double[] a2,
            ref double[] a3,
            ref double[] b,
            ref double[] dt,
            alglib.xparams _params)
        {
            int i = 0;
            int i_ = 0;

            
            //
            // allocate arrays
            //
            if( alglib.ap.len(d)<n )
            {
                d = new double[n];
            }
            if( alglib.ap.len(a1)<n )
            {
                a1 = new double[n];
            }
            if( alglib.ap.len(a2)<n )
            {
                a2 = new double[n];
            }
            if( alglib.ap.len(a3)<n )
            {
                a3 = new double[n];
            }
            if( alglib.ap.len(b)<n )
            {
                b = new double[n];
            }
            if( alglib.ap.len(dt)<n )
            {
                dt = new double[n];
            }
            
            //
            // Special cases:
            // * N=2, parabolic terminated boundary condition on both ends
            // * N=2, periodic boundary condition
            //
            if( (n==2 && boundltype==0) && boundrtype==0 )
            {
                d[0] = (y[1]-y[0])/(x[1]-x[0]);
                d[1] = d[0];
                return;
            }
            if( (n==2 && boundltype==-1) && boundrtype==-1 )
            {
                d[0] = 0;
                d[1] = 0;
                return;
            }
            
            //
            // Periodic and non-periodic boundary conditions are
            // two separate classes
            //
            if( boundrtype==-1 && boundltype==-1 )
            {
                
                //
                // Periodic boundary conditions
                //
                y[n-1] = y[0];
                
                //
                // Boundary conditions at N-1 points
                // (one point less because last point is the same as first point).
                //
                a1[0] = x[1]-x[0];
                a2[0] = 2*(x[1]-x[0]+x[n-1]-x[n-2]);
                a3[0] = x[n-1]-x[n-2];
                b[0] = 3*(y[n-1]-y[n-2])/(x[n-1]-x[n-2])*(x[1]-x[0])+3*(y[1]-y[0])/(x[1]-x[0])*(x[n-1]-x[n-2]);
                for(i=1; i<=n-2; i++)
                {
                    
                    //
                    // Altough last point is [N-2], we use X[N-1] and Y[N-1]
                    // (because of periodicity)
                    //
                    a1[i] = x[i+1]-x[i];
                    a2[i] = 2*(x[i+1]-x[i-1]);
                    a3[i] = x[i]-x[i-1];
                    b[i] = 3*(y[i]-y[i-1])/(x[i]-x[i-1])*(x[i+1]-x[i])+3*(y[i+1]-y[i])/(x[i+1]-x[i])*(x[i]-x[i-1]);
                }
                
                //
                // Solve, add last point (with index N-1)
                //
                solvecyclictridiagonal(a1, a2, a3, b, n-1, ref dt, _params);
                for(i_=0; i_<=n-2;i_++)
                {
                    d[i_] = dt[i_];
                }
                d[n-1] = d[0];
            }
            else
            {
                
                //
                // Non-periodic boundary condition.
                // Left boundary conditions.
                //
                if( boundltype==0 )
                {
                    a1[0] = 0;
                    a2[0] = 1;
                    a3[0] = 1;
                    b[0] = 2*(y[1]-y[0])/(x[1]-x[0]);
                }
                if( boundltype==1 )
                {
                    a1[0] = 0;
                    a2[0] = 1;
                    a3[0] = 0;
                    b[0] = boundl;
                }
                if( boundltype==2 )
                {
                    a1[0] = 0;
                    a2[0] = 2;
                    a3[0] = 1;
                    b[0] = 3*(y[1]-y[0])/(x[1]-x[0])-0.5*boundl*(x[1]-x[0]);
                }
                
                //
                // Central conditions
                //
                for(i=1; i<=n-2; i++)
                {
                    a1[i] = x[i+1]-x[i];
                    a2[i] = 2*(x[i+1]-x[i-1]);
                    a3[i] = x[i]-x[i-1];
                    b[i] = 3*(y[i]-y[i-1])/(x[i]-x[i-1])*(x[i+1]-x[i])+3*(y[i+1]-y[i])/(x[i+1]-x[i])*(x[i]-x[i-1]);
                }
                
                //
                // Right boundary conditions
                //
                if( boundrtype==0 )
                {
                    a1[n-1] = 1;
                    a2[n-1] = 1;
                    a3[n-1] = 0;
                    b[n-1] = 2*(y[n-1]-y[n-2])/(x[n-1]-x[n-2]);
                }
                if( boundrtype==1 )
                {
                    a1[n-1] = 0;
                    a2[n-1] = 1;
                    a3[n-1] = 0;
                    b[n-1] = boundr;
                }
                if( boundrtype==2 )
                {
                    a1[n-1] = 1;
                    a2[n-1] = 2;
                    a3[n-1] = 0;
                    b[n-1] = 3*(y[n-1]-y[n-2])/(x[n-1]-x[n-2])+0.5*boundr*(x[n-1]-x[n-2]);
                }
                
                //
                // Solve
                //
                solvetridiagonal(a1, a2, a3, b, n, ref d, _params);
            }
        }


        /*************************************************************************
        Internal subroutine. Heap sort.
        *************************************************************************/
        private static void heapsortpoints(ref double[] x,
            ref double[] y,
            int n,
            alglib.xparams _params)
        {
            double[] bufx = new double[0];
            double[] bufy = new double[0];

            tsort.tagsortfastr(ref x, ref y, ref bufx, ref bufy, n, _params);
        }


        /*************************************************************************
        Internal subroutine. Heap sort.

        Accepts:
            X, Y    -   points
            P       -   empty or preallocated array
            
        Returns:
            X, Y    -   sorted by X
            P       -   array of permutations; I-th position of output
                        arrays X/Y contains (X[P[I]],Y[P[I]])
        *************************************************************************/
        private static void heapsortppoints(ref double[] x,
            ref double[] y,
            ref int[] p,
            int n,
            alglib.xparams _params)
        {
            double[] rbuf = new double[0];
            int[] ibuf = new int[0];
            int i = 0;
            int i_ = 0;

            if( alglib.ap.len(p)<n )
            {
                p = new int[n];
            }
            rbuf = new double[n];
            for(i=0; i<=n-1; i++)
            {
                p[i] = i;
            }
            tsort.tagsortfasti(ref x, ref p, ref rbuf, ref ibuf, n, _params);
            for(i=0; i<=n-1; i++)
            {
                rbuf[i] = y[p[i]];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                y[i_] = rbuf[i_];
            }
        }


        /*************************************************************************
        Internal subroutine. Tridiagonal solver. Solves

        ( B[0] C[0]                      
        ( A[1] B[1] C[1]                 )
        (      A[2] B[2] C[2]            )
        (            ..........          ) * X = D
        (            ..........          )
        (           A[N-2] B[N-2] C[N-2] )
        (                  A[N-1] B[N-1] )

        *************************************************************************/
        private static void solvetridiagonal(double[] a,
            double[] b,
            double[] c,
            double[] d,
            int n,
            ref double[] x,
            alglib.xparams _params)
        {
            int k = 0;
            double t = 0;

            b = (double[])b.Clone();
            d = (double[])d.Clone();

            if( alglib.ap.len(x)<n )
            {
                x = new double[n];
            }
            for(k=1; k<=n-1; k++)
            {
                t = a[k]/b[k-1];
                b[k] = b[k]-t*c[k-1];
                d[k] = d[k]-t*d[k-1];
            }
            x[n-1] = d[n-1]/b[n-1];
            for(k=n-2; k>=0; k--)
            {
                x[k] = (d[k]-c[k]*x[k+1])/b[k];
            }
        }


        /*************************************************************************
        Internal subroutine. Cyclic tridiagonal solver. Solves

        ( B[0] C[0]                 A[0] )
        ( A[1] B[1] C[1]                 )
        (      A[2] B[2] C[2]            )
        (            ..........          ) * X = D
        (            ..........          )
        (           A[N-2] B[N-2] C[N-2] )
        ( C[N-1]           A[N-1] B[N-1] )
        *************************************************************************/
        private static void solvecyclictridiagonal(double[] a,
            double[] b,
            double[] c,
            double[] d,
            int n,
            ref double[] x,
            alglib.xparams _params)
        {
            int k = 0;
            double alpha = 0;
            double beta = 0;
            double gamma = 0;
            double[] y = new double[0];
            double[] z = new double[0];
            double[] u = new double[0];

            b = (double[])b.Clone();

            if( alglib.ap.len(x)<n )
            {
                x = new double[n];
            }
            beta = a[0];
            alpha = c[n-1];
            gamma = -b[0];
            b[0] = 2*b[0];
            b[n-1] = b[n-1]-alpha*beta/gamma;
            u = new double[n];
            for(k=0; k<=n-1; k++)
            {
                u[k] = 0;
            }
            u[0] = gamma;
            u[n-1] = alpha;
            solvetridiagonal(a, b, c, d, n, ref y, _params);
            solvetridiagonal(a, b, c, u, n, ref z, _params);
            for(k=0; k<=n-1; k++)
            {
                x[k] = y[k]-(y[0]+beta/gamma*y[n-1])/(1+z[0]+beta/gamma*z[n-1])*z[k];
            }
        }


        /*************************************************************************
        Internal subroutine. Three-point differentiation
        *************************************************************************/
        private static double diffthreepoint(double t,
            double x0,
            double f0,
            double x1,
            double f1,
            double x2,
            double f2,
            alglib.xparams _params)
        {
            double result = 0;
            double a = 0;
            double b = 0;

            t = t-x0;
            x1 = x1-x0;
            x2 = x2-x0;
            a = (f2-f0-x2/x1*(f1-f0))/(math.sqr(x2)-x1*x2);
            b = (f1-f0-a*math.sqr(x1))/x1;
            result = 2*a*t+b;
            return result;
        }


        /*************************************************************************
        Procedure for calculating value of a function is providet in the form of
        Hermite polinom  

        INPUT PARAMETERS:
            P0   -   value of a function at 0
            M0   -   value of a derivative at 0
            P1   -   value of a function at 1
            M1   -   value of a derivative at 1
            T    -   point inside [0;1]
            
        OUTPUT PARAMETERS:
            S    -   value of a function at T
            B0   -   value of a derivative function at T
            
         -- ALGLIB PROJECT --
             Copyright 26.09.2011 by Bochkanov Sergey
        *************************************************************************/
        private static void hermitecalc(double p0,
            double m0,
            double p1,
            double m1,
            double t,
            ref double s,
            ref double ds,
            alglib.xparams _params)
        {
            s = 0;
            ds = 0;

            s = p0*(1+2*t)*(1-t)*(1-t)+m0*t*(1-t)*(1-t)+p1*(3-2*t)*t*t+m1*t*t*(t-1);
            ds = -(p0*6*t*(1-t))+m0*(1-t)*(1-3*t)+p1*6*t*(1-t)+m1*t*(3*t-2);
        }


        /*************************************************************************
        Function for mapping from [A0;B0] to [A1;B1]

        INPUT PARAMETERS:
            A0   -   left border [A0;B0]
            B0   -   right border [A0;B0]
            A1   -   left border [A1;B1]
            B1   -   right border [A1;B1]
            T    -   value inside [A0;B0]  
            
        RESTRICTIONS OF PARAMETERS:

        We assume, that B0>A0 and B1>A1. But we chech, that T is inside [A0;B0], 
        and if T<A0 then T become A1, if T>B0 then T - B1. 

        INPUT PARAMETERS:
                A0   -   left border for segment [A0;B0] from 'T' is converted to [A1;B1] 
                B0   -   right border for segment [A0;B0] from 'T' is converted to [A1;B1] 
                A1   -   left border for segment [A1;B1] to 'T' is converted from [A0;B0] 
                B1   -   right border for segment [A1;B1] to 'T' is converted from [A0;B0] 
                T    -   the parameter is mapped from [A0;B0] to [A1;B1] 

        Result:
            is converted value for 'T' from [A0;B0] to [A1;B1]
                 
        REMARK:

        The function dont check value A0,B0 and A1,B1!

         -- ALGLIB PROJECT --
             Copyright 26.09.2011 by Bochkanov Sergey
        *************************************************************************/
        private static double rescaleval(double a0,
            double b0,
            double a1,
            double b1,
            double t,
            alglib.xparams _params)
        {
            double result = 0;

            
            //
            //return left border
            //
            if( (double)(t)<=(double)(a0) )
            {
                result = a1;
                return result;
            }
            
            //
            //return right border
            //
            if( (double)(t)>=(double)(b0) )
            {
                result = b1;
                return result;
            }
            
            //
            //return value between left and right borders
            //
            result = (b1-a1)*(t-a0)/(b0-a0)+a1;
            return result;
        }


    }
    public class lsfit
    {
        /*************************************************************************
        Polynomial fitting report:
            TaskRCond       reciprocal of task's condition number
            RMSError        RMS error
            AvgError        average error
            AvgRelError     average relative error (for non-zero Y[I])
            MaxError        maximum error
        *************************************************************************/
        public class polynomialfitreport : apobject
        {
            public double taskrcond;
            public double rmserror;
            public double avgerror;
            public double avgrelerror;
            public double maxerror;
            public polynomialfitreport()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                polynomialfitreport _result = new polynomialfitreport();
                _result.taskrcond = taskrcond;
                _result.rmserror = rmserror;
                _result.avgerror = avgerror;
                _result.avgrelerror = avgrelerror;
                _result.maxerror = maxerror;
                return _result;
            }
        };


        /*************************************************************************
        Barycentric fitting report:
            RMSError        RMS error
            AvgError        average error
            AvgRelError     average relative error (for non-zero Y[I])
            MaxError        maximum error
            TaskRCond       reciprocal of task's condition number
        *************************************************************************/
        public class barycentricfitreport : apobject
        {
            public double taskrcond;
            public int dbest;
            public double rmserror;
            public double avgerror;
            public double avgrelerror;
            public double maxerror;
            public barycentricfitreport()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                barycentricfitreport _result = new barycentricfitreport();
                _result.taskrcond = taskrcond;
                _result.dbest = dbest;
                _result.rmserror = rmserror;
                _result.avgerror = avgerror;
                _result.avgrelerror = avgrelerror;
                _result.maxerror = maxerror;
                return _result;
            }
        };


        /*************************************************************************
        Least squares fitting report. This structure contains informational fields
        which are set by fitting functions provided by this unit.

        Different functions initialize different sets of  fields,  so  you  should
        read documentation on specific function you used in order  to  know  which
        fields are initialized.

            TaskRCond       reciprocal of task's condition number
            IterationsCount number of internal iterations
            
            VarIdx          if user-supplied gradient contains errors  which  were
                            detected by nonlinear fitter, this  field  is  set  to
                            index  of  the  first  component  of gradient which is
                            suspected to be spoiled by bugs.

            RMSError        RMS error
            AvgError        average error
            AvgRelError     average relative error (for non-zero Y[I])
            MaxError        maximum error

            WRMSError       weighted RMS error

            CovPar          covariance matrix for parameters, filled by some solvers
            ErrPar          vector of errors in parameters, filled by some solvers
            ErrCurve        vector of fit errors -  variability  of  the  best-fit
                            curve, filled by some solvers.
            Noise           vector of per-point noise estimates, filled by
                            some solvers.
            R2              coefficient of determination (non-weighted, non-adjusted),
                            filled by some solvers.
        *************************************************************************/
        public class lsfitreport : apobject
        {
            public double taskrcond;
            public int iterationscount;
            public int varidx;
            public double rmserror;
            public double avgerror;
            public double avgrelerror;
            public double maxerror;
            public double wrmserror;
            public double[,] covpar;
            public double[] errpar;
            public double[] errcurve;
            public double[] noise;
            public double r2;
            public lsfitreport()
            {
                init();
            }
            public override void init()
            {
                covpar = new double[0,0];
                errpar = new double[0];
                errcurve = new double[0];
                noise = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                lsfitreport _result = new lsfitreport();
                _result.taskrcond = taskrcond;
                _result.iterationscount = iterationscount;
                _result.varidx = varidx;
                _result.rmserror = rmserror;
                _result.avgerror = avgerror;
                _result.avgrelerror = avgrelerror;
                _result.maxerror = maxerror;
                _result.wrmserror = wrmserror;
                _result.covpar = (double[,])covpar.Clone();
                _result.errpar = (double[])errpar.Clone();
                _result.errcurve = (double[])errcurve.Clone();
                _result.noise = (double[])noise.Clone();
                _result.r2 = r2;
                return _result;
            }
        };


        /*************************************************************************
        Nonlinear fitter.

        You should use ALGLIB functions to work with fitter.
        Never try to access its fields directly!
        *************************************************************************/
        public class lsfitstate : apobject
        {
            public int optalgo;
            public int m;
            public int k;
            public double epsx;
            public int maxits;
            public double stpmax;
            public bool xrep;
            public double[] c0;
            public double[] c1;
            public double[] s;
            public double[] bndl;
            public double[] bndu;
            public double[,] taskx;
            public double[] tasky;
            public int npoints;
            public double[] taskw;
            public int nweights;
            public int wkind;
            public int wits;
            public double diffstep;
            public double teststep;
            public double[,] cleic;
            public int nec;
            public int nic;
            public bool xupdated;
            public bool needf;
            public bool needfg;
            public bool needfgh;
            public int pointindex;
            public double[] x;
            public double[] c;
            public double f;
            public double[] g;
            public double[,] h;
            public double[] wcur;
            public int[] tmpct;
            public double[] tmp;
            public double[] tmpf;
            public double[,] tmpjac;
            public double[,] tmpjacw;
            public double tmpnoise;
            public matinv.matinvreport invrep;
            public int repiterationscount;
            public int repterminationtype;
            public int repvaridx;
            public double reprmserror;
            public double repavgerror;
            public double repavgrelerror;
            public double repmaxerror;
            public double repwrmserror;
            public lsfitreport rep;
            public minlm.minlmstate optstate;
            public minlm.minlmreport optrep;
            public int prevnpt;
            public int prevalgo;
            public rcommstate rstate;
            public lsfitstate()
            {
                init();
            }
            public override void init()
            {
                c0 = new double[0];
                c1 = new double[0];
                s = new double[0];
                bndl = new double[0];
                bndu = new double[0];
                taskx = new double[0,0];
                tasky = new double[0];
                taskw = new double[0];
                cleic = new double[0,0];
                x = new double[0];
                c = new double[0];
                g = new double[0];
                h = new double[0,0];
                wcur = new double[0];
                tmpct = new int[0];
                tmp = new double[0];
                tmpf = new double[0];
                tmpjac = new double[0,0];
                tmpjacw = new double[0,0];
                invrep = new matinv.matinvreport();
                rep = new lsfitreport();
                optstate = new minlm.minlmstate();
                optrep = new minlm.minlmreport();
                rstate = new rcommstate();
            }
            public override alglib.apobject make_copy()
            {
                lsfitstate _result = new lsfitstate();
                _result.optalgo = optalgo;
                _result.m = m;
                _result.k = k;
                _result.epsx = epsx;
                _result.maxits = maxits;
                _result.stpmax = stpmax;
                _result.xrep = xrep;
                _result.c0 = (double[])c0.Clone();
                _result.c1 = (double[])c1.Clone();
                _result.s = (double[])s.Clone();
                _result.bndl = (double[])bndl.Clone();
                _result.bndu = (double[])bndu.Clone();
                _result.taskx = (double[,])taskx.Clone();
                _result.tasky = (double[])tasky.Clone();
                _result.npoints = npoints;
                _result.taskw = (double[])taskw.Clone();
                _result.nweights = nweights;
                _result.wkind = wkind;
                _result.wits = wits;
                _result.diffstep = diffstep;
                _result.teststep = teststep;
                _result.cleic = (double[,])cleic.Clone();
                _result.nec = nec;
                _result.nic = nic;
                _result.xupdated = xupdated;
                _result.needf = needf;
                _result.needfg = needfg;
                _result.needfgh = needfgh;
                _result.pointindex = pointindex;
                _result.x = (double[])x.Clone();
                _result.c = (double[])c.Clone();
                _result.f = f;
                _result.g = (double[])g.Clone();
                _result.h = (double[,])h.Clone();
                _result.wcur = (double[])wcur.Clone();
                _result.tmpct = (int[])tmpct.Clone();
                _result.tmp = (double[])tmp.Clone();
                _result.tmpf = (double[])tmpf.Clone();
                _result.tmpjac = (double[,])tmpjac.Clone();
                _result.tmpjacw = (double[,])tmpjacw.Clone();
                _result.tmpnoise = tmpnoise;
                _result.invrep = (matinv.matinvreport)invrep.make_copy();
                _result.repiterationscount = repiterationscount;
                _result.repterminationtype = repterminationtype;
                _result.repvaridx = repvaridx;
                _result.reprmserror = reprmserror;
                _result.repavgerror = repavgerror;
                _result.repavgrelerror = repavgrelerror;
                _result.repmaxerror = repmaxerror;
                _result.repwrmserror = repwrmserror;
                _result.rep = (lsfitreport)rep.make_copy();
                _result.optstate = (minlm.minlmstate)optstate.make_copy();
                _result.optrep = (minlm.minlmreport)optrep.make_copy();
                _result.prevnpt = prevnpt;
                _result.prevalgo = prevalgo;
                _result.rstate = (rcommstate)rstate.make_copy();
                return _result;
            }
        };




        /*************************************************************************
        This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
        Peucker algorithm, which stops after generating specified number of linear
        sections.

        IMPORTANT:
        * it does NOT perform least-squares fitting; it  builds  curve,  but  this
          curve does not minimize some least squares metric.  See  description  of
          RDP algorithm (say, in Wikipedia) for more details on WHAT is performed.
        * this function does NOT work with parametric curves  (i.e.  curves  which
          can be represented as {X(t),Y(t)}. It works with curves   which  can  be
          represented as Y(X). Thus,  it  is  impossible  to  model  figures  like
          circles  with  this  functions.
          If  you  want  to  work  with  parametric   curves,   you   should   use
          ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
          "Interpolation" package.

        INPUT PARAMETERS:
            X       -   array of X-coordinates:
                        * at least N elements
                        * can be unordered (points are automatically sorted)
                        * this function may accept non-distinct X (see below for
                          more information on handling of such inputs)
            Y       -   array of Y-coordinates:
                        * at least N elements
            N       -   number of elements in X/Y
            M       -   desired number of sections:
                        * at most M sections are generated by this function
                        * less than M sections can be generated if we have N<M
                          (or some X are non-distinct).

        OUTPUT PARAMETERS:
            X2      -   X-values of corner points for piecewise approximation,
                        has length NSections+1 or zero (for NSections=0).
            Y2      -   Y-values of corner points,
                        has length NSections+1 or zero (for NSections=0).
            NSections-  number of sections found by algorithm, NSections<=M,
                        NSections can be zero for degenerate datasets
                        (N<=1 or all X[] are non-distinct).

        NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
              curve, (X2[NSection-1],Y2[NSection-1]) is the last point.

          -- ALGLIB --
             Copyright 02.10.2014 by Bochkanov Sergey
        *************************************************************************/
        public static void lstfitpiecewiselinearrdpfixed(double[] x,
            double[] y,
            int n,
            int m,
            ref double[] x2,
            ref double[] y2,
            ref int nsections,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int k0 = 0;
            int k1 = 0;
            int k2 = 0;
            double[] buf0 = new double[0];
            double[] buf1 = new double[0];
            double[,] sections = new double[0,0];
            double[] points = new double[0];
            double v = 0;
            int worstidx = 0;
            double worsterror = 0;
            int idx0 = 0;
            int idx1 = 0;
            double e0 = 0;
            double e1 = 0;
            double[] heaperrors = new double[0];
            int[] heaptags = new int[0];

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            x2 = new double[0];
            y2 = new double[0];
            nsections = 0;

            alglib.ap.assert(n>=0, "LSTFitPiecewiseLinearRDPFixed: N<0");
            alglib.ap.assert(m>=1, "LSTFitPiecewiseLinearRDPFixed: M<1");
            alglib.ap.assert(alglib.ap.len(x)>=n, "LSTFitPiecewiseLinearRDPFixed: Length(X)<N");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSTFitPiecewiseLinearRDPFixed: Length(Y)<N");
            if( n<=1 )
            {
                nsections = 0;
                return;
            }
            
            //
            // Sort points.
            // Handle possible ties (tied values are replaced by their mean)
            //
            tsort.tagsortfastr(ref x, ref y, ref buf0, ref buf1, n, _params);
            i = 0;
            while( i<=n-1 )
            {
                j = i+1;
                v = y[i];
                while( j<=n-1 && (double)(x[j])==(double)(x[i]) )
                {
                    v = v+y[j];
                    j = j+1;
                }
                v = v/(j-i);
                for(k=i; k<=j-1; k++)
                {
                    y[k] = v;
                }
                i = j;
            }
            
            //
            // Handle degenerate case x[0]=x[N-1]
            //
            if( (double)(x[n-1])==(double)(x[0]) )
            {
                nsections = 0;
                return;
            }
            
            //
            // Prepare first section
            //
            rdpanalyzesection(x, y, 0, n-1, ref worstidx, ref worsterror, _params);
            sections = new double[m, 4];
            heaperrors = new double[m];
            heaptags = new int[m];
            nsections = 1;
            sections[0,0] = 0;
            sections[0,1] = n-1;
            sections[0,2] = worstidx;
            sections[0,3] = worsterror;
            heaperrors[0] = worsterror;
            heaptags[0] = 0;
            alglib.ap.assert((double)(sections[0,1])==(double)(n-1), "RDP algorithm: integrity check failed");
            
            //
            // Main loop.
            // Repeatedly find section with worst error and divide it.
            // Terminate after M-th section, or because of other reasons (see loop internals).
            //
            while( nsections<m )
            {
                
                //
                // Break if worst section has zero error.
                // Store index of worst section to K.
                //
                if( (double)(heaperrors[0])==(double)(0) )
                {
                    break;
                }
                k = heaptags[0];
                
                //
                // K-th section is divided in two:
                // * first  one spans interval from X[Sections[K,0]] to X[Sections[K,2]]
                // * second one spans interval from X[Sections[K,2]] to X[Sections[K,1]]
                //
                // First section is stored at K-th position, second one is appended to the table.
                // Then we update heap which stores pairs of (error,section_index)
                //
                k0 = (int)Math.Round(sections[k,0]);
                k1 = (int)Math.Round(sections[k,1]);
                k2 = (int)Math.Round(sections[k,2]);
                rdpanalyzesection(x, y, k0, k2, ref idx0, ref e0, _params);
                rdpanalyzesection(x, y, k2, k1, ref idx1, ref e1, _params);
                sections[k,0] = k0;
                sections[k,1] = k2;
                sections[k,2] = idx0;
                sections[k,3] = e0;
                tsort.tagheapreplacetopi(ref heaperrors, ref heaptags, nsections, e0, k, _params);
                sections[nsections,0] = k2;
                sections[nsections,1] = k1;
                sections[nsections,2] = idx1;
                sections[nsections,3] = e1;
                tsort.tagheappushi(ref heaperrors, ref heaptags, ref nsections, e1, nsections, _params);
            }
            
            //
            // Convert from sections to points
            //
            points = new double[nsections+1];
            k = (int)Math.Round(sections[0,1]);
            for(i=0; i<=nsections-1; i++)
            {
                points[i] = (int)Math.Round(sections[i,0]);
                if( (double)(x[(int)Math.Round(sections[i,1])])>(double)(x[k]) )
                {
                    k = (int)Math.Round(sections[i,1]);
                }
            }
            points[nsections] = k;
            tsort.tagsortfast(ref points, ref buf0, nsections+1, _params);
            
            //
            // Output sections:
            // * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
            // * last element of X2/Y2 is filled by right boundary of rightmost section
            // * X2/Y2 is sorted by ascending of X2
            //
            x2 = new double[nsections+1];
            y2 = new double[nsections+1];
            for(i=0; i<=nsections; i++)
            {
                x2[i] = x[(int)Math.Round(points[i])];
                y2[i] = y[(int)Math.Round(points[i])];
            }
        }


        /*************************************************************************
        This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
        Peucker algorithm, which stops after achieving desired precision.

        IMPORTANT:
        * it performs non-least-squares fitting; it builds curve, but  this  curve
          does not minimize some least squares  metric.  See  description  of  RDP
          algorithm (say, in Wikipedia) for more details on WHAT is performed.
        * this function does NOT work with parametric curves  (i.e.  curves  which
          can be represented as {X(t),Y(t)}. It works with curves   which  can  be
          represented as Y(X). Thus, it is impossible to model figures like circles
          with this functions.
          If  you  want  to  work  with  parametric   curves,   you   should   use
          ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
          "Interpolation" package.

        INPUT PARAMETERS:
            X       -   array of X-coordinates:
                        * at least N elements
                        * can be unordered (points are automatically sorted)
                        * this function may accept non-distinct X (see below for
                          more information on handling of such inputs)
            Y       -   array of Y-coordinates:
                        * at least N elements
            N       -   number of elements in X/Y
            Eps     -   positive number, desired precision.
            

        OUTPUT PARAMETERS:
            X2      -   X-values of corner points for piecewise approximation,
                        has length NSections+1 or zero (for NSections=0).
            Y2      -   Y-values of corner points,
                        has length NSections+1 or zero (for NSections=0).
            NSections-  number of sections found by algorithm,
                        NSections can be zero for degenerate datasets
                        (N<=1 or all X[] are non-distinct).

        NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
              curve, (X2[NSection-1],Y2[NSection-1]) is the last point.

          -- ALGLIB --
             Copyright 02.10.2014 by Bochkanov Sergey
        *************************************************************************/
        public static void lstfitpiecewiselinearrdp(double[] x,
            double[] y,
            int n,
            double eps,
            ref double[] x2,
            ref double[] y2,
            ref int nsections,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            double[] buf0 = new double[0];
            double[] buf1 = new double[0];
            double[] xtmp = new double[0];
            double[] ytmp = new double[0];
            double v = 0;
            int npts = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            x2 = new double[0];
            y2 = new double[0];
            nsections = 0;

            alglib.ap.assert(n>=0, "LSTFitPiecewiseLinearRDP: N<0");
            alglib.ap.assert((double)(eps)>(double)(0), "LSTFitPiecewiseLinearRDP: Eps<=0");
            alglib.ap.assert(alglib.ap.len(x)>=n, "LSTFitPiecewiseLinearRDP: Length(X)<N");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSTFitPiecewiseLinearRDP: Length(Y)<N");
            if( n<=1 )
            {
                nsections = 0;
                return;
            }
            
            //
            // Sort points.
            // Handle possible ties (tied values are replaced by their mean)
            //
            tsort.tagsortfastr(ref x, ref y, ref buf0, ref buf1, n, _params);
            i = 0;
            while( i<=n-1 )
            {
                j = i+1;
                v = y[i];
                while( j<=n-1 && (double)(x[j])==(double)(x[i]) )
                {
                    v = v+y[j];
                    j = j+1;
                }
                v = v/(j-i);
                for(k=i; k<=j-1; k++)
                {
                    y[k] = v;
                }
                i = j;
            }
            
            //
            // Handle degenerate case x[0]=x[N-1]
            //
            if( (double)(x[n-1])==(double)(x[0]) )
            {
                nsections = 0;
                return;
            }
            
            //
            // Prepare data for recursive algorithm
            //
            xtmp = new double[n];
            ytmp = new double[n];
            npts = 2;
            xtmp[0] = x[0];
            ytmp[0] = y[0];
            xtmp[1] = x[n-1];
            ytmp[1] = y[n-1];
            rdprecursive(x, y, 0, n-1, eps, xtmp, ytmp, ref npts, _params);
            
            //
            // Output sections:
            // * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
            // * last element of X2/Y2 is filled by right boundary of rightmost section
            // * X2/Y2 is sorted by ascending of X2
            //
            nsections = npts-1;
            x2 = new double[npts];
            y2 = new double[npts];
            for(i=0; i<=nsections; i++)
            {
                x2[i] = xtmp[i];
                y2[i] = ytmp[i];
            }
            tsort.tagsortfastr(ref x2, ref y2, ref buf0, ref buf1, npts, _params);
        }


        /*************************************************************************
        Fitting by polynomials in barycentric form. This function provides  simple
        unterface for unconstrained unweighted fitting. See  PolynomialFitWC()  if
        you need constrained fitting.

        The task is linear, thus the linear least  squares  solver  is  used.  The
        complexity of this computational scheme is O(N*M^2), mostly  dominated  by
        the least squares solver

        SEE ALSO:
            PolynomialFitWC()

        NOTES:
            you can convert P from barycentric form  to  the  power  or  Chebyshev
            basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
            POLINT subpackage.

        INPUT PARAMETERS:
            X   -   points, array[0..N-1].
            Y   -   function values, array[0..N-1].
            N   -   number of points, N>0
                    * if given, only leading N elements of X/Y are used
                    * if not given, automatically determined from sizes of X/Y
            M   -   number of basis functions (= polynomial_degree + 1), M>=1

        OUTPUT PARAMETERS:
            Info-   same format as in LSFitLinearW() subroutine:
                    * Info>0    task is solved
                    * Info<=0   an error occured:
                                -4 means inconvergence of internal SVD
            P   -   interpolant in barycentric form.
            Rep -   report, same format as in LSFitLinearW() subroutine.
                    Following fields are set:
                    * RMSError      rms error on the (X,Y).
                    * AvgError      average error on the (X,Y).
                    * AvgRelError   average relative error on the non-zero Y
                    * MaxError      maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB PROJECT --
             Copyright 10.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialfit(double[] x,
            double[] y,
            int n,
            int m,
            ref int info,
            ratint.barycentricinterpolant p,
            polynomialfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            double[] w = new double[0];
            double[] xc = new double[0];
            double[] yc = new double[0];
            int[] dc = new int[0];

            info = 0;

            alglib.ap.assert(n>0, "PolynomialFit: N<=0!");
            alglib.ap.assert(m>0, "PolynomialFit: M<=0!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "PolynomialFit: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "PolynomialFit: Length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "PolynomialFit: X contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "PolynomialFit: Y contains infinite or NaN values!");
            w = new double[n];
            for(i=0; i<=n-1; i++)
            {
                w[i] = 1;
            }
            polynomialfitwc(x, y, w, n, xc, yc, dc, 0, m, ref info, p, rep, _params);
        }


        /*************************************************************************
        Weighted  fitting by polynomials in barycentric form, with constraints  on
        function values or first derivatives.

        Small regularizing term is used when solving constrained tasks (to improve
        stability).

        Task is linear, so linear least squares solver is used. Complexity of this
        computational scheme is O(N*M^2), mostly dominated by least squares solver

        SEE ALSO:
            PolynomialFit()

        NOTES:
            you can convert P from barycentric form  to  the  power  or  Chebyshev
            basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
            POLINT subpackage.

        INPUT PARAMETERS:
            X   -   points, array[0..N-1].
            Y   -   function values, array[0..N-1].
            W   -   weights, array[0..N-1]
                    Each summand in square  sum  of  approximation deviations from
                    given  values  is  multiplied  by  the square of corresponding
                    weight. Fill it by 1's if you don't  want  to  solve  weighted
                    task.
            N   -   number of points, N>0.
                    * if given, only leading N elements of X/Y/W are used
                    * if not given, automatically determined from sizes of X/Y/W
            XC  -   points where polynomial values/derivatives are constrained,
                    array[0..K-1].
            YC  -   values of constraints, array[0..K-1]
            DC  -   array[0..K-1], types of constraints:
                    * DC[i]=0   means that P(XC[i])=YC[i]
                    * DC[i]=1   means that P'(XC[i])=YC[i]
                    SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
            K   -   number of constraints, 0<=K<M.
                    K=0 means no constraints (XC/YC/DC are not used in such cases)
            M   -   number of basis functions (= polynomial_degree + 1), M>=1

        OUTPUT PARAMETERS:
            Info-   same format as in LSFitLinearW() subroutine:
                    * Info>0    task is solved
                    * Info<=0   an error occured:
                                -4 means inconvergence of internal SVD
                                -3 means inconsistent constraints
            P   -   interpolant in barycentric form.
            Rep -   report, same format as in LSFitLinearW() subroutine.
                    Following fields are set:
                    * RMSError      rms error on the (X,Y).
                    * AvgError      average error on the (X,Y).
                    * AvgRelError   average relative error on the non-zero Y
                    * MaxError      maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

        IMPORTANT:
            this subroitine doesn't calculate task's condition number for K<>0.

        SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

        Setting constraints can lead  to undesired  results,  like ill-conditioned
        behavior, or inconsistency being detected. From the other side,  it allows
        us to improve quality of the fit. Here we summarize  our  experience  with
        constrained regression splines:
        * even simple constraints can be inconsistent, see  Wikipedia  article  on
          this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
        * the  greater  is  M (given  fixed  constraints),  the  more chances that
          constraints will be consistent
        * in the general case, consistency of constraints is NOT GUARANTEED.
        * in the one special cases, however, we can  guarantee  consistency.  This
          case  is:  M>1  and constraints on the function values (NOT DERIVATIVES)

        Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
        can't solve your task without them. Anything beyond  special  cases  given
        above is not guaranteed and may result in inconsistency.

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB PROJECT --
             Copyright 10.12.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void polynomialfitwc(double[] x,
            double[] y,
            double[] w,
            int n,
            double[] xc,
            double[] yc,
            int[] dc,
            int k,
            int m,
            ref int info,
            ratint.barycentricinterpolant p,
            polynomialfitreport rep,
            alglib.xparams _params)
        {
            double xa = 0;
            double xb = 0;
            double sa = 0;
            double sb = 0;
            double[] xoriginal = new double[0];
            double[] yoriginal = new double[0];
            double[] y2 = new double[0];
            double[] w2 = new double[0];
            double[] tmp = new double[0];
            double[] tmp2 = new double[0];
            double[] bx = new double[0];
            double[] by = new double[0];
            double[] bw = new double[0];
            int i = 0;
            int j = 0;
            double u = 0;
            double v = 0;
            double s = 0;
            int relcnt = 0;
            lsfitreport lrep = new lsfitreport();

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            w = (double[])w.Clone();
            xc = (double[])xc.Clone();
            yc = (double[])yc.Clone();
            info = 0;

            alglib.ap.assert(n>0, "PolynomialFitWC: N<=0!");
            alglib.ap.assert(m>0, "PolynomialFitWC: M<=0!");
            alglib.ap.assert(k>=0, "PolynomialFitWC: K<0!");
            alglib.ap.assert(k<m, "PolynomialFitWC: K>=M!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "PolynomialFitWC: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "PolynomialFitWC: Length(Y)<N!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "PolynomialFitWC: Length(W)<N!");
            alglib.ap.assert(alglib.ap.len(xc)>=k, "PolynomialFitWC: Length(XC)<K!");
            alglib.ap.assert(alglib.ap.len(yc)>=k, "PolynomialFitWC: Length(YC)<K!");
            alglib.ap.assert(alglib.ap.len(dc)>=k, "PolynomialFitWC: Length(DC)<K!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "PolynomialFitWC: X contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "PolynomialFitWC: Y contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "PolynomialFitWC: X contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(xc, k, _params), "PolynomialFitWC: XC contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(yc, k, _params), "PolynomialFitWC: YC contains infinite or NaN values!");
            for(i=0; i<=k-1; i++)
            {
                alglib.ap.assert(dc[i]==0 || dc[i]==1, "PolynomialFitWC: one of DC[] is not 0 or 1!");
            }
            
            //
            // Scale X, Y, XC, YC.
            // Solve scaled problem using internal Chebyshev fitting function.
            //
            intfitserv.lsfitscalexy(ref x, ref y, ref w, n, ref xc, ref yc, dc, k, ref xa, ref xb, ref sa, ref sb, ref xoriginal, ref yoriginal, _params);
            internalchebyshevfit(x, y, w, n, xc, yc, dc, k, m, ref info, ref tmp, lrep, _params);
            if( info<0 )
            {
                return;
            }
            
            //
            // Generate barycentric model and scale it
            // * BX, BY store barycentric model nodes
            // * FMatrix is reused (remember - it is at least MxM, what we need)
            //
            // Model intialization is done in O(M^2). In principle, it can be
            // done in O(M*log(M)), but before it we solved task with O(N*M^2)
            // complexity, so it is only a small amount of total time spent.
            //
            bx = new double[m];
            by = new double[m];
            bw = new double[m];
            tmp2 = new double[m];
            s = 1;
            for(i=0; i<=m-1; i++)
            {
                if( m!=1 )
                {
                    u = Math.Cos(Math.PI*i/(m-1));
                }
                else
                {
                    u = 0;
                }
                v = 0;
                for(j=0; j<=m-1; j++)
                {
                    if( j==0 )
                    {
                        tmp2[j] = 1;
                    }
                    else
                    {
                        if( j==1 )
                        {
                            tmp2[j] = u;
                        }
                        else
                        {
                            tmp2[j] = 2*u*tmp2[j-1]-tmp2[j-2];
                        }
                    }
                    v = v+tmp[j]*tmp2[j];
                }
                bx[i] = u;
                by[i] = v;
                bw[i] = s;
                if( i==0 || i==m-1 )
                {
                    bw[i] = 0.5*bw[i];
                }
                s = -s;
            }
            ratint.barycentricbuildxyw(bx, by, bw, m, p, _params);
            ratint.barycentriclintransx(p, 2/(xb-xa), -((xa+xb)/(xb-xa)), _params);
            ratint.barycentriclintransy(p, sb-sa, sa, _params);
            
            //
            // Scale absolute errors obtained from LSFitLinearW.
            // Relative error should be calculated separately
            // (because of shifting/scaling of the task)
            //
            rep.taskrcond = lrep.taskrcond;
            rep.rmserror = lrep.rmserror*(sb-sa);
            rep.avgerror = lrep.avgerror*(sb-sa);
            rep.maxerror = lrep.maxerror*(sb-sa);
            rep.avgrelerror = 0;
            relcnt = 0;
            for(i=0; i<=n-1; i++)
            {
                if( (double)(yoriginal[i])!=(double)(0) )
                {
                    rep.avgrelerror = rep.avgrelerror+Math.Abs(ratint.barycentriccalc(p, xoriginal[i], _params)-yoriginal[i])/Math.Abs(yoriginal[i]);
                    relcnt = relcnt+1;
                }
            }
            if( relcnt!=0 )
            {
                rep.avgrelerror = rep.avgrelerror/relcnt;
            }
        }


        /*************************************************************************
        This function calculates value of four-parameter logistic (4PL)  model  at
        specified point X. 4PL model has following form:

            F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

        INPUT PARAMETERS:
            X       -   current point, X>=0:
                        * zero X is correctly handled even for B<=0
                        * negative X results in exception.
            A, B, C, D- parameters of 4PL model:
                        * A is unconstrained
                        * B is unconstrained; zero or negative values are handled
                          correctly.
                        * C>0, non-positive value results in exception
                        * D is unconstrained
                        
        RESULT:
            model value at X

        NOTE: if B=0, denominator is assumed to be equal to 2.0 even  for  zero  X
              (strictly speaking, 0^0 is undefined).

        NOTE: this function also throws exception  if  all  input  parameters  are
              correct, but overflow was detected during calculations.
              
        NOTE: this function performs a lot of checks;  if  you  need  really  high
              performance, consider evaluating model  yourself,  without  checking
              for degenerate cases.
              
            
          -- ALGLIB PROJECT --
             Copyright 14.05.2014 by Bochkanov Sergey
        *************************************************************************/
        public static double logisticcalc4(double x,
            double a,
            double b,
            double c,
            double d,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x), "LogisticCalc4: X is not finite");
            alglib.ap.assert(math.isfinite(a), "LogisticCalc4: A is not finite");
            alglib.ap.assert(math.isfinite(b), "LogisticCalc4: B is not finite");
            alglib.ap.assert(math.isfinite(c), "LogisticCalc4: C is not finite");
            alglib.ap.assert(math.isfinite(d), "LogisticCalc4: D is not finite");
            alglib.ap.assert((double)(x)>=(double)(0), "LogisticCalc4: X is negative");
            alglib.ap.assert((double)(c)>(double)(0), "LogisticCalc4: C is non-positive");
            
            //
            // Check for degenerate cases
            //
            if( (double)(b)==(double)(0) )
            {
                result = 0.5*(a+d);
                return result;
            }
            if( (double)(x)==(double)(0) )
            {
                if( (double)(b)>(double)(0) )
                {
                    result = a;
                }
                else
                {
                    result = d;
                }
                return result;
            }
            
            //
            // General case
            //
            result = d+(a-d)/(1.0+Math.Pow(x/c, b));
            alglib.ap.assert(math.isfinite(result), "LogisticCalc4: overflow during calculations");
            return result;
        }


        /*************************************************************************
        This function calculates value of five-parameter logistic (5PL)  model  at
        specified point X. 5PL model has following form:

            F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

        INPUT PARAMETERS:
            X       -   current point, X>=0:
                        * zero X is correctly handled even for B<=0
                        * negative X results in exception.
            A, B, C, D, G- parameters of 5PL model:
                        * A is unconstrained
                        * B is unconstrained; zero or negative values are handled
                          correctly.
                        * C>0, non-positive value results in exception
                        * D is unconstrained
                        * G>0, non-positive value results in exception
                        
        RESULT:
            model value at X

        NOTE: if B=0, denominator is assumed to be equal to Power(2.0,G) even  for
              zero X (strictly speaking, 0^0 is undefined).

        NOTE: this function also throws exception  if  all  input  parameters  are
              correct, but overflow was detected during calculations.
              
        NOTE: this function performs a lot of checks;  if  you  need  really  high
              performance, consider evaluating model  yourself,  without  checking
              for degenerate cases.
              
            
          -- ALGLIB PROJECT --
             Copyright 14.05.2014 by Bochkanov Sergey
        *************************************************************************/
        public static double logisticcalc5(double x,
            double a,
            double b,
            double c,
            double d,
            double g,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x), "LogisticCalc5: X is not finite");
            alglib.ap.assert(math.isfinite(a), "LogisticCalc5: A is not finite");
            alglib.ap.assert(math.isfinite(b), "LogisticCalc5: B is not finite");
            alglib.ap.assert(math.isfinite(c), "LogisticCalc5: C is not finite");
            alglib.ap.assert(math.isfinite(d), "LogisticCalc5: D is not finite");
            alglib.ap.assert(math.isfinite(g), "LogisticCalc5: G is not finite");
            alglib.ap.assert((double)(x)>=(double)(0), "LogisticCalc5: X is negative");
            alglib.ap.assert((double)(c)>(double)(0), "LogisticCalc5: C is non-positive");
            alglib.ap.assert((double)(g)>(double)(0), "LogisticCalc5: G is non-positive");
            
            //
            // Check for degenerate cases
            //
            if( (double)(b)==(double)(0) )
            {
                result = d+(a-d)/Math.Pow(2.0, g);
                return result;
            }
            if( (double)(x)==(double)(0) )
            {
                if( (double)(b)>(double)(0) )
                {
                    result = a;
                }
                else
                {
                    result = d;
                }
                return result;
            }
            
            //
            // General case
            //
            result = d+(a-d)/Math.Pow(1.0+Math.Pow(x/c, b), g);
            alglib.ap.assert(math.isfinite(result), "LogisticCalc5: overflow during calculations");
            return result;
        }


        /*************************************************************************
        This function fits four-parameter logistic (4PL) model  to  data  provided
        by user. 4PL model has following form:

            F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

        Here:
            * A, D - unconstrained (see LogisticFit4EC() for constrained 4PL)
            * B>=0
            * C>0
            
        IMPORTANT: output of this function is constrained in  such  way that  B>0.
                   Because 4PL model is symmetric with respect to B, there  is  no
                   need to explore  B<0.  Constraining  B  makes  algorithm easier
                   to stabilize and debug.
                   Users  who  for  some  reason  prefer to work with negative B's
                   should transform output themselves (swap A and D, replace B  by
                   -B).
                   
        4PL fitting is implemented as follows:
        * we perform small number of restarts from random locations which helps to
          solve problem of bad local extrema. Locations are only partially  random
          - we use input data to determine good  initial  guess,  but  we  include
          controlled amount of randomness.
        * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
          parameters B and C - it allows us to find good  initial  guess  for  the
          second stage without risk of running into "flat spot".
        * second  Levenberg-Marquardt  round  is   performed   without   excessive
          constraints. Results from the previous round are used as initial guess.
        * after fitting is done, we compare results with best values found so far,
          rewrite "best solution" if needed, and move to next random location.
          
        Overall algorithm is very stable and is not prone to  bad  local  extrema.
        Furthermore, it automatically scales when input data have  very  large  or
        very small range.

        INPUT PARAMETERS:
            X       -   array[N], stores X-values.
                        MUST include only non-negative numbers  (but  may  include
                        zero values). Can be unsorted.
            Y       -   array[N], values to fit.
            N       -   number of points. If N is less than  length  of  X/Y, only
                        leading N elements are used.
                        
        OUTPUT PARAMETERS:
            A, B, C, D- parameters of 4PL model
            Rep     -   fitting report. This structure has many fields,  but  ONLY
                        ONES LISTED BELOW ARE SET:
                        * Rep.IterationsCount - number of iterations performed
                        * Rep.RMSError - root-mean-square error
                        * Rep.AvgError - average absolute error
                        * Rep.AvgRelError - average relative error (calculated for
                          non-zero Y-values)
                        * Rep.MaxError - maximum absolute error
                        * Rep.R2 - coefficient of determination,  R-squared.  This
                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                          of nonlinear  regression  there  are  multiple  ways  to
                          define R2, each of them giving different results).

        NOTE: for stability reasons the B parameter is restricted by [1/1000,1000]
              range. It prevents  algorithm from making trial steps  deep into the
              area of bad parameters.

        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
              LogisticCalc4() function.

        NOTE: if you need better control over fitting process than provided by this
              function, you may use LogisticFit45X().
                        
        NOTE: step is automatically scaled according to scale of parameters  being
              fitted before we compare its length with EpsX. Thus,  this  function
              can be used to fit data with very small or very large values without
              changing EpsX.
            

          -- ALGLIB PROJECT --
             Copyright 14.02.2014 by Bochkanov Sergey
        *************************************************************************/
        public static void logisticfit4(double[] x,
            double[] y,
            int n,
            ref double a,
            ref double b,
            ref double c,
            ref double d,
            lsfitreport rep,
            alglib.xparams _params)
        {
            double g = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            a = 0;
            b = 0;
            c = 0;
            d = 0;

            logisticfit45x(x, y, n, Double.NaN, Double.NaN, true, 0.0, 0.0, 0, ref a, ref b, ref c, ref d, ref g, rep, _params);
        }


        /*************************************************************************
        This function fits four-parameter logistic (4PL) model  to  data  provided
        by user, with optional constraints on parameters A and D.  4PL  model  has
        following form:

            F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))

        Here:
            * A, D - with optional equality constraints
            * B>=0
            * C>0
            
        IMPORTANT: output of this function is constrained in  such  way that  B>0.
                   Because 4PL model is symmetric with respect to B, there  is  no
                   need to explore  B<0.  Constraining  B  makes  algorithm easier
                   to stabilize and debug.
                   Users  who  for  some  reason  prefer to work with negative B's
                   should transform output themselves (swap A and D, replace B  by
                   -B).
                   
        4PL fitting is implemented as follows:
        * we perform small number of restarts from random locations which helps to
          solve problem of bad local extrema. Locations are only partially  random
          - we use input data to determine good  initial  guess,  but  we  include
          controlled amount of randomness.
        * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
          parameters B and C - it allows us to find good  initial  guess  for  the
          second stage without risk of running into "flat spot".
        * second  Levenberg-Marquardt  round  is   performed   without   excessive
          constraints. Results from the previous round are used as initial guess.
        * after fitting is done, we compare results with best values found so far,
          rewrite "best solution" if needed, and move to next random location.
          
        Overall algorithm is very stable and is not prone to  bad  local  extrema.
        Furthermore, it automatically scales when input data have  very  large  or
        very small range.

        INPUT PARAMETERS:
            X       -   array[N], stores X-values.
                        MUST include only non-negative numbers  (but  may  include
                        zero values). Can be unsorted.
            Y       -   array[N], values to fit.
            N       -   number of points. If N is less than  length  of  X/Y, only
                        leading N elements are used.
            CnstrLeft-  optional equality constraint for model value at the   left
                        boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                        not need constraint on the model value at X=0 (in C++  you
                        can pass alglib::fp_nan as parameter, in  C#  it  will  be
                        Double.NaN).
                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                        information about constraints.
            CnstrRight- optional equality constraint for model value at X=infinity.
                        Specify NAN (Not-a-Number) if you do not  need  constraint
                        on the model value (in C++  you can pass alglib::fp_nan as
                        parameter, in  C# it will  be Double.NaN).
                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                        information about constraints.
                        
        OUTPUT PARAMETERS:
            A, B, C, D- parameters of 4PL model
            Rep     -   fitting report. This structure has many fields,  but  ONLY
                        ONES LISTED BELOW ARE SET:
                        * Rep.IterationsCount - number of iterations performed
                        * Rep.RMSError - root-mean-square error
                        * Rep.AvgError - average absolute error
                        * Rep.AvgRelError - average relative error (calculated for
                          non-zero Y-values)
                        * Rep.MaxError - maximum absolute error
                        * Rep.R2 - coefficient of determination,  R-squared.  This
                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                          of nonlinear  regression  there  are  multiple  ways  to
                          define R2, each of them giving different results).

        NOTE: for stability reasons the B parameter is restricted by [1/1000,1000]
              range. It prevents  algorithm from making trial steps  deep into the
              area of bad parameters.

        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
              LogisticCalc4() function.

        NOTE: if you need better control over fitting process than provided by this
              function, you may use LogisticFit45X().
                        
        NOTE: step is automatically scaled according to scale of parameters  being
              fitted before we compare its length with EpsX. Thus,  this  function
              can be used to fit data with very small or very large values without
              changing EpsX.

        EQUALITY CONSTRAINTS ON PARAMETERS

        4PL/5PL solver supports equality constraints on model values at  the  left
        boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
        completely optional and you can specify both of them, only  one  -  or  no
        constraints at all.

        Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
        fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
        ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
        D. That's because 4PL model is normalized in such way that B>=0.
            

          -- ALGLIB PROJECT --
             Copyright 14.02.2014 by Bochkanov Sergey
        *************************************************************************/
        public static void logisticfit4ec(double[] x,
            double[] y,
            int n,
            double cnstrleft,
            double cnstrright,
            ref double a,
            ref double b,
            ref double c,
            ref double d,
            lsfitreport rep,
            alglib.xparams _params)
        {
            double g = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            a = 0;
            b = 0;
            c = 0;
            d = 0;

            logisticfit45x(x, y, n, cnstrleft, cnstrright, true, 0.0, 0.0, 0, ref a, ref b, ref c, ref d, ref g, rep, _params);
        }


        /*************************************************************************
        This function fits five-parameter logistic (5PL) model  to  data  provided
        by user. 5PL model has following form:

            F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

        Here:
            * A, D - unconstrained
            * B - unconstrained
            * C>0
            * G>0
            
        IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
                   constrained in  such  way that B is guaranteed to be  positive.
                   Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
                   respect to B, so you can NOT transform model to equivalent one,
                   with B having desired sign (>0 or <0).
            
        5PL fitting is implemented as follows:
        * we perform small number of restarts from random locations which helps to
          solve problem of bad local extrema. Locations are only partially  random
          - we use input data to determine good  initial  guess,  but  we  include
          controlled amount of randomness.
        * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
          parameters B and C - it allows us to find good  initial  guess  for  the
          second stage without risk of running into "flat spot".  Parameter  G  is
          fixed at G=1.
        * second  Levenberg-Marquardt  round  is   performed   without   excessive
          constraints on B and C, but with G still equal to 1.  Results  from  the
          previous round are used as initial guess.
        * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
          different models - one with B>0 and one with B<0.
        * after fitting is done, we compare results with best values found so far,
          rewrite "best solution" if needed, and move to next random location.
          
        Overall algorithm is very stable and is not prone to  bad  local  extrema.
        Furthermore, it automatically scales when input data have  very  large  or
        very small range.

        INPUT PARAMETERS:
            X       -   array[N], stores X-values.
                        MUST include only non-negative numbers  (but  may  include
                        zero values). Can be unsorted.
            Y       -   array[N], values to fit.
            N       -   number of points. If N is less than  length  of  X/Y, only
                        leading N elements are used.
                        
        OUTPUT PARAMETERS:
            A,B,C,D,G-  parameters of 5PL model
            Rep     -   fitting report. This structure has many fields,  but  ONLY
                        ONES LISTED BELOW ARE SET:
                        * Rep.IterationsCount - number of iterations performed
                        * Rep.RMSError - root-mean-square error
                        * Rep.AvgError - average absolute error
                        * Rep.AvgRelError - average relative error (calculated for
                          non-zero Y-values)
                        * Rep.MaxError - maximum absolute error
                        * Rep.R2 - coefficient of determination,  R-squared.  This
                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                          of nonlinear  regression  there  are  multiple  ways  to
                          define R2, each of them giving different results).

        NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
              range, and G is restricted by [1/10,10] range. It prevents algorithm
              from making trial steps deep into the area of bad parameters.

        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
              LogisticCalc5() function.

        NOTE: if you need better control over fitting process than provided by this
              function, you may use LogisticFit45X().
                        
        NOTE: step is automatically scaled according to scale of parameters  being
              fitted before we compare its length with EpsX. Thus,  this  function
              can be used to fit data with very small or very large values without
              changing EpsX.
            

          -- ALGLIB PROJECT --
             Copyright 14.02.2014 by Bochkanov Sergey
        *************************************************************************/
        public static void logisticfit5(double[] x,
            double[] y,
            int n,
            ref double a,
            ref double b,
            ref double c,
            ref double d,
            ref double g,
            lsfitreport rep,
            alglib.xparams _params)
        {
            x = (double[])x.Clone();
            y = (double[])y.Clone();
            a = 0;
            b = 0;
            c = 0;
            d = 0;
            g = 0;

            logisticfit45x(x, y, n, Double.NaN, Double.NaN, false, 0.0, 0.0, 0, ref a, ref b, ref c, ref d, ref g, rep, _params);
        }


        /*************************************************************************
        This function fits five-parameter logistic (5PL) model  to  data  provided
        by user, subject to optional equality constraints on parameters A  and  D.
        5PL model has following form:

            F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)

        Here:
            * A, D - with optional equality constraints
            * B - unconstrained
            * C>0
            * G>0
            
        IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
                   constrained in  such  way that B is guaranteed to be  positive.
                   Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
                   respect to B, so you can NOT transform model to equivalent one,
                   with B having desired sign (>0 or <0).
            
        5PL fitting is implemented as follows:
        * we perform small number of restarts from random locations which helps to
          solve problem of bad local extrema. Locations are only partially  random
          - we use input data to determine good  initial  guess,  but  we  include
          controlled amount of randomness.
        * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
          parameters B and C - it allows us to find good  initial  guess  for  the
          second stage without risk of running into "flat spot".  Parameter  G  is
          fixed at G=1.
        * second  Levenberg-Marquardt  round  is   performed   without   excessive
          constraints on B and C, but with G still equal to 1.  Results  from  the
          previous round are used as initial guess.
        * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
          different models - one with B>0 and one with B<0.
        * after fitting is done, we compare results with best values found so far,
          rewrite "best solution" if needed, and move to next random location.
          
        Overall algorithm is very stable and is not prone to  bad  local  extrema.
        Furthermore, it automatically scales when input data have  very  large  or
        very small range.

        INPUT PARAMETERS:
            X       -   array[N], stores X-values.
                        MUST include only non-negative numbers  (but  may  include
                        zero values). Can be unsorted.
            Y       -   array[N], values to fit.
            N       -   number of points. If N is less than  length  of  X/Y, only
                        leading N elements are used.
            CnstrLeft-  optional equality constraint for model value at the   left
                        boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                        not need constraint on the model value at X=0 (in C++  you
                        can pass alglib::fp_nan as parameter, in  C#  it  will  be
                        Double.NaN).
                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                        information about constraints.
            CnstrRight- optional equality constraint for model value at X=infinity.
                        Specify NAN (Not-a-Number) if you do not  need  constraint
                        on the model value (in C++  you can pass alglib::fp_nan as
                        parameter, in  C# it will  be Double.NaN).
                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                        information about constraints.
                        
        OUTPUT PARAMETERS:
            A,B,C,D,G-  parameters of 5PL model
            Rep     -   fitting report. This structure has many fields,  but  ONLY
                        ONES LISTED BELOW ARE SET:
                        * Rep.IterationsCount - number of iterations performed
                        * Rep.RMSError - root-mean-square error
                        * Rep.AvgError - average absolute error
                        * Rep.AvgRelError - average relative error (calculated for
                          non-zero Y-values)
                        * Rep.MaxError - maximum absolute error
                        * Rep.R2 - coefficient of determination,  R-squared.  This
                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                          of nonlinear  regression  there  are  multiple  ways  to
                          define R2, each of them giving different results).

        NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
              range, and G is restricted by [1/10,10] range. It prevents algorithm
              from making trial steps deep into the area of bad parameters.

        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
              LogisticCalc5() function.

        NOTE: if you need better control over fitting process than provided by this
              function, you may use LogisticFit45X().
                        
        NOTE: step is automatically scaled according to scale of parameters  being
              fitted before we compare its length with EpsX. Thus,  this  function
              can be used to fit data with very small or very large values without
              changing EpsX.

        EQUALITY CONSTRAINTS ON PARAMETERS

        5PL solver supports equality constraints on model  values  at   the   left
        boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
        completely optional and you can specify both of them, only  one  -  or  no
        constraints at all.

        Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
        fitting), and CnstrRight contains right  one.

        Unlike 4PL one, 5PL model is NOT symmetric with respect to  change in sign
        of B. Thus, negative B's are possible, and left constraint  may  constrain
        parameter A (for positive B's)  -  or  parameter  D  (for  negative  B's).
        Similarly changes meaning of right constraint.

        You do not have to decide what parameter to  constrain  -  algorithm  will
        automatically determine correct parameters as fitting progresses. However,
        question highlighted above is important when you interpret fitting results.
            

          -- ALGLIB PROJECT --
             Copyright 14.02.2014 by Bochkanov Sergey
        *************************************************************************/
        public static void logisticfit5ec(double[] x,
            double[] y,
            int n,
            double cnstrleft,
            double cnstrright,
            ref double a,
            ref double b,
            ref double c,
            ref double d,
            ref double g,
            lsfitreport rep,
            alglib.xparams _params)
        {
            x = (double[])x.Clone();
            y = (double[])y.Clone();
            a = 0;
            b = 0;
            c = 0;
            d = 0;
            g = 0;

            logisticfit45x(x, y, n, cnstrleft, cnstrright, false, 0.0, 0.0, 0, ref a, ref b, ref c, ref d, ref g, rep, _params);
        }


        /*************************************************************************
        This is "expert" 4PL/5PL fitting function, which can be used if  you  need
        better control over fitting process than provided  by  LogisticFit4()  or
        LogisticFit5().

        This function fits model of the form

            F(x|A,B,C,D)   = D+(A-D)/(1+Power(x/C,B))           (4PL model)

        or

            F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)    (5PL model)
            
        Here:
            * A, D - unconstrained
            * B>=0 for 4PL, unconstrained for 5PL
            * C>0
            * G>0 (if present)

        INPUT PARAMETERS:
            X       -   array[N], stores X-values.
                        MUST include only non-negative numbers  (but  may  include
                        zero values). Can be unsorted.
            Y       -   array[N], values to fit.
            N       -   number of points. If N is less than  length  of  X/Y, only
                        leading N elements are used.
            CnstrLeft-  optional equality constraint for model value at the   left
                        boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
                        not need constraint on the model value at X=0 (in C++  you
                        can pass alglib::fp_nan as parameter, in  C#  it  will  be
                        Double.NaN).
                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                        information about constraints.
            CnstrRight- optional equality constraint for model value at X=infinity.
                        Specify NAN (Not-a-Number) if you do not  need  constraint
                        on the model value (in C++  you can pass alglib::fp_nan as
                        parameter, in  C# it will  be Double.NaN).
                        See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
                        information about constraints.
            Is4PL   -   whether 4PL or 5PL models are fitted
            LambdaV -   regularization coefficient, LambdaV>=0.
                        Set it to zero unless you know what you are doing.
            EpsX    -   stopping condition (step size), EpsX>=0.
                        Zero value means that small step is automatically chosen.
                        See notes below for more information.
            RsCnt   -   number of repeated restarts from  random  points.  4PL/5PL
                        models are prone to problem of bad local extrema. Utilizing
                        multiple random restarts allows  us  to  improve algorithm
                        convergence.
                        RsCnt>=0.
                        Zero value means that function automatically choose  small
                        amount of restarts (recommended).
                        
        OUTPUT PARAMETERS:
            A, B, C, D- parameters of 4PL model
            G       -   parameter of 5PL model; for Is4PL=True, G=1 is returned.
            Rep     -   fitting report. This structure has many fields,  but  ONLY
                        ONES LISTED BELOW ARE SET:
                        * Rep.IterationsCount - number of iterations performed
                        * Rep.RMSError - root-mean-square error
                        * Rep.AvgError - average absolute error
                        * Rep.AvgRelError - average relative error (calculated for
                          non-zero Y-values)
                        * Rep.MaxError - maximum absolute error
                        * Rep.R2 - coefficient of determination,  R-squared.  This
                          coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
                          of nonlinear  regression  there  are  multiple  ways  to
                          define R2, each of them giving different results).
                        
        NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
              range, and G is restricted by [1/10,10] range. It prevents algorithm
              from making trial steps deep into the area of bad parameters.

        NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
              LogisticCalc5() function.

        NOTE: step is automatically scaled according to scale of parameters  being
              fitted before we compare its length with EpsX. Thus,  this  function
              can be used to fit data with very small or very large values without
              changing EpsX.

        EQUALITY CONSTRAINTS ON PARAMETERS

        4PL/5PL solver supports equality constraints on model values at  the  left
        boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
        completely optional and you can specify both of them, only  one  -  or  no
        constraints at all.

        Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
        fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
        ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
        D. That's because 4PL model is normalized in such way that B>=0.

        For 5PL model things are different. Unlike  4PL  one,  5PL  model  is  NOT
        symmetric with respect to  change  in  sign  of  B. Thus, negative B's are
        possible, and left constraint may constrain parameter A (for positive B's)
        - or parameter D (for negative B's). Similarly changes  meaning  of  right
        constraint.

        You do not have to decide what parameter to  constrain  -  algorithm  will
        automatically determine correct parameters as fitting progresses. However,
        question highlighted above is important when you interpret fitting results.
            

          -- ALGLIB PROJECT --
             Copyright 14.02.2014 by Bochkanov Sergey
        *************************************************************************/
        public static void logisticfit45x(double[] x,
            double[] y,
            int n,
            double cnstrleft,
            double cnstrright,
            bool is4pl,
            double lambdav,
            double epsx,
            int rscnt,
            ref double a,
            ref double b,
            ref double c,
            ref double d,
            ref double g,
            lsfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            int outerit = 0;
            int nz = 0;
            double v = 0;
            double[] p0 = new double[0];
            double[] p1 = new double[0];
            double[] p2 = new double[0];
            double[] bndl = new double[0];
            double[] bndu = new double[0];
            double[] s = new double[0];
            double[] bndl1 = new double[0];
            double[] bndu1 = new double[0];
            double[] bndl2 = new double[0];
            double[] bndu2 = new double[0];
            double[,] z = new double[0,0];
            hqrnd.hqrndstate rs = new hqrnd.hqrndstate();
            minlm.minlmstate state = new minlm.minlmstate();
            minlm.minlmreport replm = new minlm.minlmreport();
            int maxits = 0;
            double fbest = 0;
            double flast = 0;
            double scalex = 0;
            double scaley = 0;
            double[] bufx = new double[0];
            double[] bufy = new double[0];
            double fposb = 0;
            double fnegb = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            a = 0;
            b = 0;
            c = 0;
            d = 0;
            g = 0;

            alglib.ap.assert(math.isfinite(epsx), "LogisticFitX: EpsX is infinite/NAN");
            alglib.ap.assert(math.isfinite(lambdav), "LogisticFitX: LambdaV is infinite/NAN");
            alglib.ap.assert(math.isfinite(cnstrleft) || Double.IsNaN(cnstrleft), "LogisticFitX: CnstrLeft is NOT finite or NAN");
            alglib.ap.assert(math.isfinite(cnstrright) || Double.IsNaN(cnstrright), "LogisticFitX: CnstrRight is NOT finite or NAN");
            alglib.ap.assert((double)(lambdav)>=(double)(0), "LogisticFitX: negative LambdaV");
            alglib.ap.assert(n>0, "LogisticFitX: N<=0");
            alglib.ap.assert(rscnt>=0, "LogisticFitX: RsCnt<0");
            alglib.ap.assert((double)(epsx)>=(double)(0), "LogisticFitX: EpsX<0");
            alglib.ap.assert(alglib.ap.len(x)>=n, "LogisticFitX: Length(X)<N");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LogisticFitX: Length(Y)<N");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "LogisticFitX: X contains infinite/NAN values");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LogisticFitX: X contains infinite/NAN values");
            hqrnd.hqrndseed(2211, 1033044, rs, _params);
            clearreport(rep, _params);
            if( (double)(epsx)==(double)(0) )
            {
                epsx = 1.0E-10;
            }
            if( rscnt==0 )
            {
                rscnt = 4;
            }
            maxits = 1000;
            
            //
            // Sort points by X.
            // Determine number of zero and non-zero values.
            //
            tsort.tagsortfastr(ref x, ref y, ref bufx, ref bufy, n, _params);
            alglib.ap.assert((double)(x[0])>=(double)(0), "LogisticFitX: some X[] are negative");
            nz = n;
            for(i=0; i<=n-1; i++)
            {
                if( (double)(x[i])>(double)(0) )
                {
                    nz = i;
                    break;
                }
            }
            
            //
            // For NZ=N (all X[] are zero) special code is used.
            // For NZ<N we use general-purpose code.
            //
            rep.iterationscount = 0;
            if( nz==n )
            {
                
                //
                // NZ=N, degenerate problem.
                // No need to run optimizer.
                //
                v = 0.0;
                for(i=0; i<=n-1; i++)
                {
                    v = v+y[i];
                }
                v = v/n;
                if( math.isfinite(cnstrleft) )
                {
                    a = cnstrleft;
                }
                else
                {
                    a = v;
                }
                b = 1;
                c = 1;
                if( math.isfinite(cnstrright) )
                {
                    d = cnstrright;
                }
                else
                {
                    d = a;
                }
                g = 1;
                logisticfit45errors(x, y, n, a, b, c, d, g, rep, _params);
                return;
            }
            
            //
            // Non-degenerate problem.
            // Determine scale of data.
            //
            scalex = x[nz+(n-nz)/2];
            alglib.ap.assert((double)(scalex)>(double)(0), "LogisticFitX: internal error");
            v = 0.0;
            for(i=0; i<=n-1; i++)
            {
                v = v+y[i];
            }
            v = v/n;
            scaley = 0.0;
            for(i=0; i<=n-1; i++)
            {
                scaley = scaley+math.sqr(y[i]-v);
            }
            scaley = Math.Sqrt(scaley/n);
            if( (double)(scaley)==(double)(0) )
            {
                scaley = 1.0;
            }
            s = new double[5];
            s[0] = scaley;
            s[1] = 0.1;
            s[2] = scalex;
            s[3] = scaley;
            s[4] = 0.1;
            p0 = new double[5];
            p0[0] = 0;
            p0[1] = 0;
            p0[2] = 0;
            p0[3] = 0;
            p0[4] = 0;
            bndl = new double[5];
            bndu = new double[5];
            bndl1 = new double[5];
            bndu1 = new double[5];
            bndl2 = new double[5];
            bndu2 = new double[5];
            minlm.minlmcreatevj(5, n+5, p0, state, _params);
            minlm.minlmsetscale(state, s, _params);
            minlm.minlmsetcond(state, epsx, maxits, _params);
            minlm.minlmsetxrep(state, true, _params);
            p1 = new double[5];
            p2 = new double[5];
            
            //
            // Is it 4PL problem?
            //
            if( is4pl )
            {
                
                //
                // Run outer iterations
                //
                a = 0;
                b = 1;
                c = 1;
                d = 1;
                g = 1;
                fbest = math.maxrealnumber;
                for(outerit=0; outerit<=rscnt-1; outerit++)
                {
                    
                    //
                    // Prepare initial point; use B>0
                    //
                    if( math.isfinite(cnstrleft) )
                    {
                        p1[0] = cnstrleft;
                    }
                    else
                    {
                        p1[0] = y[0]+0.15*scaley*(hqrnd.hqrnduniformr(rs, _params)-0.5);
                    }
                    p1[1] = 0.5+hqrnd.hqrnduniformr(rs, _params);
                    p1[2] = x[nz+hqrnd.hqrnduniformi(rs, n-nz, _params)];
                    if( math.isfinite(cnstrright) )
                    {
                        p1[3] = cnstrright;
                    }
                    else
                    {
                        p1[3] = y[n-1]+0.25*scaley*(hqrnd.hqrnduniformr(rs, _params)-0.5);
                    }
                    p1[4] = 1.0;
                    
                    //
                    // Run optimization with tight constraints and increased regularization
                    //
                    if( math.isfinite(cnstrleft) )
                    {
                        bndl[0] = cnstrleft;
                        bndu[0] = cnstrleft;
                    }
                    else
                    {
                        bndl[0] = Double.NegativeInfinity;
                        bndu[0] = Double.PositiveInfinity;
                    }
                    bndl[1] = 0.5;
                    bndu[1] = 2.0;
                    bndl[2] = 0.5*scalex;
                    bndu[2] = 2.0*scalex;
                    if( math.isfinite(cnstrright) )
                    {
                        bndl[3] = cnstrright;
                        bndu[3] = cnstrright;
                    }
                    else
                    {
                        bndl[3] = Double.NegativeInfinity;
                        bndu[3] = Double.PositiveInfinity;
                    }
                    bndl[4] = 1.0;
                    bndu[4] = 1.0;
                    minlm.minlmsetbc(state, bndl, bndu, _params);
                    logisticfitinternal(x, y, n, is4pl, 100*lambdav, state, replm, ref p1, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Relax constraints, run optimization one more time
                    //
                    bndl[1] = 0.1;
                    bndu[1] = 10.0;
                    bndl[2] = math.machineepsilon*scalex;
                    bndu[2] = scalex/math.machineepsilon;
                    minlm.minlmsetbc(state, bndl, bndu, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p1, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Relax constraints more, run optimization one more time
                    //
                    bndl[1] = 0.01;
                    bndu[1] = 100.0;
                    minlm.minlmsetbc(state, bndl, bndu, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p1, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Relax constraints ever more, run optimization one more time
                    //
                    bndl[1] = 0.001;
                    bndu[1] = 1000.0;
                    minlm.minlmsetbc(state, bndl, bndu, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p1, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Compare results with best value found so far.
                    //
                    if( (double)(flast)<(double)(fbest) )
                    {
                        a = p1[0];
                        b = p1[1];
                        c = p1[2];
                        d = p1[3];
                        g = p1[4];
                        fbest = flast;
                    }
                }
                logisticfit45errors(x, y, n, a, b, c, d, g, rep, _params);
                return;
            }
            
            //
            // Well.... we have 5PL fit, and we have to test two separate branches:
            // B>0 and B<0, because of asymmetry in the curve. First, we run optimization
            // with tight constraints two times, in order to determine better sign for B.
            //
            // Run outer iterations
            //
            a = 0;
            b = 1;
            c = 1;
            d = 1;
            g = 1;
            fbest = math.maxrealnumber;
            for(outerit=0; outerit<=rscnt-1; outerit++)
            {
                
                //
                // First, we try positive B.
                //
                p1[0] = y[0]+0.15*scaley*(hqrnd.hqrnduniformr(rs, _params)-0.5);
                p1[1] = 0.5+hqrnd.hqrnduniformr(rs, _params);
                p1[2] = x[nz+hqrnd.hqrnduniformi(rs, n-nz, _params)];
                p1[3] = y[n-1]+0.25*scaley*(hqrnd.hqrnduniformr(rs, _params)-0.5);
                p1[4] = 1.0;
                bndl1[0] = Double.NegativeInfinity;
                bndu1[0] = Double.PositiveInfinity;
                bndl1[1] = 0.5;
                bndu1[1] = 2.0;
                bndl1[2] = 0.5*scalex;
                bndu1[2] = 2.0*scalex;
                bndl1[3] = Double.NegativeInfinity;
                bndu1[3] = Double.PositiveInfinity;
                bndl1[4] = 0.5;
                bndu1[4] = 2.0;
                if( math.isfinite(cnstrleft) )
                {
                    p1[0] = cnstrleft;
                    bndl1[0] = cnstrleft;
                    bndu1[0] = cnstrleft;
                }
                if( math.isfinite(cnstrright) )
                {
                    p1[3] = cnstrright;
                    bndl1[3] = cnstrright;
                    bndu1[3] = cnstrright;
                }
                minlm.minlmsetbc(state, bndl1, bndu1, _params);
                logisticfitinternal(x, y, n, is4pl, 100*lambdav, state, replm, ref p1, ref fposb, _params);
                rep.iterationscount = rep.iterationscount+replm.iterationscount;
                
                //
                // Second attempt - with negative B (constraints are still tight).
                //
                p2[0] = y[n-1]+0.15*scaley*(hqrnd.hqrnduniformr(rs, _params)-0.5);
                p2[1] = -(0.5+hqrnd.hqrnduniformr(rs, _params));
                p2[2] = x[nz+hqrnd.hqrnduniformi(rs, n-nz, _params)];
                p2[3] = y[0]+0.25*scaley*(hqrnd.hqrnduniformr(rs, _params)-0.5);
                p2[4] = 1.0;
                bndl2[0] = Double.NegativeInfinity;
                bndu2[0] = Double.PositiveInfinity;
                bndl2[1] = -2.0;
                bndu2[1] = -0.5;
                bndl2[2] = 0.5*scalex;
                bndu2[2] = 2.0*scalex;
                bndl2[3] = Double.NegativeInfinity;
                bndu2[3] = Double.PositiveInfinity;
                bndl2[4] = 0.5;
                bndu2[4] = 2.0;
                if( math.isfinite(cnstrleft) )
                {
                    p2[3] = cnstrleft;
                    bndl2[3] = cnstrleft;
                    bndu2[3] = cnstrleft;
                }
                if( math.isfinite(cnstrright) )
                {
                    p2[0] = cnstrright;
                    bndl2[0] = cnstrright;
                    bndu2[0] = cnstrright;
                }
                minlm.minlmsetbc(state, bndl2, bndu2, _params);
                logisticfitinternal(x, y, n, is4pl, 100*lambdav, state, replm, ref p2, ref fnegb, _params);
                rep.iterationscount = rep.iterationscount+replm.iterationscount;
                
                //
                // Select best version of B sign
                //
                if( (double)(fposb)<(double)(fnegb) )
                {
                    
                    //
                    // Prepare relaxed constraints assuming that B is positive
                    //
                    bndl1[1] = 0.1;
                    bndu1[1] = 10.0;
                    bndl1[2] = math.machineepsilon*scalex;
                    bndu1[2] = scalex/math.machineepsilon;
                    bndl1[4] = 0.1;
                    bndu1[4] = 10.0;
                    minlm.minlmsetbc(state, bndl1, bndu1, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p1, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Prepare stronger relaxation of constraints
                    //
                    bndl1[1] = 0.01;
                    bndu1[1] = 100.0;
                    minlm.minlmsetbc(state, bndl1, bndu1, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p1, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Prepare stronger relaxation of constraints
                    //
                    bndl1[1] = 0.001;
                    bndu1[1] = 1000.0;
                    minlm.minlmsetbc(state, bndl1, bndu1, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p1, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Compare results with best value found so far.
                    //
                    if( (double)(flast)<(double)(fbest) )
                    {
                        a = p1[0];
                        b = p1[1];
                        c = p1[2];
                        d = p1[3];
                        g = p1[4];
                        fbest = flast;
                    }
                }
                else
                {
                    
                    //
                    // Prepare relaxed constraints assuming that B is negative
                    //
                    bndl2[1] = -10.0;
                    bndu2[1] = -0.1;
                    bndl2[2] = math.machineepsilon*scalex;
                    bndu2[2] = scalex/math.machineepsilon;
                    bndl2[4] = 0.1;
                    bndu2[4] = 10.0;
                    minlm.minlmsetbc(state, bndl2, bndu2, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p2, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Prepare stronger relaxation
                    //
                    bndl2[1] = -100.0;
                    bndu2[1] = -0.01;
                    minlm.minlmsetbc(state, bndl2, bndu2, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p2, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Prepare stronger relaxation
                    //
                    bndl2[1] = -1000.0;
                    bndu2[1] = -0.001;
                    minlm.minlmsetbc(state, bndl2, bndu2, _params);
                    logisticfitinternal(x, y, n, is4pl, lambdav, state, replm, ref p2, ref flast, _params);
                    rep.iterationscount = rep.iterationscount+replm.iterationscount;
                    
                    //
                    // Compare results with best value found so far.
                    //
                    if( (double)(flast)<(double)(fbest) )
                    {
                        a = p2[0];
                        b = p2[1];
                        c = p2[2];
                        d = p2[3];
                        g = p2[4];
                        fbest = flast;
                    }
                }
            }
            logisticfit45errors(x, y, n, a, b, c, d, g, rep, _params);
        }


        /*************************************************************************
        Weghted rational least  squares  fitting  using  Floater-Hormann  rational
        functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
        individual weights.

        Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
        functions. Different values of D are tried, optimal D (least WEIGHTED root
        mean square error) is chosen.  Task  is  linear,  so  linear least squares
        solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
        (mostly dominated by the least squares solver).

        SEE ALSO
        * BarycentricFitFloaterHormann(), "lightweight" fitting without invididual
          weights and constraints.

        INPUT PARAMETERS:
            X   -   points, array[0..N-1].
            Y   -   function values, array[0..N-1].
            W   -   weights, array[0..N-1]
                    Each summand in square  sum  of  approximation deviations from
                    given  values  is  multiplied  by  the square of corresponding
                    weight. Fill it by 1's if you don't  want  to  solve  weighted
                    task.
            N   -   number of points, N>0.
            XC  -   points where function values/derivatives are constrained,
                    array[0..K-1].
            YC  -   values of constraints, array[0..K-1]
            DC  -   array[0..K-1], types of constraints:
                    * DC[i]=0   means that S(XC[i])=YC[i]
                    * DC[i]=1   means that S'(XC[i])=YC[i]
                    SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
            K   -   number of constraints, 0<=K<M.
                    K=0 means no constraints (XC/YC/DC are not used in such cases)
            M   -   number of basis functions ( = number_of_nodes), M>=2.

        OUTPUT PARAMETERS:
            Info-   same format as in LSFitLinearWC() subroutine.
                    * Info>0    task is solved
                    * Info<=0   an error occured:
                                -4 means inconvergence of internal SVD
                                -3 means inconsistent constraints
                                -1 means another errors in parameters passed
                                   (N<=0, for example)
            B   -   barycentric interpolant.
            Rep -   report, same format as in LSFitLinearWC() subroutine.
                    Following fields are set:
                    * DBest         best value of the D parameter
                    * RMSError      rms error on the (X,Y).
                    * AvgError      average error on the (X,Y).
                    * AvgRelError   average relative error on the non-zero Y
                    * MaxError      maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

        IMPORTANT:
            this subroutine doesn't calculate task's condition number for K<>0.

        SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

        Setting constraints can lead  to undesired  results,  like ill-conditioned
        behavior, or inconsistency being detected. From the other side,  it allows
        us to improve quality of the fit. Here we summarize  our  experience  with
        constrained barycentric interpolants:
        * excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
          functions aren't as flexible as splines (although they are very smooth).
        * the more evenly constraints are spread across [min(x),max(x)],  the more
          chances that they will be consistent
        * the  greater  is  M (given  fixed  constraints),  the  more chances that
          constraints will be consistent
        * in the general case, consistency of constraints IS NOT GUARANTEED.
        * in the several special cases, however, we CAN guarantee consistency.
        * one of this cases is constraints on the function  VALUES at the interval
          boundaries. Note that consustency of the  constraints  on  the  function
          DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
          which are more flexible).
        * another  special  case  is ONE constraint on the function value (OR, but
          not AND, derivative) anywhere in the interval

        Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
        can't solve your task without them. Anything beyond  special  cases  given
        above is not guaranteed and may result in inconsistency.

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB PROJECT --
             Copyright 18.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentricfitfloaterhormannwc(double[] x,
            double[] y,
            double[] w,
            int n,
            double[] xc,
            double[] yc,
            int[] dc,
            int k,
            int m,
            ref int info,
            ratint.barycentricinterpolant b,
            barycentricfitreport rep,
            alglib.xparams _params)
        {
            int d = 0;
            int i = 0;
            double wrmscur = 0;
            double wrmsbest = 0;
            ratint.barycentricinterpolant locb = new ratint.barycentricinterpolant();
            barycentricfitreport locrep = new barycentricfitreport();
            int locinfo = 0;

            info = 0;

            alglib.ap.assert(n>0, "BarycentricFitFloaterHormannWC: N<=0!");
            alglib.ap.assert(m>0, "BarycentricFitFloaterHormannWC: M<=0!");
            alglib.ap.assert(k>=0, "BarycentricFitFloaterHormannWC: K<0!");
            alglib.ap.assert(k<m, "BarycentricFitFloaterHormannWC: K>=M!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "BarycentricFitFloaterHormannWC: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "BarycentricFitFloaterHormannWC: Length(Y)<N!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "BarycentricFitFloaterHormannWC: Length(W)<N!");
            alglib.ap.assert(alglib.ap.len(xc)>=k, "BarycentricFitFloaterHormannWC: Length(XC)<K!");
            alglib.ap.assert(alglib.ap.len(yc)>=k, "BarycentricFitFloaterHormannWC: Length(YC)<K!");
            alglib.ap.assert(alglib.ap.len(dc)>=k, "BarycentricFitFloaterHormannWC: Length(DC)<K!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "BarycentricFitFloaterHormannWC: X contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "BarycentricFitFloaterHormannWC: Y contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "BarycentricFitFloaterHormannWC: X contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(xc, k, _params), "BarycentricFitFloaterHormannWC: XC contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(yc, k, _params), "BarycentricFitFloaterHormannWC: YC contains infinite or NaN values!");
            for(i=0; i<=k-1; i++)
            {
                alglib.ap.assert(dc[i]==0 || dc[i]==1, "BarycentricFitFloaterHormannWC: one of DC[] is not 0 or 1!");
            }
            
            //
            // Find optimal D
            //
            // Info is -3 by default (degenerate constraints).
            // If LocInfo will always be equal to -3, Info will remain equal to -3.
            // If at least once LocInfo will be -4, Info will be -4.
            //
            wrmsbest = math.maxrealnumber;
            rep.dbest = -1;
            info = -3;
            for(d=0; d<=Math.Min(9, n-1); d++)
            {
                barycentricfitwcfixedd(x, y, w, n, xc, yc, dc, k, m, d, ref locinfo, locb, locrep, _params);
                alglib.ap.assert((locinfo==-4 || locinfo==-3) || locinfo>0, "BarycentricFitFloaterHormannWC: unexpected result from BarycentricFitWCFixedD!");
                if( locinfo>0 )
                {
                    
                    //
                    // Calculate weghted RMS
                    //
                    wrmscur = 0;
                    for(i=0; i<=n-1; i++)
                    {
                        wrmscur = wrmscur+math.sqr(w[i]*(y[i]-ratint.barycentriccalc(locb, x[i], _params)));
                    }
                    wrmscur = Math.Sqrt(wrmscur/n);
                    if( (double)(wrmscur)<(double)(wrmsbest) || rep.dbest<0 )
                    {
                        ratint.barycentriccopy(locb, b, _params);
                        rep.dbest = d;
                        info = 1;
                        rep.rmserror = locrep.rmserror;
                        rep.avgerror = locrep.avgerror;
                        rep.avgrelerror = locrep.avgrelerror;
                        rep.maxerror = locrep.maxerror;
                        rep.taskrcond = locrep.taskrcond;
                        wrmsbest = wrmscur;
                    }
                }
                else
                {
                    if( locinfo!=-3 && info<0 )
                    {
                        info = locinfo;
                    }
                }
            }
        }


        /*************************************************************************
        Rational least squares fitting using  Floater-Hormann  rational  functions
        with optimal D chosen from [0,9].

        Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
        functions. Different values of D are tried, optimal  D  (least  root  mean
        square error) is chosen.  Task  is  linear, so linear least squares solver
        is used. Complexity  of  this  computational  scheme is  O(N*M^2)  (mostly
        dominated by the least squares solver).

        INPUT PARAMETERS:
            X   -   points, array[0..N-1].
            Y   -   function values, array[0..N-1].
            N   -   number of points, N>0.
            M   -   number of basis functions ( = number_of_nodes), M>=2.

        OUTPUT PARAMETERS:
            Info-   same format as in LSFitLinearWC() subroutine.
                    * Info>0    task is solved
                    * Info<=0   an error occured:
                                -4 means inconvergence of internal SVD
                                -3 means inconsistent constraints
            B   -   barycentric interpolant.
            Rep -   report, same format as in LSFitLinearWC() subroutine.
                    Following fields are set:
                    * DBest         best value of the D parameter
                    * RMSError      rms error on the (X,Y).
                    * AvgError      average error on the (X,Y).
                    * AvgRelError   average relative error on the non-zero Y
                    * MaxError      maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB PROJECT --
             Copyright 18.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void barycentricfitfloaterhormann(double[] x,
            double[] y,
            int n,
            int m,
            ref int info,
            ratint.barycentricinterpolant b,
            barycentricfitreport rep,
            alglib.xparams _params)
        {
            double[] w = new double[0];
            double[] xc = new double[0];
            double[] yc = new double[0];
            int[] dc = new int[0];
            int i = 0;

            info = 0;

            alglib.ap.assert(n>0, "BarycentricFitFloaterHormann: N<=0!");
            alglib.ap.assert(m>0, "BarycentricFitFloaterHormann: M<=0!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "BarycentricFitFloaterHormann: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "BarycentricFitFloaterHormann: Length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "BarycentricFitFloaterHormann: X contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "BarycentricFitFloaterHormann: Y contains infinite or NaN values!");
            w = new double[n];
            for(i=0; i<=n-1; i++)
            {
                w[i] = 1;
            }
            barycentricfitfloaterhormannwc(x, y, w, n, xc, yc, dc, 0, m, ref info, b, rep, _params);
        }


        /*************************************************************************
        Weighted fitting by cubic  spline,  with constraints on function values or
        derivatives.

        Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
        basis functions. Basis functions are cubic splines with continuous  second
        derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
        regularizing term is used  when  solving  constrained  tasks  (to  improve
        stability).

        Task is linear, so linear least squares solver is used. Complexity of this
        computational scheme is O(N*M^2), mostly dominated by least squares solver

        SEE ALSO
            Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
                                        less smooth)
            Spline1DFitCubic()      -   "lightweight" fitting  by  cubic  splines,
                                        without invididual weights and constraints
                                        
        INPUT PARAMETERS:
            X   -   points, array[0..N-1].
            Y   -   function values, array[0..N-1].
            W   -   weights, array[0..N-1]
                    Each summand in square  sum  of  approximation deviations from
                    given  values  is  multiplied  by  the square of corresponding
                    weight. Fill it by 1's if you don't  want  to  solve  weighted
                    task.
            N   -   number of points (optional):
                    * N>0
                    * if given, only first N elements of X/Y/W are processed
                    * if not given, automatically determined from X/Y/W sizes
            XC  -   points where spline values/derivatives are constrained,
                    array[0..K-1].
            YC  -   values of constraints, array[0..K-1]
            DC  -   array[0..K-1], types of constraints:
                    * DC[i]=0   means that S(XC[i])=YC[i]
                    * DC[i]=1   means that S'(XC[i])=YC[i]
                    SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
            K   -   number of constraints (optional):
                    * 0<=K<M.
                    * K=0 means no constraints (XC/YC/DC are not used)
                    * if given, only first K elements of XC/YC/DC are used
                    * if not given, automatically determined from XC/YC/DC
            M   -   number of basis functions ( = number_of_nodes+2), M>=4.

        OUTPUT PARAMETERS:
            Info-   same format as in LSFitLinearWC() subroutine.
                    * Info>0    task is solved
                    * Info<=0   an error occured:
                                -4 means inconvergence of internal SVD
                                -3 means inconsistent constraints
            S   -   spline interpolant.
            Rep -   report, same format as in LSFitLinearWC() subroutine.
                    Following fields are set:
                    * RMSError      rms error on the (X,Y).
                    * AvgError      average error on the (X,Y).
                    * AvgRelError   average relative error on the non-zero Y
                    * MaxError      maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

        IMPORTANT:
            this subroitine doesn't calculate task's condition number for K<>0.


        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.

        SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

        Setting constraints can lead  to undesired  results,  like ill-conditioned
        behavior, or inconsistency being detected. From the other side,  it allows
        us to improve quality of the fit. Here we summarize  our  experience  with
        constrained regression splines:
        * excessive constraints can be inconsistent. Splines are  piecewise  cubic
          functions, and it is easy to create an example, where  large  number  of
          constraints  concentrated  in  small  area will result in inconsistency.
          Just because spline is not flexible enough to satisfy all of  them.  And
          same constraints spread across the  [min(x),max(x)]  will  be  perfectly
          consistent.
        * the more evenly constraints are spread across [min(x),max(x)],  the more
          chances that they will be consistent
        * the  greater  is  M (given  fixed  constraints),  the  more chances that
          constraints will be consistent
        * in the general case, consistency of constraints IS NOT GUARANTEED.
        * in the several special cases, however, we CAN guarantee consistency.
        * one of this cases is constraints  on  the  function  values  AND/OR  its
          derivatives at the interval boundaries.
        * another  special  case  is ONE constraint on the function value (OR, but
          not AND, derivative) anywhere in the interval

        Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
        can't solve your task without them. Anything beyond  special  cases  given
        above is not guaranteed and may result in inconsistency.

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB PROJECT --
             Copyright 18.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dfitcubicwc(double[] x,
            double[] y,
            double[] w,
            int n,
            double[] xc,
            double[] yc,
            int[] dc,
            int k,
            int m,
            ref int info,
            spline1d.spline1dinterpolant s,
            spline1d.spline1dfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;

            info = 0;

            alglib.ap.assert(n>=1, "Spline1DFitCubicWC: N<1!");
            alglib.ap.assert(m>=4, "Spline1DFitCubicWC: M<4!");
            alglib.ap.assert(k>=0, "Spline1DFitCubicWC: K<0!");
            alglib.ap.assert(k<m, "Spline1DFitCubicWC: K>=M!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DFitCubicWC: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DFitCubicWC: Length(Y)<N!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "Spline1DFitCubicWC: Length(W)<N!");
            alglib.ap.assert(alglib.ap.len(xc)>=k, "Spline1DFitCubicWC: Length(XC)<K!");
            alglib.ap.assert(alglib.ap.len(yc)>=k, "Spline1DFitCubicWC: Length(YC)<K!");
            alglib.ap.assert(alglib.ap.len(dc)>=k, "Spline1DFitCubicWC: Length(DC)<K!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DFitCubicWC: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DFitCubicWC: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "Spline1DFitCubicWC: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(xc, k, _params), "Spline1DFitCubicWC: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(yc, k, _params), "Spline1DFitCubicWC: Y contains infinite or NAN values!");
            for(i=0; i<=k-1; i++)
            {
                alglib.ap.assert(dc[i]==0 || dc[i]==1, "Spline1DFitCubicWC: DC[i] is neither 0 or 1!");
            }
            spline1dfitinternal(0, x, y, w, n, xc, yc, dc, k, m, ref info, s, rep, _params);
        }


        /*************************************************************************
        Weighted  fitting  by Hermite spline,  with constraints on function values
        or first derivatives.

        Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
        basis functions. Basis functions are Hermite splines.  Small  regularizing
        term is used when solving constrained tasks (to improve stability).

        Task is linear, so linear least squares solver is used. Complexity of this
        computational scheme is O(N*M^2), mostly dominated by least squares solver

        SEE ALSO
            Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
                                        more smooth)
            Spline1DFitHermite()    -   "lightweight" Hermite fitting, without
                                        invididual weights and constraints
                                        
        INPUT PARAMETERS:
            X   -   points, array[0..N-1].
            Y   -   function values, array[0..N-1].
            W   -   weights, array[0..N-1]
                    Each summand in square  sum  of  approximation deviations from
                    given  values  is  multiplied  by  the square of corresponding
                    weight. Fill it by 1's if you don't  want  to  solve  weighted
                    task.
            N   -   number of points (optional):
                    * N>0
                    * if given, only first N elements of X/Y/W are processed
                    * if not given, automatically determined from X/Y/W sizes
            XC  -   points where spline values/derivatives are constrained,
                    array[0..K-1].
            YC  -   values of constraints, array[0..K-1]
            DC  -   array[0..K-1], types of constraints:
                    * DC[i]=0   means that S(XC[i])=YC[i]
                    * DC[i]=1   means that S'(XC[i])=YC[i]
                    SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
            K   -   number of constraints (optional):
                    * 0<=K<M.
                    * K=0 means no constraints (XC/YC/DC are not used)
                    * if given, only first K elements of XC/YC/DC are used
                    * if not given, automatically determined from XC/YC/DC
            M   -   number of basis functions (= 2 * number of nodes),
                    M>=4,
                    M IS EVEN!

        OUTPUT PARAMETERS:
            Info-   same format as in LSFitLinearW() subroutine:
                    * Info>0    task is solved
                    * Info<=0   an error occured:
                                -4 means inconvergence of internal SVD
                                -3 means inconsistent constraints
                                -2 means odd M was passed (which is not supported)
                                -1 means another errors in parameters passed
                                   (N<=0, for example)
            S   -   spline interpolant.
            Rep -   report, same format as in LSFitLinearW() subroutine.
                    Following fields are set:
                    * RMSError      rms error on the (X,Y).
                    * AvgError      average error on the (X,Y).
                    * AvgRelError   average relative error on the non-zero Y
                    * MaxError      maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

        IMPORTANT:
            this subroitine doesn't calculate task's condition number for K<>0.

        IMPORTANT:
            this subroitine supports only even M's


        ORDER OF POINTS

        Subroutine automatically sorts points, so caller may pass unsorted array.

        SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:

        Setting constraints can lead  to undesired  results,  like ill-conditioned
        behavior, or inconsistency being detected. From the other side,  it allows
        us to improve quality of the fit. Here we summarize  our  experience  with
        constrained regression splines:
        * excessive constraints can be inconsistent. Splines are  piecewise  cubic
          functions, and it is easy to create an example, where  large  number  of
          constraints  concentrated  in  small  area will result in inconsistency.
          Just because spline is not flexible enough to satisfy all of  them.  And
          same constraints spread across the  [min(x),max(x)]  will  be  perfectly
          consistent.
        * the more evenly constraints are spread across [min(x),max(x)],  the more
          chances that they will be consistent
        * the  greater  is  M (given  fixed  constraints),  the  more chances that
          constraints will be consistent
        * in the general case, consistency of constraints is NOT GUARANTEED.
        * in the several special cases, however, we can guarantee consistency.
        * one of this cases is  M>=4  and   constraints  on   the  function  value
          (AND/OR its derivative) at the interval boundaries.
        * another special case is M>=4  and  ONE  constraint on the function value
          (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]

        Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
        can't solve your task without them. Anything beyond  special  cases  given
        above is not guaranteed and may result in inconsistency.

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB PROJECT --
             Copyright 18.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dfithermitewc(double[] x,
            double[] y,
            double[] w,
            int n,
            double[] xc,
            double[] yc,
            int[] dc,
            int k,
            int m,
            ref int info,
            spline1d.spline1dinterpolant s,
            spline1d.spline1dfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;

            info = 0;

            alglib.ap.assert(n>=1, "Spline1DFitHermiteWC: N<1!");
            alglib.ap.assert(m>=4, "Spline1DFitHermiteWC: M<4!");
            alglib.ap.assert(m%2==0, "Spline1DFitHermiteWC: M is odd!");
            alglib.ap.assert(k>=0, "Spline1DFitHermiteWC: K<0!");
            alglib.ap.assert(k<m, "Spline1DFitHermiteWC: K>=M!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DFitHermiteWC: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DFitHermiteWC: Length(Y)<N!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "Spline1DFitHermiteWC: Length(W)<N!");
            alglib.ap.assert(alglib.ap.len(xc)>=k, "Spline1DFitHermiteWC: Length(XC)<K!");
            alglib.ap.assert(alglib.ap.len(yc)>=k, "Spline1DFitHermiteWC: Length(YC)<K!");
            alglib.ap.assert(alglib.ap.len(dc)>=k, "Spline1DFitHermiteWC: Length(DC)<K!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DFitHermiteWC: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DFitHermiteWC: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "Spline1DFitHermiteWC: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(xc, k, _params), "Spline1DFitHermiteWC: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(yc, k, _params), "Spline1DFitHermiteWC: Y contains infinite or NAN values!");
            for(i=0; i<=k-1; i++)
            {
                alglib.ap.assert(dc[i]==0 || dc[i]==1, "Spline1DFitHermiteWC: DC[i] is neither 0 or 1!");
            }
            spline1dfitinternal(1, x, y, w, n, xc, yc, dc, k, m, ref info, s, rep, _params);
        }


        /*************************************************************************
        Least squares fitting by cubic spline.

        This subroutine is "lightweight" alternative for more complex and feature-
        rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
        about subroutine parameters (we don't duplicate it here because of length)

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB PROJECT --
             Copyright 18.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dfitcubic(double[] x,
            double[] y,
            int n,
            int m,
            ref int info,
            spline1d.spline1dinterpolant s,
            spline1d.spline1dfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            double[] w = new double[0];
            double[] xc = new double[0];
            double[] yc = new double[0];
            int[] dc = new int[0];

            info = 0;

            alglib.ap.assert(n>=1, "Spline1DFitCubic: N<1!");
            alglib.ap.assert(m>=4, "Spline1DFitCubic: M<4!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DFitCubic: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DFitCubic: Length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DFitCubic: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DFitCubic: Y contains infinite or NAN values!");
            w = new double[n];
            for(i=0; i<=n-1; i++)
            {
                w[i] = 1;
            }
            spline1dfitcubicwc(x, y, w, n, xc, yc, dc, 0, m, ref info, s, rep, _params);
        }


        /*************************************************************************
        Least squares fitting by Hermite spline.

        This subroutine is "lightweight" alternative for more complex and feature-
        rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
        more information about subroutine parameters (we don't duplicate  it  here
        because of length).

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB PROJECT --
             Copyright 18.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dfithermite(double[] x,
            double[] y,
            int n,
            int m,
            ref int info,
            spline1d.spline1dinterpolant s,
            spline1d.spline1dfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            double[] w = new double[0];
            double[] xc = new double[0];
            double[] yc = new double[0];
            int[] dc = new int[0];

            info = 0;

            alglib.ap.assert(n>=1, "Spline1DFitHermite: N<1!");
            alglib.ap.assert(m>=4, "Spline1DFitHermite: M<4!");
            alglib.ap.assert(m%2==0, "Spline1DFitHermite: M is odd!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DFitHermite: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DFitHermite: Length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DFitHermite: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DFitHermite: Y contains infinite or NAN values!");
            w = new double[n];
            for(i=0; i<=n-1; i++)
            {
                w[i] = 1;
            }
            spline1dfithermitewc(x, y, w, n, xc, yc, dc, 0, m, ref info, s, rep, _params);
        }


        /*************************************************************************
        Weighted linear least squares fitting.

        QR decomposition is used to reduce task to MxM, then triangular solver  or
        SVD-based solver is used depending on condition number of the  system.  It
        allows to maximize speed and retain decent accuracy.

        IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
                   convenient to use PolynomialFit() function. This function gives
                   best  results  on  polynomial  problems  and  solves  numerical
                   stability  issues  which  arise  when   you   fit   high-degree
                   polynomials to your data.

        INPUT PARAMETERS:
            Y       -   array[0..N-1] Function values in  N  points.
            W       -   array[0..N-1]  Weights  corresponding to function  values.
                        Each summand in square  sum  of  approximation  deviations
                        from  given  values  is  multiplied  by  the   square   of
                        corresponding weight.
            FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                        FMatrix[I, J] - value of J-th basis function in I-th point.
            N       -   number of points used. N>=1.
            M       -   number of basis functions, M>=1.

        OUTPUT PARAMETERS:
            Info    -   error code:
                        * -4    internal SVD decomposition subroutine failed (very
                                rare and for degenerate systems only)
                        * -1    incorrect N/M were specified
                        *  1    task is solved
            C       -   decomposition coefficients, array[0..M-1]
            Rep     -   fitting report. Following fields are set:
                        * Rep.TaskRCond     reciprocal of condition number
                        * R2                non-adjusted coefficient of determination
                                            (non-weighted)
                        * RMSError          rms error on the (X,Y).
                        * AvgError          average error on the (X,Y).
                        * AvgRelError       average relative error on the non-zero Y
                        * MaxError          maximum error
                                            NON-WEIGHTED ERRORS ARE CALCULATED
                        
        ERRORS IN PARAMETERS                
                        
        This  solver  also  calculates different kinds of errors in parameters and
        fills corresponding fields of report:
        * Rep.CovPar        covariance matrix for parameters, array[K,K].
        * Rep.ErrPar        errors in parameters, array[K],
                            errpar = sqrt(diag(CovPar))
        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                            best-fit curve from "ideal" best-fit curve built  with
                            infinite number of samples, array[N].
                            errcurve = sqrt(diag(F*CovPar*F')),
                            where F is functions matrix.
        * Rep.Noise         vector of per-point estimates of noise, array[N]
                    
        NOTE:       noise in the data is estimated as follows:
                    * for fitting without user-supplied  weights  all  points  are
                      assumed to have same level of noise, which is estimated from
                      the data
                    * for fitting with user-supplied weights we assume that  noise
                      level in I-th point is inversely proportional to Ith weight.
                      Coefficient of proportionality is estimated from the data.
                    
        NOTE:       we apply small amount of regularization when we invert squared
                    Jacobian and calculate covariance matrix. It  guarantees  that
                    algorithm won't divide by zero  during  inversion,  but  skews
                    error estimates a bit (fractional error is about 10^-9).
                    
                    However, we believe that this difference is insignificant  for
                    all practical purposes except for the situation when you  want
                    to compare ALGLIB results with "reference"  implementation  up
                    to the last significant digit.
                    
        NOTE:       covariance matrix is estimated using  correction  for  degrees
                    of freedom (covariances are divided by N-M instead of dividing
                    by N).

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.
                                            
          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitlinearw(double[] y,
            double[] w,
            double[,] fmatrix,
            int n,
            int m,
            ref int info,
            ref double[] c,
            lsfitreport rep,
            alglib.xparams _params)
        {
            info = 0;
            c = new double[0];

            alglib.ap.assert(n>=1, "LSFitLinearW: N<1!");
            alglib.ap.assert(m>=1, "LSFitLinearW: M<1!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitLinearW: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitLinearW: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "LSFitLinearW: length(W)<N!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "LSFitLinearW: W contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(fmatrix)>=n, "LSFitLinearW: rows(FMatrix)<N!");
            alglib.ap.assert(alglib.ap.cols(fmatrix)>=m, "LSFitLinearW: cols(FMatrix)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(fmatrix, n, m, _params), "LSFitLinearW: FMatrix contains infinite or NaN values!");
            lsfitlinearinternal(y, w, fmatrix, n, m, ref info, ref c, rep, _params);
        }


        /*************************************************************************
        Weighted constained linear least squares fitting.

        This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
        that  K  additional  constaints  C*x=bc are satisfied. It reduces original
        task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
        is called.

        IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
                   convenient to use PolynomialFit() function. This function gives
                   best  results  on  polynomial  problems  and  solves  numerical
                   stability  issues  which  arise  when   you   fit   high-degree
                   polynomials to your data.

        INPUT PARAMETERS:
            Y       -   array[0..N-1] Function values in  N  points.
            W       -   array[0..N-1]  Weights  corresponding to function  values.
                        Each summand in square  sum  of  approximation  deviations
                        from  given  values  is  multiplied  by  the   square   of
                        corresponding weight.
            FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                        FMatrix[I,J] - value of J-th basis function in I-th point.
            CMatrix -   a table of constaints, array[0..K-1,0..M].
                        I-th row of CMatrix corresponds to I-th linear constraint:
                        CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
            N       -   number of points used. N>=1.
            M       -   number of basis functions, M>=1.
            K       -   number of constraints, 0 <= K < M
                        K=0 corresponds to absence of constraints.

        OUTPUT PARAMETERS:
            Info    -   error code:
                        * -4    internal SVD decomposition subroutine failed (very
                                rare and for degenerate systems only)
                        * -3    either   too   many  constraints  (M   or   more),
                                degenerate  constraints   (some   constraints  are
                                repetead twice) or inconsistent  constraints  were
                                specified.
                        *  1    task is solved
            C       -   decomposition coefficients, array[0..M-1]
            Rep     -   fitting report. Following fields are set:
                        * R2                non-adjusted coefficient of determination
                                            (non-weighted)
                        * RMSError          rms error on the (X,Y).
                        * AvgError          average error on the (X,Y).
                        * AvgRelError       average relative error on the non-zero Y
                        * MaxError          maximum error
                                            NON-WEIGHTED ERRORS ARE CALCULATED

        IMPORTANT:
            this subroitine doesn't calculate task's condition number for K<>0.
                        
        ERRORS IN PARAMETERS                
                        
        This  solver  also  calculates different kinds of errors in parameters and
        fills corresponding fields of report:
        * Rep.CovPar        covariance matrix for parameters, array[K,K].
        * Rep.ErrPar        errors in parameters, array[K],
                            errpar = sqrt(diag(CovPar))
        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                            best-fit curve from "ideal" best-fit curve built  with
                            infinite number of samples, array[N].
                            errcurve = sqrt(diag(F*CovPar*F')),
                            where F is functions matrix.
        * Rep.Noise         vector of per-point estimates of noise, array[N]

        IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
                    account boundary/linear constraints! Presence  of  constraints
                    changes distribution of errors, but there is no  easy  way  to
                    account for constraints when you calculate covariance matrix.
                    
        NOTE:       noise in the data is estimated as follows:
                    * for fitting without user-supplied  weights  all  points  are
                      assumed to have same level of noise, which is estimated from
                      the data
                    * for fitting with user-supplied weights we assume that  noise
                      level in I-th point is inversely proportional to Ith weight.
                      Coefficient of proportionality is estimated from the data.
                    
        NOTE:       we apply small amount of regularization when we invert squared
                    Jacobian and calculate covariance matrix. It  guarantees  that
                    algorithm won't divide by zero  during  inversion,  but  skews
                    error estimates a bit (fractional error is about 10^-9).
                    
                    However, we believe that this difference is insignificant  for
                    all practical purposes except for the situation when you  want
                    to compare ALGLIB results with "reference"  implementation  up
                    to the last significant digit.
                    
        NOTE:       covariance matrix is estimated using  correction  for  degrees
                    of freedom (covariances are divided by N-M instead of dividing
                    by N).

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB --
             Copyright 07.09.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitlinearwc(double[] y,
            double[] w,
            double[,] fmatrix,
            double[,] cmatrix,
            int n,
            int m,
            int k,
            ref int info,
            ref double[] c,
            lsfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double[] tau = new double[0];
            double[,] q = new double[0,0];
            double[,] f2 = new double[0,0];
            double[] tmp = new double[0];
            double[] c0 = new double[0];
            double v = 0;
            int i_ = 0;

            y = (double[])y.Clone();
            cmatrix = (double[,])cmatrix.Clone();
            info = 0;
            c = new double[0];

            alglib.ap.assert(n>=1, "LSFitLinearWC: N<1!");
            alglib.ap.assert(m>=1, "LSFitLinearWC: M<1!");
            alglib.ap.assert(k>=0, "LSFitLinearWC: K<0!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitLinearWC: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitLinearWC: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "LSFitLinearWC: length(W)<N!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "LSFitLinearWC: W contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(fmatrix)>=n, "LSFitLinearWC: rows(FMatrix)<N!");
            alglib.ap.assert(alglib.ap.cols(fmatrix)>=m, "LSFitLinearWC: cols(FMatrix)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(fmatrix, n, m, _params), "LSFitLinearWC: FMatrix contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(cmatrix)>=k, "LSFitLinearWC: rows(CMatrix)<K!");
            alglib.ap.assert(alglib.ap.cols(cmatrix)>=m+1 || k==0, "LSFitLinearWC: cols(CMatrix)<M+1!");
            alglib.ap.assert(apserv.apservisfinitematrix(cmatrix, k, m+1, _params), "LSFitLinearWC: CMatrix contains infinite or NaN values!");
            if( k>=m )
            {
                info = -3;
                return;
            }
            
            //
            // Solve
            //
            if( k==0 )
            {
                
                //
                // no constraints
                //
                lsfitlinearinternal(y, w, fmatrix, n, m, ref info, ref c, rep, _params);
            }
            else
            {
                
                //
                // First, find general form solution of constraints system:
                // * factorize C = L*Q
                // * unpack Q
                // * fill upper part of C with zeros (for RCond)
                //
                // We got C=C0+Q2'*y where Q2 is lower M-K rows of Q.
                //
                ortfac.rmatrixlq(ref cmatrix, k, m, ref tau, _params);
                ortfac.rmatrixlqunpackq(cmatrix, k, m, tau, m, ref q, _params);
                for(i=0; i<=k-1; i++)
                {
                    for(j=i+1; j<=m-1; j++)
                    {
                        cmatrix[i,j] = 0.0;
                    }
                }
                if( (double)(rcond.rmatrixlurcondinf(cmatrix, k, _params))<(double)(1000*math.machineepsilon) )
                {
                    info = -3;
                    return;
                }
                tmp = new double[k];
                for(i=0; i<=k-1; i++)
                {
                    if( i>0 )
                    {
                        v = 0.0;
                        for(i_=0; i_<=i-1;i_++)
                        {
                            v += cmatrix[i,i_]*tmp[i_];
                        }
                    }
                    else
                    {
                        v = 0;
                    }
                    tmp[i] = (cmatrix[i,m]-v)/cmatrix[i,i];
                }
                c0 = new double[m];
                for(i=0; i<=m-1; i++)
                {
                    c0[i] = 0;
                }
                for(i=0; i<=k-1; i++)
                {
                    v = tmp[i];
                    for(i_=0; i_<=m-1;i_++)
                    {
                        c0[i_] = c0[i_] + v*q[i,i_];
                    }
                }
                
                //
                // Second, prepare modified matrix F2 = F*Q2' and solve modified task
                //
                tmp = new double[Math.Max(n, m)+1];
                f2 = new double[n, m-k];
                blas.matrixvectormultiply(fmatrix, 0, n-1, 0, m-1, false, c0, 0, m-1, -1.0, ref y, 0, n-1, 1.0, _params);
                ablas.rmatrixgemm(n, m-k, m, 1.0, fmatrix, 0, 0, 0, q, k, 0, 1, 0.0, f2, 0, 0, _params);
                lsfitlinearinternal(y, w, f2, n, m-k, ref info, ref tmp, rep, _params);
                rep.taskrcond = -1;
                if( info<=0 )
                {
                    return;
                }
                
                //
                // then, convert back to original answer: C = C0 + Q2'*Y0
                //
                c = new double[m];
                for(i_=0; i_<=m-1;i_++)
                {
                    c[i_] = c0[i_];
                }
                blas.matrixvectormultiply(q, k, m-1, 0, m-1, true, tmp, 0, m-k-1, 1.0, ref c, 0, m-1, 1.0, _params);
            }
        }


        /*************************************************************************
        Linear least squares fitting.

        QR decomposition is used to reduce task to MxM, then triangular solver  or
        SVD-based solver is used depending on condition number of the  system.  It
        allows to maximize speed and retain decent accuracy.

        IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
                   convenient to use PolynomialFit() function. This function gives
                   best  results  on  polynomial  problems  and  solves  numerical
                   stability  issues  which  arise  when   you   fit   high-degree
                   polynomials to your data.

        INPUT PARAMETERS:
            Y       -   array[0..N-1] Function values in  N  points.
            FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                        FMatrix[I, J] - value of J-th basis function in I-th point.
            N       -   number of points used. N>=1.
            M       -   number of basis functions, M>=1.

        OUTPUT PARAMETERS:
            Info    -   error code:
                        * -4    internal SVD decomposition subroutine failed (very
                                rare and for degenerate systems only)
                        *  1    task is solved
            C       -   decomposition coefficients, array[0..M-1]
            Rep     -   fitting report. Following fields are set:
                        * Rep.TaskRCond     reciprocal of condition number
                        * R2                non-adjusted coefficient of determination
                                            (non-weighted)
                        * RMSError          rms error on the (X,Y).
                        * AvgError          average error on the (X,Y).
                        * AvgRelError       average relative error on the non-zero Y
                        * MaxError          maximum error
                                            NON-WEIGHTED ERRORS ARE CALCULATED
                        
        ERRORS IN PARAMETERS                
                        
        This  solver  also  calculates different kinds of errors in parameters and
        fills corresponding fields of report:
        * Rep.CovPar        covariance matrix for parameters, array[K,K].
        * Rep.ErrPar        errors in parameters, array[K],
                            errpar = sqrt(diag(CovPar))
        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                            best-fit curve from "ideal" best-fit curve built  with
                            infinite number of samples, array[N].
                            errcurve = sqrt(diag(F*CovPar*F')),
                            where F is functions matrix.
        * Rep.Noise         vector of per-point estimates of noise, array[N]
                    
        NOTE:       noise in the data is estimated as follows:
                    * for fitting without user-supplied  weights  all  points  are
                      assumed to have same level of noise, which is estimated from
                      the data
                    * for fitting with user-supplied weights we assume that  noise
                      level in I-th point is inversely proportional to Ith weight.
                      Coefficient of proportionality is estimated from the data.
                    
        NOTE:       we apply small amount of regularization when we invert squared
                    Jacobian and calculate covariance matrix. It  guarantees  that
                    algorithm won't divide by zero  during  inversion,  but  skews
                    error estimates a bit (fractional error is about 10^-9).
                    
                    However, we believe that this difference is insignificant  for
                    all practical purposes except for the situation when you  want
                    to compare ALGLIB results with "reference"  implementation  up
                    to the last significant digit.
                    
        NOTE:       covariance matrix is estimated using  correction  for  degrees
                    of freedom (covariances are divided by N-M instead of dividing
                    by N).

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitlinear(double[] y,
            double[,] fmatrix,
            int n,
            int m,
            ref int info,
            ref double[] c,
            lsfitreport rep,
            alglib.xparams _params)
        {
            double[] w = new double[0];
            int i = 0;

            info = 0;
            c = new double[0];

            alglib.ap.assert(n>=1, "LSFitLinear: N<1!");
            alglib.ap.assert(m>=1, "LSFitLinear: M<1!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitLinear: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitLinear: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(fmatrix)>=n, "LSFitLinear: rows(FMatrix)<N!");
            alglib.ap.assert(alglib.ap.cols(fmatrix)>=m, "LSFitLinear: cols(FMatrix)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(fmatrix, n, m, _params), "LSFitLinear: FMatrix contains infinite or NaN values!");
            w = new double[n];
            for(i=0; i<=n-1; i++)
            {
                w[i] = 1;
            }
            lsfitlinearinternal(y, w, fmatrix, n, m, ref info, ref c, rep, _params);
        }


        /*************************************************************************
        Constained linear least squares fitting.

        This  is  variation  of LSFitLinear(),  which searchs for min|A*x=b| given
        that  K  additional  constaints  C*x=bc are satisfied. It reduces original
        task to modified one: min|B*y-d| WITHOUT constraints,  then  LSFitLinear()
        is called.

        IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
                   convenient to use PolynomialFit() function. This function gives
                   best  results  on  polynomial  problems  and  solves  numerical
                   stability  issues  which  arise  when   you   fit   high-degree
                   polynomials to your data.

        INPUT PARAMETERS:
            Y       -   array[0..N-1] Function values in  N  points.
            FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
                        FMatrix[I,J] - value of J-th basis function in I-th point.
            CMatrix -   a table of constaints, array[0..K-1,0..M].
                        I-th row of CMatrix corresponds to I-th linear constraint:
                        CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
            N       -   number of points used. N>=1.
            M       -   number of basis functions, M>=1.
            K       -   number of constraints, 0 <= K < M
                        K=0 corresponds to absence of constraints.

        OUTPUT PARAMETERS:
            Info    -   error code:
                        * -4    internal SVD decomposition subroutine failed (very
                                rare and for degenerate systems only)
                        * -3    either   too   many  constraints  (M   or   more),
                                degenerate  constraints   (some   constraints  are
                                repetead twice) or inconsistent  constraints  were
                                specified.
                        *  1    task is solved
            C       -   decomposition coefficients, array[0..M-1]
            Rep     -   fitting report. Following fields are set:
                        * R2                non-adjusted coefficient of determination
                                            (non-weighted)
                        * RMSError          rms error on the (X,Y).
                        * AvgError          average error on the (X,Y).
                        * AvgRelError       average relative error on the non-zero Y
                        * MaxError          maximum error
                                            NON-WEIGHTED ERRORS ARE CALCULATED

        IMPORTANT:
            this subroitine doesn't calculate task's condition number for K<>0.
                        
        ERRORS IN PARAMETERS                
                        
        This  solver  also  calculates different kinds of errors in parameters and
        fills corresponding fields of report:
        * Rep.CovPar        covariance matrix for parameters, array[K,K].
        * Rep.ErrPar        errors in parameters, array[K],
                            errpar = sqrt(diag(CovPar))
        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                            best-fit curve from "ideal" best-fit curve built  with
                            infinite number of samples, array[N].
                            errcurve = sqrt(diag(F*CovPar*F')),
                            where F is functions matrix.
        * Rep.Noise         vector of per-point estimates of noise, array[N]

        IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
                    account boundary/linear constraints! Presence  of  constraints
                    changes distribution of errors, but there is no  easy  way  to
                    account for constraints when you calculate covariance matrix.
                    
        NOTE:       noise in the data is estimated as follows:
                    * for fitting without user-supplied  weights  all  points  are
                      assumed to have same level of noise, which is estimated from
                      the data
                    * for fitting with user-supplied weights we assume that  noise
                      level in I-th point is inversely proportional to Ith weight.
                      Coefficient of proportionality is estimated from the data.
                    
        NOTE:       we apply small amount of regularization when we invert squared
                    Jacobian and calculate covariance matrix. It  guarantees  that
                    algorithm won't divide by zero  during  inversion,  but  skews
                    error estimates a bit (fractional error is about 10^-9).
                    
                    However, we believe that this difference is insignificant  for
                    all practical purposes except for the situation when you  want
                    to compare ALGLIB results with "reference"  implementation  up
                    to the last significant digit.
                    
        NOTE:       covariance matrix is estimated using  correction  for  degrees
                    of freedom (covariances are divided by N-M instead of dividing
                    by N).

          ! FREE EDITION OF ALGLIB:
          ! 
          ! Free Edition of ALGLIB supports following important features for  this
          ! function:
          ! * C++ version: x64 SIMD support using C++ intrinsics
          ! * C#  version: x64 SIMD support using NET5/NetCore hardware intrinsics
          !
          ! We  recommend  you  to  read  'Compiling ALGLIB' section of the ALGLIB
          ! Reference Manual in order  to  find  out  how to activate SIMD support
          ! in ALGLIB.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

          -- ALGLIB --
             Copyright 07.09.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitlinearc(double[] y,
            double[,] fmatrix,
            double[,] cmatrix,
            int n,
            int m,
            int k,
            ref int info,
            ref double[] c,
            lsfitreport rep,
            alglib.xparams _params)
        {
            double[] w = new double[0];
            int i = 0;

            y = (double[])y.Clone();
            info = 0;
            c = new double[0];

            alglib.ap.assert(n>=1, "LSFitLinearC: N<1!");
            alglib.ap.assert(m>=1, "LSFitLinearC: M<1!");
            alglib.ap.assert(k>=0, "LSFitLinearC: K<0!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitLinearC: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitLinearC: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(fmatrix)>=n, "LSFitLinearC: rows(FMatrix)<N!");
            alglib.ap.assert(alglib.ap.cols(fmatrix)>=m, "LSFitLinearC: cols(FMatrix)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(fmatrix, n, m, _params), "LSFitLinearC: FMatrix contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(cmatrix)>=k, "LSFitLinearC: rows(CMatrix)<K!");
            alglib.ap.assert(alglib.ap.cols(cmatrix)>=m+1 || k==0, "LSFitLinearC: cols(CMatrix)<M+1!");
            alglib.ap.assert(apserv.apservisfinitematrix(cmatrix, k, m+1, _params), "LSFitLinearC: CMatrix contains infinite or NaN values!");
            w = new double[n];
            for(i=0; i<=n-1; i++)
            {
                w[i] = 1;
            }
            lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, ref info, ref c, rep, _params);
        }


        /*************************************************************************
        Weighted nonlinear least squares fitting using function values only.

        Combination of numerical differentiation and secant updates is used to
        obtain function Jacobian.

        Nonlinear task min(F(c)) is solved, where

            F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,

            * N is a number of points,
            * M is a dimension of a space points belong to,
            * K is a dimension of a space of parameters being fitted,
            * w is an N-dimensional vector of weight coefficients,
            * x is a set of N points, each of them is an M-dimensional vector,
            * c is a K-dimensional vector of parameters being fitted

        This subroutine uses only f(c,x[i]).

        INPUT PARAMETERS:
            X       -   array[0..N-1,0..M-1], points (one row = one point)
            Y       -   array[0..N-1], function values.
            W       -   weights, array[0..N-1]
            C       -   array[0..K-1], initial approximation to the solution,
            N       -   number of points, N>1
            M       -   dimension of space
            K       -   number of parameters being fitted
            DiffStep-   numerical differentiation step;
                        should not be very small or large;
                        large = loss of accuracy
                        small = growth of round-off errors

        OUTPUT PARAMETERS:
            State   -   structure which stores algorithm state

          -- ALGLIB --
             Copyright 18.10.2008 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitcreatewf(double[,] x,
            double[] y,
            double[] w,
            double[] c,
            int n,
            int m,
            int k,
            double diffstep,
            lsfitstate state,
            alglib.xparams _params)
        {
            int i = 0;
            int i_ = 0;

            alglib.ap.assert(n>=1, "LSFitCreateWF: N<1!");
            alglib.ap.assert(m>=1, "LSFitCreateWF: M<1!");
            alglib.ap.assert(k>=1, "LSFitCreateWF: K<1!");
            alglib.ap.assert(alglib.ap.len(c)>=k, "LSFitCreateWF: length(C)<K!");
            alglib.ap.assert(apserv.isfinitevector(c, k, _params), "LSFitCreateWF: C contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitCreateWF: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitCreateWF: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "LSFitCreateWF: length(W)<N!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "LSFitCreateWF: W contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSFitCreateWF: rows(X)<N!");
            alglib.ap.assert(alglib.ap.cols(x)>=m, "LSFitCreateWF: cols(X)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, m, _params), "LSFitCreateWF: X contains infinite or NaN values!");
            alglib.ap.assert(math.isfinite(diffstep), "LSFitCreateWF: DiffStep is not finite!");
            alglib.ap.assert((double)(diffstep)>(double)(0), "LSFitCreateWF: DiffStep<=0!");
            state.teststep = 0;
            state.diffstep = diffstep;
            state.npoints = n;
            state.nweights = n;
            state.wkind = 1;
            state.m = m;
            state.k = k;
            lsfitsetcond(state, 0.0, 0, _params);
            lsfitsetstpmax(state, 0.0, _params);
            lsfitsetxrep(state, false, _params);
            state.taskx = new double[n, m];
            state.tasky = new double[n];
            state.taskw = new double[n];
            state.c = new double[k];
            state.c0 = new double[k];
            state.c1 = new double[k];
            for(i_=0; i_<=k-1;i_++)
            {
                state.c0[i_] = c[i_];
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c1[i_] = c[i_];
            }
            state.x = new double[m];
            for(i_=0; i_<=n-1;i_++)
            {
                state.taskw[i_] = w[i_];
            }
            for(i=0; i<=n-1; i++)
            {
                for(i_=0; i_<=m-1;i_++)
                {
                    state.taskx[i,i_] = x[i,i_];
                }
                state.tasky[i] = y[i];
            }
            state.s = new double[k];
            state.bndl = new double[k];
            state.bndu = new double[k];
            for(i=0; i<=k-1; i++)
            {
                state.s[i] = 1.0;
                state.bndl[i] = Double.NegativeInfinity;
                state.bndu[i] = Double.PositiveInfinity;
            }
            state.optalgo = 0;
            state.prevnpt = -1;
            state.prevalgo = -1;
            state.nec = 0;
            state.nic = 0;
            minlm.minlmcreatev(k, n, state.c0, diffstep, state.optstate, _params);
            lsfitclearrequestfields(state, _params);
            state.rstate.ia = new int[6+1];
            state.rstate.ra = new double[8+1];
            state.rstate.stage = -1;
        }


        /*************************************************************************
        Nonlinear least squares fitting using function values only.

        Combination of numerical differentiation and secant updates is used to
        obtain function Jacobian.

        Nonlinear task min(F(c)) is solved, where

            F(c) = (f(c,x[0])-y[0])^2 + ... + (f(c,x[n-1])-y[n-1])^2,

            * N is a number of points,
            * M is a dimension of a space points belong to,
            * K is a dimension of a space of parameters being fitted,
            * w is an N-dimensional vector of weight coefficients,
            * x is a set of N points, each of them is an M-dimensional vector,
            * c is a K-dimensional vector of parameters being fitted

        This subroutine uses only f(c,x[i]).

        INPUT PARAMETERS:
            X       -   array[0..N-1,0..M-1], points (one row = one point)
            Y       -   array[0..N-1], function values.
            C       -   array[0..K-1], initial approximation to the solution,
            N       -   number of points, N>1
            M       -   dimension of space
            K       -   number of parameters being fitted
            DiffStep-   numerical differentiation step;
                        should not be very small or large;
                        large = loss of accuracy
                        small = growth of round-off errors

        OUTPUT PARAMETERS:
            State   -   structure which stores algorithm state

          -- ALGLIB --
             Copyright 18.10.2008 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitcreatef(double[,] x,
            double[] y,
            double[] c,
            int n,
            int m,
            int k,
            double diffstep,
            lsfitstate state,
            alglib.xparams _params)
        {
            int i = 0;
            int i_ = 0;

            alglib.ap.assert(n>=1, "LSFitCreateF: N<1!");
            alglib.ap.assert(m>=1, "LSFitCreateF: M<1!");
            alglib.ap.assert(k>=1, "LSFitCreateF: K<1!");
            alglib.ap.assert(alglib.ap.len(c)>=k, "LSFitCreateF: length(C)<K!");
            alglib.ap.assert(apserv.isfinitevector(c, k, _params), "LSFitCreateF: C contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitCreateF: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitCreateF: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSFitCreateF: rows(X)<N!");
            alglib.ap.assert(alglib.ap.cols(x)>=m, "LSFitCreateF: cols(X)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, m, _params), "LSFitCreateF: X contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSFitCreateF: rows(X)<N!");
            alglib.ap.assert(alglib.ap.cols(x)>=m, "LSFitCreateF: cols(X)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, m, _params), "LSFitCreateF: X contains infinite or NaN values!");
            alglib.ap.assert(math.isfinite(diffstep), "LSFitCreateF: DiffStep is not finite!");
            alglib.ap.assert((double)(diffstep)>(double)(0), "LSFitCreateF: DiffStep<=0!");
            state.teststep = 0;
            state.diffstep = diffstep;
            state.npoints = n;
            state.wkind = 0;
            state.m = m;
            state.k = k;
            lsfitsetcond(state, 0.0, 0, _params);
            lsfitsetstpmax(state, 0.0, _params);
            lsfitsetxrep(state, false, _params);
            state.taskx = new double[n, m];
            state.tasky = new double[n];
            state.c = new double[k];
            state.c0 = new double[k];
            state.c1 = new double[k];
            for(i_=0; i_<=k-1;i_++)
            {
                state.c0[i_] = c[i_];
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c1[i_] = c[i_];
            }
            state.x = new double[m];
            for(i=0; i<=n-1; i++)
            {
                for(i_=0; i_<=m-1;i_++)
                {
                    state.taskx[i,i_] = x[i,i_];
                }
                state.tasky[i] = y[i];
            }
            state.s = new double[k];
            state.bndl = new double[k];
            state.bndu = new double[k];
            for(i=0; i<=k-1; i++)
            {
                state.s[i] = 1.0;
                state.bndl[i] = Double.NegativeInfinity;
                state.bndu[i] = Double.PositiveInfinity;
            }
            state.optalgo = 0;
            state.prevnpt = -1;
            state.prevalgo = -1;
            state.nec = 0;
            state.nic = 0;
            minlm.minlmcreatev(k, n, state.c0, diffstep, state.optstate, _params);
            lsfitclearrequestfields(state, _params);
            state.rstate.ia = new int[6+1];
            state.rstate.ra = new double[8+1];
            state.rstate.stage = -1;
        }


        /*************************************************************************
        Weighted nonlinear least squares fitting using gradient only.

        Nonlinear task min(F(c)) is solved, where

            F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
            
            * N is a number of points,
            * M is a dimension of a space points belong to,
            * K is a dimension of a space of parameters being fitted,
            * w is an N-dimensional vector of weight coefficients,
            * x is a set of N points, each of them is an M-dimensional vector,
            * c is a K-dimensional vector of parameters being fitted
            
        This subroutine uses only f(c,x[i]) and its gradient.
            
        INPUT PARAMETERS:
            X       -   array[0..N-1,0..M-1], points (one row = one point)
            Y       -   array[0..N-1], function values.
            W       -   weights, array[0..N-1]
            C       -   array[0..K-1], initial approximation to the solution,
            N       -   number of points, N>1
            M       -   dimension of space
            K       -   number of parameters being fitted
            CheapFG -   boolean flag, which is:
                        * True  if both function and gradient calculation complexity
                                are less than O(M^2).  An improved  algorithm  can
                                be  used  which corresponds  to  FGJ  scheme  from
                                MINLM unit.
                        * False otherwise.
                                Standard Jacibian-bases  Levenberg-Marquardt  algo
                                will be used (FJ scheme).

        OUTPUT PARAMETERS:
            State   -   structure which stores algorithm state

        See also:
            LSFitResults
            LSFitCreateFG (fitting without weights)
            LSFitCreateWFGH (fitting using Hessian)
            LSFitCreateFGH (fitting using Hessian, without weights)

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitcreatewfg(double[,] x,
            double[] y,
            double[] w,
            double[] c,
            int n,
            int m,
            int k,
            bool cheapfg,
            lsfitstate state,
            alglib.xparams _params)
        {
            int i = 0;
            int i_ = 0;

            alglib.ap.assert(n>=1, "LSFitCreateWFG: N<1!");
            alglib.ap.assert(m>=1, "LSFitCreateWFG: M<1!");
            alglib.ap.assert(k>=1, "LSFitCreateWFG: K<1!");
            alglib.ap.assert(alglib.ap.len(c)>=k, "LSFitCreateWFG: length(C)<K!");
            alglib.ap.assert(apserv.isfinitevector(c, k, _params), "LSFitCreateWFG: C contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitCreateWFG: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitCreateWFG: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "LSFitCreateWFG: length(W)<N!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "LSFitCreateWFG: W contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSFitCreateWFG: rows(X)<N!");
            alglib.ap.assert(alglib.ap.cols(x)>=m, "LSFitCreateWFG: cols(X)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, m, _params), "LSFitCreateWFG: X contains infinite or NaN values!");
            state.teststep = 0;
            state.diffstep = 0;
            state.npoints = n;
            state.nweights = n;
            state.wkind = 1;
            state.m = m;
            state.k = k;
            lsfitsetcond(state, 0.0, 0, _params);
            lsfitsetstpmax(state, 0.0, _params);
            lsfitsetxrep(state, false, _params);
            state.taskx = new double[n, m];
            state.tasky = new double[n];
            state.taskw = new double[n];
            state.c = new double[k];
            state.c0 = new double[k];
            state.c1 = new double[k];
            for(i_=0; i_<=k-1;i_++)
            {
                state.c0[i_] = c[i_];
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c1[i_] = c[i_];
            }
            state.x = new double[m];
            state.g = new double[k];
            for(i_=0; i_<=n-1;i_++)
            {
                state.taskw[i_] = w[i_];
            }
            for(i=0; i<=n-1; i++)
            {
                for(i_=0; i_<=m-1;i_++)
                {
                    state.taskx[i,i_] = x[i,i_];
                }
                state.tasky[i] = y[i];
            }
            state.s = new double[k];
            state.bndl = new double[k];
            state.bndu = new double[k];
            for(i=0; i<=k-1; i++)
            {
                state.s[i] = 1.0;
                state.bndl[i] = Double.NegativeInfinity;
                state.bndu[i] = Double.PositiveInfinity;
            }
            state.optalgo = 1;
            state.prevnpt = -1;
            state.prevalgo = -1;
            state.nec = 0;
            state.nic = 0;
            if( cheapfg )
            {
                minlm.minlmcreatevgj(k, n, state.c0, state.optstate, _params);
            }
            else
            {
                minlm.minlmcreatevj(k, n, state.c0, state.optstate, _params);
            }
            lsfitclearrequestfields(state, _params);
            state.rstate.ia = new int[6+1];
            state.rstate.ra = new double[8+1];
            state.rstate.stage = -1;
        }


        /*************************************************************************
        Nonlinear least squares fitting using gradient only, without individual
        weights.

        Nonlinear task min(F(c)) is solved, where

            F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,

            * N is a number of points,
            * M is a dimension of a space points belong to,
            * K is a dimension of a space of parameters being fitted,
            * x is a set of N points, each of them is an M-dimensional vector,
            * c is a K-dimensional vector of parameters being fitted

        This subroutine uses only f(c,x[i]) and its gradient.

        INPUT PARAMETERS:
            X       -   array[0..N-1,0..M-1], points (one row = one point)
            Y       -   array[0..N-1], function values.
            C       -   array[0..K-1], initial approximation to the solution,
            N       -   number of points, N>1
            M       -   dimension of space
            K       -   number of parameters being fitted
            CheapFG -   boolean flag, which is:
                        * True  if both function and gradient calculation complexity
                                are less than O(M^2).  An improved  algorithm  can
                                be  used  which corresponds  to  FGJ  scheme  from
                                MINLM unit.
                        * False otherwise.
                                Standard Jacibian-bases  Levenberg-Marquardt  algo
                                will be used (FJ scheme).

        OUTPUT PARAMETERS:
            State   -   structure which stores algorithm state

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitcreatefg(double[,] x,
            double[] y,
            double[] c,
            int n,
            int m,
            int k,
            bool cheapfg,
            lsfitstate state,
            alglib.xparams _params)
        {
            int i = 0;
            int i_ = 0;

            alglib.ap.assert(n>=1, "LSFitCreateFG: N<1!");
            alglib.ap.assert(m>=1, "LSFitCreateFG: M<1!");
            alglib.ap.assert(k>=1, "LSFitCreateFG: K<1!");
            alglib.ap.assert(alglib.ap.len(c)>=k, "LSFitCreateFG: length(C)<K!");
            alglib.ap.assert(apserv.isfinitevector(c, k, _params), "LSFitCreateFG: C contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitCreateFG: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitCreateFG: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSFitCreateFG: rows(X)<N!");
            alglib.ap.assert(alglib.ap.cols(x)>=m, "LSFitCreateFG: cols(X)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, m, _params), "LSFitCreateFG: X contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSFitCreateFG: rows(X)<N!");
            alglib.ap.assert(alglib.ap.cols(x)>=m, "LSFitCreateFG: cols(X)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, m, _params), "LSFitCreateFG: X contains infinite or NaN values!");
            state.teststep = 0;
            state.diffstep = 0;
            state.npoints = n;
            state.wkind = 0;
            state.m = m;
            state.k = k;
            lsfitsetcond(state, 0.0, 0, _params);
            lsfitsetstpmax(state, 0.0, _params);
            lsfitsetxrep(state, false, _params);
            state.taskx = new double[n, m];
            state.tasky = new double[n];
            state.c = new double[k];
            state.c0 = new double[k];
            state.c1 = new double[k];
            for(i_=0; i_<=k-1;i_++)
            {
                state.c0[i_] = c[i_];
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c1[i_] = c[i_];
            }
            state.x = new double[m];
            state.g = new double[k];
            for(i=0; i<=n-1; i++)
            {
                for(i_=0; i_<=m-1;i_++)
                {
                    state.taskx[i,i_] = x[i,i_];
                }
                state.tasky[i] = y[i];
            }
            state.s = new double[k];
            state.bndl = new double[k];
            state.bndu = new double[k];
            for(i=0; i<=k-1; i++)
            {
                state.s[i] = 1.0;
                state.bndl[i] = Double.NegativeInfinity;
                state.bndu[i] = Double.PositiveInfinity;
            }
            state.optalgo = 1;
            state.prevnpt = -1;
            state.prevalgo = -1;
            state.nec = 0;
            state.nic = 0;
            if( cheapfg )
            {
                minlm.minlmcreatevgj(k, n, state.c0, state.optstate, _params);
            }
            else
            {
                minlm.minlmcreatevj(k, n, state.c0, state.optstate, _params);
            }
            lsfitclearrequestfields(state, _params);
            state.rstate.ia = new int[6+1];
            state.rstate.ra = new double[8+1];
            state.rstate.stage = -1;
        }


        /*************************************************************************
        Weighted nonlinear least squares fitting using gradient/Hessian.

        Nonlinear task min(F(c)) is solved, where

            F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,

            * N is a number of points,
            * M is a dimension of a space points belong to,
            * K is a dimension of a space of parameters being fitted,
            * w is an N-dimensional vector of weight coefficients,
            * x is a set of N points, each of them is an M-dimensional vector,
            * c is a K-dimensional vector of parameters being fitted

        This subroutine uses f(c,x[i]), its gradient and its Hessian.

        INPUT PARAMETERS:
            X       -   array[0..N-1,0..M-1], points (one row = one point)
            Y       -   array[0..N-1], function values.
            W       -   weights, array[0..N-1]
            C       -   array[0..K-1], initial approximation to the solution,
            N       -   number of points, N>1
            M       -   dimension of space
            K       -   number of parameters being fitted

        OUTPUT PARAMETERS:
            State   -   structure which stores algorithm state

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitcreatewfgh(double[,] x,
            double[] y,
            double[] w,
            double[] c,
            int n,
            int m,
            int k,
            lsfitstate state,
            alglib.xparams _params)
        {
            int i = 0;
            int i_ = 0;

            alglib.ap.assert(n>=1, "LSFitCreateWFGH: N<1!");
            alglib.ap.assert(m>=1, "LSFitCreateWFGH: M<1!");
            alglib.ap.assert(k>=1, "LSFitCreateWFGH: K<1!");
            alglib.ap.assert(alglib.ap.len(c)>=k, "LSFitCreateWFGH: length(C)<K!");
            alglib.ap.assert(apserv.isfinitevector(c, k, _params), "LSFitCreateWFGH: C contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitCreateWFGH: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitCreateWFGH: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "LSFitCreateWFGH: length(W)<N!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "LSFitCreateWFGH: W contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSFitCreateWFGH: rows(X)<N!");
            alglib.ap.assert(alglib.ap.cols(x)>=m, "LSFitCreateWFGH: cols(X)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, m, _params), "LSFitCreateWFGH: X contains infinite or NaN values!");
            state.teststep = 0;
            state.diffstep = 0;
            state.npoints = n;
            state.nweights = n;
            state.wkind = 1;
            state.m = m;
            state.k = k;
            lsfitsetcond(state, 0.0, 0, _params);
            lsfitsetstpmax(state, 0.0, _params);
            lsfitsetxrep(state, false, _params);
            state.taskx = new double[n, m];
            state.tasky = new double[n];
            state.taskw = new double[n];
            state.c = new double[k];
            state.c0 = new double[k];
            state.c1 = new double[k];
            for(i_=0; i_<=k-1;i_++)
            {
                state.c0[i_] = c[i_];
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c1[i_] = c[i_];
            }
            state.h = new double[k, k];
            state.x = new double[m];
            state.g = new double[k];
            for(i_=0; i_<=n-1;i_++)
            {
                state.taskw[i_] = w[i_];
            }
            for(i=0; i<=n-1; i++)
            {
                for(i_=0; i_<=m-1;i_++)
                {
                    state.taskx[i,i_] = x[i,i_];
                }
                state.tasky[i] = y[i];
            }
            state.s = new double[k];
            state.bndl = new double[k];
            state.bndu = new double[k];
            for(i=0; i<=k-1; i++)
            {
                state.s[i] = 1.0;
                state.bndl[i] = Double.NegativeInfinity;
                state.bndu[i] = Double.PositiveInfinity;
            }
            state.optalgo = 2;
            state.prevnpt = -1;
            state.prevalgo = -1;
            state.nec = 0;
            state.nic = 0;
            minlm.minlmcreatefgh(k, state.c0, state.optstate, _params);
            lsfitclearrequestfields(state, _params);
            state.rstate.ia = new int[6+1];
            state.rstate.ra = new double[8+1];
            state.rstate.stage = -1;
        }


        /*************************************************************************
        Nonlinear least squares fitting using gradient/Hessian, without individial
        weights.

        Nonlinear task min(F(c)) is solved, where

            F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,

            * N is a number of points,
            * M is a dimension of a space points belong to,
            * K is a dimension of a space of parameters being fitted,
            * x is a set of N points, each of them is an M-dimensional vector,
            * c is a K-dimensional vector of parameters being fitted

        This subroutine uses f(c,x[i]), its gradient and its Hessian.

        INPUT PARAMETERS:
            X       -   array[0..N-1,0..M-1], points (one row = one point)
            Y       -   array[0..N-1], function values.
            C       -   array[0..K-1], initial approximation to the solution,
            N       -   number of points, N>1
            M       -   dimension of space
            K       -   number of parameters being fitted

        OUTPUT PARAMETERS:
            State   -   structure which stores algorithm state


          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitcreatefgh(double[,] x,
            double[] y,
            double[] c,
            int n,
            int m,
            int k,
            lsfitstate state,
            alglib.xparams _params)
        {
            int i = 0;
            int i_ = 0;

            alglib.ap.assert(n>=1, "LSFitCreateFGH: N<1!");
            alglib.ap.assert(m>=1, "LSFitCreateFGH: M<1!");
            alglib.ap.assert(k>=1, "LSFitCreateFGH: K<1!");
            alglib.ap.assert(alglib.ap.len(c)>=k, "LSFitCreateFGH: length(C)<K!");
            alglib.ap.assert(apserv.isfinitevector(c, k, _params), "LSFitCreateFGH: C contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "LSFitCreateFGH: length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "LSFitCreateFGH: Y contains infinite or NaN values!");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSFitCreateFGH: rows(X)<N!");
            alglib.ap.assert(alglib.ap.cols(x)>=m, "LSFitCreateFGH: cols(X)<M!");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, m, _params), "LSFitCreateFGH: X contains infinite or NaN values!");
            state.teststep = 0;
            state.diffstep = 0;
            state.npoints = n;
            state.wkind = 0;
            state.m = m;
            state.k = k;
            lsfitsetcond(state, 0.0, 0, _params);
            lsfitsetstpmax(state, 0.0, _params);
            lsfitsetxrep(state, false, _params);
            state.taskx = new double[n, m];
            state.tasky = new double[n];
            state.c = new double[k];
            state.c0 = new double[k];
            state.c1 = new double[k];
            for(i_=0; i_<=k-1;i_++)
            {
                state.c0[i_] = c[i_];
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c1[i_] = c[i_];
            }
            state.h = new double[k, k];
            state.x = new double[m];
            state.g = new double[k];
            for(i=0; i<=n-1; i++)
            {
                for(i_=0; i_<=m-1;i_++)
                {
                    state.taskx[i,i_] = x[i,i_];
                }
                state.tasky[i] = y[i];
            }
            state.s = new double[k];
            state.bndl = new double[k];
            state.bndu = new double[k];
            for(i=0; i<=k-1; i++)
            {
                state.s[i] = 1.0;
                state.bndl[i] = Double.NegativeInfinity;
                state.bndu[i] = Double.PositiveInfinity;
            }
            state.optalgo = 2;
            state.prevnpt = -1;
            state.prevalgo = -1;
            state.nec = 0;
            state.nic = 0;
            minlm.minlmcreatefgh(k, state.c0, state.optstate, _params);
            lsfitclearrequestfields(state, _params);
            state.rstate.ia = new int[6+1];
            state.rstate.ra = new double[8+1];
            state.rstate.stage = -1;
        }


        /*************************************************************************
        Stopping conditions for nonlinear least squares fitting.

        INPUT PARAMETERS:
            State   -   structure which stores algorithm state
            EpsX    -   >=0
                        The subroutine finishes its work if  on  k+1-th  iteration
                        the condition |v|<=EpsX is fulfilled, where:
                        * |.| means Euclidian norm
                        * v - scaled step vector, v[i]=dx[i]/s[i]
                        * dx - ste pvector, dx=X(k+1)-X(k)
                        * s - scaling coefficients set by LSFitSetScale()
            MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
                        iterations   is    unlimited.   Only   Levenberg-Marquardt
                        iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
                        counted because their cost is very low compared to that of
                        LM).

        NOTE

        Passing EpsX=0  and  MaxIts=0  (simultaneously)  will  lead  to  automatic
        stopping criterion selection (according to the scheme used by MINLM unit).


          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitsetcond(lsfitstate state,
            double epsx,
            int maxits,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(epsx), "LSFitSetCond: EpsX is not finite!");
            alglib.ap.assert((double)(epsx)>=(double)(0), "LSFitSetCond: negative EpsX!");
            alglib.ap.assert(maxits>=0, "LSFitSetCond: negative MaxIts!");
            state.epsx = epsx;
            state.maxits = maxits;
        }


        /*************************************************************************
        This function sets maximum step length

        INPUT PARAMETERS:
            State   -   structure which stores algorithm state
            StpMax  -   maximum step length, >=0. Set StpMax to 0.0,  if you don't
                        want to limit step length.

        Use this subroutine when you optimize target function which contains exp()
        or  other  fast  growing  functions,  and optimization algorithm makes too
        large  steps  which  leads  to overflow. This function allows us to reject
        steps  that  are  too  large  (and  therefore  expose  us  to the possible
        overflow) without actually calculating function value at the x+stp*d.

        NOTE: non-zero StpMax leads to moderate  performance  degradation  because
        intermediate  step  of  preconditioned L-BFGS optimization is incompatible
        with limits on step size.

          -- ALGLIB --
             Copyright 02.04.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitsetstpmax(lsfitstate state,
            double stpmax,
            alglib.xparams _params)
        {
            alglib.ap.assert((double)(stpmax)>=(double)(0), "LSFitSetStpMax: StpMax<0!");
            state.stpmax = stpmax;
        }


        /*************************************************************************
        This function turns on/off reporting.

        INPUT PARAMETERS:
            State   -   structure which stores algorithm state
            NeedXRep-   whether iteration reports are needed or not
            
        When reports are needed, State.C (current parameters) and State.F (current
        value of fitting function) are reported.


          -- ALGLIB --
             Copyright 15.08.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitsetxrep(lsfitstate state,
            bool needxrep,
            alglib.xparams _params)
        {
            state.xrep = needxrep;
        }


        /*************************************************************************
        This function sets scaling coefficients for underlying optimizer.

        ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
        size and gradient are scaled before comparison with tolerances).  Scale of
        the I-th variable is a translation invariant measure of:
        a) "how large" the variable is
        b) how large the step should be to make significant changes in the function

        Generally, scale is NOT considered to be a form of preconditioner.  But LM
        optimizer is unique in that it uses scaling matrix both  in  the  stopping
        condition tests and as Marquardt damping factor.

        Proper scaling is very important for the algorithm performance. It is less
        important for the quality of results, but still has some influence (it  is
        easier  to  converge  when  variables  are  properly  scaled, so premature
        stopping is possible when very badly scalled variables are  combined  with
        relaxed stopping conditions).

        INPUT PARAMETERS:
            State   -   structure stores algorithm state
            S       -   array[N], non-zero scaling coefficients
                        S[i] may be negative, sign doesn't matter.

          -- ALGLIB --
             Copyright 14.01.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitsetscale(lsfitstate state,
            double[] s,
            alglib.xparams _params)
        {
            int i = 0;

            alglib.ap.assert(alglib.ap.len(s)>=state.k, "LSFitSetScale: Length(S)<K");
            for(i=0; i<=state.k-1; i++)
            {
                alglib.ap.assert(math.isfinite(s[i]), "LSFitSetScale: S contains infinite or NAN elements");
                alglib.ap.assert((double)(s[i])!=(double)(0), "LSFitSetScale: S contains infinite or NAN elements");
                state.s[i] = Math.Abs(s[i]);
            }
        }


        /*************************************************************************
        This function sets boundary constraints for underlying optimizer

        Boundary constraints are inactive by default (after initial creation).
        They are preserved until explicitly turned off with another SetBC() call.

        INPUT PARAMETERS:
            State   -   structure stores algorithm state
            BndL    -   lower bounds, array[K].
                        If some (all) variables are unbounded, you may specify
                        very small number or -INF (latter is recommended because
                        it will allow solver to use better algorithm).
            BndU    -   upper bounds, array[K].
                        If some (all) variables are unbounded, you may specify
                        very large number or +INF (latter is recommended because
                        it will allow solver to use better algorithm).

        NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
        variable will be "frozen" at X[i]=BndL[i]=BndU[i].

        NOTE 2: unlike other constrained optimization algorithms, this solver  has
        following useful properties:
        * bound constraints are always satisfied exactly
        * function is evaluated only INSIDE area specified by bound constraints

          -- ALGLIB --
             Copyright 14.01.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitsetbc(lsfitstate state,
            double[] bndl,
            double[] bndu,
            alglib.xparams _params)
        {
            int i = 0;
            int k = 0;

            k = state.k;
            alglib.ap.assert(alglib.ap.len(bndl)>=k, "LSFitSetBC: Length(BndL)<K");
            alglib.ap.assert(alglib.ap.len(bndu)>=k, "LSFitSetBC: Length(BndU)<K");
            for(i=0; i<=k-1; i++)
            {
                alglib.ap.assert(math.isfinite(bndl[i]) || Double.IsNegativeInfinity(bndl[i]), "LSFitSetBC: BndL contains NAN or +INF");
                alglib.ap.assert(math.isfinite(bndu[i]) || Double.IsPositiveInfinity(bndu[i]), "LSFitSetBC: BndU contains NAN or -INF");
                if( math.isfinite(bndl[i]) && math.isfinite(bndu[i]) )
                {
                    alglib.ap.assert((double)(bndl[i])<=(double)(bndu[i]), "LSFitSetBC: BndL[i]>BndU[i]");
                }
                state.bndl[i] = bndl[i];
                state.bndu[i] = bndu[i];
            }
        }


        /*************************************************************************
        This function sets linear constraints for underlying optimizer

        Linear constraints are inactive by default (after initial creation).
        They are preserved until explicitly turned off with another SetLC() call.

        INPUT PARAMETERS:
            State   -   structure stores algorithm state
            C       -   linear constraints, array[K,N+1].
                        Each row of C represents one constraint, either equality
                        or inequality (see below):
                        * first N elements correspond to coefficients,
                        * last element corresponds to the right part.
                        All elements of C (including right part) must be finite.
            CT      -   type of constraints, array[K]:
                        * if CT[i]>0, then I-th constraint is C[i,*]*x >= C[i,n+1]
                        * if CT[i]=0, then I-th constraint is C[i,*]*x  = C[i,n+1]
                        * if CT[i]<0, then I-th constraint is C[i,*]*x <= C[i,n+1]
            K       -   number of equality/inequality constraints, K>=0:
                        * if given, only leading K elements of C/CT are used
                        * if not given, automatically determined from sizes of C/CT

        IMPORTANT: if you have linear constraints, it is strongly  recommended  to
                   set scale of variables with lsfitsetscale(). QP solver which is
                   used to calculate linearly constrained steps heavily relies  on
                   good scaling of input problems.
                   
        NOTE: linear  (non-box)  constraints  are  satisfied only approximately  -
              there  always  exists some violation due  to  numerical  errors  and
              algorithmic limitations.

        NOTE: general linear constraints  add  significant  overhead  to  solution
              process. Although solver performs roughly same amount of  iterations
              (when compared  with  similar  box-only  constrained  problem), each
              iteration   now    involves  solution  of  linearly  constrained  QP
              subproblem, which requires ~3-5 times more Cholesky  decompositions.
              Thus, if you can reformulate your problem in such way  this  it  has
              only box constraints, it may be beneficial to do so.

          -- ALGLIB --
             Copyright 29.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitsetlc(lsfitstate state,
            double[,] c,
            int[] ct,
            int k,
            alglib.xparams _params)
        {
            int i = 0;
            int n = 0;
            int i_ = 0;

            n = state.k;
            
            //
            // First, check for errors in the inputs
            //
            alglib.ap.assert(k>=0, "LSFitSetLC: K<0");
            alglib.ap.assert(alglib.ap.cols(c)>=n+1 || k==0, "LSFitSetLC: Cols(C)<N+1");
            alglib.ap.assert(alglib.ap.rows(c)>=k, "LSFitSetLC: Rows(C)<K");
            alglib.ap.assert(alglib.ap.len(ct)>=k, "LSFitSetLC: Length(CT)<K");
            alglib.ap.assert(apserv.apservisfinitematrix(c, k, n+1, _params), "LSFitSetLC: C contains infinite or NaN values!");
            
            //
            // Handle zero K
            //
            if( k==0 )
            {
                state.nec = 0;
                state.nic = 0;
                return;
            }
            
            //
            // Equality constraints are stored first, in the upper
            // NEC rows of State.CLEIC matrix. Inequality constraints
            // are stored in the next NIC rows.
            //
            // NOTE: we convert inequality constraints to the form
            // A*x<=b before copying them.
            //
            apserv.rmatrixsetlengthatleast(ref state.cleic, k, n+1, _params);
            state.nec = 0;
            state.nic = 0;
            for(i=0; i<=k-1; i++)
            {
                if( ct[i]==0 )
                {
                    for(i_=0; i_<=n;i_++)
                    {
                        state.cleic[state.nec,i_] = c[i,i_];
                    }
                    state.nec = state.nec+1;
                }
            }
            for(i=0; i<=k-1; i++)
            {
                if( ct[i]!=0 )
                {
                    if( ct[i]>0 )
                    {
                        for(i_=0; i_<=n;i_++)
                        {
                            state.cleic[state.nec+state.nic,i_] = -c[i,i_];
                        }
                    }
                    else
                    {
                        for(i_=0; i_<=n;i_++)
                        {
                            state.cleic[state.nec+state.nic,i_] = c[i,i_];
                        }
                    }
                    state.nic = state.nic+1;
                }
            }
        }


        /*************************************************************************
        NOTES:

        1. this algorithm is somewhat unusual because it works with  parameterized
           function f(C,X), where X is a function argument (we  have  many  points
           which are characterized by different  argument  values),  and  C  is  a
           parameter to fit.

           For example, if we want to do linear fit by f(c0,c1,x) = c0*x+c1,  then
           x will be argument, and {c0,c1} will be parameters.
           
           It is important to understand that this algorithm finds minimum in  the
           space of function PARAMETERS (not arguments), so it  needs  derivatives
           of f() with respect to C, not X.
           
           In the example above it will need f=c0*x+c1 and {df/dc0,df/dc1} = {x,1}
           instead of {df/dx} = {c0}.

        2. Callback functions accept C as the first parameter, and X as the second

        3. If  state  was  created  with  LSFitCreateFG(),  algorithm  needs  just
           function   and   its   gradient,   but   if   state   was  created with
           LSFitCreateFGH(), algorithm will need function, gradient and Hessian.
           
           According  to  the  said  above,  there  ase  several  versions of this
           function, which accept different sets of callbacks.
           
           This flexibility opens way to subtle errors - you may create state with
           LSFitCreateFGH() (optimization using Hessian), but call function  which
           does not accept Hessian. So when algorithm will request Hessian,  there
           will be no callback to call. In this case exception will be thrown.
           
           Be careful to avoid such errors because there is no way to find them at
           compile time - you can see them at runtime only.

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static bool lsfititeration(lsfitstate state,
            alglib.xparams _params)
        {
            bool result = new bool();
            double lx = 0;
            double lf = 0;
            double ld = 0;
            double rx = 0;
            double rf = 0;
            double rd = 0;
            int n = 0;
            int m = 0;
            int k = 0;
            double v = 0;
            double vv = 0;
            double relcnt = 0;
            int i = 0;
            int j = 0;
            int j1 = 0;
            int info = 0;
            int i_ = 0;

            
            //
            // Reverse communication preparations
            // I know it looks ugly, but it works the same way
            // anywhere from C++ to Python.
            //
            // This code initializes locals by:
            // * random values determined during code
            //   generation - on first subroutine call
            // * values from previous call - on subsequent calls
            //
            if( state.rstate.stage>=0 )
            {
                n = state.rstate.ia[0];
                m = state.rstate.ia[1];
                k = state.rstate.ia[2];
                i = state.rstate.ia[3];
                j = state.rstate.ia[4];
                j1 = state.rstate.ia[5];
                info = state.rstate.ia[6];
                lx = state.rstate.ra[0];
                lf = state.rstate.ra[1];
                ld = state.rstate.ra[2];
                rx = state.rstate.ra[3];
                rf = state.rstate.ra[4];
                rd = state.rstate.ra[5];
                v = state.rstate.ra[6];
                vv = state.rstate.ra[7];
                relcnt = state.rstate.ra[8];
            }
            else
            {
                n = 359;
                m = -58;
                k = -919;
                i = -909;
                j = 81;
                j1 = 255;
                info = 74;
                lx = -788;
                lf = 809;
                ld = 205;
                rx = -838;
                rf = 939;
                rd = -526;
                v = 763;
                vv = -541;
                relcnt = -698;
            }
            if( state.rstate.stage==0 )
            {
                goto lbl_0;
            }
            if( state.rstate.stage==1 )
            {
                goto lbl_1;
            }
            if( state.rstate.stage==2 )
            {
                goto lbl_2;
            }
            if( state.rstate.stage==3 )
            {
                goto lbl_3;
            }
            if( state.rstate.stage==4 )
            {
                goto lbl_4;
            }
            if( state.rstate.stage==5 )
            {
                goto lbl_5;
            }
            if( state.rstate.stage==6 )
            {
                goto lbl_6;
            }
            if( state.rstate.stage==7 )
            {
                goto lbl_7;
            }
            if( state.rstate.stage==8 )
            {
                goto lbl_8;
            }
            if( state.rstate.stage==9 )
            {
                goto lbl_9;
            }
            if( state.rstate.stage==10 )
            {
                goto lbl_10;
            }
            if( state.rstate.stage==11 )
            {
                goto lbl_11;
            }
            if( state.rstate.stage==12 )
            {
                goto lbl_12;
            }
            if( state.rstate.stage==13 )
            {
                goto lbl_13;
            }
            
            //
            // Routine body
            //
            
            //
            // Init
            //
            if( state.wkind==1 )
            {
                alglib.ap.assert(state.npoints==state.nweights, "LSFitFit: number of points is not equal to the number of weights");
            }
            state.repvaridx = -1;
            n = state.npoints;
            m = state.m;
            k = state.k;
            apserv.ivectorsetlengthatleast(ref state.tmpct, state.nec+state.nic, _params);
            for(i=0; i<=state.nec-1; i++)
            {
                state.tmpct[i] = 0;
            }
            for(i=0; i<=state.nic-1; i++)
            {
                state.tmpct[state.nec+i] = -1;
            }
            minlm.minlmsetcond(state.optstate, state.epsx, state.maxits, _params);
            minlm.minlmsetstpmax(state.optstate, state.stpmax, _params);
            minlm.minlmsetxrep(state.optstate, state.xrep, _params);
            minlm.minlmsetscale(state.optstate, state.s, _params);
            minlm.minlmsetbc(state.optstate, state.bndl, state.bndu, _params);
            minlm.minlmsetlc(state.optstate, state.cleic, state.tmpct, state.nec+state.nic, _params);
            
            //
            //  Check that user-supplied gradient is correct
            //
            lsfitclearrequestfields(state, _params);
            if( !((double)(state.teststep)>(double)(0) && state.optalgo==1) )
            {
                goto lbl_14;
            }
            for(i=0; i<=k-1; i++)
            {
                state.c[i] = state.c0[i];
                if( math.isfinite(state.bndl[i]) )
                {
                    state.c[i] = Math.Max(state.c[i], state.bndl[i]);
                }
                if( math.isfinite(state.bndu[i]) )
                {
                    state.c[i] = Math.Min(state.c[i], state.bndu[i]);
                }
            }
            state.needfg = true;
            i = 0;
        lbl_16:
            if( i>k-1 )
            {
                goto lbl_18;
            }
            alglib.ap.assert((double)(state.bndl[i])<=(double)(state.c[i]) && (double)(state.c[i])<=(double)(state.bndu[i]), "LSFitIteration: internal error(State.C is out of bounds)");
            v = state.c[i];
            j = 0;
        lbl_19:
            if( j>n-1 )
            {
                goto lbl_21;
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[j,i_];
            }
            state.c[i] = v-state.teststep*state.s[i];
            if( math.isfinite(state.bndl[i]) )
            {
                state.c[i] = Math.Max(state.c[i], state.bndl[i]);
            }
            lx = state.c[i];
            state.rstate.stage = 0;
            goto lbl_rcomm;
        lbl_0:
            lf = state.f;
            ld = state.g[i];
            state.c[i] = v+state.teststep*state.s[i];
            if( math.isfinite(state.bndu[i]) )
            {
                state.c[i] = Math.Min(state.c[i], state.bndu[i]);
            }
            rx = state.c[i];
            state.rstate.stage = 1;
            goto lbl_rcomm;
        lbl_1:
            rf = state.f;
            rd = state.g[i];
            state.c[i] = (lx+rx)/2;
            if( math.isfinite(state.bndl[i]) )
            {
                state.c[i] = Math.Max(state.c[i], state.bndl[i]);
            }
            if( math.isfinite(state.bndu[i]) )
            {
                state.c[i] = Math.Min(state.c[i], state.bndu[i]);
            }
            state.rstate.stage = 2;
            goto lbl_rcomm;
        lbl_2:
            state.c[i] = v;
            if( !optserv.derivativecheck(lf, ld, rf, rd, state.f, state.g[i], rx-lx, _params) )
            {
                state.repvaridx = i;
                state.repterminationtype = -7;
                result = false;
                return result;
            }
            j = j+1;
            goto lbl_19;
        lbl_21:
            i = i+1;
            goto lbl_16;
        lbl_18:
            state.needfg = false;
        lbl_14:
            
            //
            // Fill WCur by weights:
            // * for WKind=0 unit weights are chosen
            // * for WKind=1 we use user-supplied weights stored in State.TaskW
            //
            apserv.rvectorsetlengthatleast(ref state.wcur, n, _params);
            for(i=0; i<=n-1; i++)
            {
                state.wcur[i] = 1.0;
                if( state.wkind==1 )
                {
                    state.wcur[i] = state.taskw[i];
                }
            }
            
            //
            // Optimize
            //
        lbl_22:
            if( !minlm.minlmiteration(state.optstate, _params) )
            {
                goto lbl_23;
            }
            if( !state.optstate.needfi )
            {
                goto lbl_24;
            }
            
            //
            // calculate f[] = wi*(f(xi,c)-yi)
            //
            i = 0;
        lbl_26:
            if( i>n-1 )
            {
                goto lbl_28;
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c[i_] = state.optstate.x[i_];
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[i,i_];
            }
            state.pointindex = i;
            lsfitclearrequestfields(state, _params);
            state.needf = true;
            state.rstate.stage = 3;
            goto lbl_rcomm;
        lbl_3:
            state.needf = false;
            vv = state.wcur[i];
            state.optstate.fi[i] = vv*(state.f-state.tasky[i]);
            i = i+1;
            goto lbl_26;
        lbl_28:
            goto lbl_22;
        lbl_24:
            if( !state.optstate.needf )
            {
                goto lbl_29;
            }
            
            //
            // calculate F = sum (wi*(f(xi,c)-yi))^2
            //
            state.optstate.f = 0;
            i = 0;
        lbl_31:
            if( i>n-1 )
            {
                goto lbl_33;
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c[i_] = state.optstate.x[i_];
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[i,i_];
            }
            state.pointindex = i;
            lsfitclearrequestfields(state, _params);
            state.needf = true;
            state.rstate.stage = 4;
            goto lbl_rcomm;
        lbl_4:
            state.needf = false;
            vv = state.wcur[i];
            state.optstate.f = state.optstate.f+math.sqr(vv*(state.f-state.tasky[i]));
            i = i+1;
            goto lbl_31;
        lbl_33:
            goto lbl_22;
        lbl_29:
            if( !state.optstate.needfg )
            {
                goto lbl_34;
            }
            
            //
            // calculate F/gradF
            //
            state.optstate.f = 0;
            for(i=0; i<=k-1; i++)
            {
                state.optstate.g[i] = 0;
            }
            i = 0;
        lbl_36:
            if( i>n-1 )
            {
                goto lbl_38;
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c[i_] = state.optstate.x[i_];
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[i,i_];
            }
            state.pointindex = i;
            lsfitclearrequestfields(state, _params);
            state.needfg = true;
            state.rstate.stage = 5;
            goto lbl_rcomm;
        lbl_5:
            state.needfg = false;
            vv = state.wcur[i];
            state.optstate.f = state.optstate.f+math.sqr(vv*(state.f-state.tasky[i]));
            v = math.sqr(vv)*2*(state.f-state.tasky[i]);
            for(i_=0; i_<=k-1;i_++)
            {
                state.optstate.g[i_] = state.optstate.g[i_] + v*state.g[i_];
            }
            i = i+1;
            goto lbl_36;
        lbl_38:
            goto lbl_22;
        lbl_34:
            if( !state.optstate.needfij )
            {
                goto lbl_39;
            }
            
            //
            // calculate Fi/jac(Fi)
            //
            i = 0;
        lbl_41:
            if( i>n-1 )
            {
                goto lbl_43;
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c[i_] = state.optstate.x[i_];
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[i,i_];
            }
            state.pointindex = i;
            lsfitclearrequestfields(state, _params);
            state.needfg = true;
            state.rstate.stage = 6;
            goto lbl_rcomm;
        lbl_6:
            state.needfg = false;
            vv = state.wcur[i];
            state.optstate.fi[i] = vv*(state.f-state.tasky[i]);
            for(i_=0; i_<=k-1;i_++)
            {
                state.optstate.j[i,i_] = vv*state.g[i_];
            }
            i = i+1;
            goto lbl_41;
        lbl_43:
            goto lbl_22;
        lbl_39:
            if( !state.optstate.needfgh )
            {
                goto lbl_44;
            }
            
            //
            // calculate F/grad(F)/hess(F)
            //
            state.optstate.f = 0;
            for(i=0; i<=k-1; i++)
            {
                state.optstate.g[i] = 0;
            }
            for(i=0; i<=k-1; i++)
            {
                for(j=0; j<=k-1; j++)
                {
                    state.optstate.h[i,j] = 0;
                }
            }
            i = 0;
        lbl_46:
            if( i>n-1 )
            {
                goto lbl_48;
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c[i_] = state.optstate.x[i_];
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[i,i_];
            }
            state.pointindex = i;
            lsfitclearrequestfields(state, _params);
            state.needfgh = true;
            state.rstate.stage = 7;
            goto lbl_rcomm;
        lbl_7:
            state.needfgh = false;
            vv = state.wcur[i];
            state.optstate.f = state.optstate.f+math.sqr(vv*(state.f-state.tasky[i]));
            v = math.sqr(vv)*2*(state.f-state.tasky[i]);
            for(i_=0; i_<=k-1;i_++)
            {
                state.optstate.g[i_] = state.optstate.g[i_] + v*state.g[i_];
            }
            for(j=0; j<=k-1; j++)
            {
                v = 2*math.sqr(vv)*state.g[j];
                for(i_=0; i_<=k-1;i_++)
                {
                    state.optstate.h[j,i_] = state.optstate.h[j,i_] + v*state.g[i_];
                }
                v = 2*math.sqr(vv)*(state.f-state.tasky[i]);
                for(i_=0; i_<=k-1;i_++)
                {
                    state.optstate.h[j,i_] = state.optstate.h[j,i_] + v*state.h[j,i_];
                }
            }
            i = i+1;
            goto lbl_46;
        lbl_48:
            goto lbl_22;
        lbl_44:
            if( !state.optstate.xupdated )
            {
                goto lbl_49;
            }
            
            //
            // Report new iteration
            //
            for(i_=0; i_<=k-1;i_++)
            {
                state.c[i_] = state.optstate.x[i_];
            }
            state.f = state.optstate.f;
            lsfitclearrequestfields(state, _params);
            state.xupdated = true;
            state.rstate.stage = 8;
            goto lbl_rcomm;
        lbl_8:
            state.xupdated = false;
            goto lbl_22;
        lbl_49:
            goto lbl_22;
        lbl_23:
            
            //
            // Extract results
            //
            // NOTE: reverse communication protocol used by this unit does NOT
            //       allow us to reallocate State.C[] array. Thus, we extract
            //       results to the temporary variable in order to avoid possible
            //       reallocation.
            //
            minlm.minlmresults(state.optstate, ref state.c1, state.optrep, _params);
            state.repterminationtype = state.optrep.terminationtype;
            state.repiterationscount = state.optrep.iterationscount;
            
            //
            // calculate errors
            //
            if( state.repterminationtype<=0 )
            {
                goto lbl_51;
            }
            
            //
            // Calculate RMS/Avg/Max/... errors
            //
            state.reprmserror = 0;
            state.repwrmserror = 0;
            state.repavgerror = 0;
            state.repavgrelerror = 0;
            state.repmaxerror = 0;
            relcnt = 0;
            i = 0;
        lbl_53:
            if( i>n-1 )
            {
                goto lbl_55;
            }
            for(i_=0; i_<=k-1;i_++)
            {
                state.c[i_] = state.c1[i_];
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[i,i_];
            }
            state.pointindex = i;
            lsfitclearrequestfields(state, _params);
            state.needf = true;
            state.rstate.stage = 9;
            goto lbl_rcomm;
        lbl_9:
            state.needf = false;
            v = state.f;
            vv = state.wcur[i];
            state.reprmserror = state.reprmserror+math.sqr(v-state.tasky[i]);
            state.repwrmserror = state.repwrmserror+math.sqr(vv*(v-state.tasky[i]));
            state.repavgerror = state.repavgerror+Math.Abs(v-state.tasky[i]);
            if( (double)(state.tasky[i])!=(double)(0) )
            {
                state.repavgrelerror = state.repavgrelerror+Math.Abs(v-state.tasky[i])/Math.Abs(state.tasky[i]);
                relcnt = relcnt+1;
            }
            state.repmaxerror = Math.Max(state.repmaxerror, Math.Abs(v-state.tasky[i]));
            i = i+1;
            goto lbl_53;
        lbl_55:
            state.reprmserror = Math.Sqrt(state.reprmserror/n);
            state.repwrmserror = Math.Sqrt(state.repwrmserror/n);
            state.repavgerror = state.repavgerror/n;
            if( (double)(relcnt)!=(double)(0) )
            {
                state.repavgrelerror = state.repavgrelerror/relcnt;
            }
            
            //
            // Calculate covariance matrix
            //
            apserv.rmatrixsetlengthatleast(ref state.tmpjac, n, k, _params);
            apserv.rvectorsetlengthatleast(ref state.tmpf, n, _params);
            apserv.rvectorsetlengthatleast(ref state.tmp, k, _params);
            if( (double)(state.diffstep)<=(double)(0) )
            {
                goto lbl_56;
            }
            
            //
            // Compute Jacobian by means of numerical differentiation
            //
            lsfitclearrequestfields(state, _params);
            state.needf = true;
            i = 0;
        lbl_58:
            if( i>n-1 )
            {
                goto lbl_60;
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[i,i_];
            }
            state.pointindex = i;
            state.rstate.stage = 10;
            goto lbl_rcomm;
        lbl_10:
            state.tmpf[i] = state.f;
            j = 0;
        lbl_61:
            if( j>k-1 )
            {
                goto lbl_63;
            }
            v = state.c[j];
            lx = v-state.diffstep*state.s[j];
            state.c[j] = lx;
            if( math.isfinite(state.bndl[j]) )
            {
                state.c[j] = Math.Max(state.c[j], state.bndl[j]);
            }
            state.rstate.stage = 11;
            goto lbl_rcomm;
        lbl_11:
            lf = state.f;
            rx = v+state.diffstep*state.s[j];
            state.c[j] = rx;
            if( math.isfinite(state.bndu[j]) )
            {
                state.c[j] = Math.Min(state.c[j], state.bndu[j]);
            }
            state.rstate.stage = 12;
            goto lbl_rcomm;
        lbl_12:
            rf = state.f;
            state.c[j] = v;
            if( (double)(rx)!=(double)(lx) )
            {
                state.tmpjac[i,j] = (rf-lf)/(rx-lx);
            }
            else
            {
                state.tmpjac[i,j] = 0;
            }
            j = j+1;
            goto lbl_61;
        lbl_63:
            i = i+1;
            goto lbl_58;
        lbl_60:
            state.needf = false;
            goto lbl_57;
        lbl_56:
            
            //
            // Jacobian is calculated with user-provided analytic gradient
            //
            lsfitclearrequestfields(state, _params);
            state.needfg = true;
            i = 0;
        lbl_64:
            if( i>n-1 )
            {
                goto lbl_66;
            }
            for(i_=0; i_<=m-1;i_++)
            {
                state.x[i_] = state.taskx[i,i_];
            }
            state.pointindex = i;
            state.rstate.stage = 13;
            goto lbl_rcomm;
        lbl_13:
            state.tmpf[i] = state.f;
            for(j=0; j<=k-1; j++)
            {
                state.tmpjac[i,j] = state.g[j];
            }
            i = i+1;
            goto lbl_64;
        lbl_66:
            state.needfg = false;
        lbl_57:
            for(i=0; i<=k-1; i++)
            {
                state.tmp[i] = 0.0;
            }
            estimateerrors(state.tmpjac, state.tmpf, state.tasky, state.wcur, state.tmp, state.s, n, k, state.rep, ref state.tmpjacw, 0, _params);
        lbl_51:
            result = false;
            return result;
            
            //
            // Saving state
            //
        lbl_rcomm:
            result = true;
            state.rstate.ia[0] = n;
            state.rstate.ia[1] = m;
            state.rstate.ia[2] = k;
            state.rstate.ia[3] = i;
            state.rstate.ia[4] = j;
            state.rstate.ia[5] = j1;
            state.rstate.ia[6] = info;
            state.rstate.ra[0] = lx;
            state.rstate.ra[1] = lf;
            state.rstate.ra[2] = ld;
            state.rstate.ra[3] = rx;
            state.rstate.ra[4] = rf;
            state.rstate.ra[5] = rd;
            state.rstate.ra[6] = v;
            state.rstate.ra[7] = vv;
            state.rstate.ra[8] = relcnt;
            return result;
        }


        /*************************************************************************
        Nonlinear least squares fitting results.

        Called after return from LSFitFit().

        INPUT PARAMETERS:
            State   -   algorithm state

        OUTPUT PARAMETERS:
            Info    -   completion code:
                            * -8    optimizer   detected  NAN/INF  in  the  target
                                    function and/or gradient
                            * -7    gradient verification failed.
                                    See LSFitSetGradientCheck() for more information.
                            * -3    inconsistent constraints
                            *  2    relative step is no more than EpsX.
                            *  5    MaxIts steps was taken
                            *  7    stopping conditions are too stringent,
                                    further improvement is impossible
            C       -   array[0..K-1], solution
            Rep     -   optimization report. On success following fields are set:
                        * R2                non-adjusted coefficient of determination
                                            (non-weighted)
                        * RMSError          rms error on the (X,Y).
                        * AvgError          average error on the (X,Y).
                        * AvgRelError       average relative error on the non-zero Y
                        * MaxError          maximum error
                                            NON-WEIGHTED ERRORS ARE CALCULATED
                        * WRMSError         weighted rms error on the (X,Y).
                        
        ERRORS IN PARAMETERS                
                        
        This  solver  also  calculates different kinds of errors in parameters and
        fills corresponding fields of report:
        * Rep.CovPar        covariance matrix for parameters, array[K,K].
        * Rep.ErrPar        errors in parameters, array[K],
                            errpar = sqrt(diag(CovPar))
        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                            best-fit curve from "ideal" best-fit curve built  with
                            infinite number of samples, array[N].
                            errcurve = sqrt(diag(J*CovPar*J')),
                            where J is Jacobian matrix.
        * Rep.Noise         vector of per-point estimates of noise, array[N]

        IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
                    account boundary/linear constraints! Presence  of  constraints
                    changes distribution of errors, but there is no  easy  way  to
                    account for constraints when you calculate covariance matrix.
                    
        NOTE:       noise in the data is estimated as follows:
                    * for fitting without user-supplied  weights  all  points  are
                      assumed to have same level of noise, which is estimated from
                      the data
                    * for fitting with user-supplied weights we assume that  noise
                      level in I-th point is inversely proportional to Ith weight.
                      Coefficient of proportionality is estimated from the data.
                    
        NOTE:       we apply small amount of regularization when we invert squared
                    Jacobian and calculate covariance matrix. It  guarantees  that
                    algorithm won't divide by zero  during  inversion,  but  skews
                    error estimates a bit (fractional error is about 10^-9).
                    
                    However, we believe that this difference is insignificant  for
                    all practical purposes except for the situation when you  want
                    to compare ALGLIB results with "reference"  implementation  up
                    to the last significant digit.
                    
        NOTE:       covariance matrix is estimated using  correction  for  degrees
                    of freedom (covariances are divided by N-M instead of dividing
                    by N).

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitresults(lsfitstate state,
            ref int info,
            ref double[] c,
            lsfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int i_ = 0;

            info = 0;
            c = new double[0];

            clearreport(rep, _params);
            info = state.repterminationtype;
            rep.varidx = state.repvaridx;
            if( info>0 )
            {
                c = new double[state.k];
                for(i_=0; i_<=state.k-1;i_++)
                {
                    c[i_] = state.c1[i_];
                }
                rep.rmserror = state.reprmserror;
                rep.wrmserror = state.repwrmserror;
                rep.avgerror = state.repavgerror;
                rep.avgrelerror = state.repavgrelerror;
                rep.maxerror = state.repmaxerror;
                rep.iterationscount = state.repiterationscount;
                rep.covpar = new double[state.k, state.k];
                rep.errpar = new double[state.k];
                rep.errcurve = new double[state.npoints];
                rep.noise = new double[state.npoints];
                rep.r2 = state.rep.r2;
                for(i=0; i<=state.k-1; i++)
                {
                    for(j=0; j<=state.k-1; j++)
                    {
                        rep.covpar[i,j] = state.rep.covpar[i,j];
                    }
                    rep.errpar[i] = state.rep.errpar[i];
                }
                for(i=0; i<=state.npoints-1; i++)
                {
                    rep.errcurve[i] = state.rep.errcurve[i];
                    rep.noise[i] = state.rep.noise[i];
                }
            }
        }


        /*************************************************************************
        This  subroutine  turns  on  verification  of  the  user-supplied analytic
        gradient:
        * user calls this subroutine before fitting begins
        * LSFitFit() is called
        * prior to actual fitting, for  each  point  in  data  set  X_i  and  each
          component  of  parameters  being  fited C_j algorithm performs following
          steps:
          * two trial steps are made to C_j-TestStep*S[j] and C_j+TestStep*S[j],
            where C_j is j-th parameter and S[j] is a scale of j-th parameter
          * if needed, steps are bounded with respect to constraints on C[]
          * F(X_i|C) is evaluated at these trial points
          * we perform one more evaluation in the middle point of the interval
          * we  build  cubic  model using function values and derivatives at trial
            points and we compare its prediction with actual value in  the  middle
            point
          * in case difference between prediction and actual value is higher  than
            some predetermined threshold, algorithm stops with completion code -7;
            Rep.VarIdx is set to index of the parameter with incorrect derivative.
        * after verification is over, algorithm proceeds to the actual optimization.

        NOTE 1: verification needs N*K (points count * parameters count)  gradient
                evaluations. It is very costly and you should use it only for  low
                dimensional  problems,  when  you  want  to  be  sure  that you've
                correctly calculated analytic derivatives. You should not  use  it
                in the production code  (unless  you  want  to  check  derivatives
                provided by some third party).

        NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
                (so large that function behaviour is significantly non-cubic) will
                lead to false alarms. You may use  different  step  for  different
                parameters by means of setting scale with LSFitSetScale().

        NOTE 3: this function may lead to false positives. In case it reports that
                I-th  derivative was calculated incorrectly, you may decrease test
                step  and  try  one  more  time  - maybe your function changes too
                sharply  and  your  step  is  too  large for such rapidly chanding
                function.

        NOTE 4: this function works only for optimizers created with LSFitCreateWFG()
                or LSFitCreateFG() constructors.
                
        INPUT PARAMETERS:
            State       -   structure used to store algorithm state
            TestStep    -   verification step:
                            * TestStep=0 turns verification off
                            * TestStep>0 activates verification

          -- ALGLIB --
             Copyright 15.06.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void lsfitsetgradientcheck(lsfitstate state,
            double teststep,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(teststep), "LSFitSetGradientCheck: TestStep contains NaN or Infinite");
            alglib.ap.assert((double)(teststep)>=(double)(0), "LSFitSetGradientCheck: invalid argument TestStep(TestStep<0)");
            state.teststep = teststep;
        }


        /*************************************************************************
        This function analyzes section of curve for processing by RDP algorithm:
        given set of points X,Y with indexes [I0,I1] it returns point with
        worst deviation from linear model (non-parametric version which sees curve
        as Y(x)).

        Input parameters:
            X, Y        -   SORTED arrays.
            I0,I1       -   interval (boundaries included) to process
            Eps         -   desired precision
            
        OUTPUT PARAMETERS:
            WorstIdx    -   index of worst point
            WorstError  -   error at worst point
            
        NOTE: this function guarantees that it returns exactly zero for a section
              with less than 3 points.

          -- ALGLIB PROJECT --
             Copyright 02.10.2014 by Bochkanov Sergey
        *************************************************************************/
        private static void rdpanalyzesection(double[] x,
            double[] y,
            int i0,
            int i1,
            ref int worstidx,
            ref double worsterror,
            alglib.xparams _params)
        {
            int i = 0;
            double xleft = 0;
            double xright = 0;
            double vx = 0;
            double ve = 0;
            double a = 0;
            double b = 0;

            worstidx = 0;
            worsterror = 0;

            xleft = x[i0];
            xright = x[i1];
            if( i1-i0+1<3 || (double)(xright)==(double)(xleft) )
            {
                worstidx = i0;
                worsterror = 0.0;
                return;
            }
            a = (y[i1]-y[i0])/(xright-xleft);
            b = (y[i0]*xright-y[i1]*xleft)/(xright-xleft);
            worstidx = -1;
            worsterror = 0;
            for(i=i0+1; i<=i1-1; i++)
            {
                vx = x[i];
                ve = Math.Abs(a*vx+b-y[i]);
                if( ((double)(vx)>(double)(xleft) && (double)(vx)<(double)(xright)) && (double)(ve)>(double)(worsterror) )
                {
                    worsterror = ve;
                    worstidx = i;
                }
            }
        }


        /*************************************************************************
        Recursive splitting of interval [I0,I1] (right boundary included) with RDP
        algorithm (non-parametric version which sees curve as Y(x)).

        Input parameters:
            X, Y        -   SORTED arrays.
            I0,I1       -   interval (boundaries included) to process
            Eps         -   desired precision
            XOut,YOut   -   preallocated output arrays large enough to store result;
                            XOut[0..1], YOut[0..1] contain first and last points of
                            curve
            NOut        -   must contain 2 on input
            
        OUTPUT PARAMETERS:
            XOut, YOut  -   curve generated by RDP algorithm, UNSORTED
            NOut        -   number of points in curve

          -- ALGLIB PROJECT --
             Copyright 02.10.2014 by Bochkanov Sergey
        *************************************************************************/
        private static void rdprecursive(double[] x,
            double[] y,
            int i0,
            int i1,
            double eps,
            double[] xout,
            double[] yout,
            ref int nout,
            alglib.xparams _params)
        {
            int worstidx = 0;
            double worsterror = 0;

            alglib.ap.assert((double)(eps)>(double)(0), "RDPRecursive: internal error, Eps<0");
            rdpanalyzesection(x, y, i0, i1, ref worstidx, ref worsterror, _params);
            if( (double)(worsterror)<=(double)(eps) )
            {
                return;
            }
            xout[nout] = x[worstidx];
            yout[nout] = y[worstidx];
            nout = nout+1;
            if( worstidx-i0<i1-worstidx )
            {
                rdprecursive(x, y, i0, worstidx, eps, xout, yout, ref nout, _params);
                rdprecursive(x, y, worstidx, i1, eps, xout, yout, ref nout, _params);
            }
            else
            {
                rdprecursive(x, y, worstidx, i1, eps, xout, yout, ref nout, _params);
                rdprecursive(x, y, i0, worstidx, eps, xout, yout, ref nout, _params);
            }
        }


        /*************************************************************************
        Internal 4PL/5PL fitting function.

        Accepts X, Y and already initialized and prepared MinLMState structure.
        On input P1 contains initial guess, on output it contains solution.  FLast
        stores function value at P1.
        *************************************************************************/
        private static void logisticfitinternal(double[] x,
            double[] y,
            int n,
            bool is4pl,
            double lambdav,
            minlm.minlmstate state,
            minlm.minlmreport replm,
            ref double[] p1,
            ref double flast,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double ta = 0;
            double tb = 0;
            double tc = 0;
            double td = 0;
            double tg = 0;
            double vp0 = 0;
            double vp1 = 0;

            flast = 0;

            minlm.minlmrestartfrom(state, p1, _params);
            while( minlm.minlmiteration(state, _params) )
            {
                ta = state.x[0];
                tb = state.x[1];
                tc = state.x[2];
                td = state.x[3];
                tg = state.x[4];
                if( state.xupdated )
                {
                    
                    //
                    // Save best function value obtained so far.
                    //
                    flast = state.f;
                    continue;
                }
                if( state.needfi || state.needfij )
                {
                    
                    //
                    // Function vector and Jacobian
                    //
                    for(i=0; i<=n-1; i++)
                    {
                        alglib.ap.assert((double)(x[i])>=(double)(0), "LogisticFitInternal: integrity error");
                        
                        //
                        // Handle zero X
                        //
                        if( (double)(x[i])==(double)(0) )
                        {
                            if( (double)(tb)>=(double)(0) )
                            {
                                
                                //
                                // Positive or zero TB, limit X^TB subject to X->+0 is equal to zero.
                                //
                                state.fi[i] = ta-y[i];
                                if( state.needfij )
                                {
                                    state.j[i,0] = 1;
                                    state.j[i,1] = 0;
                                    state.j[i,2] = 0;
                                    state.j[i,3] = 0;
                                    state.j[i,4] = 0;
                                }
                            }
                            else
                            {
                                
                                //
                                // Negative TB, limit X^TB subject to X->+0 is equal to +INF.
                                //
                                state.fi[i] = td-y[i];
                                if( state.needfij )
                                {
                                    state.j[i,0] = 0;
                                    state.j[i,1] = 0;
                                    state.j[i,2] = 0;
                                    state.j[i,3] = 1;
                                    state.j[i,4] = 0;
                                }
                            }
                            continue;
                        }
                        
                        //
                        // Positive X.
                        // Prepare VP0/VP1, it may become infinite or nearly overflow in some rare cases,
                        // handle these cases
                        //
                        vp0 = Math.Pow(x[i]/tc, tb);
                        if( is4pl )
                        {
                            vp1 = 1+vp0;
                        }
                        else
                        {
                            vp1 = Math.Pow(1+vp0, tg);
                        }
                        if( (!math.isfinite(vp1) || (double)(vp0)>(double)(1.0E50)) || (double)(vp1)>(double)(1.0E50) )
                        {
                            
                            //
                            // VP0/VP1 are not finite, assume that it is +INF or -INF
                            //
                            state.fi[i] = td-y[i];
                            if( state.needfij )
                            {
                                state.j[i,0] = 0;
                                state.j[i,1] = 0;
                                state.j[i,2] = 0;
                                state.j[i,3] = 1;
                                state.j[i,4] = 0;
                            }
                            continue;
                        }
                        
                        //
                        // VP0/VP1 are finite, normal processing
                        //
                        if( is4pl )
                        {
                            state.fi[i] = td+(ta-td)/vp1-y[i];
                            if( state.needfij )
                            {
                                state.j[i,0] = 1/vp1;
                                state.j[i,1] = -((ta-td)*vp0*Math.Log(x[i]/tc)/math.sqr(vp1));
                                state.j[i,2] = (ta-td)*(tb/tc)*vp0/math.sqr(vp1);
                                state.j[i,3] = 1-1/vp1;
                                state.j[i,4] = 0;
                            }
                        }
                        else
                        {
                            state.fi[i] = td+(ta-td)/vp1-y[i];
                            if( state.needfij )
                            {
                                state.j[i,0] = 1/vp1;
                                state.j[i,1] = (ta-td)*-tg*Math.Pow(1+vp0, -tg-1)*vp0*Math.Log(x[i]/tc);
                                state.j[i,2] = (ta-td)*-tg*Math.Pow(1+vp0, -tg-1)*vp0*-(tb/tc);
                                state.j[i,3] = 1-1/vp1;
                                state.j[i,4] = -((ta-td)/vp1*Math.Log(1+vp0));
                            }
                        }
                    }
                    
                    //
                    // Add regularizer
                    //
                    for(i=0; i<=4; i++)
                    {
                        state.fi[n+i] = lambdav*state.x[i];
                        if( state.needfij )
                        {
                            for(j=0; j<=4; j++)
                            {
                                state.j[n+i,j] = 0.0;
                            }
                            state.j[n+i,i] = lambdav;
                        }
                    }
                    
                    //
                    // Done
                    //
                    continue;
                }
                alglib.ap.assert(false, "LogisticFitX: internal error");
            }
            minlm.minlmresultsbuf(state, ref p1, replm, _params);
            alglib.ap.assert(replm.terminationtype>0, "LogisticFitX: internal error");
        }


        /*************************************************************************
        Calculate errors for 4PL/5PL fit.
        Leaves other fields of Rep unchanged, so caller should properly initialize
        it with ClearRep() call.

          -- ALGLIB PROJECT --
             Copyright 28.04.2017 by Bochkanov Sergey
        *************************************************************************/
        private static void logisticfit45errors(double[] x,
            double[] y,
            int n,
            double a,
            double b,
            double c,
            double d,
            double g,
            lsfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            int k = 0;
            double v = 0;
            double rss = 0;
            double tss = 0;
            double meany = 0;

            
            //
            // Calculate errors
            //
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.avgrelerror = 0;
            rep.maxerror = 0;
            k = 0;
            rss = 0.0;
            tss = 0.0;
            meany = 0.0;
            for(i=0; i<=n-1; i++)
            {
                meany = meany+y[i];
            }
            meany = meany/n;
            for(i=0; i<=n-1; i++)
            {
                
                //
                // Calculate residual from regression
                //
                if( (double)(x[i])>(double)(0) )
                {
                    v = d+(a-d)/Math.Pow(1.0+Math.Pow(x[i]/c, b), g)-y[i];
                }
                else
                {
                    if( (double)(b)>=(double)(0) )
                    {
                        v = a-y[i];
                    }
                    else
                    {
                        v = d-y[i];
                    }
                }
                
                //
                // Update RSS (residual sum of squares) and TSS (total sum of squares)
                // which are used to calculate coefficient of determination.
                //
                // NOTE: we use formula R2 = 1-RSS/TSS because it has nice property of
                //       being equal to 0.0 if and only if model perfectly fits data.
                //
                //       When we fit nonlinear models, there are exist multiple ways of
                //       determining R2, each of them giving different results. Formula
                //       above is the most intuitive one.
                //
                rss = rss+v*v;
                tss = tss+math.sqr(y[i]-meany);
                
                //
                // Update errors
                //
                rep.rmserror = rep.rmserror+math.sqr(v);
                rep.avgerror = rep.avgerror+Math.Abs(v);
                if( (double)(y[i])!=(double)(0) )
                {
                    rep.avgrelerror = rep.avgrelerror+Math.Abs(v/y[i]);
                    k = k+1;
                }
                rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v));
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/n);
            rep.avgerror = rep.avgerror/n;
            if( k>0 )
            {
                rep.avgrelerror = rep.avgrelerror/k;
            }
            rep.r2 = 1.0-rss/tss;
        }


        /*************************************************************************
        Internal spline fitting subroutine

          -- ALGLIB PROJECT --
             Copyright 08.09.2009 by Bochkanov Sergey
        *************************************************************************/
        private static void spline1dfitinternal(int st,
            double[] x,
            double[] y,
            double[] w,
            int n,
            double[] xc,
            double[] yc,
            int[] dc,
            int k,
            int m,
            ref int info,
            spline1d.spline1dinterpolant s,
            spline1d.spline1dfitreport rep,
            alglib.xparams _params)
        {
            double[,] fmatrix = new double[0,0];
            double[,] cmatrix = new double[0,0];
            double[] y2 = new double[0];
            double[] w2 = new double[0];
            double[] sx = new double[0];
            double[] sy = new double[0];
            double[] sd = new double[0];
            double[] tmp = new double[0];
            double[] xoriginal = new double[0];
            double[] yoriginal = new double[0];
            lsfitreport lrep = new lsfitreport();
            double v0 = 0;
            double v1 = 0;
            double v2 = 0;
            double mx = 0;
            spline1d.spline1dinterpolant s2 = new spline1d.spline1dinterpolant();
            int i = 0;
            int j = 0;
            int relcnt = 0;
            double xa = 0;
            double xb = 0;
            double sa = 0;
            double sb = 0;
            double bl = 0;
            double br = 0;
            double decay = 0;
            int i_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            w = (double[])w.Clone();
            xc = (double[])xc.Clone();
            yc = (double[])yc.Clone();
            info = 0;

            alglib.ap.assert(st==0 || st==1, "Spline1DFit: internal error!");
            if( st==0 && m<4 )
            {
                info = -1;
                return;
            }
            if( st==1 && m<4 )
            {
                info = -1;
                return;
            }
            if( (n<1 || k<0) || k>=m )
            {
                info = -1;
                return;
            }
            for(i=0; i<=k-1; i++)
            {
                info = 0;
                if( dc[i]<0 )
                {
                    info = -1;
                }
                if( dc[i]>1 )
                {
                    info = -1;
                }
                if( info<0 )
                {
                    return;
                }
            }
            if( st==1 && m%2!=0 )
            {
                
                //
                // Hermite fitter must have even number of basis functions
                //
                info = -2;
                return;
            }
            
            //
            // weight decay for correct handling of task which becomes
            // degenerate after constraints are applied
            //
            decay = 10000*math.machineepsilon;
            
            //
            // Scale X, Y, XC, YC
            //
            intfitserv.lsfitscalexy(ref x, ref y, ref w, n, ref xc, ref yc, dc, k, ref xa, ref xb, ref sa, ref sb, ref xoriginal, ref yoriginal, _params);
            
            //
            // allocate space, initialize:
            // * SX     -   grid for basis functions
            // * SY     -   values of basis functions at grid points
            // * FMatrix-   values of basis functions at X[]
            // * CMatrix-   values (derivatives) of basis functions at XC[]
            //
            y2 = new double[n+m];
            w2 = new double[n+m];
            fmatrix = new double[n+m, m];
            if( k>0 )
            {
                cmatrix = new double[k, m+1];
            }
            if( st==0 )
            {
                
                //
                // allocate space for cubic spline
                //
                sx = new double[m-2];
                sy = new double[m-2];
                for(j=0; j<=m-2-1; j++)
                {
                    sx[j] = (double)(2*j)/(double)(m-2-1)-1;
                }
            }
            if( st==1 )
            {
                
                //
                // allocate space for Hermite spline
                //
                sx = new double[m/2];
                sy = new double[m/2];
                sd = new double[m/2];
                for(j=0; j<=m/2-1; j++)
                {
                    sx[j] = (double)(2*j)/(double)(m/2-1)-1;
                }
            }
            
            //
            // Prepare design and constraints matrices:
            // * fill constraints matrix
            // * fill first N rows of design matrix with values
            // * fill next M rows of design matrix with regularizing term
            // * append M zeros to Y
            // * append M elements, mean(abs(W)) each, to W
            //
            for(j=0; j<=m-1; j++)
            {
                
                //
                // prepare Jth basis function
                //
                if( st==0 )
                {
                    
                    //
                    // cubic spline basis
                    //
                    for(i=0; i<=m-2-1; i++)
                    {
                        sy[i] = 0;
                    }
                    bl = 0;
                    br = 0;
                    if( j<m-2 )
                    {
                        sy[j] = 1;
                    }
                    if( j==m-2 )
                    {
                        bl = 1;
                    }
                    if( j==m-1 )
                    {
                        br = 1;
                    }
                    spline1d.spline1dbuildcubic(sx, sy, m-2, 1, bl, 1, br, s2, _params);
                }
                if( st==1 )
                {
                    
                    //
                    // Hermite basis
                    //
                    for(i=0; i<=m/2-1; i++)
                    {
                        sy[i] = 0;
                        sd[i] = 0;
                    }
                    if( j%2==0 )
                    {
                        sy[j/2] = 1;
                    }
                    else
                    {
                        sd[j/2] = 1;
                    }
                    spline1d.spline1dbuildhermite(sx, sy, sd, m/2, s2, _params);
                }
                
                //
                // values at X[], XC[]
                //
                for(i=0; i<=n-1; i++)
                {
                    fmatrix[i,j] = spline1d.spline1dcalc(s2, x[i], _params);
                }
                for(i=0; i<=k-1; i++)
                {
                    alglib.ap.assert(dc[i]>=0 && dc[i]<=2, "Spline1DFit: internal error!");
                    spline1d.spline1ddiff(s2, xc[i], ref v0, ref v1, ref v2, _params);
                    if( dc[i]==0 )
                    {
                        cmatrix[i,j] = v0;
                    }
                    if( dc[i]==1 )
                    {
                        cmatrix[i,j] = v1;
                    }
                    if( dc[i]==2 )
                    {
                        cmatrix[i,j] = v2;
                    }
                }
            }
            for(i=0; i<=k-1; i++)
            {
                cmatrix[i,m] = yc[i];
            }
            for(i=0; i<=m-1; i++)
            {
                for(j=0; j<=m-1; j++)
                {
                    if( i==j )
                    {
                        fmatrix[n+i,j] = decay;
                    }
                    else
                    {
                        fmatrix[n+i,j] = 0;
                    }
                }
            }
            y2 = new double[n+m];
            w2 = new double[n+m];
            for(i_=0; i_<=n-1;i_++)
            {
                y2[i_] = y[i_];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                w2[i_] = w[i_];
            }
            mx = 0;
            for(i=0; i<=n-1; i++)
            {
                mx = mx+Math.Abs(w[i]);
            }
            mx = mx/n;
            for(i=0; i<=m-1; i++)
            {
                y2[n+i] = 0;
                w2[n+i] = mx;
            }
            
            //
            // Solve constrained task
            //
            if( k>0 )
            {
                
                //
                // solve using regularization
                //
                lsfitlinearwc(y2, w2, fmatrix, cmatrix, n+m, m, k, ref info, ref tmp, lrep, _params);
            }
            else
            {
                
                //
                // no constraints, no regularization needed
                //
                lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, ref info, ref tmp, lrep, _params);
            }
            if( info<0 )
            {
                return;
            }
            
            //
            // Generate spline and scale it
            //
            if( st==0 )
            {
                
                //
                // cubic spline basis
                //
                for(i_=0; i_<=m-2-1;i_++)
                {
                    sy[i_] = tmp[i_];
                }
                spline1d.spline1dbuildcubic(sx, sy, m-2, 1, tmp[m-2], 1, tmp[m-1], s, _params);
            }
            if( st==1 )
            {
                
                //
                // Hermite basis
                //
                for(i=0; i<=m/2-1; i++)
                {
                    sy[i] = tmp[2*i];
                    sd[i] = tmp[2*i+1];
                }
                spline1d.spline1dbuildhermite(sx, sy, sd, m/2, s, _params);
            }
            spline1d.spline1dlintransx(s, 2/(xb-xa), -((xa+xb)/(xb-xa)), _params);
            spline1d.spline1dlintransy(s, sb-sa, sa, _params);
            
            //
            // Scale absolute errors obtained from LSFitLinearW.
            // Relative error should be calculated separately
            // (because of shifting/scaling of the task)
            //
            rep.taskrcond = lrep.taskrcond;
            rep.rmserror = lrep.rmserror*(sb-sa);
            rep.avgerror = lrep.avgerror*(sb-sa);
            rep.maxerror = lrep.maxerror*(sb-sa);
            rep.avgrelerror = 0;
            relcnt = 0;
            for(i=0; i<=n-1; i++)
            {
                if( (double)(yoriginal[i])!=(double)(0) )
                {
                    rep.avgrelerror = rep.avgrelerror+Math.Abs(spline1d.spline1dcalc(s, xoriginal[i], _params)-yoriginal[i])/Math.Abs(yoriginal[i]);
                    relcnt = relcnt+1;
                }
            }
            if( relcnt!=0 )
            {
                rep.avgrelerror = rep.avgrelerror/relcnt;
            }
        }


        /*************************************************************************
        Internal fitting subroutine
        *************************************************************************/
        private static void lsfitlinearinternal(double[] y,
            double[] w,
            double[,] fmatrix,
            int n,
            int m,
            ref int info,
            ref double[] c,
            lsfitreport rep,
            alglib.xparams _params)
        {
            double threshold = 0;
            double[,] ft = new double[0,0];
            double[,] q = new double[0,0];
            double[,] l = new double[0,0];
            double[,] r = new double[0,0];
            double[] b = new double[0];
            double[] wmod = new double[0];
            double[] tau = new double[0];
            double[] nzeros = new double[0];
            double[] s = new double[0];
            int i = 0;
            int j = 0;
            double v = 0;
            double[] sv = new double[0];
            double[,] u = new double[0,0];
            double[,] vt = new double[0,0];
            double[] tmp = new double[0];
            double[] utb = new double[0];
            double[] sutb = new double[0];
            int relcnt = 0;
            int i_ = 0;

            info = 0;
            c = new double[0];

            clearreport(rep, _params);
            if( n<1 || m<1 )
            {
                info = -1;
                return;
            }
            info = 1;
            threshold = Math.Sqrt(math.machineepsilon);
            
            //
            // Degenerate case, needs special handling
            //
            if( n<m )
            {
                
                //
                // Create design matrix.
                //
                ft = new double[n, m];
                b = new double[n];
                wmod = new double[n];
                for(j=0; j<=n-1; j++)
                {
                    v = w[j];
                    for(i_=0; i_<=m-1;i_++)
                    {
                        ft[j,i_] = v*fmatrix[j,i_];
                    }
                    b[j] = w[j]*y[j];
                    wmod[j] = 1;
                }
                
                //
                // LQ decomposition and reduction to M=N
                //
                c = new double[m];
                for(i=0; i<=m-1; i++)
                {
                    c[i] = 0;
                }
                rep.taskrcond = 0;
                ortfac.rmatrixlq(ref ft, n, m, ref tau, _params);
                ortfac.rmatrixlqunpackq(ft, n, m, tau, n, ref q, _params);
                ortfac.rmatrixlqunpackl(ft, n, m, ref l, _params);
                lsfitlinearinternal(b, wmod, l, n, n, ref info, ref tmp, rep, _params);
                if( info<=0 )
                {
                    return;
                }
                for(i=0; i<=n-1; i++)
                {
                    v = tmp[i];
                    for(i_=0; i_<=m-1;i_++)
                    {
                        c[i_] = c[i_] + v*q[i,i_];
                    }
                }
                return;
            }
            
            //
            // N>=M. Generate design matrix and reduce to N=M using
            // QR decomposition.
            //
            ft = new double[n, m];
            b = new double[n];
            for(j=0; j<=n-1; j++)
            {
                v = w[j];
                for(i_=0; i_<=m-1;i_++)
                {
                    ft[j,i_] = v*fmatrix[j,i_];
                }
                b[j] = w[j]*y[j];
            }
            ortfac.rmatrixqr(ref ft, n, m, ref tau, _params);
            ortfac.rmatrixqrunpackq(ft, n, m, tau, m, ref q, _params);
            ortfac.rmatrixqrunpackr(ft, n, m, ref r, _params);
            tmp = new double[m];
            for(i=0; i<=m-1; i++)
            {
                tmp[i] = 0;
            }
            for(i=0; i<=n-1; i++)
            {
                v = b[i];
                for(i_=0; i_<=m-1;i_++)
                {
                    tmp[i_] = tmp[i_] + v*q[i,i_];
                }
            }
            b = new double[m];
            for(i_=0; i_<=m-1;i_++)
            {
                b[i_] = tmp[i_];
            }
            
            //
            // R contains reduced MxM design upper triangular matrix,
            // B contains reduced Mx1 right part.
            //
            // Determine system condition number and decide
            // should we use triangular solver (faster) or
            // SVD-based solver (more stable).
            //
            // We can use LU-based RCond estimator for this task.
            //
            rep.taskrcond = rcond.rmatrixlurcondinf(r, m, _params);
            if( (double)(rep.taskrcond)>(double)(threshold) )
            {
                
                //
                // use QR-based solver
                //
                c = new double[m];
                c[m-1] = b[m-1]/r[m-1,m-1];
                for(i=m-2; i>=0; i--)
                {
                    v = 0.0;
                    for(i_=i+1; i_<=m-1;i_++)
                    {
                        v += r[i,i_]*c[i_];
                    }
                    c[i] = (b[i]-v)/r[i,i];
                }
            }
            else
            {
                
                //
                // use SVD-based solver
                //
                if( !svd.rmatrixsvd(r, m, m, 1, 1, 2, ref sv, ref u, ref vt, _params) )
                {
                    info = -4;
                    return;
                }
                utb = new double[m];
                sutb = new double[m];
                for(i=0; i<=m-1; i++)
                {
                    utb[i] = 0;
                }
                for(i=0; i<=m-1; i++)
                {
                    v = b[i];
                    for(i_=0; i_<=m-1;i_++)
                    {
                        utb[i_] = utb[i_] + v*u[i,i_];
                    }
                }
                if( (double)(sv[0])>(double)(0) )
                {
                    rep.taskrcond = sv[m-1]/sv[0];
                    for(i=0; i<=m-1; i++)
                    {
                        if( (double)(sv[i])>(double)(threshold*sv[0]) )
                        {
                            sutb[i] = utb[i]/sv[i];
                        }
                        else
                        {
                            sutb[i] = 0;
                        }
                    }
                }
                else
                {
                    rep.taskrcond = 0;
                    for(i=0; i<=m-1; i++)
                    {
                        sutb[i] = 0;
                    }
                }
                c = new double[m];
                for(i=0; i<=m-1; i++)
                {
                    c[i] = 0;
                }
                for(i=0; i<=m-1; i++)
                {
                    v = sutb[i];
                    for(i_=0; i_<=m-1;i_++)
                    {
                        c[i_] = c[i_] + v*vt[i,i_];
                    }
                }
            }
            
            //
            // calculate errors
            //
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.avgrelerror = 0;
            rep.maxerror = 0;
            relcnt = 0;
            for(i=0; i<=n-1; i++)
            {
                v = 0.0;
                for(i_=0; i_<=m-1;i_++)
                {
                    v += fmatrix[i,i_]*c[i_];
                }
                rep.rmserror = rep.rmserror+math.sqr(v-y[i]);
                rep.avgerror = rep.avgerror+Math.Abs(v-y[i]);
                if( (double)(y[i])!=(double)(0) )
                {
                    rep.avgrelerror = rep.avgrelerror+Math.Abs(v-y[i])/Math.Abs(y[i]);
                    relcnt = relcnt+1;
                }
                rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v-y[i]));
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/n);
            rep.avgerror = rep.avgerror/n;
            if( relcnt!=0 )
            {
                rep.avgrelerror = rep.avgrelerror/relcnt;
            }
            nzeros = new double[n];
            s = new double[m];
            for(i=0; i<=m-1; i++)
            {
                s[i] = 0;
            }
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=m-1; j++)
                {
                    s[j] = s[j]+math.sqr(fmatrix[i,j]);
                }
                nzeros[i] = 0;
            }
            for(i=0; i<=m-1; i++)
            {
                if( (double)(s[i])!=(double)(0) )
                {
                    s[i] = Math.Sqrt(1/s[i]);
                }
                else
                {
                    s[i] = 1;
                }
            }
            estimateerrors(fmatrix, nzeros, y, w, c, s, n, m, rep, ref r, 1, _params);
        }


        /*************************************************************************
        Internal subroutine
        *************************************************************************/
        private static void lsfitclearrequestfields(lsfitstate state,
            alglib.xparams _params)
        {
            state.needf = false;
            state.needfg = false;
            state.needfgh = false;
            state.xupdated = false;
        }


        /*************************************************************************
        Internal subroutine, calculates barycentric basis functions.
        Used for efficient simultaneous calculation of N basis functions.

          -- ALGLIB --
             Copyright 17.08.2009 by Bochkanov Sergey
        *************************************************************************/
        private static void barycentriccalcbasis(ratint.barycentricinterpolant b,
            double t,
            ref double[] y,
            alglib.xparams _params)
        {
            double s2 = 0;
            double s = 0;
            double v = 0;
            int i = 0;
            int j = 0;
            int i_ = 0;

            
            //
            // special case: N=1
            //
            if( b.n==1 )
            {
                y[0] = 1;
                return;
            }
            
            //
            // Here we assume that task is normalized, i.e.:
            // 1. abs(Y[i])<=1
            // 2. abs(W[i])<=1
            // 3. X[] is ordered
            //
            // First, we decide: should we use "safe" formula (guarded
            // against overflow) or fast one?
            //
            s = Math.Abs(t-b.x[0]);
            for(i=0; i<=b.n-1; i++)
            {
                v = b.x[i];
                if( (double)(v)==(double)(t) )
                {
                    for(j=0; j<=b.n-1; j++)
                    {
                        y[j] = 0;
                    }
                    y[i] = 1;
                    return;
                }
                v = Math.Abs(t-v);
                if( (double)(v)<(double)(s) )
                {
                    s = v;
                }
            }
            s2 = 0;
            for(i=0; i<=b.n-1; i++)
            {
                v = s/(t-b.x[i]);
                v = v*b.w[i];
                y[i] = v;
                s2 = s2+v;
            }
            v = 1/s2;
            for(i_=0; i_<=b.n-1;i_++)
            {
                y[i_] = v*y[i_];
            }
        }


        /*************************************************************************
        This is internal function for Chebyshev fitting.

        It assumes that input data are normalized:
        * X/XC belong to [-1,+1],
        * mean(Y)=0, stddev(Y)=1.

        It does not checks inputs for errors.

        This function is used to fit general (shifted) Chebyshev models, power
        basis models or barycentric models.

        INPUT PARAMETERS:
            X   -   points, array[0..N-1].
            Y   -   function values, array[0..N-1].
            W   -   weights, array[0..N-1]
            N   -   number of points, N>0.
            XC  -   points where polynomial values/derivatives are constrained,
                    array[0..K-1].
            YC  -   values of constraints, array[0..K-1]
            DC  -   array[0..K-1], types of constraints:
                    * DC[i]=0   means that P(XC[i])=YC[i]
                    * DC[i]=1   means that P'(XC[i])=YC[i]
            K   -   number of constraints, 0<=K<M.
                    K=0 means no constraints (XC/YC/DC are not used in such cases)
            M   -   number of basis functions (= polynomial_degree + 1), M>=1

        OUTPUT PARAMETERS:
            Info-   same format as in LSFitLinearW() subroutine:
                    * Info>0    task is solved
                    * Info<=0   an error occured:
                                -4 means inconvergence of internal SVD
                                -3 means inconsistent constraints
            C   -   interpolant in Chebyshev form; [-1,+1] is used as base interval
            Rep -   report, same format as in LSFitLinearW() subroutine.
                    Following fields are set:
                    * RMSError      rms error on the (X,Y).
                    * AvgError      average error on the (X,Y).
                    * AvgRelError   average relative error on the non-zero Y
                    * MaxError      maximum error
                                    NON-WEIGHTED ERRORS ARE CALCULATED

        IMPORTANT:
            this subroitine doesn't calculate task's condition number for K<>0.

          -- ALGLIB PROJECT --
             Copyright 10.12.2009 by Bochkanov Sergey
        *************************************************************************/
        private static void internalchebyshevfit(double[] x,
            double[] y,
            double[] w,
            int n,
            double[] xc,
            double[] yc,
            int[] dc,
            int k,
            int m,
            ref int info,
            ref double[] c,
            lsfitreport rep,
            alglib.xparams _params)
        {
            double[] y2 = new double[0];
            double[] w2 = new double[0];
            double[] tmp = new double[0];
            double[] tmp2 = new double[0];
            double[] tmpdiff = new double[0];
            double[] bx = new double[0];
            double[] by = new double[0];
            double[] bw = new double[0];
            double[,] fmatrix = new double[0,0];
            double[,] cmatrix = new double[0,0];
            int i = 0;
            int j = 0;
            double mx = 0;
            double decay = 0;
            int i_ = 0;

            xc = (double[])xc.Clone();
            yc = (double[])yc.Clone();
            info = 0;
            c = new double[0];

            clearreport(rep, _params);
            
            //
            // weight decay for correct handling of task which becomes
            // degenerate after constraints are applied
            //
            decay = 10000*math.machineepsilon;
            
            //
            // allocate space, initialize/fill:
            // * FMatrix-   values of basis functions at X[]
            // * CMatrix-   values (derivatives) of basis functions at XC[]
            // * fill constraints matrix
            // * fill first N rows of design matrix with values
            // * fill next M rows of design matrix with regularizing term
            // * append M zeros to Y
            // * append M elements, mean(abs(W)) each, to W
            //
            y2 = new double[n+m];
            w2 = new double[n+m];
            tmp = new double[m];
            tmpdiff = new double[m];
            fmatrix = new double[n+m, m];
            if( k>0 )
            {
                cmatrix = new double[k, m+1];
            }
            
            //
            // Fill design matrix, Y2, W2:
            // * first N rows with basis functions for original points
            // * next M rows with decay terms
            //
            for(i=0; i<=n-1; i++)
            {
                
                //
                // prepare Ith row
                // use Tmp for calculations to avoid multidimensional arrays overhead
                //
                for(j=0; j<=m-1; j++)
                {
                    if( j==0 )
                    {
                        tmp[j] = 1;
                    }
                    else
                    {
                        if( j==1 )
                        {
                            tmp[j] = x[i];
                        }
                        else
                        {
                            tmp[j] = 2*x[i]*tmp[j-1]-tmp[j-2];
                        }
                    }
                }
                for(i_=0; i_<=m-1;i_++)
                {
                    fmatrix[i,i_] = tmp[i_];
                }
            }
            for(i=0; i<=m-1; i++)
            {
                for(j=0; j<=m-1; j++)
                {
                    if( i==j )
                    {
                        fmatrix[n+i,j] = decay;
                    }
                    else
                    {
                        fmatrix[n+i,j] = 0;
                    }
                }
            }
            for(i_=0; i_<=n-1;i_++)
            {
                y2[i_] = y[i_];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                w2[i_] = w[i_];
            }
            mx = 0;
            for(i=0; i<=n-1; i++)
            {
                mx = mx+Math.Abs(w[i]);
            }
            mx = mx/n;
            for(i=0; i<=m-1; i++)
            {
                y2[n+i] = 0;
                w2[n+i] = mx;
            }
            
            //
            // fill constraints matrix
            //
            for(i=0; i<=k-1; i++)
            {
                
                //
                // prepare Ith row
                // use Tmp for basis function values,
                // TmpDiff for basos function derivatives
                //
                for(j=0; j<=m-1; j++)
                {
                    if( j==0 )
                    {
                        tmp[j] = 1;
                        tmpdiff[j] = 0;
                    }
                    else
                    {
                        if( j==1 )
                        {
                            tmp[j] = xc[i];
                            tmpdiff[j] = 1;
                        }
                        else
                        {
                            tmp[j] = 2*xc[i]*tmp[j-1]-tmp[j-2];
                            tmpdiff[j] = 2*(tmp[j-1]+xc[i]*tmpdiff[j-1])-tmpdiff[j-2];
                        }
                    }
                }
                if( dc[i]==0 )
                {
                    for(i_=0; i_<=m-1;i_++)
                    {
                        cmatrix[i,i_] = tmp[i_];
                    }
                }
                if( dc[i]==1 )
                {
                    for(i_=0; i_<=m-1;i_++)
                    {
                        cmatrix[i,i_] = tmpdiff[i_];
                    }
                }
                cmatrix[i,m] = yc[i];
            }
            
            //
            // Solve constrained task
            //
            if( k>0 )
            {
                
                //
                // solve using regularization
                //
                lsfitlinearwc(y2, w2, fmatrix, cmatrix, n+m, m, k, ref info, ref c, rep, _params);
            }
            else
            {
                
                //
                // no constraints, no regularization needed
                //
                lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, 0, ref info, ref c, rep, _params);
            }
            if( info<0 )
            {
                return;
            }
        }


        /*************************************************************************
        Internal Floater-Hormann fitting subroutine for fixed D
        *************************************************************************/
        private static void barycentricfitwcfixedd(double[] x,
            double[] y,
            double[] w,
            int n,
            double[] xc,
            double[] yc,
            int[] dc,
            int k,
            int m,
            int d,
            ref int info,
            ratint.barycentricinterpolant b,
            barycentricfitreport rep,
            alglib.xparams _params)
        {
            double[,] fmatrix = new double[0,0];
            double[,] cmatrix = new double[0,0];
            double[] y2 = new double[0];
            double[] w2 = new double[0];
            double[] sx = new double[0];
            double[] sy = new double[0];
            double[] sbf = new double[0];
            double[] xoriginal = new double[0];
            double[] yoriginal = new double[0];
            double[] tmp = new double[0];
            lsfitreport lrep = new lsfitreport();
            double v0 = 0;
            double v1 = 0;
            double mx = 0;
            ratint.barycentricinterpolant b2 = new ratint.barycentricinterpolant();
            int i = 0;
            int j = 0;
            int relcnt = 0;
            double xa = 0;
            double xb = 0;
            double sa = 0;
            double sb = 0;
            double decay = 0;
            int i_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            w = (double[])w.Clone();
            xc = (double[])xc.Clone();
            yc = (double[])yc.Clone();
            info = 0;

            if( ((n<1 || m<2) || k<0) || k>=m )
            {
                info = -1;
                return;
            }
            for(i=0; i<=k-1; i++)
            {
                info = 0;
                if( dc[i]<0 )
                {
                    info = -1;
                }
                if( dc[i]>1 )
                {
                    info = -1;
                }
                if( info<0 )
                {
                    return;
                }
            }
            
            //
            // weight decay for correct handling of task which becomes
            // degenerate after constraints are applied
            //
            decay = 10000*math.machineepsilon;
            
            //
            // Scale X, Y, XC, YC
            //
            intfitserv.lsfitscalexy(ref x, ref y, ref w, n, ref xc, ref yc, dc, k, ref xa, ref xb, ref sa, ref sb, ref xoriginal, ref yoriginal, _params);
            
            //
            // allocate space, initialize:
            // * FMatrix-   values of basis functions at X[]
            // * CMatrix-   values (derivatives) of basis functions at XC[]
            //
            y2 = new double[n+m];
            w2 = new double[n+m];
            fmatrix = new double[n+m, m];
            if( k>0 )
            {
                cmatrix = new double[k, m+1];
            }
            y2 = new double[n+m];
            w2 = new double[n+m];
            
            //
            // Prepare design and constraints matrices:
            // * fill constraints matrix
            // * fill first N rows of design matrix with values
            // * fill next M rows of design matrix with regularizing term
            // * append M zeros to Y
            // * append M elements, mean(abs(W)) each, to W
            //
            sx = new double[m];
            sy = new double[m];
            sbf = new double[m];
            for(j=0; j<=m-1; j++)
            {
                sx[j] = (double)(2*j)/(double)(m-1)-1;
            }
            for(i=0; i<=m-1; i++)
            {
                sy[i] = 1;
            }
            ratint.barycentricbuildfloaterhormann(sx, sy, m, d, b2, _params);
            mx = 0;
            for(i=0; i<=n-1; i++)
            {
                barycentriccalcbasis(b2, x[i], ref sbf, _params);
                for(i_=0; i_<=m-1;i_++)
                {
                    fmatrix[i,i_] = sbf[i_];
                }
                y2[i] = y[i];
                w2[i] = w[i];
                mx = mx+Math.Abs(w[i])/n;
            }
            for(i=0; i<=m-1; i++)
            {
                for(j=0; j<=m-1; j++)
                {
                    if( i==j )
                    {
                        fmatrix[n+i,j] = decay;
                    }
                    else
                    {
                        fmatrix[n+i,j] = 0;
                    }
                }
                y2[n+i] = 0;
                w2[n+i] = mx;
            }
            if( k>0 )
            {
                for(j=0; j<=m-1; j++)
                {
                    for(i=0; i<=m-1; i++)
                    {
                        sy[i] = 0;
                    }
                    sy[j] = 1;
                    ratint.barycentricbuildfloaterhormann(sx, sy, m, d, b2, _params);
                    for(i=0; i<=k-1; i++)
                    {
                        alglib.ap.assert(dc[i]>=0 && dc[i]<=1, "BarycentricFit: internal error!");
                        ratint.barycentricdiff1(b2, xc[i], ref v0, ref v1, _params);
                        if( dc[i]==0 )
                        {
                            cmatrix[i,j] = v0;
                        }
                        if( dc[i]==1 )
                        {
                            cmatrix[i,j] = v1;
                        }
                    }
                }
                for(i=0; i<=k-1; i++)
                {
                    cmatrix[i,m] = yc[i];
                }
            }
            
            //
            // Solve constrained task
            //
            if( k>0 )
            {
                
                //
                // solve using regularization
                //
                lsfitlinearwc(y2, w2, fmatrix, cmatrix, n+m, m, k, ref info, ref tmp, lrep, _params);
            }
            else
            {
                
                //
                // no constraints, no regularization needed
                //
                lsfitlinearwc(y, w, fmatrix, cmatrix, n, m, k, ref info, ref tmp, lrep, _params);
            }
            if( info<0 )
            {
                return;
            }
            
            //
            // Generate interpolant and scale it
            //
            for(i_=0; i_<=m-1;i_++)
            {
                sy[i_] = tmp[i_];
            }
            ratint.barycentricbuildfloaterhormann(sx, sy, m, d, b, _params);
            ratint.barycentriclintransx(b, 2/(xb-xa), -((xa+xb)/(xb-xa)), _params);
            ratint.barycentriclintransy(b, sb-sa, sa, _params);
            
            //
            // Scale absolute errors obtained from LSFitLinearW.
            // Relative error should be calculated separately
            // (because of shifting/scaling of the task)
            //
            rep.taskrcond = lrep.taskrcond;
            rep.rmserror = lrep.rmserror*(sb-sa);
            rep.avgerror = lrep.avgerror*(sb-sa);
            rep.maxerror = lrep.maxerror*(sb-sa);
            rep.avgrelerror = 0;
            relcnt = 0;
            for(i=0; i<=n-1; i++)
            {
                if( (double)(yoriginal[i])!=(double)(0) )
                {
                    rep.avgrelerror = rep.avgrelerror+Math.Abs(ratint.barycentriccalc(b, xoriginal[i], _params)-yoriginal[i])/Math.Abs(yoriginal[i]);
                    relcnt = relcnt+1;
                }
            }
            if( relcnt!=0 )
            {
                rep.avgrelerror = rep.avgrelerror/relcnt;
            }
        }


        private static void clearreport(lsfitreport rep,
            alglib.xparams _params)
        {
            rep.taskrcond = 0;
            rep.iterationscount = 0;
            rep.varidx = -1;
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.avgrelerror = 0;
            rep.maxerror = 0;
            rep.wrmserror = 0;
            rep.r2 = 0;
            rep.covpar = new double[0, 0];
            rep.errpar = new double[0];
            rep.errcurve = new double[0];
            rep.noise = new double[0];
        }


        /*************************************************************************
        This internal function estimates covariance matrix and other error-related
        information for linear/nonlinear least squares model.

        It has a bit awkward interface, but it can be used  for  both  linear  and
        nonlinear problems.

        INPUT PARAMETERS:
            F1  -   array[0..N-1,0..K-1]:
                    * for linear problems - matrix of function values
                    * for nonlinear problems - Jacobian matrix
            F0  -   array[0..N-1]:
                    * for linear problems - must be filled with zeros
                    * for nonlinear problems - must store values of function being
                      fitted
            Y   -   array[0..N-1]:
                    * for linear and nonlinear problems - must store target values
            W   -   weights, array[0..N-1]:
                    * for linear and nonlinear problems - weights
            X   -   array[0..K-1]:
                    * for linear and nonlinear problems - current solution
            S   -   array[0..K-1]:
                    * its components should be strictly positive
                    * squared inverse of this diagonal matrix is used as damping
                      factor for covariance matrix (linear and nonlinear problems)
                    * for nonlinear problems, when scale of the variables is usually
                      explicitly given by user, you may use scale vector for this
                      parameter
                    * for linear problems you may set this parameter to
                      S=sqrt(1/diag(F'*F))
                    * this parameter is automatically rescaled by this function,
                      only relative magnitudes of its components (with respect to
                      each other) matter.
            N   -   number of points, N>0.
            K   -   number of dimensions
            Rep -   structure which is used to store results
            Z   -   additional matrix which, depending on ZKind, may contain some
                    information used to accelerate calculations - or just can be
                    temporary buffer:
                    * for ZKind=0       Z contains no information, just temporary
                                        buffer which can be resized and used as needed
                    * for ZKind=1       Z contains triangular matrix from QR
                                        decomposition of W*F1. This matrix can be used
                                        to speedup calculation of covariance matrix.
                                        It should not be changed by algorithm.
            ZKind-  contents of Z

        OUTPUT PARAMETERS:

        * Rep.CovPar        covariance matrix for parameters, array[K,K].
        * Rep.ErrPar        errors in parameters, array[K],
                            errpar = sqrt(diag(CovPar))
        * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
                            best-fit curve from "ideal" best-fit curve built  with
                            infinite number of samples, array[N].
                            errcurve = sqrt(diag(J*CovPar*J')),
                            where J is Jacobian matrix.
        * Rep.Noise         vector of per-point estimates of noise, array[N]
        * Rep.R2            coefficient of determination (non-weighted)

        Other fields of Rep are not changed.

        IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
                    account boundary/linear constraints! Presence  of  constraints
                    changes distribution of errors, but there is no  easy  way  to
                    account for constraints when you calculate covariance matrix.
                    
        NOTE:       noise in the data is estimated as follows:
                    * for fitting without user-supplied  weights  all  points  are
                      assumed to have same level of noise, which is estimated from
                      the data
                    * for fitting with user-supplied weights we assume that  noise
                      level in I-th point is inversely proportional to Ith weight.
                      Coefficient of proportionality is estimated from the data.
                    
        NOTE:       we apply small amount of regularization when we invert squared
                    Jacobian and calculate covariance matrix. It  guarantees  that
                    algorithm won't divide by zero  during  inversion,  but  skews
                    error estimates a bit (fractional error is about 10^-9).
                    
                    However, we believe that this difference is insignificant  for
                    all practical purposes except for the situation when you  want
                    to compare ALGLIB results with "reference"  implementation  up
                    to the last significant digit.

          -- ALGLIB PROJECT --
             Copyright 10.12.2009 by Bochkanov Sergey
        *************************************************************************/
        private static void estimateerrors(double[,] f1,
            double[] f0,
            double[] y,
            double[] w,
            double[] x,
            double[] s,
            int n,
            int k,
            lsfitreport rep,
            ref double[,] z,
            int zkind,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int j1 = 0;
            double v = 0;
            double noisec = 0;
            int info = 0;
            matinv.matinvreport invrep = new matinv.matinvreport();
            int nzcnt = 0;
            double avg = 0;
            double rss = 0;
            double tss = 0;
            double sz = 0;
            double ss = 0;
            int i_ = 0;

            s = (double[])s.Clone();

            
            //
            // Compute NZCnt - count of non-zero weights
            //
            nzcnt = 0;
            for(i=0; i<=n-1; i++)
            {
                if( (double)(w[i])!=(double)(0) )
                {
                    nzcnt = nzcnt+1;
                }
            }
            
            //
            // Compute R2
            //
            if( nzcnt>0 )
            {
                avg = 0.0;
                for(i=0; i<=n-1; i++)
                {
                    if( (double)(w[i])!=(double)(0) )
                    {
                        avg = avg+y[i];
                    }
                }
                avg = avg/nzcnt;
                rss = 0.0;
                tss = 0.0;
                for(i=0; i<=n-1; i++)
                {
                    if( (double)(w[i])!=(double)(0) )
                    {
                        v = 0.0;
                        for(i_=0; i_<=k-1;i_++)
                        {
                            v += f1[i,i_]*x[i_];
                        }
                        v = v+f0[i];
                        rss = rss+math.sqr(v-y[i]);
                        tss = tss+math.sqr(y[i]-avg);
                    }
                }
                if( (double)(tss)!=(double)(0) )
                {
                    rep.r2 = Math.Max(1.0-rss/tss, 0.0);
                }
                else
                {
                    rep.r2 = 1.0;
                }
            }
            else
            {
                rep.r2 = 0;
            }
            
            //
            // Compute estimate of proportionality between noise in the data and weights:
            //     NoiseC = mean(per-point-noise*per-point-weight)
            // Noise level (standard deviation) at each point is equal to NoiseC/W[I].
            //
            if( nzcnt>k )
            {
                noisec = 0.0;
                for(i=0; i<=n-1; i++)
                {
                    if( (double)(w[i])!=(double)(0) )
                    {
                        v = 0.0;
                        for(i_=0; i_<=k-1;i_++)
                        {
                            v += f1[i,i_]*x[i_];
                        }
                        v = v+f0[i];
                        noisec = noisec+math.sqr((v-y[i])*w[i]);
                    }
                }
                noisec = Math.Sqrt(noisec/(nzcnt-k));
            }
            else
            {
                noisec = 0.0;
            }
            
            //
            // Two branches on noise level:
            // * NoiseC>0   normal situation
            // * NoiseC=0   degenerate case CovPar is filled by zeros
            //
            apserv.rmatrixsetlengthatleast(ref rep.covpar, k, k, _params);
            if( (double)(noisec)>(double)(0) )
            {
                
                //
                // Normal situation: non-zero noise level
                //
                alglib.ap.assert(zkind==0 || zkind==1, "LSFit: internal error in EstimateErrors() function");
                if( zkind==0 )
                {
                    
                    //
                    // Z contains no additional information which can be used to speed up
                    // calculations. We have to calculate covariance matrix on our own:
                    // * Compute scaled Jacobian N*J, where N[i,i]=WCur[I]/NoiseC, store in Z
                    // * Compute Z'*Z, store in CovPar
                    // * Apply moderate regularization to CovPar and compute matrix inverse.
                    //   In case inverse failed, increase regularization parameter and try
                    //   again.
                    //
                    apserv.rmatrixsetlengthatleast(ref z, n, k, _params);
                    for(i=0; i<=n-1; i++)
                    {
                        v = w[i]/noisec;
                        for(i_=0; i_<=k-1;i_++)
                        {
                            z[i,i_] = v*f1[i,i_];
                        }
                    }
                    
                    //
                    // Convert S to automatically scaled damped matrix:
                    // * calculate SZ - sum of diagonal elements of Z'*Z
                    // * calculate SS - sum of diagonal elements of S^(-2)
                    // * overwrite S by (SZ/SS)*S^(-2)
                    // * now S has approximately same magnitude as giagonal of Z'*Z
                    //
                    sz = 0;
                    for(i=0; i<=n-1; i++)
                    {
                        for(j=0; j<=k-1; j++)
                        {
                            sz = sz+z[i,j]*z[i,j];
                        }
                    }
                    if( (double)(sz)==(double)(0) )
                    {
                        sz = 1;
                    }
                    ss = 0;
                    for(j=0; j<=k-1; j++)
                    {
                        ss = ss+1/math.sqr(s[j]);
                    }
                    for(j=0; j<=k-1; j++)
                    {
                        s[j] = sz/ss/math.sqr(s[j]);
                    }
                    
                    //
                    // Calculate damped inverse inv(Z'*Z+S).
                    // We increase damping factor V until Z'*Z become well-conditioned.
                    //
                    v = 1.0E3*math.machineepsilon;
                    do
                    {
                        ablas.rmatrixsyrk(k, n, 1.0, z, 0, 0, 2, 0.0, rep.covpar, 0, 0, true, _params);
                        for(i=0; i<=k-1; i++)
                        {
                            rep.covpar[i,i] = rep.covpar[i,i]+v*s[i];
                        }
                        matinv.spdmatrixinverse(ref rep.covpar, k, true, ref info, invrep, _params);
                        v = 10*v;
                    }
                    while( info<=0 );
                    for(i=0; i<=k-1; i++)
                    {
                        for(j=i+1; j<=k-1; j++)
                        {
                            rep.covpar[j,i] = rep.covpar[i,j];
                        }
                    }
                }
                if( zkind==1 )
                {
                    
                    //
                    // We can reuse additional information:
                    // * Z contains R matrix from QR decomposition of W*F1 
                    // * After multiplication by 1/NoiseC we get Z_mod = N*F1, where diag(N)=w[i]/NoiseC
                    // * Such triangular Z_mod is a Cholesky factor from decomposition of J'*N'*N*J.
                    //   Thus, we can calculate covariance matrix as inverse of the matrix given by
                    //   its Cholesky decomposition. It allow us to avoid time-consuming calculation
                    //   of J'*N'*N*J in CovPar - complexity is reduced from O(N*K^2) to O(K^3), which
                    //   is quite good because K is usually orders of magnitude smaller than N.
                    //
                    // First, convert S to automatically scaled damped matrix:
                    // * calculate SZ - sum of magnitudes of diagonal elements of Z/NoiseC
                    // * calculate SS - sum of diagonal elements of S^(-1)
                    // * overwrite S by (SZ/SS)*S^(-1)
                    // * now S has approximately same magnitude as giagonal of Z'*Z
                    //
                    sz = 0;
                    for(j=0; j<=k-1; j++)
                    {
                        sz = sz+Math.Abs(z[j,j]/noisec);
                    }
                    if( (double)(sz)==(double)(0) )
                    {
                        sz = 1;
                    }
                    ss = 0;
                    for(j=0; j<=k-1; j++)
                    {
                        ss = ss+1/s[j];
                    }
                    for(j=0; j<=k-1; j++)
                    {
                        s[j] = sz/ss/s[j];
                    }
                    
                    //
                    // Calculate damped inverse of inv((Z+v*S)'*(Z+v*S))
                    // We increase damping factor V until matrix become well-conditioned.
                    //
                    v = 1.0E3*math.machineepsilon;
                    do
                    {
                        for(i=0; i<=k-1; i++)
                        {
                            for(j=i; j<=k-1; j++)
                            {
                                rep.covpar[i,j] = z[i,j]/noisec;
                            }
                            rep.covpar[i,i] = rep.covpar[i,i]+v*s[i];
                        }
                        matinv.spdmatrixcholeskyinverse(ref rep.covpar, k, true, ref info, invrep, _params);
                        v = 10*v;
                    }
                    while( info<=0 );
                    for(i=0; i<=k-1; i++)
                    {
                        for(j=i+1; j<=k-1; j++)
                        {
                            rep.covpar[j,i] = rep.covpar[i,j];
                        }
                    }
                }
            }
            else
            {
                
                //
                // Degenerate situation: zero noise level, covariance matrix is zero.
                //
                for(i=0; i<=k-1; i++)
                {
                    for(j=0; j<=k-1; j++)
                    {
                        rep.covpar[j,i] = 0;
                    }
                }
            }
            
            //
            // Estimate erorrs in parameters, curve and per-point noise
            //
            apserv.rvectorsetlengthatleast(ref rep.errpar, k, _params);
            apserv.rvectorsetlengthatleast(ref rep.errcurve, n, _params);
            apserv.rvectorsetlengthatleast(ref rep.noise, n, _params);
            for(i=0; i<=k-1; i++)
            {
                rep.errpar[i] = Math.Sqrt(rep.covpar[i,i]);
            }
            for(i=0; i<=n-1; i++)
            {
                
                //
                // ErrCurve[I] is sqrt(P[i,i]) where P=J*CovPar*J'
                //
                v = 0.0;
                for(j=0; j<=k-1; j++)
                {
                    for(j1=0; j1<=k-1; j1++)
                    {
                        v = v+f1[i,j]*rep.covpar[j,j1]*f1[i,j1];
                    }
                }
                rep.errcurve[i] = Math.Sqrt(v);
                
                //
                // Noise[i] is filled using weights and current estimate of noise level
                //
                if( (double)(w[i])!=(double)(0) )
                {
                    rep.noise[i] = noisec/w[i];
                }
                else
                {
                    rep.noise[i] = 0;
                }
            }
        }


    }
    public class fitsphere
    {
        public class fitsphereinternalreport : apobject
        {
            public int nfev;
            public int iterationscount;
            public fitsphereinternalreport()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                fitsphereinternalreport _result = new fitsphereinternalreport();
                _result.nfev = nfev;
                _result.iterationscount = iterationscount;
                return _result;
            }
        };




        /*************************************************************************
        Fits least squares (LS) circle (or NX-dimensional sphere) to data  (a  set
        of points in NX-dimensional space).

        Least squares circle minimizes sum of squared deviations between distances
        from points to the center and  some  "candidate"  radius,  which  is  also
        fitted to the data.

        INPUT PARAMETERS:
            XY      -   array[NPoints,NX] (or larger), contains dataset.
                        One row = one point in NX-dimensional space.
            NPoints -   dataset size, NPoints>0
            NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)

        OUTPUT PARAMETERS:
            CX      -   central point for a sphere
            R       -   radius
                                            
          -- ALGLIB --
             Copyright 07.05.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void fitspherels(double[,] xy,
            int npoints,
            int nx,
            ref double[] cx,
            ref double r,
            alglib.xparams _params)
        {
            double dummy = 0;

            cx = new double[0];
            r = 0;

            fitspherex(xy, npoints, nx, 0, 0.0, 0, 0.0, ref cx, ref dummy, ref r, _params);
        }


        /*************************************************************************
        Fits minimum circumscribed (MC) circle (or NX-dimensional sphere) to  data
        (a set of points in NX-dimensional space).

        INPUT PARAMETERS:
            XY      -   array[NPoints,NX] (or larger), contains dataset.
                        One row = one point in NX-dimensional space.
            NPoints -   dataset size, NPoints>0
            NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)

        OUTPUT PARAMETERS:
            CX      -   central point for a sphere
            RHi     -   radius

        NOTE: this function is an easy-to-use wrapper around more powerful "expert"
              function fitspherex().
              
              This  wrapper  is optimized  for  ease of use and stability - at the
              cost of somewhat lower  performance  (we  have  to  use  very  tight
              stopping criteria for inner optimizer because we want to  make  sure
              that it will converge on any dataset).
              
              If you are ready to experiment with settings of  "expert"  function,
              you can achieve ~2-4x speedup over standard "bulletproof" settings.

                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void fitspheremc(double[,] xy,
            int npoints,
            int nx,
            ref double[] cx,
            ref double rhi,
            alglib.xparams _params)
        {
            double dummy = 0;

            cx = new double[0];
            rhi = 0;

            fitspherex(xy, npoints, nx, 1, 0.0, 0, 0.0, ref cx, ref dummy, ref rhi, _params);
        }


        /*************************************************************************
        Fits maximum inscribed circle (or NX-dimensional sphere) to data (a set of
        points in NX-dimensional space).

        INPUT PARAMETERS:
            XY      -   array[NPoints,NX] (or larger), contains dataset.
                        One row = one point in NX-dimensional space.
            NPoints -   dataset size, NPoints>0
            NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)

        OUTPUT PARAMETERS:
            CX      -   central point for a sphere
            RLo     -   radius

        NOTE: this function is an easy-to-use wrapper around more powerful "expert"
              function fitspherex().
              
              This  wrapper  is optimized  for  ease of use and stability - at the
              cost of somewhat lower  performance  (we  have  to  use  very  tight
              stopping criteria for inner optimizer because we want to  make  sure
              that it will converge on any dataset).
              
              If you are ready to experiment with settings of  "expert"  function,
              you can achieve ~2-4x speedup over standard "bulletproof" settings.

                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void fitspheremi(double[,] xy,
            int npoints,
            int nx,
            ref double[] cx,
            ref double rlo,
            alglib.xparams _params)
        {
            double dummy = 0;

            cx = new double[0];
            rlo = 0;

            fitspherex(xy, npoints, nx, 2, 0.0, 0, 0.0, ref cx, ref rlo, ref dummy, _params);
        }


        /*************************************************************************
        Fits minimum zone circle (or NX-dimensional sphere)  to  data  (a  set  of
        points in NX-dimensional space).

        INPUT PARAMETERS:
            XY      -   array[NPoints,NX] (or larger), contains dataset.
                        One row = one point in NX-dimensional space.
            NPoints -   dataset size, NPoints>0
            NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)

        OUTPUT PARAMETERS:
            CX      -   central point for a sphere
            RLo     -   radius of inscribed circle
            RHo     -   radius of circumscribed circle

        NOTE: this function is an easy-to-use wrapper around more powerful "expert"
              function fitspherex().
              
              This  wrapper  is optimized  for  ease of use and stability - at the
              cost of somewhat lower  performance  (we  have  to  use  very  tight
              stopping criteria for inner optimizer because we want to  make  sure
              that it will converge on any dataset).
              
              If you are ready to experiment with settings of  "expert"  function,
              you can achieve ~2-4x speedup over standard "bulletproof" settings.

                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void fitspheremz(double[,] xy,
            int npoints,
            int nx,
            ref double[] cx,
            ref double rlo,
            ref double rhi,
            alglib.xparams _params)
        {
            cx = new double[0];
            rlo = 0;
            rhi = 0;

            fitspherex(xy, npoints, nx, 3, 0.0, 0, 0.0, ref cx, ref rlo, ref rhi, _params);
        }


        /*************************************************************************
        Fitting minimum circumscribed, maximum inscribed or minimum  zone  circles
        (or NX-dimensional spheres)  to  data  (a  set of points in NX-dimensional
        space).

        This  is  expert  function  which  allows  to  tweak  many  parameters  of
        underlying nonlinear solver:
        * stopping criteria for inner iterations
        * number of outer iterations
        * penalty coefficient used to handle  nonlinear  constraints  (we  convert
          unconstrained nonsmooth optimization problem ivolving max() and/or min()
          operations to quadratically constrained smooth one).

        You may tweak all these parameters or only some  of  them,  leaving  other
        ones at their default state - just specify zero  value,  and  solver  will
        fill it with appropriate default one.

        These comments also include some discussion of  approach  used  to  handle
        such unusual fitting problem,  its  stability,  drawbacks  of  alternative
        methods, and convergence properties.
          
        INPUT PARAMETERS:
            XY      -   array[NPoints,NX] (or larger), contains dataset.
                        One row = one point in NX-dimensional space.
            NPoints -   dataset size, NPoints>0
            NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
            ProblemType-used to encode problem type:
                        * 0 for least squares circle
                        * 1 for minimum circumscribed circle/sphere fitting (MC)
                        * 2 for  maximum inscribed circle/sphere fitting (MI)
                        * 3 for minimum zone circle fitting (difference between
                            Rhi and Rlo is minimized), denoted as MZ
            EpsX    -   stopping condition for NLC optimizer:
                        * must be non-negative
                        * use 0 to choose default value (1.0E-12 is used by default)
                        * you may specify larger values, up to 1.0E-6, if you want
                          to   speed-up   solver;   NLC   solver  performs several
                          preconditioned  outer  iterations,   so   final   result
                          typically has precision much better than EpsX.
            AULIts  -   number of outer iterations performed by NLC optimizer:
                        * must be non-negative
                        * use 0 to choose default value (20 is used by default)
                        * you may specify values smaller than 20 if you want to
                          speed up solver; 10 often results in good combination of
                          precision and speed; sometimes you may get good results
                          with just 6 outer iterations.
                        Ignored for ProblemType=0.
            Penalty -   penalty coefficient for NLC optimizer:
                        * must be non-negative
                        * use 0 to choose default value (1.0E6 in current version)
                        * it should be really large, 1.0E6...1.0E7 is a good value
                          to start from;
                        * generally, default value is good enough
                        Ignored for ProblemType=0.

        OUTPUT PARAMETERS:
            CX      -   central point for a sphere
            RLo     -   radius:
                        * for ProblemType=2,3, radius of the inscribed sphere
                        * for ProblemType=0 - radius of the least squares sphere
                        * for ProblemType=1 - zero
            RHo     -   radius:
                        * for ProblemType=1,3, radius of the circumscribed sphere
                        * for ProblemType=0 - radius of the least squares sphere
                        * for ProblemType=2 - zero

        NOTE: ON THE UNIQUENESS OF SOLUTIONS

        ALGLIB provides solution to several related circle fitting  problems:   MC
        (minimum circumscribed), MI (maximum inscribed)   and   MZ  (minimum zone)
        fitting, LS (least squares) fitting.

        It  is  important  to  note  that  among these problems only MC and LS are
        convex and have unique solution independently from starting point.

        As  for MI,  it  may (or  may  not, depending on dataset properties)  have
        multiple solutions, and it always  has  one degenerate solution C=infinity
        which corresponds to infinitely large radius. Thus, there are no guarantees
        that solution to  MI returned by this solver will be the best one (and  no
        one can provide you with such guarantee because problem is  NP-hard).  The
        only guarantee you have is that this solution is locally optimal, i.e.  it
        can not be improved by infinitesimally small tweaks in the parameters.

        It  is  also  possible  to "run away" to infinity when  started  from  bad
        initial point located outside of point cloud (or when point cloud does not
        span entire circumference/surface of the sphere).

        Finally,  MZ (minimum zone circle) stands somewhere between MC  and  MI in
        stability. It is somewhat regularized by "circumscribed" term of the merit
        function; however, solutions to  MZ may be non-unique, and in some unlucky
        cases it is also possible to "run away to infinity".


        NOTE: ON THE NONLINEARLY CONSTRAINED PROGRAMMING APPROACH

        The problem formulation for MC  (minimum circumscribed   circle;  for  the
        sake of simplicity we omit MZ and MI here) is:

                [     [         ]2 ]
            min [ max [ XY[i]-C ]  ]
             C  [  i  [         ]  ]

        i.e. it is unconstrained nonsmooth optimization problem of finding  "best"
        central point, with radius R being unambiguously  determined  from  C.  In
        order to move away from non-smoothness we use following reformulation:

                [   ]                  [         ]2
            min [ R ] subject to R>=0, [ XY[i]-C ]  <= R^2
            C,R [   ]                  [         ]
            
        i.e. it becomes smooth quadratically constrained optimization problem with
        linear target function. Such problem statement is 100% equivalent  to  the
        original nonsmooth one, but much easier  to  approach.  We solve  it  with
        MinNLC solver provided by ALGLIB.


        NOTE: ON INSTABILITY OF SEQUENTIAL LINEARIZATION APPROACH

        ALGLIB  has  nonlinearly  constrained  solver which proved to be stable on
        such problems. However, some authors proposed to linearize constraints  in
        the vicinity of current approximation (Ci,Ri) and to get next  approximate
        solution (Ci+1,Ri+1) as solution to linear programming problem. Obviously,
        LP problems are easier than nonlinearly constrained ones.

        Indeed,  such approach  to   MC/MI/MZ   resulted   in  ~10-20x increase in
        performance (when compared with NLC solver). However, it turned  out  that
        in some cases linearized model fails to predict correct direction for next
        step and tells us that we converged to solution even when we are still 2-4
        digits of precision away from it.

        It is important that it is not failure of LP solver - it is failure of the
        linear model;  even  when  solved  exactly,  it  fails  to  handle  subtle
        nonlinearities which arise near the solution. We validated it by comparing
        results returned by ALGLIB linear solver with that of MATLAB.

        In our experiments with linearization:
        * MC failed most often, at both realistic and synthetic datasets
        * MI sometimes failed, but sometimes succeeded
        * MZ often  succeeded; our guess is that presence of two independent  sets
          of constraints (one set for Rlo and another one for Rhi) and  two  terms
          in the target function (Rlo and Rhi) regularizes task,  so  when  linear
          model fails to handle nonlinearities from Rlo, it uses  Rhi  as  a  hint
          (and vice versa).
          
        Because linearization approach failed to achieve stable results, we do not
        include it in ALGLIB.

                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void fitspherex(double[,] xy,
            int npoints,
            int nx,
            int problemtype,
            double epsx,
            int aulits,
            double penalty,
            ref double[] cx,
            ref double rlo,
            ref double rhi,
            alglib.xparams _params)
        {
            fitsphereinternalreport rep = new fitsphereinternalreport();

            cx = new double[0];
            rlo = 0;
            rhi = 0;

            alglib.ap.assert(math.isfinite(penalty) && (double)(penalty)>=(double)(0), "FitSphereX: Penalty<0 or is not finite");
            alglib.ap.assert(math.isfinite(epsx) && (double)(epsx)>=(double)(0), "FitSphereX: EpsX<0 or is not finite");
            alglib.ap.assert(aulits>=0, "FitSphereX: AULIts<0");
            fitsphereinternal(xy, npoints, nx, problemtype, 0, epsx, aulits, penalty, ref cx, ref rlo, ref rhi, rep, _params);
        }


        /*************************************************************************
        Fitting minimum circumscribed, maximum inscribed or minimum  zone  circles
        (or NX-dimensional spheres)  to  data  (a  set of points in NX-dimensional
        space).

        Internal computational function.

        INPUT PARAMETERS:
            XY      -   array[NPoints,NX] (or larger), contains dataset.
                        One row = one point in NX-dimensional space.
            NPoints -   dataset size, NPoints>0
            NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
            ProblemType-used to encode problem type:
                        * 0 for least squares circle
                        * 1 for minimum circumscribed circle/sphere fitting (MC)
                        * 2 for  maximum inscribed circle/sphere fitting (MI)
                        * 3 for minimum zone circle fitting (difference between
                            Rhi and Rlo is minimized), denoted as MZ
            SolverType- solver to use:
                        * 0 use best solver available (1 in current version)
                        * 1 use nonlinearly constrained optimization approach, AUL
                            (it is roughly 10-20 times  slower  than  SPC-LIN, but
                            much more stable)
                        * 2 use special fast IMPRECISE solver, SPC-LIN  sequential
                            linearization approach; SPC-LIN is fast, but sometimes
                            fails to converge with more than 3 digits of precision;
                            see comments below.
                            NOT RECOMMENDED UNLESS YOU REALLY NEED HIGH PERFORMANCE
                            AT THE COST OF SOME PRECISION.
                        * 3 use nonlinearly constrained optimization approach, SLP
                            (most robust one, but somewhat slower than AUL)
                        Ignored for ProblemType=0.
            EpsX    -   stopping criteria for SLP and NLC optimizers:
                        * must be non-negative
                        * use 0 to choose default value (1.0E-12 is used by default)
                        * if you use SLP solver, you should use default values
                        * if you use NLC solver, you may specify larger values, up
                          to 1.0E-6, if you want to speed-up  solver;  NLC  solver
                          performs several preconditioned outer iterations, so final
                          result typically has precision much better than EpsX.
            AULIts  -   number of iterations performed by NLC optimizer:
                        * must be non-negative
                        * use 0 to choose default value (20 is used by default)
                        * you may specify values smaller than 20 if you want to
                          speed up solver; 10 often results in good combination of
                          precision and speed
                        Ignored for ProblemType=0.
            Penalty -   penalty coefficient for NLC optimizer (ignored  for  SLP):
                        * must be non-negative
                        * use 0 to choose default value (1.0E6 in current version)
                        * it should be really large, 1.0E6...1.0E7 is a good value
                          to start from;
                        * generally, default value is good enough
                        * ignored by SLP optimizer
                        Ignored for ProblemType=0.

        OUTPUT PARAMETERS:
            CX      -   central point for a sphere
            RLo     -   radius:
                        * for ProblemType=2,3, radius of the inscribed sphere
                        * for ProblemType=0 - radius of the least squares sphere
                        * for ProblemType=1 - zero
            RHo     -   radius:
                        * for ProblemType=1,3, radius of the circumscribed sphere
                        * for ProblemType=0 - radius of the least squares sphere
                        * for ProblemType=2 - zero
                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void fitsphereinternal(double[,] xy,
            int npoints,
            int nx,
            int problemtype,
            int solvertype,
            double epsx,
            int aulits,
            double penalty,
            ref double[] cx,
            ref double rlo,
            ref double rhi,
            fitsphereinternalreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double v = 0;
            double vv = 0;
            int cpr = 0;
            bool userlo = new bool();
            bool userhi = new bool();
            double vlo = 0;
            double vhi = 0;
            double[] vmin = new double[0];
            double[] vmax = new double[0];
            double spread = 0;
            double[] pcr = new double[0];
            double[] scr = new double[0];
            double[] bl = new double[0];
            double[] bu = new double[0];
            int suboffset = 0;
            int dstrow = 0;
            minnlc.minnlcstate nlcstate = new minnlc.minnlcstate();
            minnlc.minnlcreport nlcrep = new minnlc.minnlcreport();
            double[,] cmatrix = new double[0,0];
            int[] ct = new int[0];
            int outeridx = 0;
            int maxouterits = 0;
            int maxits = 0;
            double safeguard = 0;
            double bi = 0;
            minbleic.minbleicstate blcstate = new minbleic.minbleicstate();
            minbleic.minbleicreport blcrep = new minbleic.minbleicreport();
            double[] prevc = new double[0];
            minlm.minlmstate lmstate = new minlm.minlmstate();
            minlm.minlmreport lmrep = new minlm.minlmreport();

            cx = new double[0];
            rlo = 0;
            rhi = 0;

            
            //
            // Check input parameters
            //
            alglib.ap.assert(npoints>0, "FitSphereX: NPoints<=0");
            alglib.ap.assert(nx>0, "FitSphereX: NX<=0");
            alglib.ap.assert(apserv.apservisfinitematrix(xy, npoints, nx, _params), "FitSphereX: XY contains infinite or NAN values");
            alglib.ap.assert(problemtype>=0 && problemtype<=3, "FitSphereX: ProblemType is neither 0, 1, 2 or 3");
            alglib.ap.assert(solvertype>=0 && solvertype<=3, "FitSphereX: ProblemType is neither 1, 2 or 3");
            alglib.ap.assert(math.isfinite(penalty) && (double)(penalty)>=(double)(0), "FitSphereX: Penalty<0 or is not finite");
            alglib.ap.assert(math.isfinite(epsx) && (double)(epsx)>=(double)(0), "FitSphereX: EpsX<0 or is not finite");
            alglib.ap.assert(aulits>=0, "FitSphereX: AULIts<0");
            if( solvertype==0 )
            {
                solvertype = 1;
            }
            if( (double)(penalty)==(double)(0) )
            {
                penalty = 1.0E6;
            }
            if( (double)(epsx)==(double)(0) )
            {
                epsx = 1.0E-12;
            }
            if( aulits==0 )
            {
                aulits = 20;
            }
            safeguard = 10;
            maxouterits = 10;
            maxits = 10000;
            rep.nfev = 0;
            rep.iterationscount = 0;
            
            //
            // Determine initial values, initial estimates and spread of the points
            //
            vmin = new double[nx];
            vmax = new double[nx];
            cx = new double[nx];
            for(j=0; j<=nx-1; j++)
            {
                vmin[j] = xy[0,j];
                vmax[j] = xy[0,j];
                cx[j] = 0;
            }
            for(i=0; i<=npoints-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    cx[j] = cx[j]+xy[i,j];
                    vmin[j] = Math.Min(vmin[j], xy[i,j]);
                    vmax[j] = Math.Max(vmax[j], xy[i,j]);
                }
            }
            spread = 0;
            for(j=0; j<=nx-1; j++)
            {
                cx[j] = cx[j]/npoints;
                spread = Math.Max(spread, vmax[j]-vmin[j]);
            }
            rlo = math.maxrealnumber;
            rhi = 0;
            for(i=0; i<=npoints-1; i++)
            {
                v = 0;
                for(j=0; j<=nx-1; j++)
                {
                    v = v+math.sqr(xy[i,j]-cx[j]);
                }
                v = Math.Sqrt(v);
                rhi = Math.Max(rhi, v);
                rlo = Math.Min(rlo, v);
            }
            
            //
            // Handle degenerate case of zero spread
            //
            if( (double)(spread)==(double)(0) )
            {
                for(j=0; j<=nx-1; j++)
                {
                    cx[j] = vmin[j];
                }
                rhi = 0;
                rlo = 0;
                return;
            }
            
            //
            // Prepare initial point for optimizer, scale vector and box constraints
            //
            pcr = new double[nx+2];
            scr = new double[nx+2];
            bl = new double[nx+2];
            bu = new double[nx+2];
            for(j=0; j<=nx-1; j++)
            {
                pcr[j] = cx[j];
                scr[j] = 0.1*spread;
                bl[j] = cx[j]-safeguard*spread;
                bu[j] = cx[j]+safeguard*spread;
            }
            pcr[nx+0] = rlo;
            pcr[nx+1] = rhi;
            scr[nx+0] = 0.5*spread;
            scr[nx+1] = 0.5*spread;
            bl[nx+0] = 0;
            bl[nx+1] = 0;
            bu[nx+0] = safeguard*rhi;
            bu[nx+1] = safeguard*rhi;
            
            //
            // First branch: least squares fitting vs MI/MC/MZ fitting
            //
            if( problemtype==0 )
            {
                
                //
                // Solve problem with Levenberg-Marquardt algorithm
                //
                pcr[nx] = rhi;
                minlm.minlmcreatevj(nx+1, npoints, pcr, lmstate, _params);
                minlm.minlmsetscale(lmstate, scr, _params);
                minlm.minlmsetbc(lmstate, bl, bu, _params);
                minlm.minlmsetcond(lmstate, epsx, maxits, _params);
                while( minlm.minlmiteration(lmstate, _params) )
                {
                    if( lmstate.needfij || lmstate.needfi )
                    {
                        apserv.inc(ref rep.nfev, _params);
                        for(i=0; i<=npoints-1; i++)
                        {
                            v = 0;
                            for(j=0; j<=nx-1; j++)
                            {
                                v = v+math.sqr(lmstate.x[j]-xy[i,j]);
                            }
                            lmstate.fi[i] = Math.Sqrt(v)-lmstate.x[nx];
                            if( lmstate.needfij )
                            {
                                for(j=0; j<=nx-1; j++)
                                {
                                    lmstate.j[i,j] = 0.5/(1.0E-9*spread+Math.Sqrt(v))*2*(lmstate.x[j]-xy[i,j]);
                                }
                                lmstate.j[i,nx] = -1;
                            }
                        }
                        continue;
                    }
                    alglib.ap.assert(false);
                }
                minlm.minlmresults(lmstate, ref pcr, lmrep, _params);
                alglib.ap.assert(lmrep.terminationtype>0, "FitSphereX: unexpected failure of LM solver");
                rep.iterationscount = rep.iterationscount+lmrep.iterationscount;
                
                //
                // Offload center coordinates from PCR to CX,
                // re-calculate exact value of RLo/RHi using CX.
                //
                for(j=0; j<=nx-1; j++)
                {
                    cx[j] = pcr[j];
                }
                vv = 0;
                for(i=0; i<=npoints-1; i++)
                {
                    v = 0;
                    for(j=0; j<=nx-1; j++)
                    {
                        v = v+math.sqr(xy[i,j]-cx[j]);
                    }
                    v = Math.Sqrt(v);
                    vv = vv+v/npoints;
                }
                rlo = vv;
                rhi = vv;
            }
            else
            {
                
                //
                // MI, MC, MZ fitting.
                // Prepare problem metrics
                //
                userlo = problemtype==2 || problemtype==3;
                userhi = problemtype==1 || problemtype==3;
                if( userlo && userhi )
                {
                    cpr = 2;
                }
                else
                {
                    cpr = 1;
                }
                if( userlo )
                {
                    vlo = 1;
                }
                else
                {
                    vlo = 0;
                }
                if( userhi )
                {
                    vhi = 1;
                }
                else
                {
                    vhi = 0;
                }
                
                //
                // Solve with NLC solver; problem is treated as general nonlinearly constrained
                // programming, with augmented Lagrangian solver or SLP being used.
                //
                if( solvertype==1 || solvertype==3 )
                {
                    minnlc.minnlccreate(nx+2, pcr, nlcstate, _params);
                    minnlc.minnlcsetscale(nlcstate, scr, _params);
                    minnlc.minnlcsetbc(nlcstate, bl, bu, _params);
                    minnlc.minnlcsetnlc(nlcstate, 0, cpr*npoints, _params);
                    minnlc.minnlcsetcond(nlcstate, epsx, maxits, _params);
                    minnlc.minnlcsetprecexactrobust(nlcstate, 5, _params);
                    minnlc.minnlcsetstpmax(nlcstate, 0.1, _params);
                    if( solvertype==1 )
                    {
                        minnlc.minnlcsetalgoaul(nlcstate, penalty, aulits, _params);
                    }
                    else
                    {
                        minnlc.minnlcsetalgoslp(nlcstate, _params);
                    }
                    minnlc.minnlcrestartfrom(nlcstate, pcr, _params);
                    while( minnlc.minnlciteration(nlcstate, _params) )
                    {
                        if( nlcstate.needfij )
                        {
                            apserv.inc(ref rep.nfev, _params);
                            nlcstate.fi[0] = vhi*nlcstate.x[nx+1]-vlo*nlcstate.x[nx+0];
                            for(j=0; j<=nx-1; j++)
                            {
                                nlcstate.j[0,j] = 0;
                            }
                            nlcstate.j[0,nx+0] = -(1*vlo);
                            nlcstate.j[0,nx+1] = 1*vhi;
                            for(i=0; i<=npoints-1; i++)
                            {
                                suboffset = 0;
                                if( userhi )
                                {
                                    dstrow = 1+cpr*i+suboffset;
                                    v = 0;
                                    for(j=0; j<=nx-1; j++)
                                    {
                                        vv = nlcstate.x[j]-xy[i,j];
                                        v = v+vv*vv;
                                        nlcstate.j[dstrow,j] = 2*vv;
                                    }
                                    vv = nlcstate.x[nx+1];
                                    v = v-vv*vv;
                                    nlcstate.j[dstrow,nx+0] = 0;
                                    nlcstate.j[dstrow,nx+1] = -(2*vv);
                                    nlcstate.fi[dstrow] = v;
                                    apserv.inc(ref suboffset, _params);
                                }
                                if( userlo )
                                {
                                    dstrow = 1+cpr*i+suboffset;
                                    v = 0;
                                    for(j=0; j<=nx-1; j++)
                                    {
                                        vv = nlcstate.x[j]-xy[i,j];
                                        v = v-vv*vv;
                                        nlcstate.j[dstrow,j] = -(2*vv);
                                    }
                                    vv = nlcstate.x[nx+0];
                                    v = v+vv*vv;
                                    nlcstate.j[dstrow,nx+0] = 2*vv;
                                    nlcstate.j[dstrow,nx+1] = 0;
                                    nlcstate.fi[dstrow] = v;
                                    apserv.inc(ref suboffset, _params);
                                }
                                alglib.ap.assert(suboffset==cpr);
                            }
                            continue;
                        }
                        alglib.ap.assert(false);
                    }
                    minnlc.minnlcresults(nlcstate, ref pcr, nlcrep, _params);
                    alglib.ap.assert(nlcrep.terminationtype>0, "FitSphereX: unexpected failure of NLC solver");
                    rep.iterationscount = rep.iterationscount+nlcrep.iterationscount;
                    
                    //
                    // Offload center coordinates from PCR to CX,
                    // re-calculate exact value of RLo/RHi using CX.
                    //
                    for(j=0; j<=nx-1; j++)
                    {
                        cx[j] = pcr[j];
                    }
                    rlo = math.maxrealnumber;
                    rhi = 0;
                    for(i=0; i<=npoints-1; i++)
                    {
                        v = 0;
                        for(j=0; j<=nx-1; j++)
                        {
                            v = v+math.sqr(xy[i,j]-cx[j]);
                        }
                        v = Math.Sqrt(v);
                        rhi = Math.Max(rhi, v);
                        rlo = Math.Min(rlo, v);
                    }
                    if( !userlo )
                    {
                        rlo = 0;
                    }
                    if( !userhi )
                    {
                        rhi = 0;
                    }
                    return;
                }
                
                //
                // Solve problem with SLP (sequential LP) approach; this approach
                // is much faster than NLP, but often fails for MI and MC (for MZ
                // it performs well enough).
                //
                // REFERENCE: "On a sequential linear programming approach to finding
                //            the smallest circumscribed, largest inscribed, and minimum
                //            zone circle or sphere", Helmuth Spath and G.A.Watson
                //
                if( solvertype==2 )
                {
                    cmatrix = new double[cpr*npoints, nx+3];
                    ct = new int[cpr*npoints];
                    prevc = new double[nx];
                    minbleic.minbleiccreate(nx+2, pcr, blcstate, _params);
                    minbleic.minbleicsetscale(blcstate, scr, _params);
                    minbleic.minbleicsetbc(blcstate, bl, bu, _params);
                    minbleic.minbleicsetcond(blcstate, 0, 0, epsx, maxits, _params);
                    for(outeridx=0; outeridx<=maxouterits-1; outeridx++)
                    {
                        
                        //
                        // Prepare initial point for algorithm; center coordinates at
                        // PCR are used to calculate RLo/RHi and update PCR with them.
                        //
                        rlo = math.maxrealnumber;
                        rhi = 0;
                        for(i=0; i<=npoints-1; i++)
                        {
                            v = 0;
                            for(j=0; j<=nx-1; j++)
                            {
                                v = v+math.sqr(xy[i,j]-pcr[j]);
                            }
                            v = Math.Sqrt(v);
                            rhi = Math.Max(rhi, v);
                            rlo = Math.Min(rlo, v);
                        }
                        pcr[nx+0] = rlo*0.99999;
                        pcr[nx+1] = rhi/0.99999;
                        
                        //
                        // Generate matrix of linear constraints
                        //
                        for(i=0; i<=npoints-1; i++)
                        {
                            v = 0;
                            for(j=0; j<=nx-1; j++)
                            {
                                v = v+math.sqr(xy[i,j]);
                            }
                            bi = -(v/2);
                            suboffset = 0;
                            if( userhi )
                            {
                                dstrow = cpr*i+suboffset;
                                for(j=0; j<=nx-1; j++)
                                {
                                    cmatrix[dstrow,j] = pcr[j]/2-xy[i,j];
                                }
                                cmatrix[dstrow,nx+0] = 0;
                                cmatrix[dstrow,nx+1] = -(rhi/2);
                                cmatrix[dstrow,nx+2] = bi;
                                ct[dstrow] = -1;
                                apserv.inc(ref suboffset, _params);
                            }
                            if( userlo )
                            {
                                dstrow = cpr*i+suboffset;
                                for(j=0; j<=nx-1; j++)
                                {
                                    cmatrix[dstrow,j] = -(pcr[j]/2-xy[i,j]);
                                }
                                cmatrix[dstrow,nx+0] = rlo/2;
                                cmatrix[dstrow,nx+1] = 0;
                                cmatrix[dstrow,nx+2] = -bi;
                                ct[dstrow] = -1;
                                apserv.inc(ref suboffset, _params);
                            }
                            alglib.ap.assert(suboffset==cpr);
                        }
                        
                        //
                        // Solve LP subproblem with MinBLEIC
                        //
                        for(j=0; j<=nx-1; j++)
                        {
                            prevc[j] = pcr[j];
                        }
                        minbleic.minbleicsetlc(blcstate, cmatrix, ct, cpr*npoints, _params);
                        minbleic.minbleicrestartfrom(blcstate, pcr, _params);
                        while( minbleic.minbleiciteration(blcstate, _params) )
                        {
                            if( blcstate.needfg )
                            {
                                apserv.inc(ref rep.nfev, _params);
                                blcstate.f = vhi*blcstate.x[nx+1]-vlo*blcstate.x[nx+0];
                                for(j=0; j<=nx-1; j++)
                                {
                                    blcstate.g[j] = 0;
                                }
                                blcstate.g[nx+0] = -(1*vlo);
                                blcstate.g[nx+1] = 1*vhi;
                                continue;
                            }
                        }
                        minbleic.minbleicresults(blcstate, ref pcr, blcrep, _params);
                        alglib.ap.assert(blcrep.terminationtype>0, "FitSphereX: unexpected failure of BLEIC solver");
                        rep.iterationscount = rep.iterationscount+blcrep.iterationscount;
                        
                        //
                        // Terminate iterations early if we converged
                        //
                        v = 0;
                        for(j=0; j<=nx-1; j++)
                        {
                            v = v+math.sqr(prevc[j]-pcr[j]);
                        }
                        v = Math.Sqrt(v);
                        if( (double)(v)<=(double)(epsx) )
                        {
                            break;
                        }
                    }
                    
                    //
                    // Offload center coordinates from PCR to CX,
                    // re-calculate exact value of RLo/RHi using CX.
                    //
                    for(j=0; j<=nx-1; j++)
                    {
                        cx[j] = pcr[j];
                    }
                    rlo = math.maxrealnumber;
                    rhi = 0;
                    for(i=0; i<=npoints-1; i++)
                    {
                        v = 0;
                        for(j=0; j<=nx-1; j++)
                        {
                            v = v+math.sqr(xy[i,j]-cx[j]);
                        }
                        v = Math.Sqrt(v);
                        rhi = Math.Max(rhi, v);
                        rlo = Math.Min(rlo, v);
                    }
                    if( !userlo )
                    {
                        rlo = 0;
                    }
                    if( !userhi )
                    {
                        rhi = 0;
                    }
                    return;
                }
                
                //
                // Oooops...!
                //
                alglib.ap.assert(false, "FitSphereX: integrity check failed");
            }
        }


    }
    public class parametric
    {
        /*************************************************************************
        Parametric spline inteprolant: 2-dimensional curve.

        You should not try to access its members directly - use PSpline2XXXXXXXX()
        functions instead.
        *************************************************************************/
        public class pspline2interpolant : apobject
        {
            public int n;
            public bool periodic;
            public double[] p;
            public spline1d.spline1dinterpolant x;
            public spline1d.spline1dinterpolant y;
            public pspline2interpolant()
            {
                init();
            }
            public override void init()
            {
                p = new double[0];
                x = new spline1d.spline1dinterpolant();
                y = new spline1d.spline1dinterpolant();
            }
            public override alglib.apobject make_copy()
            {
                pspline2interpolant _result = new pspline2interpolant();
                _result.n = n;
                _result.periodic = periodic;
                _result.p = (double[])p.Clone();
                _result.x = (spline1d.spline1dinterpolant)x.make_copy();
                _result.y = (spline1d.spline1dinterpolant)y.make_copy();
                return _result;
            }
        };


        /*************************************************************************
        Parametric spline inteprolant: 3-dimensional curve.

        You should not try to access its members directly - use PSpline3XXXXXXXX()
        functions instead.
        *************************************************************************/
        public class pspline3interpolant : apobject
        {
            public int n;
            public bool periodic;
            public double[] p;
            public spline1d.spline1dinterpolant x;
            public spline1d.spline1dinterpolant y;
            public spline1d.spline1dinterpolant z;
            public pspline3interpolant()
            {
                init();
            }
            public override void init()
            {
                p = new double[0];
                x = new spline1d.spline1dinterpolant();
                y = new spline1d.spline1dinterpolant();
                z = new spline1d.spline1dinterpolant();
            }
            public override alglib.apobject make_copy()
            {
                pspline3interpolant _result = new pspline3interpolant();
                _result.n = n;
                _result.periodic = periodic;
                _result.p = (double[])p.Clone();
                _result.x = (spline1d.spline1dinterpolant)x.make_copy();
                _result.y = (spline1d.spline1dinterpolant)y.make_copy();
                _result.z = (spline1d.spline1dinterpolant)z.make_copy();
                return _result;
            }
        };




        /*************************************************************************
        This function  builds  non-periodic 2-dimensional parametric spline  which
        starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).

        INPUT PARAMETERS:
            XY  -   points, array[0..N-1,0..1].
                    XY[I,0:1] corresponds to the Ith point.
                    Order of points is important!
            N   -   points count, N>=5 for Akima splines, N>=2 for other types  of
                    splines.
            ST  -   spline type:
                    * 0     Akima spline
                    * 1     parabolically terminated Catmull-Rom spline (Tension=0)
                    * 2     parabolically terminated cubic spline
            PT  -   parameterization type:
                    * 0     uniform
                    * 1     chord length
                    * 2     centripetal

        OUTPUT PARAMETERS:
            P   -   parametric spline interpolant


        NOTES:
        * this function  assumes  that  there all consequent points  are distinct.
          I.e. (x0,y0)<>(x1,y1),  (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so on.
          However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
          =(x2,y2).

          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline2build(double[,] xy,
            int n,
            int st,
            int pt,
            pspline2interpolant p,
            alglib.xparams _params)
        {
            double[] tmp = new double[0];
            int i_ = 0;

            xy = (double[,])xy.Clone();

            alglib.ap.assert(st>=0 && st<=2, "PSpline2Build: incorrect spline type!");
            alglib.ap.assert(pt>=0 && pt<=2, "PSpline2Build: incorrect parameterization type!");
            if( st==0 )
            {
                alglib.ap.assert(n>=5, "PSpline2Build: N<5 (minimum value for Akima splines)!");
            }
            else
            {
                alglib.ap.assert(n>=2, "PSpline2Build: N<2!");
            }
            
            //
            // Prepare
            //
            p.n = n;
            p.periodic = false;
            tmp = new double[n];
            
            //
            // Build parameterization, check that all parameters are distinct
            //
            pspline2par(xy, n, pt, ref p.p, _params);
            alglib.ap.assert(apserv.aredistinct(p.p, n, _params), "PSpline2Build: consequent points are too close!");
            
            //
            // Build splines
            //
            if( st==0 )
            {
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,0];
                }
                spline1d.spline1dbuildakima(p.p, tmp, n, p.x, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,1];
                }
                spline1d.spline1dbuildakima(p.p, tmp, n, p.y, _params);
            }
            if( st==1 )
            {
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,0];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.x, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,1];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.y, _params);
            }
            if( st==2 )
            {
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,0];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, 0.0, p.x, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,1];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, 0.0, p.y, _params);
            }
        }


        /*************************************************************************
        This function  builds  non-periodic 3-dimensional parametric spline  which
        starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).

        Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
        description here.

          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline3build(double[,] xy,
            int n,
            int st,
            int pt,
            pspline3interpolant p,
            alglib.xparams _params)
        {
            double[] tmp = new double[0];
            int i_ = 0;

            xy = (double[,])xy.Clone();

            alglib.ap.assert(st>=0 && st<=2, "PSpline3Build: incorrect spline type!");
            alglib.ap.assert(pt>=0 && pt<=2, "PSpline3Build: incorrect parameterization type!");
            if( st==0 )
            {
                alglib.ap.assert(n>=5, "PSpline3Build: N<5 (minimum value for Akima splines)!");
            }
            else
            {
                alglib.ap.assert(n>=2, "PSpline3Build: N<2!");
            }
            
            //
            // Prepare
            //
            p.n = n;
            p.periodic = false;
            tmp = new double[n];
            
            //
            // Build parameterization, check that all parameters are distinct
            //
            pspline3par(xy, n, pt, ref p.p, _params);
            alglib.ap.assert(apserv.aredistinct(p.p, n, _params), "PSpline3Build: consequent points are too close!");
            
            //
            // Build splines
            //
            if( st==0 )
            {
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,0];
                }
                spline1d.spline1dbuildakima(p.p, tmp, n, p.x, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,1];
                }
                spline1d.spline1dbuildakima(p.p, tmp, n, p.y, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,2];
                }
                spline1d.spline1dbuildakima(p.p, tmp, n, p.z, _params);
            }
            if( st==1 )
            {
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,0];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.x, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,1];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.y, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,2];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n, 0, 0.0, p.z, _params);
            }
            if( st==2 )
            {
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,0];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, 0.0, p.x, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,1];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, 0.0, p.y, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    tmp[i_] = xy[i_,2];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n, 0, 0.0, 0, 0.0, p.z, _params);
            }
        }


        /*************************************************************************
        This  function  builds  periodic  2-dimensional  parametric  spline  which
        starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
        back to (X[0],Y[0]).

        INPUT PARAMETERS:
            XY  -   points, array[0..N-1,0..1].
                    XY[I,0:1] corresponds to the Ith point.
                    XY[N-1,0:1] must be different from XY[0,0:1].
                    Order of points is important!
            N   -   points count, N>=3 for other types of splines.
            ST  -   spline type:
                    * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
                    * 2     cubic spline with cyclic boundary conditions
            PT  -   parameterization type:
                    * 0     uniform
                    * 1     chord length
                    * 2     centripetal

        OUTPUT PARAMETERS:
            P   -   parametric spline interpolant


        NOTES:
        * this function  assumes  that there all consequent points  are  distinct.
          I.e. (x0,y0)<>(x1,y1), (x1,y1)<>(x2,y2),  (x2,y2)<>(x3,y3)  and  so  on.
          However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
          =(x2,y2).
        * last point of sequence is NOT equal to the first  point.  You  shouldn't
          make curve "explicitly periodic" by making them equal.

          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline2buildperiodic(double[,] xy,
            int n,
            int st,
            int pt,
            pspline2interpolant p,
            alglib.xparams _params)
        {
            double[,] xyp = new double[0,0];
            double[] tmp = new double[0];
            int i_ = 0;

            xy = (double[,])xy.Clone();

            alglib.ap.assert(st>=1 && st<=2, "PSpline2BuildPeriodic: incorrect spline type!");
            alglib.ap.assert(pt>=0 && pt<=2, "PSpline2BuildPeriodic: incorrect parameterization type!");
            alglib.ap.assert(n>=3, "PSpline2BuildPeriodic: N<3!");
            
            //
            // Prepare
            //
            p.n = n;
            p.periodic = true;
            tmp = new double[n+1];
            xyp = new double[n+1, 2];
            for(i_=0; i_<=n-1;i_++)
            {
                xyp[i_,0] = xy[i_,0];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                xyp[i_,1] = xy[i_,1];
            }
            for(i_=0; i_<=1;i_++)
            {
                xyp[n,i_] = xy[0,i_];
            }
            
            //
            // Build parameterization, check that all parameters are distinct
            //
            pspline2par(xyp, n+1, pt, ref p.p, _params);
            alglib.ap.assert(apserv.aredistinct(p.p, n+1, _params), "PSpline2BuildPeriodic: consequent (or first and last) points are too close!");
            
            //
            // Build splines
            //
            if( st==1 )
            {
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,0];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n+1, -1, 0.0, p.x, _params);
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,1];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n+1, -1, 0.0, p.y, _params);
            }
            if( st==2 )
            {
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,0];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n+1, -1, 0.0, -1, 0.0, p.x, _params);
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,1];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n+1, -1, 0.0, -1, 0.0, p.y, _params);
            }
        }


        /*************************************************************************
        This  function  builds  periodic  3-dimensional  parametric  spline  which
        starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
        and then back to (X[0],Y[0],Z[0]).

        Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
        description here.

          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline3buildperiodic(double[,] xy,
            int n,
            int st,
            int pt,
            pspline3interpolant p,
            alglib.xparams _params)
        {
            double[,] xyp = new double[0,0];
            double[] tmp = new double[0];
            int i_ = 0;

            xy = (double[,])xy.Clone();

            alglib.ap.assert(st>=1 && st<=2, "PSpline3BuildPeriodic: incorrect spline type!");
            alglib.ap.assert(pt>=0 && pt<=2, "PSpline3BuildPeriodic: incorrect parameterization type!");
            alglib.ap.assert(n>=3, "PSpline3BuildPeriodic: N<3!");
            
            //
            // Prepare
            //
            p.n = n;
            p.periodic = true;
            tmp = new double[n+1];
            xyp = new double[n+1, 3];
            for(i_=0; i_<=n-1;i_++)
            {
                xyp[i_,0] = xy[i_,0];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                xyp[i_,1] = xy[i_,1];
            }
            for(i_=0; i_<=n-1;i_++)
            {
                xyp[i_,2] = xy[i_,2];
            }
            for(i_=0; i_<=2;i_++)
            {
                xyp[n,i_] = xy[0,i_];
            }
            
            //
            // Build parameterization, check that all parameters are distinct
            //
            pspline3par(xyp, n+1, pt, ref p.p, _params);
            alglib.ap.assert(apserv.aredistinct(p.p, n+1, _params), "PSplineBuild2Periodic: consequent (or first and last) points are too close!");
            
            //
            // Build splines
            //
            if( st==1 )
            {
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,0];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n+1, -1, 0.0, p.x, _params);
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,1];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n+1, -1, 0.0, p.y, _params);
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,2];
                }
                spline1d.spline1dbuildcatmullrom(p.p, tmp, n+1, -1, 0.0, p.z, _params);
            }
            if( st==2 )
            {
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,0];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n+1, -1, 0.0, -1, 0.0, p.x, _params);
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,1];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n+1, -1, 0.0, -1, 0.0, p.y, _params);
                for(i_=0; i_<=n;i_++)
                {
                    tmp[i_] = xyp[i_,2];
                }
                spline1d.spline1dbuildcubic(p.p, tmp, n+1, -1, 0.0, -1, 0.0, p.z, _params);
            }
        }


        /*************************************************************************
        This function returns vector of parameter values correspoding to points.

        I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
        have
            (X[0],Y[0]) = PSpline2Calc(P,U[0]),
            (X[1],Y[1]) = PSpline2Calc(P,U[1]),
            (X[2],Y[2]) = PSpline2Calc(P,U[2]),
            ...

        INPUT PARAMETERS:
            P   -   parametric spline interpolant

        OUTPUT PARAMETERS:
            N   -   array size
            T   -   array[0..N-1]


        NOTES:
        * for non-periodic splines U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]=1
        * for periodic splines     U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]<1

          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline2parametervalues(pspline2interpolant p,
            ref int n,
            ref double[] t,
            alglib.xparams _params)
        {
            int i_ = 0;

            n = 0;
            t = new double[0];

            alglib.ap.assert(p.n>=2, "PSpline2ParameterValues: internal error!");
            n = p.n;
            t = new double[n];
            for(i_=0; i_<=n-1;i_++)
            {
                t[i_] = p.p[i_];
            }
            t[0] = 0;
            if( !p.periodic )
            {
                t[n-1] = 1;
            }
        }


        /*************************************************************************
        This function returns vector of parameter values correspoding to points.

        Same as PSpline2ParameterValues(), but for 3D.

          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline3parametervalues(pspline3interpolant p,
            ref int n,
            ref double[] t,
            alglib.xparams _params)
        {
            int i_ = 0;

            n = 0;
            t = new double[0];

            alglib.ap.assert(p.n>=2, "PSpline3ParameterValues: internal error!");
            n = p.n;
            t = new double[n];
            for(i_=0; i_<=n-1;i_++)
            {
                t[i_] = p.p[i_];
            }
            t[0] = 0;
            if( !p.periodic )
            {
                t[n-1] = 1;
            }
        }


        /*************************************************************************
        This function  calculates  the value of the parametric spline for a  given
        value of parameter T

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            T   -   point:
                    * T in [0,1] corresponds to interval spanned by points
                    * for non-periodic splines T<0 (or T>1) correspond to parts of
                      the curve before the first (after the last) point
                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                      by making T=T-floor(T).

        OUTPUT PARAMETERS:
            X   -   X-position
            Y   -   Y-position


          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline2calc(pspline2interpolant p,
            double t,
            ref double x,
            ref double y,
            alglib.xparams _params)
        {
            x = 0;
            y = 0;

            if( p.periodic )
            {
                t = t-(int)Math.Floor(t);
            }
            x = spline1d.spline1dcalc(p.x, t, _params);
            y = spline1d.spline1dcalc(p.y, t, _params);
        }


        /*************************************************************************
        This function  calculates  the value of the parametric spline for a  given
        value of parameter T.

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            T   -   point:
                    * T in [0,1] corresponds to interval spanned by points
                    * for non-periodic splines T<0 (or T>1) correspond to parts of
                      the curve before the first (after the last) point
                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                      by making T=T-floor(T).

        OUTPUT PARAMETERS:
            X   -   X-position
            Y   -   Y-position
            Z   -   Z-position


          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline3calc(pspline3interpolant p,
            double t,
            ref double x,
            ref double y,
            ref double z,
            alglib.xparams _params)
        {
            x = 0;
            y = 0;
            z = 0;

            if( p.periodic )
            {
                t = t-(int)Math.Floor(t);
            }
            x = spline1d.spline1dcalc(p.x, t, _params);
            y = spline1d.spline1dcalc(p.y, t, _params);
            z = spline1d.spline1dcalc(p.z, t, _params);
        }


        /*************************************************************************
        This function  calculates  tangent vector for a given value of parameter T

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            T   -   point:
                    * T in [0,1] corresponds to interval spanned by points
                    * for non-periodic splines T<0 (or T>1) correspond to parts of
                      the curve before the first (after the last) point
                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                      by making T=T-floor(T).

        OUTPUT PARAMETERS:
            X    -   X-component of tangent vector (normalized)
            Y    -   Y-component of tangent vector (normalized)
            
        NOTE:
            X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.


          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline2tangent(pspline2interpolant p,
            double t,
            ref double x,
            ref double y,
            alglib.xparams _params)
        {
            double v = 0;
            double v0 = 0;
            double v1 = 0;

            x = 0;
            y = 0;

            if( p.periodic )
            {
                t = t-(int)Math.Floor(t);
            }
            pspline2diff(p, t, ref v0, ref x, ref v1, ref y, _params);
            if( (double)(x)!=(double)(0) || (double)(y)!=(double)(0) )
            {
                
                //
                // this code is a bit more complex than X^2+Y^2 to avoid
                // overflow for large values of X and Y.
                //
                v = apserv.safepythag2(x, y, _params);
                x = x/v;
                y = y/v;
            }
        }


        /*************************************************************************
        This function  calculates  tangent vector for a given value of parameter T

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            T   -   point:
                    * T in [0,1] corresponds to interval spanned by points
                    * for non-periodic splines T<0 (or T>1) correspond to parts of
                      the curve before the first (after the last) point
                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                      by making T=T-floor(T).

        OUTPUT PARAMETERS:
            X    -   X-component of tangent vector (normalized)
            Y    -   Y-component of tangent vector (normalized)
            Z    -   Z-component of tangent vector (normalized)

        NOTE:
            X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.


          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline3tangent(pspline3interpolant p,
            double t,
            ref double x,
            ref double y,
            ref double z,
            alglib.xparams _params)
        {
            double v = 0;
            double v0 = 0;
            double v1 = 0;
            double v2 = 0;

            x = 0;
            y = 0;
            z = 0;

            if( p.periodic )
            {
                t = t-(int)Math.Floor(t);
            }
            pspline3diff(p, t, ref v0, ref x, ref v1, ref y, ref v2, ref z, _params);
            if( ((double)(x)!=(double)(0) || (double)(y)!=(double)(0)) || (double)(z)!=(double)(0) )
            {
                v = apserv.safepythag3(x, y, z, _params);
                x = x/v;
                y = y/v;
                z = z/v;
            }
        }


        /*************************************************************************
        This function calculates derivative, i.e. it returns (dX/dT,dY/dT).

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            T   -   point:
                    * T in [0,1] corresponds to interval spanned by points
                    * for non-periodic splines T<0 (or T>1) correspond to parts of
                      the curve before the first (after the last) point
                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                      by making T=T-floor(T).

        OUTPUT PARAMETERS:
            X   -   X-value
            DX  -   X-derivative
            Y   -   Y-value
            DY  -   Y-derivative


          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline2diff(pspline2interpolant p,
            double t,
            ref double x,
            ref double dx,
            ref double y,
            ref double dy,
            alglib.xparams _params)
        {
            double d2s = 0;

            x = 0;
            dx = 0;
            y = 0;
            dy = 0;

            if( p.periodic )
            {
                t = t-(int)Math.Floor(t);
            }
            spline1d.spline1ddiff(p.x, t, ref x, ref dx, ref d2s, _params);
            spline1d.spline1ddiff(p.y, t, ref y, ref dy, ref d2s, _params);
        }


        /*************************************************************************
        This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            T   -   point:
                    * T in [0,1] corresponds to interval spanned by points
                    * for non-periodic splines T<0 (or T>1) correspond to parts of
                      the curve before the first (after the last) point
                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                      by making T=T-floor(T).

        OUTPUT PARAMETERS:
            X   -   X-value
            DX  -   X-derivative
            Y   -   Y-value
            DY  -   Y-derivative
            Z   -   Z-value
            DZ  -   Z-derivative


          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline3diff(pspline3interpolant p,
            double t,
            ref double x,
            ref double dx,
            ref double y,
            ref double dy,
            ref double z,
            ref double dz,
            alglib.xparams _params)
        {
            double d2s = 0;

            x = 0;
            dx = 0;
            y = 0;
            dy = 0;
            z = 0;
            dz = 0;

            if( p.periodic )
            {
                t = t-(int)Math.Floor(t);
            }
            spline1d.spline1ddiff(p.x, t, ref x, ref dx, ref d2s, _params);
            spline1d.spline1ddiff(p.y, t, ref y, ref dy, ref d2s, _params);
            spline1d.spline1ddiff(p.z, t, ref z, ref dz, ref d2s, _params);
        }


        /*************************************************************************
        This function calculates first and second derivative with respect to T.

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            T   -   point:
                    * T in [0,1] corresponds to interval spanned by points
                    * for non-periodic splines T<0 (or T>1) correspond to parts of
                      the curve before the first (after the last) point
                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                      by making T=T-floor(T).

        OUTPUT PARAMETERS:
            X   -   X-value
            DX  -   derivative
            D2X -   second derivative
            Y   -   Y-value
            DY  -   derivative
            D2Y -   second derivative


          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline2diff2(pspline2interpolant p,
            double t,
            ref double x,
            ref double dx,
            ref double d2x,
            ref double y,
            ref double dy,
            ref double d2y,
            alglib.xparams _params)
        {
            x = 0;
            dx = 0;
            d2x = 0;
            y = 0;
            dy = 0;
            d2y = 0;

            if( p.periodic )
            {
                t = t-(int)Math.Floor(t);
            }
            spline1d.spline1ddiff(p.x, t, ref x, ref dx, ref d2x, _params);
            spline1d.spline1ddiff(p.y, t, ref y, ref dy, ref d2y, _params);
        }


        /*************************************************************************
        This function calculates first and second derivative with respect to T.

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            T   -   point:
                    * T in [0,1] corresponds to interval spanned by points
                    * for non-periodic splines T<0 (or T>1) correspond to parts of
                      the curve before the first (after the last) point
                    * for periodic splines T<0 (or T>1) are projected  into  [0,1]
                      by making T=T-floor(T).

        OUTPUT PARAMETERS:
            X   -   X-value
            DX  -   derivative
            D2X -   second derivative
            Y   -   Y-value
            DY  -   derivative
            D2Y -   second derivative
            Z   -   Z-value
            DZ  -   derivative
            D2Z -   second derivative


          -- ALGLIB PROJECT --
             Copyright 28.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void pspline3diff2(pspline3interpolant p,
            double t,
            ref double x,
            ref double dx,
            ref double d2x,
            ref double y,
            ref double dy,
            ref double d2y,
            ref double z,
            ref double dz,
            ref double d2z,
            alglib.xparams _params)
        {
            x = 0;
            dx = 0;
            d2x = 0;
            y = 0;
            dy = 0;
            d2y = 0;
            z = 0;
            dz = 0;
            d2z = 0;

            if( p.periodic )
            {
                t = t-(int)Math.Floor(t);
            }
            spline1d.spline1ddiff(p.x, t, ref x, ref dx, ref d2x, _params);
            spline1d.spline1ddiff(p.y, t, ref y, ref dy, ref d2y, _params);
            spline1d.spline1ddiff(p.z, t, ref z, ref dz, ref d2z, _params);
        }


        /*************************************************************************
        This function  calculates  arc length, i.e. length of  curve  between  t=a
        and t=b.

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            A,B -   parameter values corresponding to arc ends:
                    * B>A will result in positive length returned
                    * B<A will result in negative length returned

        RESULT:
            length of arc starting at T=A and ending at T=B.


          -- ALGLIB PROJECT --
             Copyright 30.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static double pspline2arclength(pspline2interpolant p,
            double a,
            double b,
            alglib.xparams _params)
        {
            double result = 0;
            autogk.autogkstate state = new autogk.autogkstate();
            autogk.autogkreport rep = new autogk.autogkreport();
            double sx = 0;
            double dsx = 0;
            double d2sx = 0;
            double sy = 0;
            double dsy = 0;
            double d2sy = 0;

            autogk.autogksmooth(a, b, state, _params);
            while( autogk.autogkiteration(state, _params) )
            {
                spline1d.spline1ddiff(p.x, state.x, ref sx, ref dsx, ref d2sx, _params);
                spline1d.spline1ddiff(p.y, state.x, ref sy, ref dsy, ref d2sy, _params);
                state.f = apserv.safepythag2(dsx, dsy, _params);
            }
            autogk.autogkresults(state, ref result, rep, _params);
            alglib.ap.assert(rep.terminationtype>0, "PSpline2ArcLength: internal error!");
            return result;
        }


        /*************************************************************************
        This function  calculates  arc length, i.e. length of  curve  between  t=a
        and t=b.

        INPUT PARAMETERS:
            P   -   parametric spline interpolant
            A,B -   parameter values corresponding to arc ends:
                    * B>A will result in positive length returned
                    * B<A will result in negative length returned

        RESULT:
            length of arc starting at T=A and ending at T=B.


          -- ALGLIB PROJECT --
             Copyright 30.05.2010 by Bochkanov Sergey
        *************************************************************************/
        public static double pspline3arclength(pspline3interpolant p,
            double a,
            double b,
            alglib.xparams _params)
        {
            double result = 0;
            autogk.autogkstate state = new autogk.autogkstate();
            autogk.autogkreport rep = new autogk.autogkreport();
            double sx = 0;
            double dsx = 0;
            double d2sx = 0;
            double sy = 0;
            double dsy = 0;
            double d2sy = 0;
            double sz = 0;
            double dsz = 0;
            double d2sz = 0;

            autogk.autogksmooth(a, b, state, _params);
            while( autogk.autogkiteration(state, _params) )
            {
                spline1d.spline1ddiff(p.x, state.x, ref sx, ref dsx, ref d2sx, _params);
                spline1d.spline1ddiff(p.y, state.x, ref sy, ref dsy, ref d2sy, _params);
                spline1d.spline1ddiff(p.z, state.x, ref sz, ref dsz, ref d2sz, _params);
                state.f = apserv.safepythag3(dsx, dsy, dsz, _params);
            }
            autogk.autogkresults(state, ref result, rep, _params);
            alglib.ap.assert(rep.terminationtype>0, "PSpline3ArcLength: internal error!");
            return result;
        }


        /*************************************************************************
        This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
        Peucker algorithm. This  function  performs PARAMETRIC fit, i.e. it can be
        used to fit curves like circles.

        On  input  it  accepts dataset which describes parametric multidimensional
        curve X(t), with X being vector, and t taking values in [0,N), where N  is
        a number of points in dataset. As result, it returns reduced  dataset  X2,
        which can be used to build  parametric  curve  X2(t),  which  approximates
        X(t) with desired precision (or has specified number of sections).


        INPUT PARAMETERS:
            X       -   array of multidimensional points:
                        * at least N elements, leading N elements are used if more
                          than N elements were specified
                        * order of points is IMPORTANT because  it  is  parametric
                          fit
                        * each row of array is one point which has D coordinates
            N       -   number of elements in X
            D       -   number of dimensions (elements per row of X)
            StopM   -   stopping condition - desired number of sections:
                        * at most M sections are generated by this function
                        * less than M sections can be generated if we have N<M
                          (or some X are non-distinct).
                        * zero StopM means that algorithm does not stop after
                          achieving some pre-specified section count
            StopEps -   stopping condition - desired precision:
                        * algorithm stops after error in each section is at most Eps
                        * zero Eps means that algorithm does not stop after
                          achieving some pre-specified precision

        OUTPUT PARAMETERS:
            X2      -   array of corner points for piecewise approximation,
                        has length NSections+1 or zero (for NSections=0).
            Idx2    -   array of indexes (parameter values):
                        * has length NSections+1 or zero (for NSections=0).
                        * each element of Idx2 corresponds to same-numbered
                          element of X2
                        * each element of Idx2 is index of  corresponding  element
                          of X2 at original array X, i.e. I-th  row  of  X2  is
                          Idx2[I]-th row of X.
                        * elements of Idx2 can be treated as parameter values
                          which should be used when building new parametric curve
                        * Idx2[0]=0, Idx2[NSections]=N-1
            NSections-  number of sections found by algorithm, NSections<=M,
                        NSections can be zero for degenerate datasets
                        (N<=1 or all X[] are non-distinct).

        NOTE: algorithm stops after:
              a) dividing curve into StopM sections 
              b) achieving required precision StopEps
              c) dividing curve into N-1 sections
              If both StopM and StopEps are non-zero, algorithm is stopped by  the
              FIRST criterion which is satisfied. In case both StopM  and  StopEps
              are zero, algorithm stops because of (c).
                        
          -- ALGLIB --
             Copyright 02.10.2014 by Bochkanov Sergey
        *************************************************************************/
        public static void parametricrdpfixed(double[,] x,
            int n,
            int d,
            int stopm,
            double stopeps,
            ref double[,] x2,
            ref int[] idx2,
            ref int nsections,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            bool allsame = new bool();
            int k0 = 0;
            int k1 = 0;
            int k2 = 0;
            double e0 = 0;
            double e1 = 0;
            int idx0 = 0;
            int idx1 = 0;
            int worstidx = 0;
            double worsterror = 0;
            double[,] sections = new double[0,0];
            double[] heaperrors = new double[0];
            int[] heaptags = new int[0];
            double[] buf0 = new double[0];
            double[] buf1 = new double[0];

            x2 = new double[0,0];
            idx2 = new int[0];
            nsections = 0;

            alglib.ap.assert(n>=0, "LSTFitPiecewiseLinearParametricRDP: N<0");
            alglib.ap.assert(d>=1, "LSTFitPiecewiseLinearParametricRDP: D<=0");
            alglib.ap.assert(stopm>=0, "LSTFitPiecewiseLinearParametricRDP: StopM<1");
            alglib.ap.assert(math.isfinite(stopeps) && (double)(stopeps)>=(double)(0), "LSTFitPiecewiseLinearParametricRDP: StopEps<0 or is infinite");
            alglib.ap.assert(alglib.ap.rows(x)>=n, "LSTFitPiecewiseLinearParametricRDP: Rows(X)<N");
            alglib.ap.assert(alglib.ap.cols(x)>=d, "LSTFitPiecewiseLinearParametricRDP: Cols(X)<D");
            alglib.ap.assert(apserv.apservisfinitematrix(x, n, d, _params), "LSTFitPiecewiseLinearParametricRDP: X contains infinite/NAN values");
            
            //
            // Handle degenerate cases
            //
            if( n<=1 )
            {
                nsections = 0;
                return;
            }
            allsame = true;
            for(i=1; i<=n-1; i++)
            {
                for(j=0; j<=d-1; j++)
                {
                    allsame = allsame && (double)(x[i,j])==(double)(x[0,j]);
                }
            }
            if( allsame )
            {
                nsections = 0;
                return;
            }
            
            //
            // Prepare first section
            //
            rdpanalyzesectionpar(x, 0, n-1, d, ref worstidx, ref worsterror, _params);
            sections = new double[n, 4];
            heaperrors = new double[n];
            heaptags = new int[n];
            nsections = 1;
            sections[0,0] = 0;
            sections[0,1] = n-1;
            sections[0,2] = worstidx;
            sections[0,3] = worsterror;
            heaperrors[0] = worsterror;
            heaptags[0] = 0;
            alglib.ap.assert((double)(sections[0,1])==(double)(n-1), "RDP algorithm: integrity check failed");
            
            //
            // Main loop.
            // Repeatedly find section with worst error and divide it.
            // Terminate after M-th section, or because of other reasons (see loop internals).
            //
            while( true )
            {
                
                //
                // Break loop if one of the stopping conditions was met.
                // Store index of worst section to K.
                //
                if( (double)(heaperrors[0])==(double)(0) )
                {
                    break;
                }
                if( (double)(stopeps)>(double)(0) && (double)(heaperrors[0])<=(double)(stopeps) )
                {
                    break;
                }
                if( stopm>0 && nsections>=stopm )
                {
                    break;
                }
                k = heaptags[0];
                
                //
                // K-th section is divided in two:
                // * first  one spans interval from X[Sections[K,0]] to X[Sections[K,2]]
                // * second one spans interval from X[Sections[K,2]] to X[Sections[K,1]]
                //
                // First section is stored at K-th position, second one is appended to the table.
                // Then we update heap which stores pairs of (error,section_index)
                //
                k0 = (int)Math.Round(sections[k,0]);
                k1 = (int)Math.Round(sections[k,1]);
                k2 = (int)Math.Round(sections[k,2]);
                rdpanalyzesectionpar(x, k0, k2, d, ref idx0, ref e0, _params);
                rdpanalyzesectionpar(x, k2, k1, d, ref idx1, ref e1, _params);
                sections[k,0] = k0;
                sections[k,1] = k2;
                sections[k,2] = idx0;
                sections[k,3] = e0;
                tsort.tagheapreplacetopi(ref heaperrors, ref heaptags, nsections, e0, k, _params);
                sections[nsections,0] = k2;
                sections[nsections,1] = k1;
                sections[nsections,2] = idx1;
                sections[nsections,3] = e1;
                tsort.tagheappushi(ref heaperrors, ref heaptags, ref nsections, e1, nsections, _params);
            }
            
            //
            // Convert from sections to indexes
            //
            buf0 = new double[nsections+1];
            for(i=0; i<=nsections-1; i++)
            {
                buf0[i] = (int)Math.Round(sections[i,0]);
            }
            buf0[nsections] = n-1;
            tsort.tagsortfast(ref buf0, ref buf1, nsections+1, _params);
            idx2 = new int[nsections+1];
            for(i=0; i<=nsections; i++)
            {
                idx2[i] = (int)Math.Round(buf0[i]);
            }
            alglib.ap.assert(idx2[0]==0, "RDP algorithm: integrity check failed");
            alglib.ap.assert(idx2[nsections]==n-1, "RDP algorithm: integrity check failed");
            
            //
            // Output sections:
            // * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
            // * last element of X2/Y2 is filled by right boundary of rightmost section
            // * X2/Y2 is sorted by ascending of X2
            //
            x2 = new double[nsections+1, d];
            for(i=0; i<=nsections; i++)
            {
                for(j=0; j<=d-1; j++)
                {
                    x2[i,j] = x[idx2[i],j];
                }
            }
        }


        /*************************************************************************
        Builds non-periodic parameterization for 2-dimensional spline
        *************************************************************************/
        private static void pspline2par(double[,] xy,
            int n,
            int pt,
            ref double[] p,
            alglib.xparams _params)
        {
            double v = 0;
            int i = 0;
            int i_ = 0;

            p = new double[0];

            alglib.ap.assert(pt>=0 && pt<=2, "PSpline2Par: internal error!");
            
            //
            // Build parameterization:
            // * fill by non-normalized values
            // * normalize them so we have P[0]=0, P[N-1]=1.
            //
            p = new double[n];
            if( pt==0 )
            {
                for(i=0; i<=n-1; i++)
                {
                    p[i] = i;
                }
            }
            if( pt==1 )
            {
                p[0] = 0;
                for(i=1; i<=n-1; i++)
                {
                    p[i] = p[i-1]+apserv.safepythag2(xy[i,0]-xy[i-1,0], xy[i,1]-xy[i-1,1], _params);
                }
            }
            if( pt==2 )
            {
                p[0] = 0;
                for(i=1; i<=n-1; i++)
                {
                    p[i] = p[i-1]+Math.Sqrt(apserv.safepythag2(xy[i,0]-xy[i-1,0], xy[i,1]-xy[i-1,1], _params));
                }
            }
            v = 1/p[n-1];
            for(i_=0; i_<=n-1;i_++)
            {
                p[i_] = v*p[i_];
            }
        }


        /*************************************************************************
        Builds non-periodic parameterization for 3-dimensional spline
        *************************************************************************/
        private static void pspline3par(double[,] xy,
            int n,
            int pt,
            ref double[] p,
            alglib.xparams _params)
        {
            double v = 0;
            int i = 0;
            int i_ = 0;

            p = new double[0];

            alglib.ap.assert(pt>=0 && pt<=2, "PSpline3Par: internal error!");
            
            //
            // Build parameterization:
            // * fill by non-normalized values
            // * normalize them so we have P[0]=0, P[N-1]=1.
            //
            p = new double[n];
            if( pt==0 )
            {
                for(i=0; i<=n-1; i++)
                {
                    p[i] = i;
                }
            }
            if( pt==1 )
            {
                p[0] = 0;
                for(i=1; i<=n-1; i++)
                {
                    p[i] = p[i-1]+apserv.safepythag3(xy[i,0]-xy[i-1,0], xy[i,1]-xy[i-1,1], xy[i,2]-xy[i-1,2], _params);
                }
            }
            if( pt==2 )
            {
                p[0] = 0;
                for(i=1; i<=n-1; i++)
                {
                    p[i] = p[i-1]+Math.Sqrt(apserv.safepythag3(xy[i,0]-xy[i-1,0], xy[i,1]-xy[i-1,1], xy[i,2]-xy[i-1,2], _params));
                }
            }
            v = 1/p[n-1];
            for(i_=0; i_<=n-1;i_++)
            {
                p[i_] = v*p[i_];
            }
        }


        /*************************************************************************
        This function analyzes section of curve for processing by RDP algorithm:
        given set of points X,Y with indexes [I0,I1] it returns point with
        worst deviation from linear model (PARAMETRIC version which sees curve
        as X(t) with vector X).

        Input parameters:
            XY          -   array
            I0,I1       -   interval (boundaries included) to process
            D           -   number of dimensions
            
        OUTPUT PARAMETERS:
            WorstIdx    -   index of worst point
            WorstError  -   error at worst point
            
        NOTE: this function guarantees that it returns exactly zero for a section
              with less than 3 points.

          -- ALGLIB PROJECT --
             Copyright 02.10.2014 by Bochkanov Sergey
        *************************************************************************/
        private static void rdpanalyzesectionpar(double[,] xy,
            int i0,
            int i1,
            int d,
            ref int worstidx,
            ref double worsterror,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double v = 0;
            double d2 = 0;
            double ts = 0;
            double vv = 0;

            worstidx = 0;
            worsterror = 0;

            
            //
            // Quick exit for 0, 1, 2 points
            //
            if( i1-i0+1<3 )
            {
                worstidx = i0;
                worsterror = 0.0;
                return;
            }
            
            //
            // Estimate D2 - squared distance between XY[I1] and XY[I0].
            // In case D2=0 handle it as special case.
            //
            d2 = 0.0;
            for(j=0; j<=d-1; j++)
            {
                d2 = d2+math.sqr(xy[i1,j]-xy[i0,j]);
            }
            if( (double)(d2)==(double)(0) )
            {
                
                //
                // First and last points are equal, interval evaluation is
                // trivial - we just calculate distance from all points to
                // the first/last one.
                //
                worstidx = i0;
                worsterror = 0.0;
                for(i=i0+1; i<=i1-1; i++)
                {
                    vv = 0.0;
                    for(j=0; j<=d-1; j++)
                    {
                        v = xy[i,j]-xy[i0,j];
                        vv = vv+v*v;
                    }
                    vv = Math.Sqrt(vv);
                    if( (double)(vv)>(double)(worsterror) )
                    {
                        worsterror = vv;
                        worstidx = i;
                    }
                }
                return;
            }
            
            //
            // General case
            //
            // Current section of curve is modeled as x(t) = d*t+c, where
            //     d = XY[I1]-XY[I0]
            //     c = XY[I0]
            //     t is in [0,1]
            //
            worstidx = i0;
            worsterror = 0.0;
            for(i=i0+1; i<=i1-1; i++)
            {
                
                //
                // Determine t_s - parameter value for projected point.
                //
                ts = (double)(i-i0)/(double)(i1-i0);
                
                //
                // Estimate error norm
                //
                vv = 0.0;
                for(j=0; j<=d-1; j++)
                {
                    v = (xy[i1,j]-xy[i0,j])*ts-(xy[i,j]-xy[i0,j]);
                    vv = vv+math.sqr(v);
                }
                vv = Math.Sqrt(vv);
                if( (double)(vv)>(double)(worsterror) )
                {
                    worsterror = vv;
                    worstidx = i;
                }
            }
        }


    }
    public class rbfv1
    {
        /*************************************************************************
        Buffer object which is used to perform nearest neighbor  requests  in  the
        multithreaded mode (multiple threads working with same KD-tree object).

        This object should be created with KDTreeCreateBuffer().
        *************************************************************************/
        public class rbfv1calcbuffer : apobject
        {
            public double[] calcbufxcx;
            public double[,] calcbufx;
            public int[] calcbuftags;
            public nearestneighbor.kdtreerequestbuffer requestbuffer;
            public rbfv1calcbuffer()
            {
                init();
            }
            public override void init()
            {
                calcbufxcx = new double[0];
                calcbufx = new double[0,0];
                calcbuftags = new int[0];
                requestbuffer = new nearestneighbor.kdtreerequestbuffer();
            }
            public override alglib.apobject make_copy()
            {
                rbfv1calcbuffer _result = new rbfv1calcbuffer();
                _result.calcbufxcx = (double[])calcbufxcx.Clone();
                _result.calcbufx = (double[,])calcbufx.Clone();
                _result.calcbuftags = (int[])calcbuftags.Clone();
                _result.requestbuffer = (nearestneighbor.kdtreerequestbuffer)requestbuffer.make_copy();
                return _result;
            }
        };


        /*************************************************************************
        RBF model.

        Never try to directly work with fields of this object - always use  ALGLIB
        functions to use this object.
        *************************************************************************/
        public class rbfv1model : apobject
        {
            public int ny;
            public int nx;
            public int nc;
            public int nl;
            public nearestneighbor.kdtree tree;
            public double[,] xc;
            public double[,] wr;
            public double rmax;
            public double[,] v;
            public double[] calcbufxcx;
            public double[,] calcbufx;
            public int[] calcbuftags;
            public rbfv1model()
            {
                init();
            }
            public override void init()
            {
                tree = new nearestneighbor.kdtree();
                xc = new double[0,0];
                wr = new double[0,0];
                v = new double[0,0];
                calcbufxcx = new double[0];
                calcbufx = new double[0,0];
                calcbuftags = new int[0];
            }
            public override alglib.apobject make_copy()
            {
                rbfv1model _result = new rbfv1model();
                _result.ny = ny;
                _result.nx = nx;
                _result.nc = nc;
                _result.nl = nl;
                _result.tree = (nearestneighbor.kdtree)tree.make_copy();
                _result.xc = (double[,])xc.Clone();
                _result.wr = (double[,])wr.Clone();
                _result.rmax = rmax;
                _result.v = (double[,])v.Clone();
                _result.calcbufxcx = (double[])calcbufxcx.Clone();
                _result.calcbufx = (double[,])calcbufx.Clone();
                _result.calcbuftags = (int[])calcbuftags.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Internal buffer for GridCalc3
        *************************************************************************/
        public class gridcalc3v1buf : apobject
        {
            public double[] tx;
            public double[] cx;
            public double[] ty;
            public bool[] flag0;
            public bool[] flag1;
            public bool[] flag2;
            public bool[] flag12;
            public double[] expbuf0;
            public double[] expbuf1;
            public double[] expbuf2;
            public nearestneighbor.kdtreerequestbuffer requestbuf;
            public double[,] calcbufx;
            public int[] calcbuftags;
            public gridcalc3v1buf()
            {
                init();
            }
            public override void init()
            {
                tx = new double[0];
                cx = new double[0];
                ty = new double[0];
                flag0 = new bool[0];
                flag1 = new bool[0];
                flag2 = new bool[0];
                flag12 = new bool[0];
                expbuf0 = new double[0];
                expbuf1 = new double[0];
                expbuf2 = new double[0];
                requestbuf = new nearestneighbor.kdtreerequestbuffer();
                calcbufx = new double[0,0];
                calcbuftags = new int[0];
            }
            public override alglib.apobject make_copy()
            {
                gridcalc3v1buf _result = new gridcalc3v1buf();
                _result.tx = (double[])tx.Clone();
                _result.cx = (double[])cx.Clone();
                _result.ty = (double[])ty.Clone();
                _result.flag0 = (bool[])flag0.Clone();
                _result.flag1 = (bool[])flag1.Clone();
                _result.flag2 = (bool[])flag2.Clone();
                _result.flag12 = (bool[])flag12.Clone();
                _result.expbuf0 = (double[])expbuf0.Clone();
                _result.expbuf1 = (double[])expbuf1.Clone();
                _result.expbuf2 = (double[])expbuf2.Clone();
                _result.requestbuf = (nearestneighbor.kdtreerequestbuffer)requestbuf.make_copy();
                _result.calcbufx = (double[,])calcbufx.Clone();
                _result.calcbuftags = (int[])calcbuftags.Clone();
                return _result;
            }
        };


        /*************************************************************************
        RBF solution report:
        * TerminationType   -   termination type, positive values - success,
                                non-positive - failure.
        *************************************************************************/
        public class rbfv1report : apobject
        {
            public int arows;
            public int acols;
            public int annz;
            public int iterationscount;
            public int nmv;
            public int terminationtype;
            public rbfv1report()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                rbfv1report _result = new rbfv1report();
                _result.arows = arows;
                _result.acols = acols;
                _result.annz = annz;
                _result.iterationscount = iterationscount;
                _result.nmv = nmv;
                _result.terminationtype = terminationtype;
                return _result;
            }
        };




        public const int mxnx = 3;
        public const double rbffarradius = 6;
        public const double rbfnearradius = 2.1;
        public const double rbfmlradius = 3;
        public const double minbasecasecost = 100000;


        /*************************************************************************
        This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
        function in a NX-dimensional space (NX=2 or NX=3).

        INPUT PARAMETERS:
            NX      -   dimension of the space, NX=2 or NX=3
            NY      -   function dimension, NY>=1

        OUTPUT PARAMETERS:
            S       -   RBF model (initially equals to zero)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1create(int nx,
            int ny,
            rbfv1model s,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;

            alglib.ap.assert(nx==2 || nx==3, "RBFCreate: NX<>2 and NX<>3");
            alglib.ap.assert(ny>=1, "RBFCreate: NY<1");
            s.nx = nx;
            s.ny = ny;
            s.nl = 0;
            s.nc = 0;
            s.v = new double[ny, mxnx+1];
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=mxnx; j++)
                {
                    s.v[i,j] = 0;
                }
            }
            s.rmax = 0;
        }


        /*************************************************************************
        This function creates buffer  structure  which  can  be  used  to  perform
        parallel  RBF  model  evaluations  (with  one  RBF  model  instance  being
        used from multiple threads, as long as  different  threads  use  different
        instances of buffer).

        This buffer object can be used with  rbftscalcbuf()  function  (here  "ts"
        stands for "thread-safe", "buf" is a suffix which denotes  function  which
        reuses previously allocated output space).

        How to use it:
        * create RBF model structure with rbfcreate()
        * load data, tune parameters
        * call rbfbuildmodel()
        * call rbfcreatecalcbuffer(), once per thread working with RBF model  (you
          should call this function only AFTER call to rbfbuildmodel(), see  below
          for more information)
        * call rbftscalcbuf() from different threads,  with  each  thread  working
          with its own copy of buffer object.

        INPUT PARAMETERS
            S           -   RBF model

        OUTPUT PARAMETERS
            Buf         -   external buffer.
            
            
        IMPORTANT: buffer object should be used only with  RBF model object  which
                   was used to initialize buffer. Any attempt to use buffer   with
                   different object is dangerous - you may  get  memory  violation
                   error because sizes of internal arrays do not fit to dimensions
                   of RBF structure.
                   
        IMPORTANT: you  should  call  this function only for model which was built
                   with rbfbuildmodel() function, after successful  invocation  of
                   rbfbuildmodel().  Sizes   of   some   internal  structures  are
                   determined only after model is built, so buffer object  created
                   before model  construction  stage  will  be  useless  (and  any
                   attempt to use it will result in exception).

          -- ALGLIB --
             Copyright 02.04.2016 by Sergey Bochkanov
        *************************************************************************/
        public static void rbfv1createcalcbuffer(rbfv1model s,
            rbfv1calcbuffer buf,
            alglib.xparams _params)
        {
            nearestneighbor.kdtreecreaterequestbuffer(s.tree, buf.requestbuffer, _params);
        }


        /*************************************************************************
        This   function  builds  RBF  model  and  returns  report  (contains  some 
        information which can be used for evaluation of the algorithm properties).

        Call to this function modifies RBF model by calculating its centers/radii/
        weights  and  saving  them  into  RBFModel  structure.  Initially RBFModel 
        contain zero coefficients, but after call to this function  we  will  have
        coefficients which were calculated in order to fit our dataset.

        After you called this function you can call RBFCalc(),  RBFGridCalc()  and
        other model calculation functions.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call
            Rep     -   report:
                        * Rep.TerminationType:
                          * -5 - non-distinct basis function centers were detected,
                                 interpolation aborted
                          * -4 - nonconvergence of the internal SVD solver
                          *  1 - successful termination
                        Fields are used for debugging purposes:
                        * Rep.IterationsCount - iterations count of the LSQR solver
                        * Rep.NMV - number of matrix-vector products
                        * Rep.ARows - rows count for the system matrix
                        * Rep.ACols - columns count for the system matrix
                        * Rep.ANNZ - number of significantly non-zero elements
                          (elements above some algorithm-determined threshold)

        NOTE:  failure  to  build  model will leave current state of the structure
        unchanged.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1buildmodel(double[,] x,
            double[,] y,
            int n,
            int aterm,
            int algorithmtype,
            int nlayers,
            double radvalue,
            double radzvalue,
            double lambdav,
            double epsort,
            double epserr,
            int maxits,
            rbfv1model s,
            rbfv1report rep,
            alglib.xparams _params)
        {
            nearestneighbor.kdtree tree = new nearestneighbor.kdtree();
            nearestneighbor.kdtree ctree = new nearestneighbor.kdtree();
            double[] dist = new double[0];
            double[] xcx = new double[0];
            double[,] a = new double[0,0];
            double[,] v = new double[0,0];
            double[,] omega = new double[0,0];
            double[,] residualy = new double[0,0];
            double[] radius = new double[0];
            double[,] xc = new double[0,0];
            int nc = 0;
            double rmax = 0;
            int[] tags = new int[0];
            int[] ctags = new int[0];
            int i = 0;
            int j = 0;
            int k = 0;
            int snnz = 0;
            double[] tmp0 = new double[0];
            double[] tmp1 = new double[0];
            int layerscnt = 0;
            bool modelstatus = new bool();

            alglib.ap.assert(s.nx==2 || s.nx==3, "RBFBuildModel: S.NX<>2 or S.NX<>3!");
            
            //
            // Quick exit when we have no points
            //
            if( n==0 )
            {
                rep.terminationtype = 1;
                rep.iterationscount = 0;
                rep.nmv = 0;
                rep.arows = 0;
                rep.acols = 0;
                nearestneighbor.kdtreebuildtagged(s.xc, tags, 0, mxnx, 0, 2, s.tree, _params);
                s.xc = new double[0, 0];
                s.wr = new double[0, 0];
                s.nc = 0;
                s.rmax = 0;
                s.v = new double[s.ny, mxnx+1];
                for(i=0; i<=s.ny-1; i++)
                {
                    for(j=0; j<=mxnx; j++)
                    {
                        s.v[i,j] = 0;
                    }
                }
                return;
            }
            
            //
            // General case, N>0
            //
            rep.annz = 0;
            rep.iterationscount = 0;
            rep.nmv = 0;
            xcx = new double[mxnx];
            
            //
            // First model in a sequence - linear model.
            // Residuals from linear regression are stored in the ResidualY variable
            // (used later to build RBF models).
            //
            residualy = new double[n, s.ny];
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=s.ny-1; j++)
                {
                    residualy[i,j] = y[i,j];
                }
            }
            if( !rbfv1buildlinearmodel(x, ref residualy, n, s.ny, aterm, ref v, _params) )
            {
                rep.terminationtype = -5;
                return;
            }
            
            //
            // Handle special case: multilayer model with NLayers=0.
            // Quick exit.
            //
            if( algorithmtype==2 && nlayers==0 )
            {
                rep.terminationtype = 1;
                rep.iterationscount = 0;
                rep.nmv = 0;
                rep.arows = 0;
                rep.acols = 0;
                nearestneighbor.kdtreebuildtagged(s.xc, tags, 0, mxnx, 0, 2, s.tree, _params);
                s.xc = new double[0, 0];
                s.wr = new double[0, 0];
                s.nc = 0;
                s.rmax = 0;
                s.v = new double[s.ny, mxnx+1];
                for(i=0; i<=s.ny-1; i++)
                {
                    for(j=0; j<=mxnx; j++)
                    {
                        s.v[i,j] = v[i,j];
                    }
                }
                return;
            }
            
            //
            // Second model in a sequence - RBF term.
            //
            // NOTE: assignments below are not necessary, but without them
            //       MSVC complains about unitialized variables.
            //
            nc = 0;
            rmax = 0;
            layerscnt = 0;
            modelstatus = false;
            if( algorithmtype==1 )
            {
                
                //
                // Add RBF model.
                // This model uses local KD-trees to speed-up nearest neighbor searches.
                //
                nc = n;
                xc = new double[nc, mxnx];
                for(i=0; i<=nc-1; i++)
                {
                    for(j=0; j<=mxnx-1; j++)
                    {
                        xc[i,j] = x[i,j];
                    }
                }
                rmax = 0;
                radius = new double[nc];
                ctags = new int[nc];
                for(i=0; i<=nc-1; i++)
                {
                    ctags[i] = i;
                }
                nearestneighbor.kdtreebuildtagged(xc, ctags, nc, mxnx, 0, 2, ctree, _params);
                if( nc==0 )
                {
                    rmax = 1;
                }
                else
                {
                    if( nc==1 )
                    {
                        radius[0] = radvalue;
                        rmax = radius[0];
                    }
                    else
                    {
                        
                        //
                        // NC>1, calculate radii using distances to nearest neigbors
                        //
                        for(i=0; i<=nc-1; i++)
                        {
                            for(j=0; j<=mxnx-1; j++)
                            {
                                xcx[j] = xc[i,j];
                            }
                            if( nearestneighbor.kdtreequeryknn(ctree, xcx, 1, false, _params)>0 )
                            {
                                nearestneighbor.kdtreequeryresultsdistances(ctree, ref dist, _params);
                                radius[i] = radvalue*dist[0];
                            }
                            else
                            {
                                
                                //
                                // No neighbors found (it will happen when we have only one center).
                                // Initialize radius with default value.
                                //
                                radius[i] = 1.0;
                            }
                        }
                        
                        //
                        // Apply filtering
                        //
                        apserv.rvectorsetlengthatleast(ref tmp0, nc, _params);
                        for(i=0; i<=nc-1; i++)
                        {
                            tmp0[i] = radius[i];
                        }
                        tsort.tagsortfast(ref tmp0, ref tmp1, nc, _params);
                        for(i=0; i<=nc-1; i++)
                        {
                            radius[i] = Math.Min(radius[i], radzvalue*tmp0[nc/2]);
                        }
                        
                        //
                        // Calculate RMax, check that all radii are non-zero
                        //
                        for(i=0; i<=nc-1; i++)
                        {
                            rmax = Math.Max(rmax, radius[i]);
                        }
                        for(i=0; i<=nc-1; i++)
                        {
                            if( (double)(radius[i])==(double)(0) )
                            {
                                rep.terminationtype = -5;
                                return;
                            }
                        }
                    }
                }
                apserv.ivectorsetlengthatleast(ref tags, n, _params);
                for(i=0; i<=n-1; i++)
                {
                    tags[i] = i;
                }
                nearestneighbor.kdtreebuildtagged(x, tags, n, mxnx, 0, 2, tree, _params);
                buildrbfmodellsqr(x, ref residualy, xc, radius, n, nc, s.ny, tree, ctree, epsort, epserr, maxits, ref rep.annz, ref snnz, ref omega, ref rep.terminationtype, ref rep.iterationscount, ref rep.nmv, _params);
                layerscnt = 1;
                modelstatus = true;
            }
            if( algorithmtype==2 )
            {
                rmax = radvalue;
                buildrbfmlayersmodellsqr(x, ref residualy, ref xc, radvalue, ref radius, n, ref nc, s.ny, nlayers, ctree, 1.0E-6, 1.0E-6, 50, lambdav, ref rep.annz, ref omega, ref rep.terminationtype, ref rep.iterationscount, ref rep.nmv, _params);
                layerscnt = nlayers;
                modelstatus = true;
            }
            alglib.ap.assert(modelstatus, "RBFBuildModel: integrity error");
            if( rep.terminationtype<=0 )
            {
                return;
            }
            
            //
            // Model is built
            //
            s.nc = nc/layerscnt;
            s.rmax = rmax;
            s.nl = layerscnt;
            s.xc = new double[s.nc, mxnx];
            s.wr = new double[s.nc, 1+s.nl*s.ny];
            s.v = new double[s.ny, mxnx+1];
            for(i=0; i<=s.nc-1; i++)
            {
                for(j=0; j<=mxnx-1; j++)
                {
                    s.xc[i,j] = xc[i,j];
                }
            }
            apserv.ivectorsetlengthatleast(ref tags, s.nc, _params);
            for(i=0; i<=s.nc-1; i++)
            {
                tags[i] = i;
            }
            nearestneighbor.kdtreebuildtagged(s.xc, tags, s.nc, mxnx, 0, 2, s.tree, _params);
            for(i=0; i<=s.nc-1; i++)
            {
                s.wr[i,0] = radius[i];
                for(k=0; k<=layerscnt-1; k++)
                {
                    for(j=0; j<=s.ny-1; j++)
                    {
                        s.wr[i,1+k*s.ny+j] = omega[k*s.nc+i,j];
                    }
                }
            }
            for(i=0; i<=s.ny-1; i++)
            {
                for(j=0; j<=mxnx; j++)
                {
                    s.v[i,j] = v[i,j];
                }
            }
            rep.terminationtype = 1;
            rep.arows = n;
            rep.acols = s.nc;
        }


        /*************************************************************************
        Serializer: allocation

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1alloc(alglib.serializer s,
            rbfv1model model,
            alglib.xparams _params)
        {
            
            //
            // Data
            //
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            nearestneighbor.kdtreealloc(s, model.tree, _params);
            apserv.allocrealmatrix(s, model.xc, -1, -1, _params);
            apserv.allocrealmatrix(s, model.wr, -1, -1, _params);
            s.alloc_entry();
            apserv.allocrealmatrix(s, model.v, -1, -1, _params);
        }


        /*************************************************************************
        Serializer: serialization

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1serialize(alglib.serializer s,
            rbfv1model model,
            alglib.xparams _params)
        {
            
            //
            // Data
            //
            s.serialize_int(model.nx);
            s.serialize_int(model.ny);
            s.serialize_int(model.nc);
            s.serialize_int(model.nl);
            nearestneighbor.kdtreeserialize(s, model.tree, _params);
            apserv.serializerealmatrix(s, model.xc, -1, -1, _params);
            apserv.serializerealmatrix(s, model.wr, -1, -1, _params);
            s.serialize_double(model.rmax);
            apserv.serializerealmatrix(s, model.v, -1, -1, _params);
        }


        /*************************************************************************
        Serializer: unserialization

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1unserialize(alglib.serializer s,
            rbfv1model model,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;

            
            //
            // Unserialize primary model parameters, initialize model.
            //
            // It is necessary to call RBFCreate() because some internal fields
            // which are NOT unserialized will need initialization.
            //
            nx = s.unserialize_int();
            ny = s.unserialize_int();
            rbfv1create(nx, ny, model, _params);
            model.nc = s.unserialize_int();
            model.nl = s.unserialize_int();
            nearestneighbor.kdtreeunserialize(s, model.tree, _params);
            apserv.unserializerealmatrix(s, ref model.xc, _params);
            apserv.unserializerealmatrix(s, ref model.wr, _params);
            model.rmax = s.unserialize_double();
            apserv.unserializerealmatrix(s, ref model.v, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model in the given point.

        This function should be used when we have NY=1 (scalar function) and  NX=2
        (2-dimensional space). If you have 3-dimensional space, use RBFCalc3(). If
        you have general situation (NX-dimensional space, NY-dimensional function)
        you should use general, less efficient implementation RBFCalc().

        If  you  want  to  calculate  function  values  many times, consider using 
        RBFGridCalc2(), which is far more efficient than many subsequent calls  to
        RBFCalc2().

        This function returns 0.0 when:
        * model is not initialized
        * NX<>2
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfv1calc2(rbfv1model s,
            double x0,
            double x1,
            alglib.xparams _params)
        {
            double result = 0;
            int i = 0;
            int j = 0;
            int lx = 0;
            int tg = 0;
            double d2 = 0;
            double t = 0;
            double bfcur = 0;
            double rcur = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc2: invalid value for X0 (X0 is Inf)!");
            alglib.ap.assert(math.isfinite(x1), "RBFCalc2: invalid value for X1 (X1 is Inf)!");
            if( s.ny!=1 || s.nx!=2 )
            {
                result = 0;
                return result;
            }
            result = s.v[0,0]*x0+s.v[0,1]*x1+s.v[0,mxnx];
            if( s.nc==0 )
            {
                return result;
            }
            apserv.rvectorsetlengthatleast(ref s.calcbufxcx, mxnx, _params);
            for(i=0; i<=mxnx-1; i++)
            {
                s.calcbufxcx[i] = 0.0;
            }
            s.calcbufxcx[0] = x0;
            s.calcbufxcx[1] = x1;
            lx = nearestneighbor.kdtreequeryrnn(s.tree, s.calcbufxcx, s.rmax*rbffarradius, true, _params);
            nearestneighbor.kdtreequeryresultsx(s.tree, ref s.calcbufx, _params);
            nearestneighbor.kdtreequeryresultstags(s.tree, ref s.calcbuftags, _params);
            for(i=0; i<=lx-1; i++)
            {
                tg = s.calcbuftags[i];
                d2 = math.sqr(x0-s.calcbufx[i,0])+math.sqr(x1-s.calcbufx[i,1]);
                rcur = s.wr[tg,0];
                bfcur = Math.Exp(-(d2/(rcur*rcur)));
                for(j=0; j<=s.nl-1; j++)
                {
                    result = result+bfcur*s.wr[tg,1+j];
                    rcur = 0.5*rcur;
                    t = bfcur*bfcur;
                    bfcur = t*t;
                }
            }
            return result;
        }


        /*************************************************************************
        This function calculates values of the RBF model in the given point.

        This function should be used when we have NY=1 (scalar function) and  NX=3
        (3-dimensional space). If you have 2-dimensional space, use RBFCalc2(). If
        you have general situation (NX-dimensional space, NY-dimensional function)
        you should use general, less efficient implementation RBFCalc().

        This function returns 0.0 when:
        * model is not initialized
        * NX<>3
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number
            X2      -   third coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfv1calc3(rbfv1model s,
            double x0,
            double x1,
            double x2,
            alglib.xparams _params)
        {
            double result = 0;
            int i = 0;
            int j = 0;
            int lx = 0;
            int tg = 0;
            double t = 0;
            double rcur = 0;
            double bf = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc3: invalid value for X0 (X0 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x1), "RBFCalc3: invalid value for X1 (X1 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x2), "RBFCalc3: invalid value for X2 (X2 is Inf or NaN)!");
            if( s.ny!=1 || s.nx!=3 )
            {
                result = 0;
                return result;
            }
            result = s.v[0,0]*x0+s.v[0,1]*x1+s.v[0,2]*x2+s.v[0,mxnx];
            if( s.nc==0 )
            {
                return result;
            }
            
            //
            // calculating value for F(X)
            //
            apserv.rvectorsetlengthatleast(ref s.calcbufxcx, mxnx, _params);
            for(i=0; i<=mxnx-1; i++)
            {
                s.calcbufxcx[i] = 0.0;
            }
            s.calcbufxcx[0] = x0;
            s.calcbufxcx[1] = x1;
            s.calcbufxcx[2] = x2;
            lx = nearestneighbor.kdtreequeryrnn(s.tree, s.calcbufxcx, s.rmax*rbffarradius, true, _params);
            nearestneighbor.kdtreequeryresultsx(s.tree, ref s.calcbufx, _params);
            nearestneighbor.kdtreequeryresultstags(s.tree, ref s.calcbuftags, _params);
            for(i=0; i<=lx-1; i++)
            {
                tg = s.calcbuftags[i];
                rcur = s.wr[tg,0];
                bf = Math.Exp(-((math.sqr(x0-s.calcbufx[i,0])+math.sqr(x1-s.calcbufx[i,1])+math.sqr(x2-s.calcbufx[i,2]))/math.sqr(rcur)));
                for(j=0; j<=s.nl-1; j++)
                {
                    result = result+bf*s.wr[tg,1+j];
                    t = bf*bf;
                    bf = t*t;
                }
            }
            return result;
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point.

        Same as RBFCalc(), but does not reallocate Y when in is large enough to 
        store function values.

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1calcbuf(rbfv1model s,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int lx = 0;
            int tg = 0;
            double t = 0;
            double rcur = 0;
            double bf = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFCalcBuf: X contains infinite or NaN values");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = s.v[i,mxnx];
                for(j=0; j<=s.nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                }
            }
            if( s.nc==0 )
            {
                return;
            }
            apserv.rvectorsetlengthatleast(ref s.calcbufxcx, mxnx, _params);
            for(i=0; i<=mxnx-1; i++)
            {
                s.calcbufxcx[i] = 0.0;
            }
            for(i=0; i<=s.nx-1; i++)
            {
                s.calcbufxcx[i] = x[i];
            }
            lx = nearestneighbor.kdtreequeryrnn(s.tree, s.calcbufxcx, s.rmax*rbffarradius, true, _params);
            nearestneighbor.kdtreequeryresultsx(s.tree, ref s.calcbufx, _params);
            nearestneighbor.kdtreequeryresultstags(s.tree, ref s.calcbuftags, _params);
            for(i=0; i<=s.ny-1; i++)
            {
                for(j=0; j<=lx-1; j++)
                {
                    tg = s.calcbuftags[j];
                    rcur = s.wr[tg,0];
                    bf = Math.Exp(-((math.sqr(s.calcbufxcx[0]-s.calcbufx[j,0])+math.sqr(s.calcbufxcx[1]-s.calcbufx[j,1])+math.sqr(s.calcbufxcx[2]-s.calcbufx[j,2]))/math.sqr(rcur)));
                    for(k=0; k<=s.nl-1; k++)
                    {
                        y[i] = y[i]+bf*s.wr[tg,1+k*s.ny+i];
                        t = bf*bf;
                        bf = t*t;
                    }
                }
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point, using
        external  buffer  object  (internal  temporaries  of  RBF  model  are  not
        modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1tscalcbuf(rbfv1model s,
            rbfv1calcbuffer buf,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int lx = 0;
            int tg = 0;
            double t = 0;
            double rcur = 0;
            double bf = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFCalcBuf: X contains infinite or NaN values");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = s.v[i,mxnx];
                for(j=0; j<=s.nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                }
            }
            if( s.nc==0 )
            {
                return;
            }
            apserv.rvectorsetlengthatleast(ref buf.calcbufxcx, mxnx, _params);
            for(i=0; i<=mxnx-1; i++)
            {
                buf.calcbufxcx[i] = 0.0;
            }
            for(i=0; i<=s.nx-1; i++)
            {
                buf.calcbufxcx[i] = x[i];
            }
            lx = nearestneighbor.kdtreetsqueryrnn(s.tree, buf.requestbuffer, buf.calcbufxcx, s.rmax*rbffarradius, true, _params);
            nearestneighbor.kdtreetsqueryresultsx(s.tree, buf.requestbuffer, ref buf.calcbufx, _params);
            nearestneighbor.kdtreetsqueryresultstags(s.tree, buf.requestbuffer, ref buf.calcbuftags, _params);
            for(i=0; i<=s.ny-1; i++)
            {
                for(j=0; j<=lx-1; j++)
                {
                    tg = buf.calcbuftags[j];
                    rcur = s.wr[tg,0];
                    bf = Math.Exp(-((math.sqr(buf.calcbufxcx[0]-buf.calcbufx[j,0])+math.sqr(buf.calcbufxcx[1]-buf.calcbufx[j,1])+math.sqr(buf.calcbufxcx[2]-buf.calcbufx[j,2]))/math.sqr(rcur)));
                    for(k=0; k<=s.nl-1; k++)
                    {
                        y[i] = y[i]+bf*s.wr[tg,1+k*s.ny+i];
                        t = bf*bf;
                        bf = t*t;
                    }
                }
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the  given  point  and
        its derivatives, using external buffer object (internal temporaries of the
        RBF model are not modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y, DY   -   possibly preallocated arrays

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.
            DY      -   derivatives, array[NY*NX]. DY is not reallocated when it
                        is larger than NY*NX.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1tsdiffbuf(rbfv1model s,
            rbfv1calcbuffer buf,
            double[] x,
            ref double[] y,
            ref double[] dy,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int kk = 0;
            int lx = 0;
            int tg = 0;
            double t = 0;
            double rcur = 0;
            double invrcur2 = 0;
            double f = 0;
            double df = 0;
            double w = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFDiffBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFDiffBuf: X contains infinite or NaN values");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = s.v[i,mxnx];
                for(j=0; j<=s.nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                    dy[i*s.nx+j] = s.v[i,j];
                }
            }
            if( s.nc==0 )
            {
                return;
            }
            apserv.rvectorsetlengthatleast(ref buf.calcbufxcx, mxnx, _params);
            for(i=0; i<=mxnx-1; i++)
            {
                buf.calcbufxcx[i] = 0.0;
            }
            for(i=0; i<=s.nx-1; i++)
            {
                buf.calcbufxcx[i] = x[i];
            }
            lx = nearestneighbor.kdtreetsqueryrnn(s.tree, buf.requestbuffer, buf.calcbufxcx, s.rmax*rbffarradius, true, _params);
            nearestneighbor.kdtreetsqueryresultsx(s.tree, buf.requestbuffer, ref buf.calcbufx, _params);
            nearestneighbor.kdtreetsqueryresultstags(s.tree, buf.requestbuffer, ref buf.calcbuftags, _params);
            for(i=0; i<=s.ny-1; i++)
            {
                for(j=0; j<=lx-1; j++)
                {
                    tg = buf.calcbuftags[j];
                    rcur = s.wr[tg,0];
                    invrcur2 = 1/(rcur*rcur);
                    f = Math.Exp(-((math.sqr(buf.calcbufxcx[0]-buf.calcbufx[j,0])+math.sqr(buf.calcbufxcx[1]-buf.calcbufx[j,1])+math.sqr(buf.calcbufxcx[2]-buf.calcbufx[j,2]))*invrcur2));
                    df = -f;
                    for(k=0; k<=s.nl-1; k++)
                    {
                        w = s.wr[tg,1+k*s.ny+i];
                        y[i] = y[i]+f*w;
                        for(kk=0; kk<=s.nx-1; kk++)
                        {
                            dy[i*s.nx+kk] = dy[i*s.nx+kk]+w*df*invrcur2*2*(buf.calcbufxcx[kk]-buf.calcbufx[j,kk]);
                        }
                        t = f*f;
                        f = t*t;
                        df = -f;
                        invrcur2 = 4*invrcur2;
                    }
                }
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the  given  point  and
        its first/second  derivatives,  using  external  buffer  object  (internal
        temporaries of the RBF model are not modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y, DY, D2Y -   possibly preallocated arrays

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.
            DY      -   derivatives, array[NY*NX]. DY is not reallocated when it
                        is larger than NY*NX.
            D2Y     -   derivatives, array[NY*NX*NX]. D2Y is not reallocated when
                        it is larger than NY*NX*NX.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1tshessbuf(rbfv1model s,
            rbfv1calcbuffer buf,
            double[] x,
            ref double[] y,
            ref double[] dy,
            ref double[] d2y,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int i0 = 0;
            int i1 = 0;
            int lx = 0;
            int tg = 0;
            double t = 0;
            double rcur = 0;
            double invrcur2 = 0;
            double f = 0;
            double df = 0;
            double d2f = 0;
            double w = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFDiffBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFDiffBuf: X contains infinite or NaN values");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            if( alglib.ap.len(d2y)<s.ny*s.nx*s.nx )
            {
                d2y = new double[s.ny*s.nx*s.nx];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = s.v[i,mxnx];
                for(j=0; j<=s.nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                    dy[i*s.nx+j] = s.v[i,j];
                }
            }
            ablasf.rsetv(s.ny*s.nx*s.nx, 0.0, d2y, _params);
            if( s.nc==0 )
            {
                return;
            }
            apserv.rvectorsetlengthatleast(ref buf.calcbufxcx, mxnx, _params);
            for(i=0; i<=mxnx-1; i++)
            {
                buf.calcbufxcx[i] = 0.0;
            }
            for(i=0; i<=s.nx-1; i++)
            {
                buf.calcbufxcx[i] = x[i];
            }
            lx = nearestneighbor.kdtreetsqueryrnn(s.tree, buf.requestbuffer, buf.calcbufxcx, s.rmax*rbffarradius, true, _params);
            nearestneighbor.kdtreetsqueryresultsx(s.tree, buf.requestbuffer, ref buf.calcbufx, _params);
            nearestneighbor.kdtreetsqueryresultstags(s.tree, buf.requestbuffer, ref buf.calcbuftags, _params);
            for(i=0; i<=s.ny-1; i++)
            {
                for(j=0; j<=lx-1; j++)
                {
                    tg = buf.calcbuftags[j];
                    rcur = s.wr[tg,0];
                    invrcur2 = 1/(rcur*rcur);
                    f = Math.Exp(-((math.sqr(buf.calcbufxcx[0]-buf.calcbufx[j,0])+math.sqr(buf.calcbufxcx[1]-buf.calcbufx[j,1])+math.sqr(buf.calcbufxcx[2]-buf.calcbufx[j,2]))*invrcur2));
                    df = -f;
                    d2f = f;
                    for(k=0; k<=s.nl-1; k++)
                    {
                        w = s.wr[tg,1+k*s.ny+i];
                        y[i] = y[i]+f*w;
                        for(i0=0; i0<=s.nx-1; i0++)
                        {
                            for(i1=0; i1<=s.nx-1; i1++)
                            {
                                if( i0==i1 )
                                {
                                    
                                    //
                                    // Compute derivative and diagonal element of the Hessian
                                    //
                                    dy[i*s.nx+i0] = dy[i*s.nx+i0]+w*df*invrcur2*2*(buf.calcbufxcx[i0]-buf.calcbufx[j,i0]);
                                    d2y[i*s.nx*s.nx+i0*s.nx+i1] = d2y[i*s.nx*s.nx+i0*s.nx+i1]+w*(d2f*invrcur2*invrcur2*4*math.sqr(buf.calcbufxcx[i0]-buf.calcbufx[j,i0])+df*invrcur2*2);
                                }
                                else
                                {
                                    
                                    //
                                    // Compute off-diagonal element of the Hessian
                                    //
                                    d2y[i*s.nx*s.nx+i0*s.nx+i1] = d2y[i*s.nx*s.nx+i0*s.nx+i1]+w*d2f*invrcur2*invrcur2*4*(buf.calcbufxcx[i0]-buf.calcbufx[j,i0])*(buf.calcbufxcx[i1]-buf.calcbufx[j,i1]);
                                }
                            }
                        }
                        t = f*f;
                        f = t*t;
                        df = -f;
                        d2f = f;
                        invrcur2 = 4*invrcur2;
                    }
                }
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the regular grid.

        Grid have N0*N1 points, with Point[I,J] = (X0[I], X1[J])

        This function returns 0.0 when:
        * model is not initialized
        * NX<>2
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   array of grid nodes, first coordinates, array[N0]
            N0      -   grid size (number of nodes) in the first dimension
            X1      -   array of grid nodes, second coordinates, array[N1]
            N1      -   grid size (number of nodes) in the second dimension

        OUTPUT PARAMETERS:
            Y       -   function values, array[N0,N1]. Y is out-variable and 
                        is reallocated by this function.
                        
        NOTE: as a special exception, this function supports unordered  arrays  X0
              and X1. However, future versions may be  more  efficient  for  X0/X1
              ordered by ascending.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1gridcalc2(rbfv1model s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            ref double[,] y,
            alglib.xparams _params)
        {
            double[] cpx0 = new double[0];
            double[] cpx1 = new double[0];
            int[] p01 = new int[0];
            int[] p11 = new int[0];
            int[] p2 = new int[0];
            double rlimit = 0;
            double xcnorm2 = 0;
            int hp01 = 0;
            double hcpx0 = 0;
            double xc0 = 0;
            double xc1 = 0;
            double omega = 0;
            double radius = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int d = 0;
            int i00 = 0;
            int i01 = 0;
            int i10 = 0;
            int i11 = 0;

            y = new double[0,0];

            alglib.ap.assert(n0>0, "RBFGridCalc2: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc2: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc2: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc2: Length(X1)<N1");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc2: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc2: X1 contains infinite or NaN values!");
            y = new double[n0, n1];
            for(i=0; i<=n0-1; i++)
            {
                for(j=0; j<=n1-1; j++)
                {
                    y[i,j] = 0;
                }
            }
            if( (s.ny!=1 || s.nx!=2) || s.nc==0 )
            {
                return;
            }
            
            //
            //create and sort arrays
            //
            cpx0 = new double[n0];
            for(i=0; i<=n0-1; i++)
            {
                cpx0[i] = x0[i];
            }
            tsort.tagsort(ref cpx0, n0, ref p01, ref p2, _params);
            cpx1 = new double[n1];
            for(i=0; i<=n1-1; i++)
            {
                cpx1[i] = x1[i];
            }
            tsort.tagsort(ref cpx1, n1, ref p11, ref p2, _params);
            
            //
            //calculate function's value
            //
            for(i=0; i<=s.nc-1; i++)
            {
                radius = s.wr[i,0];
                for(d=0; d<=s.nl-1; d++)
                {
                    omega = s.wr[i,1+d];
                    rlimit = radius*rbffarradius;
                    
                    //
                    //search lower and upper indexes
                    //
                    i00 = tsort.lowerbound(cpx0, n0, s.xc[i,0]-rlimit, _params);
                    i01 = tsort.upperbound(cpx0, n0, s.xc[i,0]+rlimit, _params);
                    i10 = tsort.lowerbound(cpx1, n1, s.xc[i,1]-rlimit, _params);
                    i11 = tsort.upperbound(cpx1, n1, s.xc[i,1]+rlimit, _params);
                    xc0 = s.xc[i,0];
                    xc1 = s.xc[i,1];
                    for(j=i00; j<=i01-1; j++)
                    {
                        hcpx0 = cpx0[j];
                        hp01 = p01[j];
                        for(k=i10; k<=i11-1; k++)
                        {
                            xcnorm2 = math.sqr(hcpx0-xc0)+math.sqr(cpx1[k]-xc1);
                            if( (double)(xcnorm2)<=(double)(rlimit*rlimit) )
                            {
                                y[hp01,p11[k]] = y[hp01,p11[k]]+Math.Exp(-(xcnorm2/math.sqr(radius)))*omega;
                            }
                        }
                    }
                    radius = 0.5*radius;
                }
            }
            
            //
            //add linear term
            //
            for(i=0; i<=n0-1; i++)
            {
                for(j=0; j<=n1-1; j++)
                {
                    y[i,j] = y[i,j]+s.v[0,0]*x0[i]+s.v[0,1]*x1[j]+s.v[0,mxnx];
                }
            }
        }


        public static void rbfv1gridcalc3vrec(rbfv1model s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            int[] blocks0,
            int block0a,
            int block0b,
            int[] blocks1,
            int block1a,
            int block1b,
            int[] blocks2,
            int block2a,
            int block2b,
            bool[] flagy,
            bool sparsey,
            double searchradius,
            double avgfuncpernode,
            alglib.smp.shared_pool bufpool,
            double[] y,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int t = 0;
            int l = 0;
            int i0 = 0;
            int i1 = 0;
            int i2 = 0;
            int ic = 0;
            gridcalc3v1buf pbuf = null;
            int flag12dim1 = 0;
            int flag12dim2 = 0;
            double problemcost = 0;
            int maxbs = 0;
            int nx = 0;
            int ny = 0;
            double v = 0;
            int kc = 0;
            int tg = 0;
            double rcur = 0;
            double rcur2 = 0;
            double basisfuncval = 0;
            int dstoffs = 0;
            int srcoffs = 0;
            int ubnd = 0;
            double w0 = 0;
            double w1 = 0;
            double w2 = 0;
            bool allnodes = new bool();
            bool somenodes = new bool();

            nx = s.nx;
            ny = s.ny;
            
            //
            // Try to split large problem
            //
            problemcost = (s.nl+1)*s.ny*2*(avgfuncpernode+1);
            problemcost = problemcost*(blocks0[block0b]-blocks0[block0a]);
            problemcost = problemcost*(blocks1[block1b]-blocks1[block1a]);
            problemcost = problemcost*(blocks2[block2b]-blocks2[block2a]);
            maxbs = 0;
            maxbs = Math.Max(maxbs, block0b-block0a);
            maxbs = Math.Max(maxbs, block1b-block1a);
            maxbs = Math.Max(maxbs, block2b-block2a);
            if( (double)(problemcost)>=(double)(minbasecasecost) && maxbs>=2 )
            {
                if( block0b-block0a==maxbs )
                {
                    rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0a+maxbs/2, blocks1, block1a, block1b, blocks2, block2a, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _params);
                    rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a+maxbs/2, block0b, blocks1, block1a, block1b, blocks2, block2a, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _params);
                    return;
                }
                if( block1b-block1a==maxbs )
                {
                    rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0b, blocks1, block1a, block1a+maxbs/2, blocks2, block2a, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _params);
                    rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0b, blocks1, block1a+maxbs/2, block1b, blocks2, block2a, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _params);
                    return;
                }
                if( block2b-block2a==maxbs )
                {
                    rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a, block2a+maxbs/2, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _params);
                    rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a+maxbs/2, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _params);
                    return;
                }
            }
            
            //
            // Retrieve buffer object from pool (it will be returned later)
            //
            alglib.smp.ae_shared_pool_retrieve(bufpool, ref pbuf);
            
            //
            // Calculate RBF model
            //
            for(i2=block2a; i2<=block2b-1; i2++)
            {
                for(i1=block1a; i1<=block1b-1; i1++)
                {
                    for(i0=block0a; i0<=block0b-1; i0++)
                    {
                        
                        //
                        // Analyze block - determine what elements are needed and what are not.
                        //
                        // After this block is done, two flag variables can be used:
                        // * SomeNodes, which is True when there are at least one node which have
                        //   to be calculated
                        // * AllNodes, which is True when all nodes are required
                        //
                        somenodes = true;
                        allnodes = true;
                        flag12dim1 = blocks1[i1+1]-blocks1[i1];
                        flag12dim2 = blocks2[i2+1]-blocks2[i2];
                        if( sparsey )
                        {
                            
                            //
                            // Use FlagY to determine what is required.
                            //
                            apserv.bvectorsetlengthatleast(ref pbuf.flag0, n0, _params);
                            apserv.bvectorsetlengthatleast(ref pbuf.flag1, n1, _params);
                            apserv.bvectorsetlengthatleast(ref pbuf.flag2, n2, _params);
                            apserv.bvectorsetlengthatleast(ref pbuf.flag12, flag12dim1*flag12dim2, _params);
                            for(i=blocks0[i0]; i<=blocks0[i0+1]-1; i++)
                            {
                                pbuf.flag0[i] = false;
                            }
                            for(j=blocks1[i1]; j<=blocks1[i1+1]-1; j++)
                            {
                                pbuf.flag1[j] = false;
                            }
                            for(k=blocks2[i2]; k<=blocks2[i2+1]-1; k++)
                            {
                                pbuf.flag2[k] = false;
                            }
                            for(i=0; i<=flag12dim1*flag12dim2-1; i++)
                            {
                                pbuf.flag12[i] = false;
                            }
                            somenodes = false;
                            allnodes = true;
                            for(k=blocks2[i2]; k<=blocks2[i2+1]-1; k++)
                            {
                                for(j=blocks1[i1]; j<=blocks1[i1+1]-1; j++)
                                {
                                    dstoffs = j-blocks1[i1]+flag12dim1*(k-blocks2[i2]);
                                    srcoffs = j*n0+k*n0*n1;
                                    for(i=blocks0[i0]; i<=blocks0[i0+1]-1; i++)
                                    {
                                        if( flagy[srcoffs+i] )
                                        {
                                            pbuf.flag0[i] = true;
                                            pbuf.flag1[j] = true;
                                            pbuf.flag2[k] = true;
                                            pbuf.flag12[dstoffs] = true;
                                            somenodes = true;
                                        }
                                        else
                                        {
                                            allnodes = false;
                                        }
                                    }
                                }
                            }
                        }
                        
                        //
                        // Skip block if it is completely empty.
                        //
                        if( !somenodes )
                        {
                            continue;
                        }
                        
                        //
                        // compute linear term for block (I0,I1,I2)
                        //
                        for(k=blocks2[i2]; k<=blocks2[i2+1]-1; k++)
                        {
                            for(j=blocks1[i1]; j<=blocks1[i1+1]-1; j++)
                            {
                                
                                //
                                // do we need this micro-row?
                                //
                                if( !allnodes && !pbuf.flag12[j-blocks1[i1]+flag12dim1*(k-blocks2[i2])] )
                                {
                                    continue;
                                }
                                
                                //
                                // Compute linear term
                                //
                                for(i=blocks0[i0]; i<=blocks0[i0+1]-1; i++)
                                {
                                    pbuf.tx[0] = x0[i];
                                    pbuf.tx[1] = x1[j];
                                    pbuf.tx[2] = x2[k];
                                    for(l=0; l<=s.ny-1; l++)
                                    {
                                        v = s.v[l,mxnx];
                                        for(t=0; t<=nx-1; t++)
                                        {
                                            v = v+s.v[l,t]*pbuf.tx[t];
                                        }
                                        y[l+ny*(i+j*n0+k*n0*n1)] = v;
                                    }
                                }
                            }
                        }
                        
                        //
                        // compute RBF term for block (I0,I1,I2)
                        //
                        pbuf.tx[0] = 0.5*(x0[blocks0[i0]]+x0[blocks0[i0+1]-1]);
                        pbuf.tx[1] = 0.5*(x1[blocks1[i1]]+x1[blocks1[i1+1]-1]);
                        pbuf.tx[2] = 0.5*(x2[blocks2[i2]]+x2[blocks2[i2+1]-1]);
                        kc = nearestneighbor.kdtreetsqueryrnn(s.tree, pbuf.requestbuf, pbuf.tx, searchradius, true, _params);
                        nearestneighbor.kdtreetsqueryresultsx(s.tree, pbuf.requestbuf, ref pbuf.calcbufx, _params);
                        nearestneighbor.kdtreetsqueryresultstags(s.tree, pbuf.requestbuf, ref pbuf.calcbuftags, _params);
                        for(ic=0; ic<=kc-1; ic++)
                        {
                            pbuf.cx[0] = pbuf.calcbufx[ic,0];
                            pbuf.cx[1] = pbuf.calcbufx[ic,1];
                            pbuf.cx[2] = pbuf.calcbufx[ic,2];
                            tg = pbuf.calcbuftags[ic];
                            rcur = s.wr[tg,0];
                            rcur2 = rcur*rcur;
                            for(i=blocks0[i0]; i<=blocks0[i0+1]-1; i++)
                            {
                                if( allnodes || pbuf.flag0[i] )
                                {
                                    pbuf.expbuf0[i] = Math.Exp(-(math.sqr(x0[i]-pbuf.cx[0])/rcur2));
                                }
                                else
                                {
                                    pbuf.expbuf0[i] = 0.0;
                                }
                            }
                            for(j=blocks1[i1]; j<=blocks1[i1+1]-1; j++)
                            {
                                if( allnodes || pbuf.flag1[j] )
                                {
                                    pbuf.expbuf1[j] = Math.Exp(-(math.sqr(x1[j]-pbuf.cx[1])/rcur2));
                                }
                                else
                                {
                                    pbuf.expbuf1[j] = 0.0;
                                }
                            }
                            for(k=blocks2[i2]; k<=blocks2[i2+1]-1; k++)
                            {
                                if( allnodes || pbuf.flag2[k] )
                                {
                                    pbuf.expbuf2[k] = Math.Exp(-(math.sqr(x2[k]-pbuf.cx[2])/rcur2));
                                }
                                else
                                {
                                    pbuf.expbuf2[k] = 0.0;
                                }
                            }
                            for(t=0; t<=s.nl-1; t++)
                            {
                                
                                //
                                // Calculate
                                //
                                for(k=blocks2[i2]; k<=blocks2[i2+1]-1; k++)
                                {
                                    for(j=blocks1[i1]; j<=blocks1[i1+1]-1; j++)
                                    {
                                        
                                        //
                                        // do we need this micro-row?
                                        //
                                        if( !allnodes && !pbuf.flag12[j-blocks1[i1]+flag12dim1*(k-blocks2[i2])] )
                                        {
                                            continue;
                                        }
                                        
                                        //
                                        // Prepare local variables
                                        //
                                        dstoffs = ny*(blocks0[i0]+j*n0+k*n0*n1);
                                        v = pbuf.expbuf1[j]*pbuf.expbuf2[k];
                                        
                                        //
                                        // Optimized for NY=1
                                        //
                                        if( s.ny==1 )
                                        {
                                            w0 = s.wr[tg,1+t*s.ny+0];
                                            ubnd = blocks0[i0+1]-1;
                                            for(i=blocks0[i0]; i<=ubnd; i++)
                                            {
                                                basisfuncval = pbuf.expbuf0[i]*v;
                                                y[dstoffs] = y[dstoffs]+basisfuncval*w0;
                                                dstoffs = dstoffs+1;
                                            }
                                            continue;
                                        }
                                        
                                        //
                                        // Optimized for NY=2
                                        //
                                        if( s.ny==2 )
                                        {
                                            w0 = s.wr[tg,1+t*s.ny+0];
                                            w1 = s.wr[tg,1+t*s.ny+1];
                                            ubnd = blocks0[i0+1]-1;
                                            for(i=blocks0[i0]; i<=ubnd; i++)
                                            {
                                                basisfuncval = pbuf.expbuf0[i]*v;
                                                y[dstoffs+0] = y[dstoffs+0]+basisfuncval*w0;
                                                y[dstoffs+1] = y[dstoffs+1]+basisfuncval*w1;
                                                dstoffs = dstoffs+2;
                                            }
                                            continue;
                                        }
                                        
                                        //
                                        // Optimized for NY=3
                                        //
                                        if( s.ny==3 )
                                        {
                                            w0 = s.wr[tg,1+t*s.ny+0];
                                            w1 = s.wr[tg,1+t*s.ny+1];
                                            w2 = s.wr[tg,1+t*s.ny+2];
                                            ubnd = blocks0[i0+1]-1;
                                            for(i=blocks0[i0]; i<=ubnd; i++)
                                            {
                                                basisfuncval = pbuf.expbuf0[i]*v;
                                                y[dstoffs+0] = y[dstoffs+0]+basisfuncval*w0;
                                                y[dstoffs+1] = y[dstoffs+1]+basisfuncval*w1;
                                                y[dstoffs+2] = y[dstoffs+2]+basisfuncval*w2;
                                                dstoffs = dstoffs+3;
                                            }
                                            continue;
                                        }
                                        
                                        //
                                        // General case
                                        //
                                        for(i=blocks0[i0]; i<=blocks0[i0+1]-1; i++)
                                        {
                                            basisfuncval = pbuf.expbuf0[i]*v;
                                            for(l=0; l<=s.ny-1; l++)
                                            {
                                                y[l+dstoffs] = y[l+dstoffs]+basisfuncval*s.wr[tg,1+t*s.ny+l];
                                            }
                                            dstoffs = dstoffs+ny;
                                        }
                                    }
                                }
                                
                                //
                                // Update basis functions
                                //
                                if( t!=s.nl-1 )
                                {
                                    ubnd = blocks0[i0+1]-1;
                                    for(i=blocks0[i0]; i<=ubnd; i++)
                                    {
                                        if( allnodes || pbuf.flag0[i] )
                                        {
                                            v = pbuf.expbuf0[i]*pbuf.expbuf0[i];
                                            pbuf.expbuf0[i] = v*v;
                                        }
                                    }
                                    ubnd = blocks1[i1+1]-1;
                                    for(j=blocks1[i1]; j<=ubnd; j++)
                                    {
                                        if( allnodes || pbuf.flag1[j] )
                                        {
                                            v = pbuf.expbuf1[j]*pbuf.expbuf1[j];
                                            pbuf.expbuf1[j] = v*v;
                                        }
                                    }
                                    ubnd = blocks2[i2+1]-1;
                                    for(k=blocks2[i2]; k<=ubnd; k++)
                                    {
                                        if( allnodes || pbuf.flag2[k] )
                                        {
                                            v = pbuf.expbuf2[k]*pbuf.expbuf2[k];
                                            pbuf.expbuf2[k] = v*v;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            //
            // Recycle buffer object back to pool
            //
            alglib.smp.ae_shared_pool_recycle(bufpool, ref pbuf);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_rbfv1gridcalc3vrec(rbfv1model s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            int[] blocks0,
            int block0a,
            int block0b,
            int[] blocks1,
            int block1a,
            int block1b,
            int[] blocks2,
            int block2a,
            int block2b,
            bool[] flagy,
            bool sparsey,
            double searchradius,
            double avgfuncpernode,
            alglib.smp.shared_pool bufpool,
            double[] y, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function "unpacks" RBF model by extracting its coefficients.

        INPUT PARAMETERS:
            S       -   RBF model

        OUTPUT PARAMETERS:
            NX      -   dimensionality of argument
            NY      -   dimensionality of the target function
            XWR     -   model information, array[NC,NX+NY+1].
                        One row of the array corresponds to one basis function:
                        * first NX columns  - coordinates of the center 
                        * next NY columns   - weights, one per dimension of the 
                                              function being modelled
                        * last column       - radius, same for all dimensions of
                                              the function being modelled
            NC      -   number of the centers
            V       -   polynomial  term , array[NY,NX+1]. One row per one 
                        dimension of the function being modelled. First NX 
                        elements are linear coefficients, V[NX] is equal to the 
                        constant part.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv1unpack(rbfv1model s,
            ref int nx,
            ref int ny,
            ref double[,] xwr,
            ref int nc,
            ref double[,] v,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double rcur = 0;
            int i_ = 0;
            int i1_ = 0;

            nx = 0;
            ny = 0;
            xwr = new double[0,0];
            nc = 0;
            v = new double[0,0];

            nx = s.nx;
            ny = s.ny;
            nc = s.nc;
            
            //
            // Fill V
            //
            v = new double[s.ny, s.nx+1];
            for(i=0; i<=s.ny-1; i++)
            {
                for(i_=0; i_<=s.nx-1;i_++)
                {
                    v[i,i_] = s.v[i,i_];
                }
                v[i,s.nx] = s.v[i,mxnx];
            }
            
            //
            // Fill XWR and V
            //
            if( nc*s.nl>0 )
            {
                xwr = new double[s.nc*s.nl, s.nx+s.ny+1];
                for(i=0; i<=s.nc-1; i++)
                {
                    rcur = s.wr[i,0];
                    for(j=0; j<=s.nl-1; j++)
                    {
                        for(i_=0; i_<=s.nx-1;i_++)
                        {
                            xwr[i*s.nl+j,i_] = s.xc[i,i_];
                        }
                        i1_ = (1+j*s.ny) - (s.nx);
                        for(i_=s.nx; i_<=s.nx+s.ny-1;i_++)
                        {
                            xwr[i*s.nl+j,i_] = s.wr[i,i_+i1_];
                        }
                        xwr[i*s.nl+j,s.nx+s.ny] = rcur;
                        rcur = 0.5*rcur;
                    }
                }
            }
        }


        private static bool rbfv1buildlinearmodel(double[,] x,
            ref double[,] y,
            int n,
            int ny,
            int modeltype,
            ref double[,] v,
            alglib.xparams _params)
        {
            bool result = new bool();
            double[] tmpy = new double[0];
            double[,] a = new double[0,0];
            double scaling = 0;
            double[] shifting = new double[0];
            double mn = 0;
            double mx = 0;
            double[] c = new double[0];
            lsfit.lsfitreport rep = new lsfit.lsfitreport();
            int i = 0;
            int j = 0;
            int k = 0;
            int info = 0;

            v = new double[0,0];

            alglib.ap.assert(n>=0, "BuildLinearModel: N<0");
            alglib.ap.assert(ny>0, "BuildLinearModel: NY<=0");
            
            //
            // Handle degenerate case (N=0)
            //
            result = true;
            v = new double[ny, mxnx+1];
            if( n==0 )
            {
                for(j=0; j<=mxnx; j++)
                {
                    for(i=0; i<=ny-1; i++)
                    {
                        v[i,j] = 0;
                    }
                }
                return result;
            }
            
            //
            // Allocate temporaries
            //
            tmpy = new double[n];
            
            //
            // General linear model.
            //
            if( modeltype==1 )
            {
                
                //
                // Calculate scaling/shifting, transform variables, prepare LLS problem
                //
                a = new double[n, mxnx+1];
                shifting = new double[mxnx];
                scaling = 0;
                for(i=0; i<=mxnx-1; i++)
                {
                    mn = x[0,i];
                    mx = mn;
                    for(j=1; j<=n-1; j++)
                    {
                        if( (double)(mn)>(double)(x[j,i]) )
                        {
                            mn = x[j,i];
                        }
                        if( (double)(mx)<(double)(x[j,i]) )
                        {
                            mx = x[j,i];
                        }
                    }
                    scaling = Math.Max(scaling, mx-mn);
                    shifting[i] = 0.5*(mx+mn);
                }
                if( (double)(scaling)==(double)(0) )
                {
                    scaling = 1;
                }
                else
                {
                    scaling = 0.5*scaling;
                }
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=mxnx-1; j++)
                    {
                        a[i,j] = (x[i,j]-shifting[j])/scaling;
                    }
                }
                for(i=0; i<=n-1; i++)
                {
                    a[i,mxnx] = 1;
                }
                
                //
                // Solve linear system in transformed variables, make backward 
                //
                for(i=0; i<=ny-1; i++)
                {
                    for(j=0; j<=n-1; j++)
                    {
                        tmpy[j] = y[j,i];
                    }
                    lsfit.lsfitlinear(tmpy, a, n, mxnx+1, ref info, ref c, rep, _params);
                    if( info<=0 )
                    {
                        result = false;
                        return result;
                    }
                    for(j=0; j<=mxnx-1; j++)
                    {
                        v[i,j] = c[j]/scaling;
                    }
                    v[i,mxnx] = c[mxnx];
                    for(j=0; j<=mxnx-1; j++)
                    {
                        v[i,mxnx] = v[i,mxnx]-shifting[j]*v[i,j];
                    }
                    for(j=0; j<=n-1; j++)
                    {
                        for(k=0; k<=mxnx-1; k++)
                        {
                            y[j,i] = y[j,i]-x[j,k]*v[i,k];
                        }
                        y[j,i] = y[j,i]-v[i,mxnx];
                    }
                }
                return result;
            }
            
            //
            // Constant model, very simple
            //
            if( modeltype==2 )
            {
                for(i=0; i<=ny-1; i++)
                {
                    for(j=0; j<=mxnx; j++)
                    {
                        v[i,j] = 0;
                    }
                    for(j=0; j<=n-1; j++)
                    {
                        v[i,mxnx] = v[i,mxnx]+y[j,i];
                    }
                    if( n>0 )
                    {
                        v[i,mxnx] = v[i,mxnx]/n;
                    }
                    for(j=0; j<=n-1; j++)
                    {
                        y[j,i] = y[j,i]-v[i,mxnx];
                    }
                }
                return result;
            }
            
            //
            // Zero model
            //
            alglib.ap.assert(modeltype==3, "BuildLinearModel: unknown model type");
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=mxnx; j++)
                {
                    v[i,j] = 0;
                }
            }
            return result;
        }


        private static void buildrbfmodellsqr(double[,] x,
            ref double[,] y,
            double[,] xc,
            double[] r,
            int n,
            int nc,
            int ny,
            nearestneighbor.kdtree pointstree,
            nearestneighbor.kdtree centerstree,
            double epsort,
            double epserr,
            int maxits,
            ref int gnnz,
            ref int snnz,
            ref double[,] w,
            ref int info,
            ref int iterationscount,
            ref int nmv,
            alglib.xparams _params)
        {
            linlsqr.linlsqrstate state = new linlsqr.linlsqrstate();
            linlsqr.linlsqrreport lsqrrep = new linlsqr.linlsqrreport();
            sparse.sparsematrix spg = new sparse.sparsematrix();
            sparse.sparsematrix sps = new sparse.sparsematrix();
            int[] nearcenterscnt = new int[0];
            int[] nearpointscnt = new int[0];
            int[] skipnearpointscnt = new int[0];
            int[] farpointscnt = new int[0];
            int maxnearcenterscnt = 0;
            int maxnearpointscnt = 0;
            int maxfarpointscnt = 0;
            int sumnearcenterscnt = 0;
            int sumnearpointscnt = 0;
            int sumfarpointscnt = 0;
            double maxrad = 0;
            int[] pointstags = new int[0];
            int[] centerstags = new int[0];
            double[,] nearpoints = new double[0,0];
            double[,] nearcenters = new double[0,0];
            double[,] farpoints = new double[0,0];
            int tmpi = 0;
            int pointscnt = 0;
            int centerscnt = 0;
            double[] xcx = new double[0];
            double[] tmpy = new double[0];
            double[] tc = new double[0];
            double[] g = new double[0];
            double[] c = new double[0];
            int i = 0;
            int j = 0;
            int k = 0;
            int sind = 0;
            double[,] a = new double[0,0];
            double vv = 0;
            double vx = 0;
            double vy = 0;
            double vz = 0;
            double vr = 0;
            double gnorm2 = 0;
            double[] tmp0 = new double[0];
            double[] tmp1 = new double[0];
            double[] tmp2 = new double[0];
            double fx = 0;
            double[,] xx = new double[0,0];
            double[,] cx = new double[0,0];
            double mrad = 0;
            int i_ = 0;

            gnnz = 0;
            snnz = 0;
            w = new double[0,0];
            info = 0;
            iterationscount = 0;
            nmv = 0;

            
            //
            // Handle special cases: NC=0
            //
            if( nc==0 )
            {
                info = 1;
                iterationscount = 0;
                nmv = 0;
                return;
            }
            
            //
            // Prepare for general case, NC>0
            //
            xcx = new double[mxnx];
            pointstags = new int[n];
            centerstags = new int[nc];
            info = -1;
            iterationscount = 0;
            nmv = 0;
            
            //
            // This block prepares quantities used to compute approximate cardinal basis functions (ACBFs):
            // * NearCentersCnt[]   -   array[NC], whose elements store number of near centers used to build ACBF
            // * NearPointsCnt[]    -   array[NC], number of near points used to build ACBF
            // * FarPointsCnt[]     -   array[NC], number of far points (ones where ACBF is nonzero)
            // * MaxNearCentersCnt  -   max(NearCentersCnt)
            // * MaxNearPointsCnt   -   max(NearPointsCnt)
            // * SumNearCentersCnt  -   sum(NearCentersCnt)
            // * SumNearPointsCnt   -   sum(NearPointsCnt)
            // * SumFarPointsCnt    -   sum(FarPointsCnt)
            //
            nearcenterscnt = new int[nc];
            nearpointscnt = new int[nc];
            skipnearpointscnt = new int[nc];
            farpointscnt = new int[nc];
            maxnearcenterscnt = 0;
            maxnearpointscnt = 0;
            maxfarpointscnt = 0;
            sumnearcenterscnt = 0;
            sumnearpointscnt = 0;
            sumfarpointscnt = 0;
            for(i=0; i<=nc-1; i++)
            {
                for(j=0; j<=mxnx-1; j++)
                {
                    xcx[j] = xc[i,j];
                }
                
                //
                // Determine number of near centers and maximum radius of near centers
                //
                nearcenterscnt[i] = nearestneighbor.kdtreequeryrnn(centerstree, xcx, r[i]*rbfnearradius, true, _params);
                nearestneighbor.kdtreequeryresultstags(centerstree, ref centerstags, _params);
                maxrad = 0;
                for(j=0; j<=nearcenterscnt[i]-1; j++)
                {
                    maxrad = Math.Max(maxrad, Math.Abs(r[centerstags[j]]));
                }
                
                //
                // Determine number of near points (ones which used to build ACBF)
                // and skipped points (the most near points which are NOT used to build ACBF
                // and are NOT included in the near points count
                //
                skipnearpointscnt[i] = nearestneighbor.kdtreequeryrnn(pointstree, xcx, 0.1*r[i], true, _params);
                nearpointscnt[i] = nearestneighbor.kdtreequeryrnn(pointstree, xcx, (r[i]+maxrad)*rbfnearradius, true, _params)-skipnearpointscnt[i];
                alglib.ap.assert(nearpointscnt[i]>=0, "BuildRBFModelLSQR: internal error");
                
                //
                // Determine number of far points
                //
                farpointscnt[i] = nearestneighbor.kdtreequeryrnn(pointstree, xcx, Math.Max(r[i]*rbfnearradius+maxrad*rbffarradius, r[i]*rbffarradius), true, _params);
                
                //
                // calculate sum and max, make some basic checks
                //
                alglib.ap.assert(nearcenterscnt[i]>0, "BuildRBFModelLSQR: internal error");
                maxnearcenterscnt = Math.Max(maxnearcenterscnt, nearcenterscnt[i]);
                maxnearpointscnt = Math.Max(maxnearpointscnt, nearpointscnt[i]);
                maxfarpointscnt = Math.Max(maxfarpointscnt, farpointscnt[i]);
                sumnearcenterscnt = sumnearcenterscnt+nearcenterscnt[i];
                sumnearpointscnt = sumnearpointscnt+nearpointscnt[i];
                sumfarpointscnt = sumfarpointscnt+farpointscnt[i];
            }
            snnz = sumnearcenterscnt;
            gnnz = sumfarpointscnt;
            alglib.ap.assert(maxnearcenterscnt>0, "BuildRBFModelLSQR: internal error");
            
            //
            // Allocate temporaries.
            //
            // NOTE: we want to avoid allocation of zero-size arrays, so we
            //       use max(desired_size,1) instead of desired_size when performing
            //       memory allocation.
            //
            a = new double[maxnearpointscnt+maxnearcenterscnt, maxnearcenterscnt];
            tmpy = new double[maxnearpointscnt+maxnearcenterscnt];
            g = new double[maxnearcenterscnt];
            c = new double[maxnearcenterscnt];
            nearcenters = new double[maxnearcenterscnt, mxnx];
            nearpoints = new double[Math.Max(maxnearpointscnt, 1), mxnx];
            farpoints = new double[Math.Max(maxfarpointscnt, 1), mxnx];
            
            //
            // fill matrix SpG
            //
            sparse.sparsecreate(n, nc, gnnz, spg, _params);
            sparse.sparsecreate(nc, nc, snnz, sps, _params);
            for(i=0; i<=nc-1; i++)
            {
                centerscnt = nearcenterscnt[i];
                
                //
                // main center
                //
                for(j=0; j<=mxnx-1; j++)
                {
                    xcx[j] = xc[i,j];
                }
                
                //
                // center's tree
                //
                tmpi = nearestneighbor.kdtreequeryknn(centerstree, xcx, centerscnt, true, _params);
                alglib.ap.assert(tmpi==centerscnt, "BuildRBFModelLSQR: internal error");
                nearestneighbor.kdtreequeryresultsx(centerstree, ref cx, _params);
                nearestneighbor.kdtreequeryresultstags(centerstree, ref centerstags, _params);
                
                //
                // point's tree
                //
                mrad = 0;
                for(j=0; j<=centerscnt-1; j++)
                {
                    mrad = Math.Max(mrad, r[centerstags[j]]);
                }
                
                //
                // we need to be sure that 'CTree' contains
                // at least one side center
                //
                sparse.sparseset(sps, i, i, 1, _params);
                c[0] = 1.0;
                for(j=1; j<=centerscnt-1; j++)
                {
                    c[j] = 0.0;
                }
                if( centerscnt>1 && nearpointscnt[i]>0 )
                {
                    
                    //
                    // first KDTree request for points
                    //
                    pointscnt = nearpointscnt[i];
                    tmpi = nearestneighbor.kdtreequeryknn(pointstree, xcx, skipnearpointscnt[i]+nearpointscnt[i], true, _params);
                    alglib.ap.assert(tmpi==skipnearpointscnt[i]+nearpointscnt[i], "BuildRBFModelLSQR: internal error");
                    nearestneighbor.kdtreequeryresultsx(pointstree, ref xx, _params);
                    sind = skipnearpointscnt[i];
                    for(j=0; j<=pointscnt-1; j++)
                    {
                        vx = xx[sind+j,0];
                        vy = xx[sind+j,1];
                        vz = xx[sind+j,2];
                        for(k=0; k<=centerscnt-1; k++)
                        {
                            vr = 0.0;
                            vv = vx-cx[k,0];
                            vr = vr+vv*vv;
                            vv = vy-cx[k,1];
                            vr = vr+vv*vv;
                            vv = vz-cx[k,2];
                            vr = vr+vv*vv;
                            vv = r[centerstags[k]];
                            a[j,k] = Math.Exp(-(vr/(vv*vv)));
                        }
                    }
                    for(j=0; j<=centerscnt-1; j++)
                    {
                        g[j] = Math.Exp(-((math.sqr(xcx[0]-cx[j,0])+math.sqr(xcx[1]-cx[j,1])+math.sqr(xcx[2]-cx[j,2]))/math.sqr(r[centerstags[j]])));
                    }
                    
                    //
                    // calculate the problem
                    //
                    gnorm2 = 0.0;
                    for(i_=0; i_<=centerscnt-1;i_++)
                    {
                        gnorm2 += g[i_]*g[i_];
                    }
                    for(j=0; j<=pointscnt-1; j++)
                    {
                        vv = 0.0;
                        for(i_=0; i_<=centerscnt-1;i_++)
                        {
                            vv += a[j,i_]*g[i_];
                        }
                        vv = vv/gnorm2;
                        tmpy[j] = -vv;
                        for(i_=0; i_<=centerscnt-1;i_++)
                        {
                            a[j,i_] = a[j,i_] - vv*g[i_];
                        }
                    }
                    for(j=pointscnt; j<=pointscnt+centerscnt-1; j++)
                    {
                        for(k=0; k<=centerscnt-1; k++)
                        {
                            a[j,k] = 0.0;
                        }
                        a[j,j-pointscnt] = 1.0E-6;
                        tmpy[j] = 0.0;
                    }
                    fbls.fblssolvels(ref a, ref tmpy, pointscnt+centerscnt, centerscnt, ref tmp0, ref tmp1, ref tmp2, _params);
                    for(i_=0; i_<=centerscnt-1;i_++)
                    {
                        c[i_] = tmpy[i_];
                    }
                    vv = 0.0;
                    for(i_=0; i_<=centerscnt-1;i_++)
                    {
                        vv += g[i_]*c[i_];
                    }
                    vv = vv/gnorm2;
                    for(i_=0; i_<=centerscnt-1;i_++)
                    {
                        c[i_] = c[i_] - vv*g[i_];
                    }
                    vv = 1/gnorm2;
                    for(i_=0; i_<=centerscnt-1;i_++)
                    {
                        c[i_] = c[i_] + vv*g[i_];
                    }
                    for(j=0; j<=centerscnt-1; j++)
                    {
                        sparse.sparseset(sps, i, centerstags[j], c[j], _params);
                    }
                }
                
                //
                // second KDTree request for points
                //
                pointscnt = farpointscnt[i];
                tmpi = nearestneighbor.kdtreequeryknn(pointstree, xcx, pointscnt, true, _params);
                alglib.ap.assert(tmpi==pointscnt, "BuildRBFModelLSQR: internal error");
                nearestneighbor.kdtreequeryresultsx(pointstree, ref xx, _params);
                nearestneighbor.kdtreequeryresultstags(pointstree, ref pointstags, _params);
                
                //
                //fill SpG matrix
                //
                for(j=0; j<=pointscnt-1; j++)
                {
                    fx = 0;
                    vx = xx[j,0];
                    vy = xx[j,1];
                    vz = xx[j,2];
                    for(k=0; k<=centerscnt-1; k++)
                    {
                        vr = 0.0;
                        vv = vx-cx[k,0];
                        vr = vr+vv*vv;
                        vv = vy-cx[k,1];
                        vr = vr+vv*vv;
                        vv = vz-cx[k,2];
                        vr = vr+vv*vv;
                        vv = r[centerstags[k]];
                        vv = vv*vv;
                        fx = fx+c[k]*Math.Exp(-(vr/vv));
                    }
                    sparse.sparseset(spg, pointstags[j], i, fx, _params);
                }
            }
            sparse.sparseconverttocrs(spg, _params);
            sparse.sparseconverttocrs(sps, _params);
            
            //
            // solve by LSQR method
            //
            tmpy = new double[n];
            tc = new double[nc];
            w = new double[nc, ny];
            linlsqr.linlsqrcreate(n, nc, state, _params);
            linlsqr.linlsqrsetcond(state, epsort, epserr, maxits, _params);
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=n-1; j++)
                {
                    tmpy[j] = y[j,i];
                }
                linlsqr.linlsqrsolvesparse(state, spg, tmpy, _params);
                linlsqr.linlsqrresults(state, ref c, lsqrrep, _params);
                if( lsqrrep.terminationtype<=0 )
                {
                    info = -4;
                    return;
                }
                sparse.sparsemtv(sps, c, ref tc, _params);
                for(j=0; j<=nc-1; j++)
                {
                    w[j,i] = tc[j];
                }
                iterationscount = iterationscount+lsqrrep.iterationscount;
                nmv = nmv+lsqrrep.nmv;
            }
            info = 1;
        }


        private static void buildrbfmlayersmodellsqr(double[,] x,
            ref double[,] y,
            ref double[,] xc,
            double rval,
            ref double[] r,
            int n,
            ref int nc,
            int ny,
            int nlayers,
            nearestneighbor.kdtree centerstree,
            double epsort,
            double epserr,
            int maxits,
            double lambdav,
            ref int annz,
            ref double[,] w,
            ref int info,
            ref int iterationscount,
            ref int nmv,
            alglib.xparams _params)
        {
            linlsqr.linlsqrstate state = new linlsqr.linlsqrstate();
            linlsqr.linlsqrreport lsqrrep = new linlsqr.linlsqrreport();
            sparse.sparsematrix spa = new sparse.sparsematrix();
            double anorm = 0;
            double[] omega = new double[0];
            double[] xx = new double[0];
            double[] tmpy = new double[0];
            double[,] cx = new double[0,0];
            double yval = 0;
            int nec = 0;
            int[] centerstags = new int[0];
            int layer = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            double v = 0;
            double rmaxbefore = 0;
            double rmaxafter = 0;

            xc = new double[0,0];
            r = new double[0];
            nc = 0;
            annz = 0;
            w = new double[0,0];
            info = 0;
            iterationscount = 0;
            nmv = 0;

            alglib.ap.assert(nlayers>=0, "BuildRBFMLayersModelLSQR: invalid argument(NLayers<0)");
            alglib.ap.assert(n>=0, "BuildRBFMLayersModelLSQR: invalid argument(N<0)");
            alglib.ap.assert(mxnx>0 && mxnx<=3, "BuildRBFMLayersModelLSQR: internal error(invalid global const MxNX: either MxNX<=0 or MxNX>3)");
            annz = 0;
            if( n==0 || nlayers==0 )
            {
                info = 1;
                iterationscount = 0;
                nmv = 0;
                return;
            }
            nc = n*nlayers;
            xx = new double[mxnx];
            centerstags = new int[n];
            xc = new double[nc, mxnx];
            r = new double[nc];
            for(i=0; i<=nc-1; i++)
            {
                for(j=0; j<=mxnx-1; j++)
                {
                    xc[i,j] = x[i%n,j];
                }
            }
            for(i=0; i<=nc-1; i++)
            {
                r[i] = rval/Math.Pow(2, i/n);
            }
            for(i=0; i<=n-1; i++)
            {
                centerstags[i] = i;
            }
            nearestneighbor.kdtreebuildtagged(xc, centerstags, n, mxnx, 0, 2, centerstree, _params);
            omega = new double[n];
            tmpy = new double[n];
            w = new double[nc, ny];
            info = -1;
            iterationscount = 0;
            nmv = 0;
            linlsqr.linlsqrcreate(n, n, state, _params);
            linlsqr.linlsqrsetcond(state, epsort, epserr, maxits, _params);
            linlsqr.linlsqrsetlambdai(state, 1.0E-6, _params);
            
            //
            // calculate number of non-zero elements for sparse matrix
            //
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=mxnx-1; j++)
                {
                    xx[j] = x[i,j];
                }
                annz = annz+nearestneighbor.kdtreequeryrnn(centerstree, xx, r[0]*rbfmlradius, true, _params);
            }
            for(layer=0; layer<=nlayers-1; layer++)
            {
                
                //
                // Fill sparse matrix, calculate norm(A)
                //
                anorm = 0.0;
                sparse.sparsecreate(n, n, annz, spa, _params);
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=mxnx-1; j++)
                    {
                        xx[j] = x[i,j];
                    }
                    nec = nearestneighbor.kdtreequeryrnn(centerstree, xx, r[layer*n]*rbfmlradius, true, _params);
                    nearestneighbor.kdtreequeryresultsx(centerstree, ref cx, _params);
                    nearestneighbor.kdtreequeryresultstags(centerstree, ref centerstags, _params);
                    for(j=0; j<=nec-1; j++)
                    {
                        v = Math.Exp(-((math.sqr(xx[0]-cx[j,0])+math.sqr(xx[1]-cx[j,1])+math.sqr(xx[2]-cx[j,2]))/math.sqr(r[layer*n+centerstags[j]])));
                        sparse.sparseset(spa, i, centerstags[j], v, _params);
                        anorm = anorm+math.sqr(v);
                    }
                }
                anorm = Math.Sqrt(anorm);
                sparse.sparseconverttocrs(spa, _params);
                
                //
                // Calculate maximum residual before adding new layer.
                // This value is not used by algorithm, the only purpose is to make debugging easier.
                //
                rmaxbefore = 0.0;
                for(j=0; j<=n-1; j++)
                {
                    for(i=0; i<=ny-1; i++)
                    {
                        rmaxbefore = Math.Max(rmaxbefore, Math.Abs(y[j,i]));
                    }
                }
                
                //
                // Process NY dimensions of the target function
                //
                for(i=0; i<=ny-1; i++)
                {
                    for(j=0; j<=n-1; j++)
                    {
                        tmpy[j] = y[j,i];
                    }
                    
                    //
                    // calculate Omega for current layer
                    //
                    linlsqr.linlsqrsetlambdai(state, lambdav*anorm/n, _params);
                    linlsqr.linlsqrsolvesparse(state, spa, tmpy, _params);
                    linlsqr.linlsqrresults(state, ref omega, lsqrrep, _params);
                    if( lsqrrep.terminationtype<=0 )
                    {
                        info = -4;
                        return;
                    }
                    
                    //
                    // calculate error for current layer
                    //
                    for(j=0; j<=n-1; j++)
                    {
                        yval = 0;
                        for(k=0; k<=mxnx-1; k++)
                        {
                            xx[k] = x[j,k];
                        }
                        nec = nearestneighbor.kdtreequeryrnn(centerstree, xx, r[layer*n]*rbffarradius, true, _params);
                        nearestneighbor.kdtreequeryresultsx(centerstree, ref cx, _params);
                        nearestneighbor.kdtreequeryresultstags(centerstree, ref centerstags, _params);
                        for(k=0; k<=nec-1; k++)
                        {
                            yval = yval+omega[centerstags[k]]*Math.Exp(-((math.sqr(xx[0]-cx[k,0])+math.sqr(xx[1]-cx[k,1])+math.sqr(xx[2]-cx[k,2]))/math.sqr(r[layer*n+centerstags[k]])));
                        }
                        y[j,i] = y[j,i]-yval;
                    }
                    
                    //
                    // write Omega in out parameter W
                    //
                    for(j=0; j<=n-1; j++)
                    {
                        w[layer*n+j,i] = omega[j];
                    }
                    iterationscount = iterationscount+lsqrrep.iterationscount;
                    nmv = nmv+lsqrrep.nmv;
                }
                
                //
                // Calculate maximum residual before adding new layer.
                // This value is not used by algorithm, the only purpose is to make debugging easier.
                //
                rmaxafter = 0.0;
                for(j=0; j<=n-1; j++)
                {
                    for(i=0; i<=ny-1; i++)
                    {
                        rmaxafter = Math.Max(rmaxafter, Math.Abs(y[j,i]));
                    }
                }
            }
            info = 1;
        }


    }
    public class rbfv3
    {
        /*************************************************************************
        Model evaluator:
        *************************************************************************/
        public class rbf3evaluator : apobject
        {
            public int n;
            public int storagetype;
            public double[,] f;
            public int nx;
            public int functype;
            public double funcparam;
            public int chunksize;
            public int[] entireset;
            public double[,] x;
            public double[,] xtchunked;
            public alglib.smp.shared_pool bufferpool;
            public double[] chunk1;
            public rbf3evaluator()
            {
                init();
            }
            public override void init()
            {
                f = new double[0,0];
                entireset = new int[0];
                x = new double[0,0];
                xtchunked = new double[0,0];
                bufferpool = new alglib.smp.shared_pool();
                chunk1 = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                rbf3evaluator _result = new rbf3evaluator();
                _result.n = n;
                _result.storagetype = storagetype;
                _result.f = (double[,])f.Clone();
                _result.nx = nx;
                _result.functype = functype;
                _result.funcparam = funcparam;
                _result.chunksize = chunksize;
                _result.entireset = (int[])entireset.Clone();
                _result.x = (double[,])x.Clone();
                _result.xtchunked = (double[,])xtchunked.Clone();
                _result.bufferpool = (alglib.smp.shared_pool)bufferpool.make_copy();
                _result.chunk1 = (double[])chunk1.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Buffer object for parallel evaluation on the model matrix
        *************************************************************************/
        public class rbf3evaluatorbuffer : apobject
        {
            public double[] x;
            public double[] coeffbuf;
            public double[] funcbuf;
            public double[] wrkbuf;
            public double[] mindist2;
            public double[] df1;
            public double[] df2;
            public double[,] deltabuf;
            public rbf3evaluatorbuffer()
            {
                init();
            }
            public override void init()
            {
                x = new double[0];
                coeffbuf = new double[0];
                funcbuf = new double[0];
                wrkbuf = new double[0];
                mindist2 = new double[0];
                df1 = new double[0];
                df2 = new double[0];
                deltabuf = new double[0,0];
            }
            public override alglib.apobject make_copy()
            {
                rbf3evaluatorbuffer _result = new rbf3evaluatorbuffer();
                _result.x = (double[])x.Clone();
                _result.coeffbuf = (double[])coeffbuf.Clone();
                _result.funcbuf = (double[])funcbuf.Clone();
                _result.wrkbuf = (double[])wrkbuf.Clone();
                _result.mindist2 = (double[])mindist2.Clone();
                _result.df1 = (double[])df1.Clone();
                _result.df2 = (double[])df2.Clone();
                _result.deltabuf = (double[,])deltabuf.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Buffer object  which  is  used  to  perform  evaluation  requests  in  the
        multithreaded mode (multiple threads working with same RBF object).
        *************************************************************************/
        public class rbfv3calcbuffer : apobject
        {
            public double[] x;
            public rbf3evaluatorbuffer evalbuf;
            public double[] x123;
            public double[] y123;
            public double[] xg;
            public double[] yg;
            public rbfv3calcbuffer()
            {
                init();
            }
            public override void init()
            {
                x = new double[0];
                evalbuf = new rbf3evaluatorbuffer();
                x123 = new double[0];
                y123 = new double[0];
                xg = new double[0];
                yg = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                rbfv3calcbuffer _result = new rbfv3calcbuffer();
                _result.x = (double[])x.Clone();
                _result.evalbuf = (rbf3evaluatorbuffer)evalbuf.make_copy();
                _result.x123 = (double[])x123.Clone();
                _result.y123 = (double[])y123.Clone();
                _result.xg = (double[])xg.Clone();
                _result.yg = (double[])yg.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Approximate Cardinal Basis Function builder object

        Following fields store problem formulation:
        * NTotal                -   total points count in the dataset
        * NX                    -   dimensions count
        * XX                    -   array[NTotal,NX], points
        * FuncType              -   basis function type
        * FuncParam             -   basis function parameter
        * RoughDatasetDiameter  -   a rough upper bound on the dataset diameter

        Following global parameters are set:
        * NGlobal               -   global nodes count, >=0
        * GlobalGrid            -   global nodes
        * GlobalGridSeparation  -   maximum distance between any pair of grid nodes;
                                    also an upper bound on distance between any random
                                    point in the dataset and a nearest grid node
        * NLocal                -   number of nearest neighbors select for each
                                    node.
        * NCorrection           -   nodes count for each corrector layer
        * CorrectorGrowth       -   growth factor for corrector layer
        * BatchSize             -   batch size for ACBF construction
        * LambdaV               -   smoothing coefficient, LambdaV>=0
        * ATerm                 -   linear term for basis functions:
                                    * 1 = linear polynomial        (STRONGLY RECOMMENDED)
                                    * 2 = constant polynomial term (may break convergence for thin plate splines)
                                    * 3 = zero polynomial term     (may break convergence for all types of splines)

        Following fields are initialized:
        * KDT                   -   KD-tree search structure for the entire dataset
        * KDT1, KDT2            -   simplified KD-trees (build with progressively
                                    sparsified dataset)
        * BufferPool            -   shared pool for ACBFBuffer instances
        * ChunksProducer        -   shared pool seeded with an instance of ACBFChunk
                                    object (several rows of the preconditioner)
        * ChunksPool            -   shared pool that contains computed preconditioner
                                    chunks as recycled entries

        Temporaries:
        * WrkIdx
        *************************************************************************/
        public class acbfbuilder : apobject
        {
            public bool dodetailedtrace;
            public int ntotal;
            public int nx;
            public double[,] xx;
            public int functype;
            public double funcparam;
            public double roughdatasetdiameter;
            public int nglobal;
            public int[] globalgrid;
            public double globalgridseparation;
            public int nlocal;
            public int ncorrection;
            public double correctorgrowth;
            public int batchsize;
            public double lambdav;
            public int aterm;
            public nearestneighbor.kdtree kdt;
            public nearestneighbor.kdtree kdt1;
            public nearestneighbor.kdtree kdt2;
            public alglib.smp.shared_pool bufferpool;
            public alglib.smp.shared_pool chunksproducer;
            public alglib.smp.shared_pool chunkspool;
            public int[] wrkidx;
            public acbfbuilder()
            {
                init();
            }
            public override void init()
            {
                xx = new double[0,0];
                globalgrid = new int[0];
                kdt = new nearestneighbor.kdtree();
                kdt1 = new nearestneighbor.kdtree();
                kdt2 = new nearestneighbor.kdtree();
                bufferpool = new alglib.smp.shared_pool();
                chunksproducer = new alglib.smp.shared_pool();
                chunkspool = new alglib.smp.shared_pool();
                wrkidx = new int[0];
            }
            public override alglib.apobject make_copy()
            {
                acbfbuilder _result = new acbfbuilder();
                _result.dodetailedtrace = dodetailedtrace;
                _result.ntotal = ntotal;
                _result.nx = nx;
                _result.xx = (double[,])xx.Clone();
                _result.functype = functype;
                _result.funcparam = funcparam;
                _result.roughdatasetdiameter = roughdatasetdiameter;
                _result.nglobal = nglobal;
                _result.globalgrid = (int[])globalgrid.Clone();
                _result.globalgridseparation = globalgridseparation;
                _result.nlocal = nlocal;
                _result.ncorrection = ncorrection;
                _result.correctorgrowth = correctorgrowth;
                _result.batchsize = batchsize;
                _result.lambdav = lambdav;
                _result.aterm = aterm;
                _result.kdt = (nearestneighbor.kdtree)kdt.make_copy();
                _result.kdt1 = (nearestneighbor.kdtree)kdt1.make_copy();
                _result.kdt2 = (nearestneighbor.kdtree)kdt2.make_copy();
                _result.bufferpool = (alglib.smp.shared_pool)bufferpool.make_copy();
                _result.chunksproducer = (alglib.smp.shared_pool)chunksproducer.make_copy();
                _result.chunkspool = (alglib.smp.shared_pool)chunkspool.make_copy();
                _result.wrkidx = (int[])wrkidx.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Temporary buffers used by divide-and-conquer ACBF preconditioner.

        This structure is initialized at the beginning of DC  procedure  and  put
        into shared pool. Basecase handling routine retrieves it  from  the  bool
        and returns back.

        Following fields can be used:
        * bFlags        -   boolean array[N], all values are set to False on  the
                            retrieval, and MUST  be  False  when  the  buffer  is
                            returned to the pool
        * KDTBuf        -   KD-tree request buffer for thread-safe requests
        * KDT1Buf, KDT2Buf- buffers for simplified KD-trees

        Additional preallocated temporaries are provided:
        * tmpBoxMin     -   array[NX], no special properties
        * tmpBoxMax     -   array[NX], no special properties
        * TargetNodes   -   dynamically resized as needed
        *************************************************************************/
        public class acbfbuffer : apobject
        {
            public bool[] bflags;
            public nearestneighbor.kdtreerequestbuffer kdtbuf;
            public nearestneighbor.kdtreerequestbuffer kdt1buf;
            public nearestneighbor.kdtreerequestbuffer kdt2buf;
            public double[] tmpboxmin;
            public double[] tmpboxmax;
            public int[] currentnodes;
            public int[] neighbors;
            public int[] chosenneighbors;
            public double[] y;
            public double[] z;
            public double[] d;
            public double[,] atwrk;
            public double[,] xq;
            public double[,] q;
            public double[,] q1;
            public double[,] wrkq;
            public double[,] b;
            public double[,] c;
            public double[] choltmp;
            public double[] tau;
            public double[,] r;
            public int[] perm;
            public acbfbuffer()
            {
                init();
            }
            public override void init()
            {
                bflags = new bool[0];
                kdtbuf = new nearestneighbor.kdtreerequestbuffer();
                kdt1buf = new nearestneighbor.kdtreerequestbuffer();
                kdt2buf = new nearestneighbor.kdtreerequestbuffer();
                tmpboxmin = new double[0];
                tmpboxmax = new double[0];
                currentnodes = new int[0];
                neighbors = new int[0];
                chosenneighbors = new int[0];
                y = new double[0];
                z = new double[0];
                d = new double[0];
                atwrk = new double[0,0];
                xq = new double[0,0];
                q = new double[0,0];
                q1 = new double[0,0];
                wrkq = new double[0,0];
                b = new double[0,0];
                c = new double[0,0];
                choltmp = new double[0];
                tau = new double[0];
                r = new double[0,0];
                perm = new int[0];
            }
            public override alglib.apobject make_copy()
            {
                acbfbuffer _result = new acbfbuffer();
                _result.bflags = (bool[])bflags.Clone();
                _result.kdtbuf = (nearestneighbor.kdtreerequestbuffer)kdtbuf.make_copy();
                _result.kdt1buf = (nearestneighbor.kdtreerequestbuffer)kdt1buf.make_copy();
                _result.kdt2buf = (nearestneighbor.kdtreerequestbuffer)kdt2buf.make_copy();
                _result.tmpboxmin = (double[])tmpboxmin.Clone();
                _result.tmpboxmax = (double[])tmpboxmax.Clone();
                _result.currentnodes = (int[])currentnodes.Clone();
                _result.neighbors = (int[])neighbors.Clone();
                _result.chosenneighbors = (int[])chosenneighbors.Clone();
                _result.y = (double[])y.Clone();
                _result.z = (double[])z.Clone();
                _result.d = (double[])d.Clone();
                _result.atwrk = (double[,])atwrk.Clone();
                _result.xq = (double[,])xq.Clone();
                _result.q = (double[,])q.Clone();
                _result.q1 = (double[,])q1.Clone();
                _result.wrkq = (double[,])wrkq.Clone();
                _result.b = (double[,])b.Clone();
                _result.c = (double[,])c.Clone();
                _result.choltmp = (double[])choltmp.Clone();
                _result.tau = (double[])tau.Clone();
                _result.r = (double[,])r.Clone();
                _result.perm = (int[])perm.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Several rows of the ACBF preconditioner
        *************************************************************************/
        public class acbfchunk : apobject
        {
            public int ntargetrows;
            public int ntargetcols;
            public int[] targetrows;
            public int[] targetcols;
            public double[,] s;
            public acbfchunk()
            {
                init();
            }
            public override void init()
            {
                targetrows = new int[0];
                targetcols = new int[0];
                s = new double[0,0];
            }
            public override alglib.apobject make_copy()
            {
                acbfchunk _result = new acbfchunk();
                _result.ntargetrows = ntargetrows;
                _result.ntargetcols = ntargetcols;
                _result.targetrows = (int[])targetrows.Clone();
                _result.targetcols = (int[])targetcols.Clone();
                _result.s = (double[,])s.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Temporary buffers used by divide-and-conquer DDM solver

        This structure is initialized at the beginning of DC  procedure  and  put
        into shared pool. Basecase handling routine retrieves it  from  the  pool
        and returns back.

        Following fields can be used:
        * bFlags        -   boolean array[N], all values are set to False on  the
                            retrieval, and MUST  be  False  when  the  buffer  is
                            returned to the pool
        * KDTBuf        -   KD-tree request buffer for thread-safe requests

        Additional preallocated temporaries are provided:
        * Idx2PrecCol   -   integer array[N+NX+1], no special properties
        * tmpBoxMin     -   array[NX], no special properties
        * tmpBoxMax     -   array[NX], no special properties
        *************************************************************************/
        public class rbf3ddmbuffer : apobject
        {
            public bool[] bflags;
            public int[] idx2preccol;
            public nearestneighbor.kdtreerequestbuffer kdtbuf;
            public double[] tmpboxmin;
            public double[] tmpboxmax;
            public rbf3ddmbuffer()
            {
                init();
            }
            public override void init()
            {
                bflags = new bool[0];
                idx2preccol = new int[0];
                kdtbuf = new nearestneighbor.kdtreerequestbuffer();
                tmpboxmin = new double[0];
                tmpboxmax = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                rbf3ddmbuffer _result = new rbf3ddmbuffer();
                _result.bflags = (bool[])bflags.Clone();
                _result.idx2preccol = (int[])idx2preccol.Clone();
                _result.kdtbuf = (nearestneighbor.kdtreerequestbuffer)kdtbuf.make_copy();
                _result.tmpboxmin = (double[])tmpboxmin.Clone();
                _result.tmpboxmax = (double[])tmpboxmax.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Subproblem for DDM algorithm, stores precomputed factorization and  other
        information.

        Following fields are set during construction:
        * IsValid       -   whether instance is valid subproblem or not
        * NTarget       -   number of target nodes in the subproblem, NTarget>=1
        * TargetNodes   -   array containing target node indexes
        * NWork         -   number of working nodes in the subproblem, NWork>=NTarget
        * WorkingNodes  -   array containing working node indexes
        * RegSystem     -   smoothed (regularized) working system
        * Decomposition -   decomposition type:
                            * 0 for LU
                            * 1 for regularized QR
        * WrkLU         -   NWork*NWork sized LU factorization of the subproblem
        * WrkP          -   pivots for the LU decomposition
        * WrkQ, WrkR    -   NWork*NWork sized matrices, factors of QR decomposition
                            of RegSystem. Due to regularization rows added, the
                            Q factor is actually an 2NWork*NWork matrix, but in
                            order to solve the system we need only leading NWork
                            rows, so the rest is not stored.
        *************************************************************************/
        public class rbf3ddmsubproblem : apobject
        {
            public bool isvalid;
            public int ntarget;
            public int[] targetnodes;
            public int nwork;
            public int[] workingnodes;
            public double[,] regsystem;
            public int decomposition;
            public double[,] wrklu;
            public double[,] rhs;
            public double[,] qtrhs;
            public double[,] sol;
            public double[,] pred;
            public int[] wrkp;
            public double[,] wrkq;
            public double[,] wrkr;
            public rbf3ddmsubproblem()
            {
                init();
            }
            public override void init()
            {
                targetnodes = new int[0];
                workingnodes = new int[0];
                regsystem = new double[0,0];
                wrklu = new double[0,0];
                rhs = new double[0,0];
                qtrhs = new double[0,0];
                sol = new double[0,0];
                pred = new double[0,0];
                wrkp = new int[0];
                wrkq = new double[0,0];
                wrkr = new double[0,0];
            }
            public override alglib.apobject make_copy()
            {
                rbf3ddmsubproblem _result = new rbf3ddmsubproblem();
                _result.isvalid = isvalid;
                _result.ntarget = ntarget;
                _result.targetnodes = (int[])targetnodes.Clone();
                _result.nwork = nwork;
                _result.workingnodes = (int[])workingnodes.Clone();
                _result.regsystem = (double[,])regsystem.Clone();
                _result.decomposition = decomposition;
                _result.wrklu = (double[,])wrklu.Clone();
                _result.rhs = (double[,])rhs.Clone();
                _result.qtrhs = (double[,])qtrhs.Clone();
                _result.sol = (double[,])sol.Clone();
                _result.pred = (double[,])pred.Clone();
                _result.wrkp = (int[])wrkp.Clone();
                _result.wrkq = (double[,])wrkq.Clone();
                _result.wrkr = (double[,])wrkr.Clone();
                return _result;
            }
        };


        /*************************************************************************
        DDM solver

        Following fields store information about problem:
            LambdaV     -   smoothing coefficient
            
        Following fields related to DDM part are present:
            SubproblemsCnt-  number of subproblems created, SubproblemCnt>=1
            SubproblemsPool- shared pool seeded with instance of RBFV3DDMSubproblem
                            class (default seed has Seed.IsValid=False).  It  also
                            contains exactly SubproblemCnt subproblem instances as
                            recycled  entries,  each  of   these   instances   has
                            Seed.IsValid=True and  contains  a  partition  of  the
                            complete  problem  into  subproblems  and  precomputed
                            factorization
            SubproblemsBuffer-shared pool seeded with instance of RBFV3DDMSubproblem
                            class (default seed has Seed.IsValid=False).  Contains
                            no recycled entries, should be used just for temporary
                            storage of the already processed subproblems.
                            
        Following fields store information about corrector spline:
            NCorrector  -   corrector nodes count, NCorrector>0
            CorrQ       -   Q factor from the QR decomposition of the corrector
                            linear system, array[NCorrector,NCorrector]
            CorrR       -   R factor from the QR decomposition of the corrector
                            linear system, array[NCorrector,NCorrector]
            CorrNodes   -   array[NCorrector], indexes of dataset nodes chosen
                            for the corrector spline
            CorrX       -   array[NCorrector,NX], dataset points

        Following fields store information that is used for logging and testing:
            CntLU       -   number of subproblems solved with LU (well conditioned)
            CntRegQR    -   number of subproblems solved with Reg-QR (badly conditioned)    
        *************************************************************************/
        public class rbf3ddmsolver : apobject
        {
            public double lambdav;
            public nearestneighbor.kdtree kdt;
            public alglib.smp.shared_pool bufferpool;
            public int subproblemscnt;
            public alglib.smp.shared_pool subproblemspool;
            public alglib.smp.shared_pool subproblemsbuffer;
            public int ncorrector;
            public double[,] corrq;
            public double[,] corrr;
            public int[] corrnodes;
            public double[,] corrx;
            public double[,] tmpres1;
            public double[,] tmpupd1;
            public int cntlu;
            public int cntregqr;
            public rbf3ddmsolver()
            {
                init();
            }
            public override void init()
            {
                kdt = new nearestneighbor.kdtree();
                bufferpool = new alglib.smp.shared_pool();
                subproblemspool = new alglib.smp.shared_pool();
                subproblemsbuffer = new alglib.smp.shared_pool();
                corrq = new double[0,0];
                corrr = new double[0,0];
                corrnodes = new int[0];
                corrx = new double[0,0];
                tmpres1 = new double[0,0];
                tmpupd1 = new double[0,0];
            }
            public override alglib.apobject make_copy()
            {
                rbf3ddmsolver _result = new rbf3ddmsolver();
                _result.lambdav = lambdav;
                _result.kdt = (nearestneighbor.kdtree)kdt.make_copy();
                _result.bufferpool = (alglib.smp.shared_pool)bufferpool.make_copy();
                _result.subproblemscnt = subproblemscnt;
                _result.subproblemspool = (alglib.smp.shared_pool)subproblemspool.make_copy();
                _result.subproblemsbuffer = (alglib.smp.shared_pool)subproblemsbuffer.make_copy();
                _result.ncorrector = ncorrector;
                _result.corrq = (double[,])corrq.Clone();
                _result.corrr = (double[,])corrr.Clone();
                _result.corrnodes = (int[])corrnodes.Clone();
                _result.corrx = (double[,])corrx.Clone();
                _result.tmpres1 = (double[,])tmpres1.Clone();
                _result.tmpupd1 = (double[,])tmpupd1.Clone();
                _result.cntlu = cntlu;
                _result.cntregqr = cntregqr;
                return _result;
            }
        };


        /*************************************************************************
        RBF model.

        Never try to work with fields of this object directly - always use  ALGLIB
        functions to use this object.
        *************************************************************************/
        public class rbfv3model : apobject
        {
            public int ny;
            public int nx;
            public int bftype;
            public double bfparam;
            public double[] s;
            public double[,] v;
            public double[] cw;
            public int[] pointindexes;
            public int nc;
            public rbf3evaluator evaluator;
            public double[,] wchunked;
            public rbfv3calcbuffer calcbuf;
            public bool dbgregqrusedforddm;
            public rbfv3model()
            {
                init();
            }
            public override void init()
            {
                s = new double[0];
                v = new double[0,0];
                cw = new double[0];
                pointindexes = new int[0];
                evaluator = new rbf3evaluator();
                wchunked = new double[0,0];
                calcbuf = new rbfv3calcbuffer();
            }
            public override alglib.apobject make_copy()
            {
                rbfv3model _result = new rbfv3model();
                _result.ny = ny;
                _result.nx = nx;
                _result.bftype = bftype;
                _result.bfparam = bfparam;
                _result.s = (double[])s.Clone();
                _result.v = (double[,])v.Clone();
                _result.cw = (double[])cw.Clone();
                _result.pointindexes = (int[])pointindexes.Clone();
                _result.nc = nc;
                _result.evaluator = (rbf3evaluator)evaluator.make_copy();
                _result.wchunked = (double[,])wchunked.Clone();
                _result.calcbuf = (rbfv3calcbuffer)calcbuf.make_copy();
                _result.dbgregqrusedforddm = dbgregqrusedforddm;
                return _result;
            }
        };


        /*************************************************************************
        RBF solution report:
        * TerminationType   -   termination type, positive values - success,
                                non-positive - failure.
        *************************************************************************/
        public class rbfv3report : apobject
        {
            public int terminationtype;
            public double maxerror;
            public double rmserror;
            public int iterationscount;
            public rbfv3report()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                rbfv3report _result = new rbfv3report();
                _result.terminationtype = terminationtype;
                _result.maxerror = maxerror;
                _result.rmserror = rmserror;
                _result.iterationscount = iterationscount;
                return _result;
            }
        };




        public const double epsred = 0.999999;
        public const int maxddmits = 50;
        public const double polyharmonic2scale = 4.0;
        public const int acbfparallelthreshold = 512;
        public const int ddmparallelthreshold = 512;
        public const int bfparallelthreshold = 512;


        /*************************************************************************
        This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
        function in a NX-dimensional space (NX>=1).

        INPUT PARAMETERS:
            NX      -   dimension of the space, NX>=1
            NY      -   function dimension, NY>=1
            BF      -   basis function type:
                        * 1 for biharmonic/multiquadric f=sqrt(r^2+alpha^2) (with f=r being a special case)
                        * 2 for polyharmonic f=r^2*ln(r)
            BFP     -   basis function parameter:
                        * BF=0      parameter ignored

        OUTPUT PARAMETERS:
            S       -   RBF model (initially equals to zero)

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3create(int nx,
            int ny,
            int bf,
            double bfp,
            rbfv3model s,
            alglib.xparams _params)
        {
            alglib.ap.assert(nx>=1, "RBFCreate: NX<1");
            alglib.ap.assert(ny>=1, "RBFCreate: NY<1");
            alglib.ap.assert(bf==1 || bf==2, "RBFCreate: unsupported basis function type");
            alglib.ap.assert(math.isfinite(bfp) && (double)(bfp)>=(double)(0), "RBFCreate: infinite or negative basis function parameter");
            
            //
            // Serializable parameters
            //
            s.nx = nx;
            s.ny = ny;
            s.bftype = bf;
            s.bfparam = bfp;
            s.nc = 0;
            ablasf.rsetallocv(nx, 1.0, ref s.s, _params);
            ablasf.rsetallocm(ny, nx+1, 0.0, ref s.v, _params);
            allocatecalcbuffer(s, s.calcbuf, _params);
            
            //
            // Debug counters
            //
            s.dbgregqrusedforddm = false;
        }


        /*************************************************************************
        This function creates buffer  structure  which  can  be  used  to  perform
        parallel  RBF  model  evaluations  (with  one  RBF  model  instance  being
        used from multiple threads, as long as  different  threads  use  different
        instances of buffer).

        This buffer object can be used with  rbftscalcbuf()  function  (here  "ts"
        stands for "thread-safe", "buf" is a suffix which denotes  function  which
        reuses previously allocated output space).

        How to use it:
        * create RBF model structure with rbfcreate()
        * load data, tune parameters
        * call rbfbuildmodel()
        * call rbfcreatecalcbuffer(), once per thread working with RBF model  (you
          should call this function only AFTER call to rbfbuildmodel(), see  below
          for more information)
        * call rbftscalcbuf() from different threads,  with  each  thread  working
          with its own copy of buffer object.

        INPUT PARAMETERS
            S           -   RBF model

        OUTPUT PARAMETERS
            Buf         -   external buffer.
            
            
        IMPORTANT: buffer object should be used only with  RBF model object  which
                   was used to initialize buffer. Any attempt to use buffer   with
                   different object is dangerous - you may  get  memory  violation
                   error because sizes of internal arrays do not fit to dimensions
                   of RBF structure.
                   
        IMPORTANT: you  should  call  this function only for model which was built
                   with rbfbuildmodel() function, after successful  invocation  of
                   rbfbuildmodel().  Sizes   of   some   internal  structures  are
                   determined only after model is built, so buffer object  created
                   before model  construction  stage  will  be  useless  (and  any
                   attempt to use it will result in exception).

          -- ALGLIB --
             Copyright 02.04.2022 by Sergey Bochkanov
        *************************************************************************/
        public static void rbfv3createcalcbuffer(rbfv3model s,
            rbfv3calcbuffer buf,
            alglib.xparams _params)
        {
            allocatecalcbuffer(s, buf, _params);
        }


        /*************************************************************************
        This function builds hierarchical RBF model.

        INPUT PARAMETERS:
            X       -   array[N,S.NX], X-values
            Y       -   array[N,S.NY], Y-values
            ScaleVec-   array[S.NX], vector of per-dimension scales
            N       -   points count
            BFtype  -   basis function type:
                        * 1 for biharmonic spline f=r or multiquadric f=sqrt(r^2+param^2)
                        * 2 for thin plate spline f=r^2*ln(r)
            BFParam -   for BFType=1 zero value means biharmonic, nonzero means multiquadric
                        ignored for BFType=2
            LambdaV -   regularization parameter
            ATerm   -   polynomial term type:
                        * 1 for linear term (STRONGLY RECOMMENDED)
                        * 2 for constant term (may break convergence guarantees for thin plate splines)
                        * 3 for zero term (may break convergence guarantees for all types of splines)
            S       -   RBF model, already initialized by RBFCreate() call.
            progress10000- variable used for progress reports, it is regularly set
                        to the current progress multiplied by 10000, in order to
                        get value in [0,10000] range. The rationale for such scaling
                        is that it allows us to use integer type to store progress,
                        which has less potential for non-atomic corruption on unprotected
                        reads from another threads.
                        You can read this variable from some other thread to get
                        estimate of the current progress.
                        Initial value of this variable is ignored, it is written by
                        this function, but not read.
            terminationrequest - variable used for termination requests; its initial
                        value must be False, and you can set it to True from some
                        other thread. This routine regularly checks this variable
                        and will terminate model construction shortly upon discovering
                        that termination was requested.
            
        OUTPUT PARAMETERS:
            S       -   updated model (for rep.terminationtype>0, unchanged otherwise)
            Rep     -   report:
                        * Rep.TerminationType:
                          *  1 - successful termination
                          *  8 terminated by user via rbfrequesttermination()
                        Fields are used for debugging purposes:
                        * Rep.IterationsCount - iterations count of the GMRES solver

        NOTE:  failure  to  build  model will leave current state of the structure
        unchanged.

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3build(double[,] xraw,
            double[,] yraw,
            int nraw,
            double[] scaleraw,
            int bftype,
            double bfparamraw,
            double lambdavraw,
            int aterm,
            rbfv3model s,
            ref int progress10000,
            ref bool terminationrequest,
            rbfv3report rep,
            alglib.xparams _params)
        {
            double tol = 0;
            int n = 0;
            int nx = 0;
            int ny = 0;
            double bfparamscaled = 0;
            double lambdavwrk = 0;
            double rescaledby = 0;
            double mergetol = 0;
            int matrixformat = 0;
            int acbfbatch = 0;
            int nglobal = 0;
            int nlocal = 0;
            int ncorrection = 0;
            int nbatch = 0;
            int nneighbors = 0;
            int ncoarse = 0;
            double[,] xscaled = new double[0,0];
            double[,] yscaled = new double[0,0];
            double[,] xcoarse = new double[0,0];
            double[,] x1t = new double[0,0];
            rbf3evaluator bfmatrix = new rbf3evaluator();
            double[] b = new double[0];
            double[] x0 = new double[0];
            double[] x1 = new double[0];
            double[] y0 = new double[0];
            double[] y1 = new double[0];
            double[] sft = new double[0];
            double[] scalewrk = new double[0];
            double[,] c2 = new double[0,0];
            double[,] res = new double[0,0];
            double[,] upd0 = new double[0,0];
            double[,] upd1 = new double[0,0];
            double[,] ortbasis = new double[0,0];
            int ortbasissize = 0;
            int[] raw2wrkmap = new int[0];
            int[] wrk2rawmap = new int[0];
            int[] idummy = new int[0];
            sparse.sparsematrix sp = new sparse.sparsematrix();
            iterativesparse.sparsesolverstate ss = new iterativesparse.sparsesolverstate();
            directsparsesolvers.sparsesolverreport ssrep = new directsparsesolvers.sparsesolverreport();
            rbf3ddmsolver ddmsolver = new rbf3ddmsolver();
            double resnrm = 0;
            double res0nrm = 0;
            int iteridx = 0;
            int yidx = 0;
            bool dotrace = new bool();
            bool dodetailedtrace = new bool();
            fbls.fblsgmresstate gmressolver = new fbls.fblsgmresstate();
            double orterr = 0;
            int timeprec = 0;
            int timedesign = 0;
            int timeddminit = 0;
            int timeddmsolve = 0;
            int timecorrinit = 0;
            int timecorrsolve = 0;
            int timereeval = 0;
            int timetotal = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            double v = 0;
            double vv = 0;
            double[,] refrhs = new double[0,0];
            double[] refrhs1 = new double[0];
            double[] refsol1 = new double[0];

            mergetol = 1000*math.machineepsilon;
            tol = 1.0E-6;
            alglib.ap.assert(s.nx>0, "RBFV3Build: incorrect NX");
            alglib.ap.assert(s.ny>0, "RBFV3Build: incorrect NY");
            alglib.ap.assert((bftype==1 || bftype==2) || bftype==3, "RBFV3Build: incorrect BFType");
            alglib.ap.assert((aterm==1 || aterm==2) || aterm==3, "RBFV3Build: incorrect BFType");
            for(j=0; j<=s.nx-1; j++)
            {
                alglib.ap.assert((double)(scaleraw[j])>(double)(0), "RBFV2BuildHierarchical: incorrect ScaleVec");
            }
            nx = s.nx;
            ny = s.ny;
            bfparamscaled = bfparamraw;
            
            //
            // Trace output (if needed)
            //
            dotrace = ap.istraceenabled("RBF", _params);
            dodetailedtrace = dotrace && ap.istraceenabled("RBF.DETAILED", _params);
            if( dotrace )
            {
                alglib.ap.trace("\n\n");
                alglib.ap.trace("////////////////////////////////////////////////////////////////////////////////////////////////////\n");
                alglib.ap.trace("// DDM-RBF builder started                                                                        //\n");
                alglib.ap.trace("////////////////////////////////////////////////////////////////////////////////////////////////////\n");
            }
            
            //
            // Clean up communication and report fields
            //
            progress10000 = 0;
            rep.maxerror = 0;
            rep.rmserror = 0;
            rep.iterationscount = 0;
            timeprec = 0;
            timedesign = 0;
            timeddminit = 0;
            timeddmsolve = 0;
            timecorrinit = 0;
            timecorrsolve = 0;
            timereeval = 0;
            timetotal = 0-unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            
            //
            // Quick exit when we have no points
            //
            if( nraw==0 )
            {
                zerofill(s, nx, ny, _params);
                rep.terminationtype = 1;
                progress10000 = 10000;
                return;
            }
            
            //
            // Preprocess dataset (scale points, merge nondistinct ones)
            //
            preprocessdataset(xraw, mergetol, yraw, scaleraw, nraw, nx, ny, bftype, bfparamraw, lambdavraw, ref xscaled, ref yscaled, ref raw2wrkmap, ref wrk2rawmap, ref n, ref scalewrk, ref sft, ref bfparamscaled, ref lambdavwrk, ref rescaledby, _params);
            ablasf.rallocm(nx+1, n, ref x1t, _params);
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    x1t[j,i] = xscaled[i,j];
                }
                x1t[nx,i] = 1.0;
            }
            
            //
            // Compute design matrix
            //
            matrixformat = 1;
            if( dotrace )
            {
                alglib.ap.trace("=== MODEL MATRIX INITIALIZATION STARTED ============================================================\n");
                alglib.ap.trace(System.String.Format("N           = {0,0:d}\nNX          = {1,0:d}\nNY          = {2,0:d}\n", n, nx, ny));
                alglib.ap.trace(System.String.Format("BFType      = {0,0:d}", bftype));
                if( bftype==1 && (double)(bfparamraw)>(double)(0) )
                {
                    alglib.ap.trace(System.String.Format("  ( f=sqrt(r^2+alpha^2), alpha={0,0:F3}, multiquadric with manual radius)", bfparamraw));
                }
                if( bftype==1 && (double)(bfparamraw)==(double)(0) )
                {
                    alglib.ap.trace("  ( f=r, biharmonic spline )");
                }
                if( bftype==1 && (double)(bfparamraw)<(double)(0) )
                {
                    alglib.ap.trace(System.String.Format("  ( f=sqrt(r^2+alpha^2), alpha=AUTO*{0,0:F3}={1,0:E2}, multiquadric )", -bfparamraw, bfparamscaled));
                }
                if( bftype==2 )
                {
                    alglib.ap.trace("  ( f=log(r)*r^2, thin plate spline )");
                }
                if( bftype==3 )
                {
                    alglib.ap.trace("  ( f=r^3 )");
                }
                alglib.ap.trace("\n");
                alglib.ap.trace(System.String.Format("Polinom.term= {0,0:d} ", aterm));
                if( aterm==1 )
                {
                    alglib.ap.trace("(linear term)");
                }
                if( aterm==2 )
                {
                    alglib.ap.trace("(constant term)");
                }
                if( aterm==3 )
                {
                    alglib.ap.trace("(zero term)");
                }
                alglib.ap.trace("\n");
                alglib.ap.trace(System.String.Format("LambdaV     = {0,0:E2} (raw value of the smoothing parameter; effective value after adjusting for data spread is {1,0:E2})\n", lambdavraw, lambdavwrk));
                alglib.ap.trace("VarScales   = ");
                apserv.tracevectore3(scaleraw, 0, nx, _params);
                alglib.ap.trace(" (raw values of variable scales)\n");
            }
            timedesign = timedesign-unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            modelmatrixinit(xscaled, n, nx, bftype, bfparamscaled, matrixformat, bfmatrix, _params);
            timedesign = timedesign+unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            if( dotrace )
            {
                alglib.ap.trace(System.String.Format("> model matrix initialized in {0,0:d} ms\n", timedesign));
            }
            
            //
            // Build orthogonal basis of the subspace spanned by polynomials of 1st degree.
            // This basis is used later to check orthogonality conditions for the coefficients.
            //
            ablasf.rallocm(nx+1, n, ref ortbasis, _params);
            ablasf.rsetr(n, 1/Math.Sqrt(n), ortbasis, 0, _params);
            ortbasissize = 1;
            ablasf.rallocv(n, ref x0, _params);
            for(k=0; k<=nx-1; k++)
            {
                for(j=0; j<=n-1; j++)
                {
                    x0[j] = xscaled[j,k];
                }
                v = Math.Sqrt(ablasf.rdotv2(n, x0, _params));
                ablas.rowwisegramschmidt(ortbasis, ortbasissize, n, x0, ref x0, false, _params);
                vv = Math.Sqrt(ablasf.rdotv2(n, x0, _params));
                if( (double)(vv)>(double)(Math.Sqrt(math.machineepsilon)*(v+1)) )
                {
                    ablasf.rcopymulvr(n, 1/vv, x0, ortbasis, ortbasissize, _params);
                    ortbasissize = ortbasissize+1;
                }
            }
            
            //
            // Build preconditioner
            //
            nglobal = 0;
            nlocal = Math.Max((int)Math.Round(Math.Pow(5.5, nx)), 25);
            ncorrection = (int)Math.Round(Math.Pow(5, nx));
            acbfbatch = 32;
            if( dotrace )
            {
                alglib.ap.trace("=== PRECONDITIONER CONSTRUCTION STARTED ============================================================\n");
                alglib.ap.trace(System.String.Format("nglobal     = {0,0:d}\nnlocal      = {1,0:d}\nncorrection = {2,0:d}\nnbatch      = {3,0:d}\n", nglobal, nlocal, ncorrection, acbfbatch));
            }
            timeprec = timeprec-unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            computeacbfpreconditioner(xscaled, n, nx, bftype, bfparamscaled, aterm, acbfbatch, nglobal, nlocal, ncorrection, 5, 2, lambdavwrk, sp, _params);
            timeprec = timeprec+unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            if( dotrace )
            {
                alglib.ap.trace(System.String.Format("> ACBF preconditioner computed in {0,0:d} ms\n", timeprec));
            }
            
            //
            // DDM
            //
            if( dotrace )
            {
                alglib.ap.trace("=== DOMAIN DECOMPOSITION METHOD STARTED ============================================================\n");
            }
            ablasf.rsetallocm(n+nx+1, ny, 0.0, ref c2, _params);
            nneighbors = (int)Math.Round(Math.Pow(5, nx));
            if( nx==1 )
            {
                nbatch = apserv.imin2(100, n, _params);
            }
            else
            {
                if( nx==2 )
                {
                    nbatch = apserv.imin2(100, n, _params);
                }
                else
                {
                    nbatch = apserv.imin3((int)Math.Round(Math.Pow(10, nx)), 1000, n, _params);
                }
            }
            ncoarse = (int)Math.Round(Math.Max(4, Math.Pow(3.0, nx))*((double)n/(double)nbatch+1));
            ncoarse = Math.Max(ncoarse, (int)Math.Round(Math.Pow(4, nx)));
            ncoarse = Math.Min(ncoarse, n);
            if( dotrace )
            {
                alglib.ap.trace("> problem metrics and settings\n");
                alglib.ap.trace(System.String.Format("NNeighbors  = {0,0:d}\n", nneighbors));
                alglib.ap.trace(System.String.Format("NBatch      = {0,0:d}\n", nbatch));
                alglib.ap.trace(System.String.Format("NCoarse     = {0,0:d}\n", ncoarse));
            }
            ddmsolverinit(xscaled, rescaledby, n, nx, bfmatrix, bftype, bfparamscaled, lambdavwrk, aterm, sp, nneighbors, nbatch, ncoarse, dotrace, dodetailedtrace, ddmsolver, ref timeddminit, ref timecorrinit, _params);
            if( dotrace )
            {
                alglib.ap.trace(System.String.Format("> DDM initialization done in {0,0:d} ms, {1,0:d} subproblems solved ({2,0:d} well-conditioned, {3,0:d} ill-conditioned)\n", timeddminit, ddmsolver.subproblemscnt, ddmsolver.cntlu, ddmsolver.cntregqr));
            }
            
            //
            // Use preconditioned GMRES
            //
            rep.rmserror = 0;
            rep.maxerror = 0;
            rep.iterationscount = 0;
            for(yidx=0; yidx<=ny-1; yidx++)
            {
                if( dotrace )
                {
                    alglib.ap.trace(System.String.Format("> solving for component {0,2:d}:\n", yidx));
                }
                ablasf.rsetallocv(n+nx+1, 0.0, ref y0, _params);
                ablasf.rsetallocv(n+nx+1, 0.0, ref y1, _params);
                ablasf.rcopycv(n, yscaled, yidx, y0, _params);
                fbls.fblsgmrescreate(y0, n, Math.Min(maxddmits, n), gmressolver, _params);
                gmressolver.epsres = tol;
                gmressolver.epsred = epsred;
                iteridx = 0;
                while( fbls.fblsgmresiteration(gmressolver, _params) )
                {
                    if( dotrace )
                    {
                        alglib.ap.trace(System.String.Format(">> DDM iteration {0,2:d}: {1,0:E2} relative residual\n", iteridx, gmressolver.reprelres));
                    }
                    ablasf.rallocv(n+nx+1, ref y0, _params);
                    ablasf.rallocv(n+nx+1, ref y1, _params);
                    ddmsolverrun1(ddmsolver, gmressolver.x, n, nx, sp, bfmatrix, ref y0, ref timeddmsolve, ref timecorrsolve, _params);
                    timereeval = timereeval-unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
                    modelmatrixcomputeproduct(bfmatrix, y0, ref y1, _params);
                    ablasf.rgemvx(n, nx+1, 1.0, x1t, 0, 0, 1, y0, n, 1.0, y1, 0, _params);
                    for(i=0; i<=n-1; i++)
                    {
                        y1[i] = y1[i]+lambdavwrk*y0[i];
                    }
                    timereeval = timereeval+unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
                    ablasf.rcopyv(n, y1, gmressolver.ax, _params);
                    rep.iterationscount = rep.iterationscount+1;
                    iteridx = iteridx+1;
                }
                ddmsolverrun1(ddmsolver, gmressolver.xs, n, nx, sp, bfmatrix, ref x1, ref timeddmsolve, ref timecorrsolve, _params);
                ablasf.rcopyvc(n+nx+1, x1, c2, yidx, _params);
                
                //
                // Compute predictions and errors
                //
                // NOTE: because dataset preprocessing may reorder and merge points we have
                //       to use raw-to-work mapping in order to be able to compute correct
                //       error metrics.
                //
                timereeval = timereeval-unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
                modelmatrixcomputeproduct(bfmatrix, x1, ref y1, _params);
                ablasf.rgemvx(n, nx+1, 1.0, x1t, 0, 0, 1, x1, n, 1.0, y1, 0, _params);
                timereeval = timereeval+unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
                resnrm = 0;
                res0nrm = 0;
                for(i=0; i<=n-1; i++)
                {
                    resnrm = resnrm+math.sqr(yscaled[i,yidx]-y1[i]-lambdavwrk*x1[i]);
                    res0nrm = res0nrm+math.sqr(yscaled[i,yidx]);
                }
                resnrm = Math.Sqrt(resnrm);
                res0nrm = Math.Sqrt(res0nrm);
                for(i=0; i<=nraw-1; i++)
                {
                    v = yraw[i,yidx]-y1[raw2wrkmap[i]];
                    rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v));
                    rep.rmserror = rep.rmserror+v*v;
                }
                if( dotrace )
                {
                    alglib.ap.trace(System.String.Format(">> done with {0,0:E2} relative residual, GMRES completion code {1,0:d}\n", resnrm/apserv.coalesce(res0nrm, 1, _params), gmressolver.retcode));
                }
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/(nraw*ny));
            timetotal = timetotal+unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            if( dotrace )
            {
                ablasf.rallocv(n, ref y0, _params);
                orterr = 0;
                for(k=0; k<=ny-1; k++)
                {
                    ablasf.rcopycv(n, c2, k, y0, _params);
                    for(i=0; i<=ortbasissize-1; i++)
                    {
                        orterr = Math.Max(orterr, Math.Abs(ablasf.rdotvr(n, y0, ortbasis, i, _params)));
                    }
                }
                alglib.ap.trace("=== PRINTING RBF SOLVER RESULTS ====================================================================\n");
                alglib.ap.trace("> errors\n");
                alglib.ap.trace(System.String.Format("RMS.err     = {0,0:E2}\n", rep.rmserror));
                alglib.ap.trace(System.String.Format("MAX.err     = {0,0:E2}\n", rep.maxerror));
                alglib.ap.trace(System.String.Format("ORT.err     = {0,0:E2} (orthogonality condition)\n", orterr));
                alglib.ap.trace("> DDM iterations\n");
                alglib.ap.trace(System.String.Format("ItsCnt      = {0,0:d}\n", rep.iterationscount));
                alglib.ap.trace(System.String.Format("> total running time is {0,0:d} ms, including:\n", timetotal));
                alglib.ap.trace(System.String.Format(">> model matrix generation               {0,8:d} ms\n", timedesign));
                alglib.ap.trace(System.String.Format(">> ACBF preconditioner construction      {0,8:d} ms\n", timeprec));
                alglib.ap.trace(System.String.Format(">> DDM solver initialization             {0,8:d} ms\n", timeddminit));
                alglib.ap.trace(System.String.Format(">> DDM corrector initialization          {0,8:d} ms\n", timecorrinit));
                alglib.ap.trace(System.String.Format(">> DDM solution phase                    {0,8:d} ms\n", timeddmsolve));
                alglib.ap.trace(System.String.Format(">> DDM correction phase                  {0,8:d} ms\n", timecorrsolve));
                alglib.ap.trace(System.String.Format(">> DDM solver model reevaluation         {0,8:d} ms\n", timereeval));
            }
            s.bftype = bftype;
            s.bfparam = bfparamscaled;
            ablasf.rcopyallocv(nx, scalewrk, ref s.s, _params);
            for(j=0; j<=ny-1; j++)
            {
                s.v[j,nx] = c2[n+nx,j];
                for(i=0; i<=nx-1; i++)
                {
                    s.v[j,i] = c2[n+i,j]/scalewrk[i];
                    s.v[j,nx] = s.v[j,nx]-c2[n+i,j]*sft[i]/scalewrk[i];
                }
            }
            ablasf.rallocv(n*(nx+ny), ref s.cw, _params);
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    s.cw[i*(nx+ny)+j] = xscaled[i,j]+sft[j]/scalewrk[j];
                }
                for(j=0; j<=ny-1; j++)
                {
                    s.cw[i*(nx+ny)+nx+j] = c2[i,j];
                }
            }
            ablasf.icopyallocv(n, wrk2rawmap, ref s.pointindexes, _params);
            s.nc = n;
            createfastevaluator(s, _params);
            
            //
            // Set up debug fields
            //
            s.dbgregqrusedforddm = ddmsolver.cntregqr>0;
            
            //
            // Update progress reports
            //
            rep.terminationtype = 1;
            progress10000 = 10000;
        }


        /*************************************************************************
        Serializer: allocation

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3alloc(alglib.serializer s,
            rbfv3model model,
            alglib.xparams _params)
        {
            
            //
            // Data
            //
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            apserv.allocrealarray(s, model.s, model.nx, _params);
            apserv.allocrealmatrix(s, model.v, model.ny, model.nx+1, _params);
            apserv.allocrealarray(s, model.cw, model.nc*(model.nx+model.ny), _params);
            apserv.allocintegerarray(s, model.pointindexes, model.nc, _params);
            
            //
            // End of stream, no additional data
            //
            s.alloc_entry();
        }


        /*************************************************************************
        Serializer: serialization

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3serialize(alglib.serializer s,
            rbfv3model model,
            alglib.xparams _params)
        {
            
            //
            // Data
            //
            s.serialize_int(model.nx);
            s.serialize_int(model.ny);
            s.serialize_int(model.bftype);
            s.serialize_double(model.bfparam);
            s.serialize_int(model.nc);
            apserv.serializerealarray(s, model.s, model.nx, _params);
            apserv.serializerealmatrix(s, model.v, model.ny, model.nx+1, _params);
            apserv.serializerealarray(s, model.cw, model.nc*(model.nx+model.ny), _params);
            apserv.serializeintegerarray(s, model.pointindexes, model.nc, _params);
            
            //
            // End of stream, no additional data
            //
            s.serialize_int(117256);
        }


        /*************************************************************************
        Serializer: unserialization

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3unserialize(alglib.serializer s,
            rbfv3model model,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;
            int bftype = 0;
            int k = 0;
            double bfparam = 0;

            
            //
            // Unserialize primary model parameters, initialize model.
            //
            // It is necessary to call RBFCreate() because some internal fields
            // which are NOT unserialized will need initialization.
            //
            nx = s.unserialize_int();
            ny = s.unserialize_int();
            bftype = s.unserialize_int();
            bfparam = s.unserialize_double();
            rbfv3create(nx, ny, bftype, bfparam, model, _params);
            model.nc = s.unserialize_int();
            apserv.unserializerealarray(s, ref model.s, _params);
            apserv.unserializerealmatrix(s, ref model.v, _params);
            apserv.unserializerealarray(s, ref model.cw, _params);
            apserv.unserializeintegerarray(s, ref model.pointindexes, _params);
            
            //
            // End of stream, check that no additional data is present
            //
            k = s.unserialize_int();
            alglib.ap.assert(k==117256, "RBFV3Unserialize: unexpected payload detected in the data stream. Integrity check failed");
            
            //
            // Finalize construction
            //
            createfastevaluator(model, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model in the given point.

        This function should be used when we have NY=1 (scalar function) and  NX=1
        (1-dimensional space).

        This function returns 0.0 when:
        * the model is not initialized
        * NX<>1
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   X-coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfv3calc1(rbfv3model s,
            double x0,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc1: invalid value for X0 (X0 is Inf)!");
            if( s.ny!=1 || s.nx!=1 )
            {
                result = 0;
                return result;
            }
            result = s.v[0,0]*x0-s.v[0,1];
            s.calcbuf.x123[0] = x0;
            rbfv3tscalcbuf(s, s.calcbuf, s.calcbuf.x123, ref s.calcbuf.y123, _params);
            result = s.calcbuf.y123[0];
            return result;
        }


        /*************************************************************************
        This function calculates values of the RBF model in the given point.

        This function should be used when we have NY=1 (scalar function) and  NX=2
        (2-dimensional space). If you have 3-dimensional space, use RBFCalc3(). If
        you have general situation (NX-dimensional space, NY-dimensional function)
        you should use general, less efficient implementation RBFCalc().

        If  you  want  to  calculate  function  values  many times, consider using 
        RBFGridCalc2(), which is far more efficient than many subsequent calls  to
        RBFCalc2().

        This function returns 0.0 when:
        * model is not initialized
        * NX<>2
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfv3calc2(rbfv3model s,
            double x0,
            double x1,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc2: invalid value for X0 (X0 is Inf)!");
            alglib.ap.assert(math.isfinite(x1), "RBFCalc2: invalid value for X1 (X1 is Inf)!");
            if( s.ny!=1 || s.nx!=2 )
            {
                result = 0;
                return result;
            }
            result = s.v[0,0]*x0+s.v[0,1]*x1+s.v[0,2];
            if( s.nc==0 )
            {
                return result;
            }
            s.calcbuf.x123[0] = x0;
            s.calcbuf.x123[1] = x1;
            rbfv3tscalcbuf(s, s.calcbuf, s.calcbuf.x123, ref s.calcbuf.y123, _params);
            result = s.calcbuf.y123[0];
            return result;
        }


        /*************************************************************************
        This function calculates values of the RBF model in the given point.

        This function should be used when we have NY=1 (scalar function) and  NX=3
        (3-dimensional space). If you have 2-dimensional space, use RBFCalc2(). If
        you have general situation (NX-dimensional space, NY-dimensional function)
        you should use general, less efficient implementation RBFCalc().

        This function returns 0.0 when:
        * model is not initialized
        * NX<>3
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number
            X2      -   third coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfv3calc3(rbfv3model s,
            double x0,
            double x1,
            double x2,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc3: invalid value for X0 (X0 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x1), "RBFCalc3: invalid value for X1 (X1 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x2), "RBFCalc3: invalid value for X2 (X2 is Inf or NaN)!");
            if( s.ny!=1 || s.nx!=3 )
            {
                result = 0;
                return result;
            }
            result = s.v[0,0]*x0+s.v[0,1]*x1+s.v[0,2]*x2+s.v[0,3];
            if( s.nc==0 )
            {
                return result;
            }
            s.calcbuf.x123[0] = x0;
            s.calcbuf.x123[1] = x1;
            s.calcbuf.x123[2] = x2;
            rbfv3tscalcbuf(s, s.calcbuf, s.calcbuf.x123, ref s.calcbuf.y123, _params);
            result = s.calcbuf.y123[0];
            return result;
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point.

        Same as RBFCalc(), but does not reallocate Y when in is large enough to 
        store function values.

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3calcbuf(rbfv3model s,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            rbfv3tscalcbuf(s, s.calcbuf, x, ref y, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point, using
        external  buffer  object  (internal  temporaries  of  RBF  model  are  not
        modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3tscalcbuf(rbfv3model s,
            rbfv3calcbuffer buf,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;
            int i = 0;
            int j = 0;
            double distance0 = 0;
            int colidx = 0;
            int srcidx = 0;
            int widx = 0;
            int curchunk = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFV3TsCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFV3TsCalcBuf: X contains infinite or NaN values");
            nx = s.nx;
            ny = s.ny;
            
            //
            // Handle linear term
            //
            if( alglib.ap.len(y)<ny )
            {
                y = new double[ny];
            }
            for(i=0; i<=ny-1; i++)
            {
                y[i] = s.v[i,nx];
                for(j=0; j<=nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                }
            }
            if( s.nc==0 )
            {
                return;
            }
            
            //
            // Handle RBF term
            //
            alglib.ap.assert((s.bftype==1 || s.bftype==2) || s.bftype==3, "RBFV3TsCalcBuf: unsupported basis function type");
            for(j=0; j<=nx-1; j++)
            {
                buf.x[j] = x[j]/s.s[j];
            }
            ablasf.rallocv(s.evaluator.chunksize, ref buf.evalbuf.funcbuf, _params);
            ablasf.rallocv(s.evaluator.chunksize, ref buf.evalbuf.wrkbuf, _params);
            colidx = 0;
            srcidx = 0;
            widx = 0;
            distance0 = 1.0E-50;
            if( s.bftype==1 )
            {
                
                //
                // Kernels that add squared parameter to the squared distance
                //
                distance0 = math.sqr(s.bfparam);
            }
            while( colidx<s.nc )
            {
                
                //
                // Handle basecase with size at most ChunkSize*ChunkSize
                //
                curchunk = Math.Min(s.evaluator.chunksize, s.nc-colidx);
                computerowchunk(s.evaluator, buf.x, buf.evalbuf, curchunk, srcidx, distance0, 0, _params);
                for(i=0; i<=ny-1; i++)
                {
                    y[i] = y[i]+ablasf.rdotvr(curchunk, buf.evalbuf.funcbuf, s.wchunked, widx+i, _params);
                }
                colidx = colidx+curchunk;
                srcidx = srcidx+nx;
                widx = widx+ny;
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the  given  point  and
        its derivatives, using external buffer object (internal temporaries of the
        RBF model are not modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y, DY   -   possibly preallocated arrays

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.
            DY      -   derivatives, array[NY*NX]. DY is not reallocated when it
                        is larger than NY*NX.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3tsdiffbuf(rbfv3model s,
            rbfv3calcbuffer buf,
            double[] x,
            ref double[] y,
            ref double[] dy,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;
            int i = 0;
            int j = 0;
            double smalldist2 = 0;
            bool nograd = new bool();
            int colidx = 0;
            int srcidx = 0;
            int widx = 0;
            int curchunk = 0;
            int maxchunksize = 0;
            double distance0 = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFV3TsCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFV3TsCalcBuf: X contains infinite or NaN values");
            nx = s.nx;
            ny = s.ny;
            
            //
            // Handle linear term
            //
            if( alglib.ap.len(y)<ny )
            {
                y = new double[ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            for(i=0; i<=ny-1; i++)
            {
                y[i] = s.v[i,nx];
                for(j=0; j<=nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                    dy[i*nx+j] = s.v[i,j];
                }
            }
            if( s.nc==0 )
            {
                return;
            }
            
            //
            // Rescale X and DY to the internal scaling used by the RBF model
            //
            for(j=0; j<=nx-1; j++)
            {
                buf.x[j] = x[j]/s.s[j];
            }
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    dy[i*nx+j] = dy[i*nx+j]*s.s[j];
                }
            }
            
            //
            // Prepare information necessary for the detection of the nonexistent gradient
            //
            nograd = false;
            smalldist2 = (ablasf.rdotv2(nx, buf.x, _params)+1.0)*math.sqr(100*math.machineepsilon);
            
            //
            // Handle RBF term
            //
            alglib.ap.assert((s.bftype==1 || s.bftype==2) || s.bftype==3, "RBFV3TsDiffBuf: unsupported basis function type");
            alglib.ap.assert(s.bftype!=1 || (double)(s.bfparam)>=(double)(0), "RBFV3TsDiffBuf: inconsistent BFType/BFParam");
            maxchunksize = s.evaluator.chunksize;
            ablasf.rallocv(maxchunksize, ref buf.evalbuf.funcbuf, _params);
            ablasf.rallocv(maxchunksize, ref buf.evalbuf.wrkbuf, _params);
            ablasf.rallocv(maxchunksize, ref buf.evalbuf.df1, _params);
            ablasf.rallocm(nx, maxchunksize, ref buf.evalbuf.deltabuf, _params);
            ablasf.rsetallocv(maxchunksize, 1.0E50, ref buf.evalbuf.mindist2, _params);
            colidx = 0;
            srcidx = 0;
            widx = 0;
            distance0 = 1.0E-50;
            if( s.bftype==1 )
            {
                
                //
                // Kernels that add squared parameter to the squared distance
                //
                distance0 = math.sqr(s.bfparam);
            }
            while( colidx<s.nc )
            {
                
                //
                // Handle basecase with size at most ChunkSize*ChunkSize
                //
                curchunk = Math.Min(maxchunksize, s.nc-colidx);
                computerowchunk(s.evaluator, buf.x, buf.evalbuf, curchunk, srcidx, distance0, 1, _params);
                for(j=0; j<=nx-1; j++)
                {
                    ablasf.rmergemulvr(curchunk, buf.evalbuf.df1, buf.evalbuf.deltabuf, j, _params);
                }
                for(i=0; i<=ny-1; i++)
                {
                    y[i] = y[i]+ablasf.rdotvr(curchunk, buf.evalbuf.funcbuf, s.wchunked, widx+i, _params);
                    for(j=0; j<=nx-1; j++)
                    {
                        dy[i*nx+j] = dy[i*nx+j]+2*ablasf.rdotrr(curchunk, s.wchunked, widx+i, buf.evalbuf.deltabuf, j, _params);
                    }
                }
                colidx = colidx+curchunk;
                srcidx = srcidx+nx;
                widx = widx+ny;
            }
            if( s.bftype==1 && (double)(s.bfparam)==(double)(0) )
            {
                
                //
                // The kernel function is nondifferentiable at nodes, check whether we are close to one of the nodes or not
                //
                for(i=0; i<=maxchunksize-1; i++)
                {
                    nograd = nograd || buf.evalbuf.mindist2[i]<=smalldist2;
                }
                if( nograd )
                {
                    
                    //
                    // The gradient is undefined at the trial point, flush it to zero
                    //
                    ablasf.rsetv(ny*nx, 0.0, dy, _params);
                }
            }
            
            //
            // Rescale derivatives back
            //
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    dy[i*nx+j] = dy[i*nx+j]/s.s[j];
                }
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the  given  point  and
        its first and second derivatives, using external buffer  object  (internal
        temporaries of the RBF model are not modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y,DY,D2Y -  possibly preallocated arrays

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.
            DY      -   derivatives, array[NY*NX]. DY is not reallocated when it
                        is larger than NY*NX.
            D2Y     -   second derivatives, array[NY*NX*NX].
                        D2Y is not reallocated when it is larger than NY*NX*NX.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3tshessbuf(rbfv3model s,
            rbfv3calcbuffer buf,
            double[] x,
            ref double[] y,
            ref double[] dy,
            ref double[] d2y,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int k0 = 0;
            int k1 = 0;
            bool nearnode = new bool();
            bool nograd = new bool();
            bool nohess = new bool();
            double smalldist2 = 0;
            int colidx = 0;
            int srcidx = 0;
            int widx = 0;
            int curchunk = 0;
            int maxchunksize = 0;
            double distance0 = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFV3TsCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFV3TsCalcBuf: X contains infinite or NaN values");
            nx = s.nx;
            ny = s.ny;
            
            //
            // Handle linear term
            //
            if( alglib.ap.len(y)<ny )
            {
                y = new double[ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            if( alglib.ap.len(d2y)<ny*nx*nx )
            {
                d2y = new double[ny*nx*nx];
            }
            for(i=0; i<=ny-1; i++)
            {
                y[i] = s.v[i,nx];
                for(j=0; j<=nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                    dy[i*nx+j] = s.v[i,j];
                }
            }
            ablasf.rsetv(ny*nx*nx, 0.0, d2y, _params);
            if( s.nc==0 )
            {
                return;
            }
            
            //
            // Rescale X and DY to the internal scaling used by the RBF model (D2Y is zero,
            // so it does not need rescaling).
            //
            for(j=0; j<=nx-1; j++)
            {
                buf.x[j] = x[j]/s.s[j];
            }
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    dy[i*nx+j] = dy[i*nx+j]*s.s[j];
                }
            }
            
            //
            // Prepare information necessary for the detection of the nonexistent Hessian
            //
            nograd = false;
            nohess = false;
            smalldist2 = (ablasf.rdotv2(nx, buf.x, _params)+1.0)*math.sqr(100*math.machineepsilon);
            
            //
            // Handle RBF term
            //
            alglib.ap.assert(s.bftype==1 || s.bftype==2, "RBFV3TsHessBuf: unsupported basis function type");
            alglib.ap.assert(s.bftype!=1 || (double)(s.bfparam)>=(double)(0), "RBFV3TsHessBuf: inconsistent BFType/BFParam");
            maxchunksize = s.evaluator.chunksize;
            ablasf.rallocv(maxchunksize, ref buf.evalbuf.funcbuf, _params);
            ablasf.rallocv(maxchunksize, ref buf.evalbuf.wrkbuf, _params);
            ablasf.rallocv(maxchunksize, ref buf.evalbuf.df1, _params);
            ablasf.rallocv(maxchunksize, ref buf.evalbuf.df2, _params);
            ablasf.rallocm(nx, maxchunksize, ref buf.evalbuf.deltabuf, _params);
            ablasf.rsetallocv(maxchunksize, 1.0E50, ref buf.evalbuf.mindist2, _params);
            colidx = 0;
            srcidx = 0;
            widx = 0;
            distance0 = 1.0E-50;
            if( s.bftype==1 )
            {
                
                //
                // Kernels that add squared parameter to the squared distance
                //
                distance0 = math.sqr(s.bfparam);
            }
            while( colidx<s.nc )
            {
                
                //
                // Handle basecase with size at most ChunkSize*ChunkSize
                //
                curchunk = Math.Min(maxchunksize, s.nc-colidx);
                computerowchunk(s.evaluator, buf.x, buf.evalbuf, curchunk, srcidx, distance0, 2, _params);
                for(i=0; i<=ny-1; i++)
                {
                    y[i] = y[i]+ablasf.rdotvr(curchunk, buf.evalbuf.funcbuf, s.wchunked, widx+i, _params);
                    for(k0=0; k0<=nx-1; k0++)
                    {
                        ablasf.rcopyrv(curchunk, buf.evalbuf.deltabuf, k0, buf.evalbuf.wrkbuf, _params);
                        ablasf.rmergemulv(curchunk, buf.evalbuf.df1, buf.evalbuf.wrkbuf, _params);
                        dy[i*nx+k0] = dy[i*nx+k0]+2*ablasf.rdotvr(curchunk, buf.evalbuf.wrkbuf, s.wchunked, widx+i, _params);
                    }
                    for(k0=0; k0<=nx-1; k0++)
                    {
                        for(k1=0; k1<=nx-1; k1++)
                        {
                            ablasf.rcopyv(curchunk, buf.evalbuf.df2, buf.evalbuf.wrkbuf, _params);
                            ablasf.rmergemulrv(curchunk, buf.evalbuf.deltabuf, k0, buf.evalbuf.wrkbuf, _params);
                            ablasf.rmergemulrv(curchunk, buf.evalbuf.deltabuf, k1, buf.evalbuf.wrkbuf, _params);
                            d2y[i*nx*nx+k0*nx+k1] = d2y[i*nx*nx+k0*nx+k1]+4*ablasf.rdotvr(curchunk, buf.evalbuf.wrkbuf, s.wchunked, widx+i, _params);
                            if( k0==k1 )
                            {
                                d2y[i*nx*nx+k0*nx+k1] = d2y[i*nx*nx+k0*nx+k1]+2*ablasf.rdotvr(curchunk, buf.evalbuf.df1, s.wchunked, widx+i, _params);
                            }
                        }
                    }
                }
                colidx = colidx+curchunk;
                srcidx = srcidx+nx;
                widx = widx+ny;
            }
            nearnode = false;
            if( (s.bftype==1 && (double)(s.bfparam)==(double)(0)) || s.bftype==2 )
            {
                
                //
                // The kernel function is nondifferentiable at nodes, check whether we are close to one of the nodes or not
                //
                for(i=0; i<=maxchunksize-1; i++)
                {
                    nearnode = nearnode || buf.evalbuf.mindist2[i]<=smalldist2;
                }
            }
            nograd = nearnode && (s.bftype==1 && (double)(s.bfparam)==(double)(0));
            nohess = nearnode && ((s.bftype==1 && (double)(s.bfparam)==(double)(0)) || s.bftype==2);
            if( nograd )
            {
                
                //
                // The gradient is undefined at the trial point, flush it to zero
                //
                ablasf.rsetv(ny*nx, 0.0, dy, _params);
            }
            if( nohess )
            {
                
                //
                // The Hessian is undefined at the trial point, flush it to zero
                //
                ablasf.rsetv(ny*nx*nx, 0.0, d2y, _params);
            }
            
            //
            // Rescale derivatives back
            //
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    dy[i*nx+j] = dy[i*nx+j]/s.s[j];
                }
            }
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    for(k=0; k<=nx-1; k++)
                    {
                        d2y[i*nx*nx+j*nx+k] = d2y[i*nx*nx+j*nx+k]/(s.s[j]*s.s[k]);
                    }
                }
            }
        }


        /*************************************************************************
        This function is used to perform gridded calculation  for  2D,  3D  or  4D
        problems. It accepts parameters X0...X3 and counters N0...N3. If RBF model
        has dimensionality less than 4, corresponding arrays should  contain  just
        one element equal to zero, and corresponding N's should be equal to 1.

        NOTE: array Y should be preallocated by caller.

          -- ALGLIB --
             Copyright 12.07.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3gridcalcvx(rbfv3model s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            double[] x3,
            int n3,
            bool[] flagy,
            bool sparsey,
            double[] y,
            alglib.xparams _params)
        {
            rbfv3calcbuffer bufseed = new rbfv3calcbuffer();
            alglib.smp.shared_pool bufpool = new alglib.smp.shared_pool();
            int simdwidth = 0;
            int tilescnt = 0;

            
            //
            // Perform integrity checks
            //
            alglib.ap.assert(s.nx==2 || s.nx==3, "RBFGridCalcVX: integrity check failed");
            alglib.ap.assert(((n0>=1 && n1>=1) && n2>=1) && n3>=1, "RBFGridCalcVX: integrity check failed");
            alglib.ap.assert(s.nx>=4 || ((alglib.ap.len(x3)>=1 && (double)(x3[0])==(double)(0)) && n3==1), "RBFGridCalcVX: integrity check failed");
            alglib.ap.assert(s.nx>=3 || ((alglib.ap.len(x2)>=1 && (double)(x2[0])==(double)(0)) && n2==1), "RBFGridCalcVX: integrity check failed");
            alglib.ap.assert(s.nx>=2 || ((alglib.ap.len(x1)>=1 && (double)(x1[0])==(double)(0)) && n1==1), "RBFGridCalcVX: integrity check failed");
            alglib.ap.assert(!sparsey || alglib.ap.len(flagy)>=n0*n1*n2*n3, "RBFGridCalcVX: integrity check failed");
            
            //
            // Prepare shared pool
            //
            rbfv3createcalcbuffer(s, bufseed, _params);
            alglib.smp.ae_shared_pool_set_seed(bufpool, bufseed);
            
            //
            // Call worker function
            //
            simdwidth = 8;
            tilescnt = apserv.idivup(n0, simdwidth, _params)*apserv.idivup(n1, simdwidth, _params)*apserv.idivup(n2, simdwidth, _params)*apserv.idivup(n3, simdwidth, _params);
            gridcalcrec(s, simdwidth, 0, tilescnt, x0, n0, x1, n1, x2, n2, x3, n3, flagy, sparsey, y, bufpool, true, _params);
        }


        /*************************************************************************
        This function "unpacks" RBF model by extracting its coefficients.

        INPUT PARAMETERS:
            S       -   RBF model

        OUTPUT PARAMETERS:
            NX      -   dimensionality of argument
            NY      -   dimensionality of the target function
            XWR     -   model information, array[NC,NX+NY+NX+2].
                        One row of the array corresponds to one basis function
                        * first NX columns  - coordinates of the center 
                        * next  NY columns  - weights, one per dimension of the 
                                              function being modeled
                        * next NX columns   - radii, one per dimension
                        * next column       - basis function type:
                                              * 1  for f=r
                                              * 2  for f=r^2*ln(r)
                                              * 10 for multiquadric f=sqrt(r^2+alpha^2)
                        * next column       - basis function parameter:
                                              * alpha, for basis function type 10
                                              * ignored (zero) for other basis function types
                        * next column       - point index in the original dataset,
                                              or -1 for an artificial node created
                                              by the solver. The algorithm may reorder
                                              the nodes, drop some nodes or add
                                              artificial nodes. Thus, one parsing
                                              this column should expect all these
                                              kinds of alterations in the dataset.
            NC      -   number of the centers
            V       -   polynomial  term , array[NY,NX+1]. One row per one 
                        dimension of the function being modelled. First NX 
                        elements are linear coefficients, V[NX] is equal to the 
                        constant part.

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv3unpack(rbfv3model s,
            ref int nx,
            ref int ny,
            ref double[,] xwr,
            ref int nc,
            ref double[,] v,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int cwwidth = 0;
            bool recognized = new bool();

            nx = 0;
            ny = 0;
            xwr = new double[0,0];
            nc = 0;
            v = new double[0,0];

            nx = s.nx;
            ny = s.ny;
            nc = s.nc;
            
            //
            // Fill V
            //
            v = new double[s.ny, s.nx+1];
            for(i=0; i<=s.ny-1; i++)
            {
                ablasf.rcopyrr(nx+1, s.v, i, v, i, _params);
            }
            
            //
            // Fill XWR
            //
            if( nc>0 )
            {
                cwwidth = nx+ny;
                xwr = new double[nc, nx+ny+nx+3];
                for(i=0; i<=nc-1; i++)
                {
                    
                    //
                    // Output centers (in the original variable scaling), weights and radii
                    //
                    for(j=0; j<=nx-1; j++)
                    {
                        xwr[i,j] = s.cw[i*cwwidth+j]*s.s[j];
                    }
                    for(j=0; j<=ny-1; j++)
                    {
                        xwr[i,nx+j] = s.cw[i*cwwidth+nx+j];
                    }
                    for(j=0; j<=nx-1; j++)
                    {
                        xwr[i,nx+ny+j] = s.s[j];
                    }
                    
                    //
                    // Recognize specific basis function used and perform post-processing
                    //
                    recognized = false;
                    if( s.bftype==1 && (double)(s.bfparam)==(double)(0) )
                    {
                        
                        //
                        // Biharmonic kernel f=r
                        //
                        // Weights are multiplied by -1 because actually it is f=-r (the latter
                        // is conditionally positive definite basis function, and the former is
                        // how it is known to most users)
                        //
                        xwr[i,nx+ny+nx+0] = 1;
                        xwr[i,nx+ny+nx+1] = 0.0;
                        for(j=0; j<=ny-1; j++)
                        {
                            xwr[i,nx+j] = -xwr[i,nx+j];
                        }
                        recognized = true;
                    }
                    if( s.bftype==1 && (double)(s.bfparam)>(double)(0) )
                    {
                        
                        //
                        // Multiquadric f=sqrt(r^2+alpha^2)
                        //
                        // Weights are multiplied by -1 because actually it is f=-sqrt(r^2+alpha^2)
                        // (the latter is conditionally positive definite basis function, and the
                        // former is how it is known to most users)
                        //
                        xwr[i,nx+ny+nx+0] = 10;
                        xwr[i,nx+ny+nx+1] = s.bfparam;
                        for(j=0; j<=ny-1; j++)
                        {
                            xwr[i,nx+j] = -xwr[i,nx+j];
                        }
                        recognized = true;
                    }
                    if( s.bftype==2 )
                    {
                        
                        //
                        // Thin plate spline f=r^2*ln(r)
                        //
                        xwr[i,nx+ny+nx+0] = 2;
                        xwr[i,nx+ny+nx+1] = 0;
                        recognized = true;
                    }
                    alglib.ap.assert(recognized, "RBFV3: integrity check 5342 failed");
                    
                    //
                    // Output indexes
                    //
                    xwr[i,nx+ny+nx+2] = s.pointindexes[i];
                }
            }
        }


        /*************************************************************************
        Creates fast evaluation structures after initialization of the model

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void createfastevaluator(rbfv3model model,
            alglib.xparams _params)
        {
            int offs = 0;
            int ontheflystorage = 0;
            int i = 0;
            int j = 0;
            int nchunks = 0;
            int srcoffs = 0;
            int dstoffs = 0;
            int curlen = 0;
            double[,] xx = new double[0,0];

            
            //
            // Setup model matrix structure
            //
            ontheflystorage = 1;
            ablasf.rallocm(model.nc, model.nx, ref xx, _params);
            offs = 0;
            for(i=0; i<=model.nc-1; i++)
            {
                for(j=0; j<=model.nx-1; j++)
                {
                    xx[i,j] = model.cw[offs+j];
                }
                offs = offs+model.nx+model.ny;
            }
            modelmatrixinit(xx, model.nc, model.nx, model.bftype, model.bfparam, ontheflystorage, model.evaluator, _params);
            
            //
            // Store model coefficients in the efficient chunked format (chunk size is aligned with that
            // of the Model.Evaluator).
            //
            alglib.ap.assert(model.evaluator.chunksize>=1, "RBFV3: integrity check 3535 failed");
            nchunks = apserv.idivup(model.nc, model.evaluator.chunksize, _params);
            ablasf.rsetallocm(nchunks*model.ny, model.evaluator.chunksize, 0.0, ref model.wchunked, _params);
            srcoffs = 0;
            dstoffs = 0;
            while( srcoffs<model.nc )
            {
                curlen = Math.Min(model.evaluator.chunksize, model.nc-srcoffs);
                for(i=0; i<=curlen-1; i++)
                {
                    for(j=0; j<=model.ny-1; j++)
                    {
                        model.wchunked[dstoffs+j,i] = model.cw[(srcoffs+i)*(model.nx+model.ny)+model.nx+j];
                    }
                }
                srcoffs = srcoffs+curlen;
                dstoffs = dstoffs+model.ny;
            }
        }


        /*************************************************************************
        Recursive worker function for gridded calculation

          -- ALGLIB --
             Copyright 01.05.2022 by Bochkanov Sergey
        *************************************************************************/
        private static void gridcalcrec(rbfv3model s,
            int simdwidth,
            int tileidx0,
            int tileidx1,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            double[] x3,
            int n3,
            bool[] flagy,
            bool sparsey,
            double[] y,
            alglib.smp.shared_pool calcpool,
            bool isrootcall,
            alglib.xparams _params)
        {
            int ny = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int dstoffs = 0;
            int l = 0;
            rbfv3calcbuffer buf = null;
            double problemcost = 0;
            int tileidxm = 0;
            int k0 = 0;
            int k1 = 0;
            int k2 = 0;
            int r0a = 0;
            int r0b = 0;
            int r1a = 0;
            int r1b = 0;
            int r2a = 0;
            int r2b = 0;

            ny = s.ny;
            
            //
            // Try parallelism if needed; then perform parallel subdivision:
            // * make all dimensions either (a) multiples of SIMDWidth or (b) less than SIMDWidth by
            //   splitting small chunks from tails
            // * after that iteratively subdivide largest side of the grid (one having largest length,
            //   not largest points count) until we have a chunk with nodes count not greater than SIMDWidth
            //
            problemcost = apserv.rmul2(tileidx1-tileidx0, s.nc, _params);
            problemcost = problemcost*apserv.rmul4(Math.Min(n0, simdwidth), Math.Min(n1, simdwidth), Math.Min(n2, simdwidth), Math.Min(n3, simdwidth), _params);
            if( isrootcall && (double)(problemcost)>=(double)(apserv.smpactivationlevel(_params)) )
            {
                if( _trypexec_gridcalcrec(s,simdwidth,tileidx0,tileidx1,x0,n0,x1,n1,x2,n2,x3,n3,flagy,sparsey,y,calcpool,isrootcall, _params) )
                {
                    return;
                }
            }
            if( (double)(problemcost)>=(double)(apserv.spawnlevel(_params)) && tileidx1-tileidx0>=2 )
            {
            }
            if( tileidx1-tileidx0>=2 )
            {
                tileidxm = tileidx0+apserv.idivup(tileidx1-tileidx0, 2, _params);
                gridcalcrec(s, simdwidth, tileidx0, tileidxm, x0, n0, x1, n1, x2, n2, x3, n3, flagy, sparsey, y, calcpool, false, _params);
                gridcalcrec(s, simdwidth, tileidxm, tileidx1, x0, n0, x1, n1, x2, n2, x3, n3, flagy, sparsey, y, calcpool, false, _params);
                return;
            }
            
            //
            // Handle basecase
            //
            k = tileidx0;
            k0 = k%apserv.idivup(n0, simdwidth, _params);
            k = k/apserv.idivup(n0, simdwidth, _params);
            k1 = k%apserv.idivup(n1, simdwidth, _params);
            k = k/apserv.idivup(n1, simdwidth, _params);
            k2 = k%apserv.idivup(n2, simdwidth, _params);
            k = k/apserv.idivup(n2, simdwidth, _params);
            k = k/apserv.idivup(n3, simdwidth, _params);
            alglib.ap.assert(k==0, "RBFV3: integrity check 7350 failed");
            r0a = k0*simdwidth;
            r0b = Math.Min(r0a+simdwidth, n0);
            r1a = k1*simdwidth;
            r1b = Math.Min(r1a+simdwidth, n1);
            r2a = k2*simdwidth;
            r2b = Math.Min(r2a+simdwidth, n2);
            alglib.smp.ae_shared_pool_retrieve(calcpool, ref buf);
            for(i=r0a; i<=r0b-1; i++)
            {
                for(j=r1a; j<=r1b-1; j++)
                {
                    for(k=r2a; k<=r2b-1; k++)
                    {
                        dstoffs = i+j*n0+k*n0*n1;
                        if( sparsey && !flagy[dstoffs] )
                        {
                            for(l=0; l<=ny-1; l++)
                            {
                                y[l+ny*dstoffs] = 0;
                            }
                            continue;
                        }
                        buf.xg[0] = x0[i];
                        buf.xg[1] = x1[j];
                        buf.xg[2] = x2[k];
                        rbfv3tscalcbuf(s, buf, buf.xg, ref buf.yg, _params);
                        for(l=0; l<=ny-1; l++)
                        {
                            y[l+ny*dstoffs] = buf.yg[l];
                        }
                    }
                }
            }
            alglib.smp.ae_shared_pool_recycle(calcpool, ref buf);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_gridcalcrec(rbfv3model s,
            int simdwidth,
            int tileidx0,
            int tileidx1,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            double[] x3,
            int n3,
            bool[] flagy,
            bool sparsey,
            double[] y,
            alglib.smp.shared_pool calcpool,
            bool isrootcall, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function fills RBF model by zeros, also cleans up debug fields.

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        private static void zerofill(rbfv3model s,
            int nx,
            int ny,
            alglib.xparams _params)
        {
            s.bftype = 0;
            s.bfparam = 0;
            s.nc = 0;
            ablasf.rsetallocv(nx, 1.0, ref s.s, _params);
            ablasf.rsetallocm(ny, nx+1, 0.0, ref s.v, _params);
        }


        /*************************************************************************
        Reallocates calcBuf if necessary, reuses previously allocated space if
        possible.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void allocatecalcbuffer(rbfv3model s,
            rbfv3calcbuffer buf,
            alglib.xparams _params)
        {
            if( alglib.ap.len(buf.x)<s.nx )
            {
                buf.x = new double[s.nx];
            }
            if( alglib.ap.len(buf.x123)<s.nx )
            {
                buf.x123 = new double[s.nx];
            }
            if( alglib.ap.len(buf.y123)<s.ny )
            {
                buf.y123 = new double[s.ny];
            }
            if( alglib.ap.len(buf.xg)<4 )
            {
                buf.xg = new double[4];
            }
            if( alglib.ap.len(buf.yg)<s.ny )
            {
                buf.yg = new double[s.ny];
            }
        }


        /*************************************************************************
        Recursive function that merges points, used by PreprocessDataset()

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void preprocessdatasetrec(double[,] xbuf,
            double[,] ybuf,
            int[] initidx,
            int wrk0,
            int wrk1,
            int nx,
            int ny,
            double mergetol,
            ref double[] tmpboxmin,
            ref double[] tmpboxmax,
            double[,] xout,
            double[,] yout,
            int[] raw2wrkmap,
            int[] wrk2rawmap,
            ref int nout,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k0 = 0;
            int k1 = 0;
            int largestdim = 0;
            double splitval = 0;

            if( wrk1<=wrk0 )
            {
                return;
            }
            
            //
            // Analyze current working set
            //
            ablasf.rallocv(nx, ref tmpboxmin, _params);
            ablasf.rallocv(nx, ref tmpboxmax, _params);
            ablasf.rcopyrv(nx, xbuf, wrk0, tmpboxmin, _params);
            ablasf.rcopyrv(nx, xbuf, wrk0, tmpboxmax, _params);
            for(i=wrk0+1; i<=wrk1-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    tmpboxmin[j] = Math.Min(tmpboxmin[j], xbuf[i,j]);
                    tmpboxmax[j] = Math.Max(tmpboxmax[j], xbuf[i,j]);
                }
            }
            largestdim = 0;
            for(j=1; j<=nx-1; j++)
            {
                if( (double)(tmpboxmax[j]-tmpboxmin[j])>(double)(tmpboxmax[largestdim]-tmpboxmin[largestdim]) )
                {
                    largestdim = j;
                }
            }
            
            //
            // Handle basecase or perform recursive split
            //
            if( wrk1-wrk0==1 || (double)(tmpboxmax[largestdim]-tmpboxmin[largestdim])<(double)(mergetol*apserv.rmax3(ablasf.rmaxabsv(nx, tmpboxmax, _params), ablasf.rmaxabsv(nx, tmpboxmin, _params), 1, _params)) )
            {
                
                //
                // Merge all points, output
                //
                ablasf.rsetr(nx, 0.0, xout, nout, _params);
                ablasf.rsetr(ny, 0.0, yout, nout, _params);
                for(i=wrk0; i<=wrk1-1; i++)
                {
                    ablasf.raddrr(nx, (double)1/(double)(wrk1-wrk0), xbuf, i, xout, nout, _params);
                    ablasf.raddrr(ny, (double)1/(double)(wrk1-wrk0), ybuf, i, yout, nout, _params);
                    raw2wrkmap[initidx[i]] = nout;
                }
                wrk2rawmap[nout] = initidx[wrk0];
                nout = nout+1;
            }
            else
            {
                
                //
                // Perform recursive split along largest axis
                //
                splitval = 0.5*(tmpboxmax[largestdim]+tmpboxmin[largestdim]);
                k0 = wrk0;
                k1 = wrk1-1;
                while( k0<=k1 )
                {
                    if( (double)(xbuf[k0,largestdim])<=(double)(splitval) )
                    {
                        k0 = k0+1;
                        continue;
                    }
                    if( (double)(xbuf[k1,largestdim])>(double)(splitval) )
                    {
                        k1 = k1-1;
                        continue;
                    }
                    apserv.swaprows(xbuf, k0, k1, nx, _params);
                    apserv.swaprows(ybuf, k0, k1, ny, _params);
                    apserv.swapelementsi(initidx, k0, k1, _params);
                    k0 = k0+1;
                    k1 = k1-1;
                }
                alglib.ap.assert(k0>wrk0 && k1<wrk1-1, "RBFV3: integrity check 5843 in the recursive subdivision code failed");
                alglib.ap.assert(k0==k1+1, "RBFV3: integrity check 5364 in the recursive subdivision code failed");
                preprocessdatasetrec(xbuf, ybuf, initidx, wrk0, k0, nx, ny, mergetol, ref tmpboxmin, ref tmpboxmax, xout, yout, raw2wrkmap, wrk2rawmap, ref nout, _params);
                preprocessdatasetrec(xbuf, ybuf, initidx, k0, wrk1, nx, ny, mergetol, ref tmpboxmin, ref tmpboxmax, xout, yout, raw2wrkmap, wrk2rawmap, ref nout, _params);
            }
        }


        /*************************************************************************
        This function preprocesses dataset by:
        * merging non-distinct points
        * centering points
        * applying user scale to X-values
        * performing additional scaling of X-values
        * normalizing Y-values

        INPUT PARAMETERS:
            XRaw        -   array[NRaw,NX], variable values
            YRaw        -   array[NRaw,NY], target values
            XScaleRaw   -   array[NX], user scales
            NRaw,NX,NY  -   metrics; N>0, NX>0, NY>0
            BFType      -   basis function type
            BFParamRaw  -   initial value for basis function paramerer (before
                            applying additional rescaling AddXRescaleAplied)
            LambdaVRaw  -   smoothing coefficient, as specified by user
            
        OUTPUT PARAMETERS:
            XWrk        -   array[NWrk,NX], processed points, XWrk=(XRaw-XShift)/XScaleWrk
            YWrk        -   array[NWrk,NY], targets, scaled by dividing by YScale
            PointIndexes-   array[NWrk], point indexes in the original dataset
            NWrk        -   number of points after preprocessing, 0<NWrk<=NRaw
            XScaleWrk   -   array[NX], XScaleWrk[]=XScaleRaw[]*AddXRescaleAplied
            XShift      -   array[NX], centering coefficients
            YScale      -   common scaling for targets
            BFParamWrk  -   BFParamRaw/AddXRescaleAplied
            LambdaVWrk  -   LambdaV after dataset scaling, automatically adjusted for
                            dataset spread
            AddXRescaleAplied-additional scaling applied after user scaling

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void preprocessdataset(double[,] xraw,
            double mergetol,
            double[,] yraw,
            double[] xscaleraw,
            int nraw,
            int nx,
            int ny,
            int bftype,
            double bfparamraw,
            double lambdavraw,
            ref double[,] xwrk,
            ref double[,] ywrk,
            ref int[] raw2wrkmap,
            ref int[] wrk2rawmap,
            ref int nwrk,
            ref double[] xscalewrk,
            ref double[] xshift,
            ref double bfparamwrk,
            ref double lambdavwrk,
            ref double addxrescaleaplied,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double diag2 = 0;
            double v = 0;
            double[,] xbuf = new double[0,0];
            double[,] ybuf = new double[0,0];
            double[] tmp0 = new double[0];
            double[] tmp1 = new double[0];
            double[] boxmin = new double[0];
            double[] boxmax = new double[0];
            int[] initidx = new int[0];

            xraw = (double[,])xraw.Clone();
            yraw = (double[,])yraw.Clone();
            xscaleraw = (double[])xscaleraw.Clone();
            xwrk = new double[0,0];
            ywrk = new double[0,0];
            raw2wrkmap = new int[0];
            wrk2rawmap = new int[0];
            nwrk = 0;
            xscalewrk = new double[0];
            xshift = new double[0];
            bfparamwrk = 0;
            lambdavwrk = 0;
            addxrescaleaplied = 0;

            alglib.ap.assert(nraw>=1, "RBFV3: integrity check 7295 failed");
            
            //
            // Scale dataset:
            // * first, scale it according to user-supplied scale
            // * second, analyze original dataset and rescale it one more time (same scaling across
            //   all dimensions) so it has zero mean and unit deviation
            // As a result, user-supplied scaling handles dimensionality issues and our additional
            // scaling normalizes data.
            //
            // After this block we have NRaw-sized dataset in XWrk/YWrk
            //
            ablasf.rcopyallocv(nx, xscaleraw, ref xscalewrk, _params);
            ablasf.rsetallocv(nx, 0.0, ref xshift, _params);
            ablasf.rallocm(nraw, nx, ref xwrk, _params);
            for(i=0; i<=nraw-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    xwrk[i,j] = xraw[i,j]/xscalewrk[j];
                    xshift[j] = xshift[j]+xwrk[i,j];
                }
            }
            ablasf.rmulv(nx, (double)1/(double)nraw, xshift, _params);
            v = 0;
            for(i=0; i<=nraw-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    v = v+(xwrk[i,j]-xshift[j])*(xwrk[i,j]-xshift[j]);
                }
            }
            addxrescaleaplied = Math.Sqrt((v+Math.Sqrt(math.machineepsilon))/(nraw*nx));
            bfparamwrk = bfparamraw;
            if( bftype==1 )
            {
                
                //
                // Basis function parameter needs rescaling
                //
                if( (double)(bfparamraw)<(double)(0) )
                {
                    bfparamwrk = autodetectscaleparameter(xwrk, nraw, nx, _params)*-bfparamraw/addxrescaleaplied;
                }
                else
                {
                    bfparamwrk = bfparamraw/addxrescaleaplied;
                }
            }
            else
            {
                if( bftype==2 )
                {
                    
                    //
                    // Thin plate splines need special scaling; no params to rescale
                    //
                    addxrescaleaplied = polyharmonic2scale*addxrescaleaplied;
                }
                else
                {
                    alglib.ap.assert(false, "RBFV3: integrity check 0632 failed");
                }
            }
            ablasf.rmulv(nx, addxrescaleaplied, xscalewrk, _params);
            for(i=0; i<=nraw-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    xwrk[i,j] = (xraw[i,j]-xshift[j])/xscalewrk[j];
                }
            }
            ablasf.rcopyallocm(nraw, ny, yraw, ref ywrk, _params);
            
            //
            // Merge nondistinct points
            //
            ablasf.iallocv(nraw, ref initidx, _params);
            for(i=0; i<=nraw-1; i++)
            {
                initidx[i] = i;
            }
            ablasf.rcopyallocm(nraw, nx, xwrk, ref xbuf, _params);
            ablasf.rcopyallocm(nraw, ny, ywrk, ref ybuf, _params);
            ablasf.iallocv(nraw, ref raw2wrkmap, _params);
            ablasf.iallocv(nraw, ref wrk2rawmap, _params);
            nwrk = 0;
            preprocessdatasetrec(xbuf, ybuf, initidx, 0, nraw, nx, ny, mergetol, ref tmp0, ref tmp1, xwrk, ywrk, raw2wrkmap, wrk2rawmap, ref nwrk, _params);
            
            //
            // Compute LambdaV:
            // * compute bounding box
            // * compute DIAG2 = squared diagonal of the box
            // * set LambdaVWrk = LambdaVRaw times upper bound of the basis function value
            //
            ablasf.rallocv(nx, ref boxmin, _params);
            ablasf.rallocv(nx, ref boxmax, _params);
            ablasf.rcopyrv(nx, xwrk, 0, boxmin, _params);
            ablasf.rcopyrv(nx, xwrk, 0, boxmax, _params);
            for(i=1; i<=nwrk-1; i++)
            {
                ablasf.rmergeminrv(nx, xwrk, i, boxmin, _params);
                ablasf.rmergemaxrv(nx, xwrk, i, boxmax, _params);
            }
            diag2 = 0;
            for(i=0; i<=nx-1; i++)
            {
                diag2 = diag2+math.sqr(boxmax[i]-boxmin[i]);
            }
            diag2 = Math.Max(diag2, 1);
            if( bftype==1 )
            {
                lambdavwrk = lambdavraw*Math.Sqrt(diag2+bfparamwrk*bfparamwrk);
            }
            else
            {
                if( bftype==2 )
                {
                    lambdavwrk = lambdavraw*diag2*Math.Max(Math.Abs(0.5*Math.Log(diag2)), 1.0);
                }
                else
                {
                    lambdavwrk = lambdavraw;
                    alglib.ap.assert(false, "RBFV3: integrity check 7232 failed");
                }
            }
            lambdavwrk = lambdavwrk/math.sqr(addxrescaleaplied);
        }


        /*************************************************************************
        This function selects NSpec global nodes for approximate cardinal basis functions.

        This function has O(N*NSpec) running time and O(N) memory requirements.

        Each approximate cardinal basis function is a combination of several local
        nodes (ones nearby to the center) and several global nodes (ones scattered
        over entire dataset span).

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void selectglobalnodes(double[,] xx,
            int n,
            int nx,
            int[] existingnodes,
            int nexisting,
            int nspec,
            ref int[] nodes,
            ref int nchosen,
            ref double maxdist,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            double[] d2 = new double[0];
            double[] x = new double[0];
            bool[] busy = new bool[0];
            double v = 0;
            double vv = 0;

            nchosen = 0;
            maxdist = 0;

            alglib.ap.assert(n>=1, "RBFV3: integrity check 6429 failed");
            alglib.ap.assert(nexisting>=0, "RBFV3: integrity check 6412 failed");
            alglib.ap.assert(nspec>=1, "RBFV3: integrity check 6430 failed");
            nspec = Math.Min(nspec, n);
            ablasf.rsetallocv(n, 1.0E50, ref d2, _params);
            ablasf.rsetallocv(nx, 0.0, ref x, _params);
            ablasf.bsetallocv(n, false, ref busy, _params);
            if( nexisting==0 )
            {
                
                //
                // No initial grid is provided, start distance evaluation from the data center
                //
                for(i=0; i<=n-1; i++)
                {
                    ablasf.rcopyrv(nx, xx, i, x, _params);
                }
                ablasf.rmulv(nx, (double)1/(double)n, x, _params);
            }
            else
            {
                
                //
                //
                //
                alglib.ap.assert(false, "SelectGlobalNodes: NExisting<>0");
            }
            ablasf.iallocv(nspec, ref nodes, _params);
            nchosen = 0;
            maxdist = math.maxrealnumber;
            while( nchosen<nspec )
            {
                
                //
                // Update distances using last added point stored in X.
                //
                for(j=0; j<=n-1; j++)
                {
                    v = 0;
                    for(k=0; k<=nx-1; k++)
                    {
                        vv = x[k]-xx[j,k];
                        v = v+vv*vv;
                    }
                    d2[j] = Math.Min(d2[j], v);
                }
                
                //
                // Select point with largest distance, add
                //
                k = 0;
                for(j=0; j<=n-1; j++)
                {
                    if( (double)(d2[j])>(double)(d2[k]) && !busy[j] )
                    {
                        k = j;
                    }
                }
                if( busy[k] )
                {
                    break;
                }
                maxdist = Math.Min(maxdist, d2[k]);
                nodes[nchosen] = k;
                busy[k] = true;
                ablasf.rcopyrv(nx, xx, k, x, _params);
                nchosen = nchosen+1;
            }
            maxdist = Math.Sqrt(maxdist);
            alglib.ap.assert(nchosen>=1 || nexisting>0, "RBFV3: integrity check 6431 failed");
        }


        /*************************************************************************
        This function builds simplified tagged KD-tree: it assigns a tag (index in
        the dataset) to each point, then drops most points (leaving  approximately
        1/ReduceFactor of the entire dataset)  trying to  spread  residual  points
        uniformly, and then constructs KD-tree.

        It ensures that at least min(N,MinSize) points is retained.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void buildsimplifiedkdtree(double[,] xx,
            int n,
            int nx,
            int reducefactor,
            int minsize,
            nearestneighbor.kdtree kdt,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int ns = 0;
            double[,] xs = new double[0,0];
            int[] idx = new int[0];
            hqrnd.hqrndstate rs = new hqrnd.hqrndstate();

            alglib.ap.assert(n>=1, "BuildSimplifiedKDTree: N<1");
            alglib.ap.assert(reducefactor>=1, "BuildSimplifiedKDTree: ReduceFactor<1");
            alglib.ap.assert(minsize>=0, "BuildSimplifiedKDTree: ReduceFactor<1");
            hqrnd.hqrndseed(7674, 45775, rs, _params);
            ns = apserv.imax3((int)Math.Round((double)n/(double)reducefactor), minsize, 1, _params);
            ns = Math.Min(ns, n);
            ablasf.iallocv(n, ref idx, _params);
            ablasf.rallocm(ns, nx, ref xs, _params);
            for(i=0; i<=n-1; i++)
            {
                idx[i] = i;
            }
            for(i=0; i<=ns-1; i++)
            {
                j = i+hqrnd.hqrnduniformi(rs, n-i, _params);
                k = idx[i];
                idx[i] = idx[j];
                idx[j] = k;
                ablasf.rcopyrr(nx, xx, idx[i], xs, i, _params);
            }
            nearestneighbor.kdtreebuildtagged(xs, idx, ns, nx, 0, 2, kdt, _params);
        }


        /*************************************************************************
        Compute design matrices for the target-scatter preconditioner

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void computetargetscatterdesignmatrices(double[,] xx,
            int ntotal,
            int nx,
            int functype,
            double funcparam,
            int[] workingnodes,
            int nwrk,
            int[] scatternodes,
            int nscatter,
            ref double[,] atwrk,
            ref double[,] atsctr,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            double v = 0;
            double vv = 0;
            int ni = 0;
            int nj = 0;
            double alpha2 = 0;

            
            //
            // Compute working set and scatter set design matrices ATWrk and ATSctr
            //
            // ATWrk  is a (NWrk+NX+1)*NWrk matrix whose entries a[i,j] store:
            // * for I<NWrk             BasisFunc(X[wrk[i]]-X[wrj[j]])
            // * for NWrk<=I<NWrk+NX    X[wrk[j]], coordinate #(i-NWrk)
            // * for I=NWrk+NX          1.0
            //
            // ATSctr is a (NWrk+NX+1)*NScatter matrix whose entries a[i,j] store:
            // * for I<NWrk             BasisFunc(X[wrk[i]]-X[scatter[j]])
            // * for NWrk<=I<NWrk+NX    X[scatter[j]], coordinate #(i-NWrk)
            // * for I=NWrk+NX          1.0
            //
            alglib.ap.assert((functype==1 || functype==2) || functype==3, "ACBF: unexpected basis function type");
            alpha2 = funcparam*funcparam;
            ablasf.rallocm(nwrk+nx+1, nwrk, ref atwrk, _params);
            for(i=0; i<=nwrk-1; i++)
            {
                ni = workingnodes[i];
                for(j=i; j<=nwrk-1; j++)
                {
                    nj = workingnodes[j];
                    v = 0;
                    for(k=0; k<=nx-1; k++)
                    {
                        vv = xx[ni,k]-xx[nj,k];
                        v = v+vv*vv;
                    }
                    if( functype==1 )
                    {
                        v = -Math.Sqrt(v+alpha2);
                    }
                    if( functype==2 )
                    {
                        if( v!=0 )
                        {
                            v = v*0.5*Math.Log(v);
                        }
                        else
                        {
                            v = 0;
                        }
                    }
                    if( functype==3 )
                    {
                        v = v*Math.Sqrt(v);
                    }
                    atwrk[i,j] = v;
                    atwrk[j,i] = v;
                }
            }
            for(j=0; j<=nwrk-1; j++)
            {
                nj = workingnodes[j];
                for(i=0; i<=nx-1; i++)
                {
                    atwrk[nwrk+i,j] = xx[nj,i];
                }
            }
            for(j=0; j<=nwrk-1; j++)
            {
                atwrk[nwrk+nx,j] = 1.0;
            }
            if( nscatter>0 )
            {
                
                //
                // We have scattered points too
                //
                ablasf.rallocm(nwrk+nx+1, nscatter, ref atsctr, _params);
                for(i=0; i<=nwrk-1; i++)
                {
                    ni = workingnodes[i];
                    for(j=0; j<=nscatter-1; j++)
                    {
                        nj = scatternodes[j];
                        v = 0;
                        for(k=0; k<=nx-1; k++)
                        {
                            vv = xx[ni,k]-xx[nj,k];
                            v = v+vv*vv;
                        }
                        if( functype==1 )
                        {
                            v = -Math.Sqrt(v+alpha2);
                        }
                        if( functype==2 )
                        {
                            if( v!=0 )
                            {
                                v = v*0.5*Math.Log(v);
                            }
                            else
                            {
                                v = 0;
                            }
                        }
                        if( functype==3 )
                        {
                            v = v*Math.Sqrt(v);
                        }
                        atsctr[i,j] = v;
                    }
                }
                for(j=0; j<=nscatter-1; j++)
                {
                    nj = scatternodes[j];
                    for(i=0; i<=nx-1; i++)
                    {
                        atsctr[nwrk+i,j] = xx[nj,i];
                    }
                }
                for(j=0; j<=nscatter-1; j++)
                {
                    atsctr[nwrk+nx,j] = 1.0;
                }
            }
        }


        /*************************************************************************
        ACBF preconditioner generation basecase.

        PARAMETERS:
            Builder             -   ACBF builder object
            Wrk0, Wrk1          -   elements [Wrk0...Wrk1-1] of Builder.WrkIdx[]
                                    array store row indexes of XX that are processed.
            
        OUTPUT:
            Builder.OutputPool is updated with new chunks

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void computeacbfpreconditionerbasecase(acbfbuilder builder,
            acbfbuffer buf,
            int wrk0,
            int wrk1,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int widx = 0;
            int targetidx = 0;
            int nx = 0;
            int nglobal = 0;
            int nlocal = 0;
            int ncorrection = 0;
            int ncenters = 0;
            int nchosen = 0;
            int ncoeff = 0;
            int batchsize = 0;
            int nk = 0;
            int nq = 0;
            double[] x = new double[0];
            double[] batchcenter = new double[0];
            int[] idummy = new int[0];
            double localrad = 0;
            double currentrad = 0;
            double reg = 0;
            double v = 0;
            double vv = 0;
            double mx = 0;
            double maxdist2 = 0;
            int ortbasissize = 0;
            int[] ortbasismap = new int[0];
            acbfchunk precchunk = null;
            int expansionscount = 0;
            double[,] dbgb = new double[0,0];
            double dbgerrnodes = 0;
            double dbgerrort = 0;
            double dbgcondq = 0;
            double dbgmaxc = 0;

            if( wrk1<=wrk0 )
            {
                return;
            }
            nx = builder.nx;
            nglobal = builder.nglobal;
            nlocal = builder.nlocal;
            ncorrection = builder.ncorrection;
            reg = Math.Sqrt(math.machineepsilon);
            ablasf.rallocv(nx, ref x, _params);
            expansionscount = 0;
            
            //
            // First, select a batch of central points and compute batch center
            //
            batchsize = wrk1-wrk0;
            ablasf.iallocv(batchsize, ref buf.currentnodes, _params);
            ablasf.rsetallocv(nx, 0.0, ref batchcenter, _params);
            for(i=0; i<=batchsize-1; i++)
            {
                targetidx = builder.wrkidx[wrk0+i];
                buf.currentnodes[i] = targetidx;
                buf.bflags[targetidx] = true;
                ablasf.raddrv(nx, (double)1/(double)batchsize, builder.xx, builder.wrkidx[wrk0+i], batchcenter, _params);
            }
            ncenters = batchsize;
            
            //
            // Then, add a hull of nearest neighbors and compute its radius
            //
            localrad = 0;
            for(widx=0; widx<=batchsize-1; widx++)
            {
                
                //
                // Select immediate neighbors
                //
                ablasf.rcopyrv(nx, builder.xx, builder.wrkidx[wrk0+widx], x, _params);
                nq = nearestneighbor.kdtreetsqueryknn(builder.kdt, buf.kdtbuf, x, nlocal, true, _params);
                nearestneighbor.kdtreetsqueryresultstags(builder.kdt, buf.kdtbuf, ref buf.neighbors, _params);
                nearestneighbor.kdtreetsqueryresultsdistances(builder.kdt, buf.kdtbuf, ref buf.d, _params);
                for(k=0; k<=nq-1; k++)
                {
                    nk = buf.neighbors[k];
                    if( !buf.bflags[nk] )
                    {
                        buf.bflags[nk] = true;
                        ablasf.igrowv(ncenters+1, ref buf.currentnodes, _params);
                        buf.currentnodes[ncenters] = nk;
                        ncenters = ncenters+1;
                        v = 0;
                        for(j=0; j<=nx-1; j++)
                        {
                            v = v+(builder.xx[nk,j]-batchcenter[j])*(builder.xx[nk,j]-batchcenter[j]);
                        }
                        localrad = Math.Max(localrad, v);
                    }
                }
            }
            localrad = Math.Sqrt(localrad);
            currentrad = localrad;
            
            //
            // Add global grid
            //
            if( nglobal>0 )
            {
                for(k=0; k<=nglobal-1; k++)
                {
                    nk = builder.globalgrid[k];
                    if( !buf.bflags[nk] )
                    {
                        buf.bflags[nk] = true;
                        ablasf.igrowv(ncenters+1, ref buf.currentnodes, _params);
                        buf.currentnodes[ncenters] = nk;
                        ncenters = ncenters+1;
                    }
                }
            }
            
            //
            // Add local correction grid: select more distant neighbors
            //
            while( (double)(currentrad)>(double)(0) && (double)(currentrad)<(double)(builder.roughdatasetdiameter) )
            {
                
                //
                // Select neighbors within CurrentRad*Builder.CorrectorGrowth
                //
                if( expansionscount==0 )
                {
                    
                    //
                    // First expansion, use simplified kd-tree #1
                    //
                    nq = nearestneighbor.kdtreetsqueryrnn(builder.kdt1, buf.kdt1buf, batchcenter, currentrad*builder.correctorgrowth, true, _params);
                    nearestneighbor.kdtreetsqueryresultstags(builder.kdt1, buf.kdt1buf, ref buf.neighbors, _params);
                }
                else
                {
                    
                    //
                    // Subsequent expansions, use simplified kd-tree #2
                    //
                    nq = nearestneighbor.kdtreetsqueryrnn(builder.kdt2, buf.kdt2buf, batchcenter, currentrad*builder.correctorgrowth, true, _params);
                    nearestneighbor.kdtreetsqueryresultstags(builder.kdt2, buf.kdt2buf, ref buf.neighbors, _params);
                }
                
                //
                // Compute a grid of well-separated nodes using neighbors
                //
                ablasf.rallocm(nq, nx, ref buf.xq, _params);
                for(k=0; k<=nq-1; k++)
                {
                    nk = buf.neighbors[k];
                    for(j=0; j<=nx-1; j++)
                    {
                        buf.xq[k,j] = builder.xx[nk,j];
                    }
                }
                selectglobalnodes(buf.xq, nq, nx, idummy, 0, ncorrection, ref buf.chosenneighbors, ref nchosen, ref maxdist2, _params);
                
                //
                // Select neighbrs that are NOT within CurrentRad from the batch center
                // and that are NOT already chosen.
                //
                for(k=0; k<=nchosen-1; k++)
                {
                    nk = buf.neighbors[buf.chosenneighbors[k]];
                    v = 0;
                    for(j=0; j<=nx-1; j++)
                    {
                        v = v+math.sqr(builder.xx[nk,j]-batchcenter[j]);
                    }
                    v = Math.Sqrt(v);
                    if( !buf.bflags[nk] && (double)(v)>(double)(currentrad) )
                    {
                        buf.bflags[nk] = true;
                        ablasf.igrowv(ncenters+1, ref buf.currentnodes, _params);
                        buf.currentnodes[ncenters] = nk;
                        ncenters = ncenters+1;
                    }
                }
                
                //
                // Update radius and debug counters
                //
                currentrad = currentrad*builder.correctorgrowth;
                apserv.inc(ref expansionscount, _params);
            }
            
            //
            // Clean up bFlags[]
            //
            for(k=0; k<=ncenters-1; k++)
            {
                buf.bflags[buf.currentnodes[k]] = false;
            }
            
            //
            // Compute working set and scatter set design matrices ATWrk and ATSctr
            //
            // ATWrk  is a (NWrk+NX+1)*NWrk matrix whose entries a[i,j] store:
            // * for I<NWrk             BasisFunc(X[wrk[i]]-X[wrj[j]])
            // * for NWrk<=I<NWrk+NX    X[wrk[j]], coordinate #(i-NWrk)
            // * for I=NWrk+NX          1.0
            //
            // ATSctr is a (NWrk+NX+1)*NScatter matrix whose entries a[i,j] store:
            // * for I<NWrk             BasisFunc(X[wrk[i]]-X[scatter[j]])
            // * for NWrk<=I<NWrk+NX    X[scatter[j]], coordinate #(i-NWrk)
            // * for I=NWrk+NX          1.0
            //
            computetargetscatterdesignmatrices(builder.xx, builder.ntotal, nx, builder.functype, builder.funcparam, buf.currentnodes, ncenters, buf.currentnodes, 0, ref buf.atwrk, ref buf.atwrk, _params);
            
            //
            // Prepare and solve linear system, coefficients are stored in rows of Buf.B
            //
            // Depending on whether the basis is conditionally positive definite (given current polynomial term type),
            // we either:
            // * use generic QR solver to solve the linear system (when the basis is not CPD)
            // * use specialized CPD solver that is several times faster and is more accurate
            //
            if( builder.aterm!=1 || !iscpdfunction(builder.functype, builder.aterm, _params) )
            {
                alglib.ap.assert((double)(builder.lambdav)>=(double)(0), "RBF3: integrity check 8363 failed");
                alglib.ap.assert((builder.aterm==1 || builder.aterm==2) || builder.aterm==3, "RBF3: integrity check 8364 failed");
                
                //
                // Basis function has no conditional positive definiteness guarantees (given the linear term type).
                //
                // Solve using QR decomposition.
                //
                ncoeff = ncenters+nx+1;
                ablasf.rsetallocm(ncoeff, ncoeff+batchsize, 0.0, ref buf.q, _params);
                for(i=0; i<=ncenters-1; i++)
                {
                    ablasf.rcopyrr(ncenters, buf.atwrk, i, buf.q, i, _params);
                    buf.q[i,i] = buf.q[i,i]+builder.lambdav;
                }
                if( builder.aterm==1 )
                {
                    
                    //
                    // Linear term is used
                    //
                    for(i=0; i<=nx; i++)
                    {
                        for(j=0; j<=ncenters-1; j++)
                        {
                            buf.q[ncenters+i,j] = buf.atwrk[ncenters+i,j];
                            buf.q[j,ncenters+i] = buf.atwrk[ncenters+i,j];
                        }
                    }
                }
                if( builder.aterm==2 )
                {
                    
                    //
                    // Constant term is used
                    //
                    for(i=0; i<=nx-1; i++)
                    {
                        buf.q[ncenters+i,ncenters+i] = 1.0;
                    }
                    for(j=0; j<=ncenters-1; j++)
                    {
                        buf.q[ncenters+nx,j] = 1.0;
                        buf.q[j,ncenters+nx] = 1.0;
                    }
                }
                if( builder.aterm==3 )
                {
                    
                    //
                    // Zero term is used
                    //
                    for(i=0; i<=nx; i++)
                    {
                        buf.q[ncenters+i,ncenters+i] = 1.0;
                    }
                }
                for(i=0; i<=batchsize-1; i++)
                {
                    buf.q[i,ncoeff+i] = 1.0;
                }
                mx = 1.0;
                for(i=0; i<=ncoeff-1; i++)
                {
                    for(j=i; j<=ncoeff-1; j++)
                    {
                        mx = Math.Max(mx, Math.Abs(buf.q[i,j]));
                    }
                }
                for(j=0; j<=ncoeff-1; j++)
                {
                    buf.q[j,j] = buf.q[j,j]+reg*mx*apserv.possign(buf.q[j,j], _params);
                }
                ortfac.rmatrixqr(ref buf.q, ncoeff, ncoeff+batchsize, ref buf.tau, _params);
                ablasf.rallocm(batchsize, ncoeff, ref buf.b, _params);
                ablas.rmatrixtranspose(ncoeff, batchsize, buf.q, 0, ncoeff, buf.b, 0, 0, _params);
                ablas.rmatrixrighttrsm(batchsize, ncoeff, buf.q, 0, 0, true, false, 1, buf.b, 0, 0, _params);
            }
            else
            {
                alglib.ap.assert((double)(builder.lambdav)>=(double)(0), "RBF3: integrity check 8368 failed");
                alglib.ap.assert(builder.aterm==1, "RBF3: integrity check 7365 failed");
                ncoeff = ncenters+nx+1;
                
                //
                // First, compute orthogonal basis of space spanned by polynomials of degree 1
                //
                ablasf.rallocm(ncenters, ncenters, ref buf.r, _params);
                ablasf.rallocm(nx+1, ncenters, ref buf.q1, _params);
                ablasf.iallocv(nx+1, ref ortbasismap, _params);
                ablasf.rsetr(ncenters, 1/Math.Sqrt(ncenters), buf.q1, 0, _params);
                buf.r[0,0] = Math.Sqrt(ncenters);
                ortbasismap[0] = nx;
                ortbasissize = 1;
                ablasf.rallocv(ncenters, ref buf.z, _params);
                for(k=0; k<=nx-1; k++)
                {
                    for(j=0; j<=ncenters-1; j++)
                    {
                        buf.z[j] = buf.atwrk[ncenters+k,j];
                    }
                    v = Math.Sqrt(ablasf.rdotv2(ncenters, buf.z, _params));
                    ablas.rowwisegramschmidt(buf.q1, ortbasissize, ncenters, buf.z, ref buf.y, true, _params);
                    vv = Math.Sqrt(ablasf.rdotv2(ncenters, buf.z, _params));
                    if( (double)(vv)>(double)(Math.Sqrt(math.machineepsilon)*(v+1)) )
                    {
                        ablasf.rcopymulvr(ncenters, 1/vv, buf.z, buf.q1, ortbasissize, _params);
                        ablasf.rcopyvc(ortbasissize, buf.y, buf.r, ortbasissize, _params);
                        buf.r[ortbasissize,ortbasissize] = vv;
                        ortbasismap[ortbasissize] = k;
                        ortbasissize = ortbasissize+1;
                    }
                }
                
                //
                // Second, compute system matrix Q and target values for cardinal basis functions B.
                //
                // The Q is conditionally positive definite, i.e. x'*Q*x>0 for any x satisfying orthogonality conditions
                // (orthogonal with respect to basis stored in Q1).
                //
                ablasf.rsetallocm(ncenters, ncenters, 0.0, ref buf.q, _params);
                for(i=0; i<=ncenters-1; i++)
                {
                    ablasf.rcopyrr(ncenters, buf.atwrk, i, buf.q, i, _params);
                }
                ablasf.rsetallocm(batchsize, ncoeff, 0.0, ref buf.b, _params);
                for(i=0; i<=batchsize-1; i++)
                {
                    buf.b[i,i] = 1.0;
                }
                for(i=0; i<=ncenters-1; i++)
                {
                    buf.q[i,i] = buf.q[i,i]+builder.lambdav;
                }
                
                //
                // Transform Q from conditionally positive definite to the (simply) positive definite one:
                // multiply linear system Q*x=RHS from both sides by (I-Q1'*Q1), apply additional regularization.
                //
                // NOTE: RHS is also multiplied by (I-Q1'*Q1), but from the left only.
                //
                ablasf.rallocv(ncenters, ref buf.z, _params);
                for(i=0; i<=ncenters-1; i++)
                {
                    ablasf.rcopyrv(ncenters, buf.q, i, buf.z, _params);
                    ablas.rowwisegramschmidt(buf.q1, ortbasissize, ncenters, buf.z, ref buf.y, false, _params);
                    ablasf.rcopyvr(ncenters, buf.z, buf.q, i, _params);
                }
                for(i=0; i<=ncenters-1; i++)
                {
                    ablasf.rcopycv(ncenters, buf.q, i, buf.z, _params);
                    ablas.rowwisegramschmidt(buf.q1, ortbasissize, ncenters, buf.z, ref buf.y, false, _params);
                    ablasf.rcopyvc(ncenters, buf.z, buf.q, i, _params);
                }
                for(i=0; i<=batchsize-1; i++)
                {
                    ablasf.rcopyrv(ncenters, buf.b, i, buf.z, _params);
                    ablas.rowwisegramschmidt(buf.q1, ortbasissize, ncenters, buf.z, ref buf.y, false, _params);
                    ablasf.rcopyvr(ncenters, buf.z, buf.b, i, _params);
                }
                mx = 1.0;
                for(i=0; i<=ncenters-1; i++)
                {
                    mx = Math.Max(mx, Math.Abs(buf.q[i,i]));
                }
                for(i=0; i<=ncenters-1; i++)
                {
                    ablasf.rcopyrv(ncenters, buf.q, i, buf.z, _params);
                    for(j=0; j<=ortbasissize-1; j++)
                    {
                        ablasf.raddrv(ncenters, mx*buf.q1[j,i], buf.q1, j, buf.z, _params);
                    }
                    ablasf.rcopyvr(ncenters, buf.z, buf.q, i, _params);
                }
                if( builder.dodetailedtrace )
                {
                    
                    //
                    // Compute condition number for future reports
                    //
                    dbgcondq = 1/(rcond.spdmatrixrcond(buf.q, ncenters, false, _params)+math.machineepsilon);
                }
                else
                {
                    dbgcondq = 0;
                }
                for(i=0; i<=ncenters-1; i++)
                {
                    buf.q[i,i] = buf.q[i,i]+reg*mx;
                }
                
                //
                // Perform Cholesky factorization, solve and obtain RBF coefficients (we still have
                // to compute polynomial term - it will be done later)
                //
                if( !trfac.spdmatrixcholeskyrec(ref buf.q, 0, ncenters, false, ref buf.choltmp, _params) )
                {
                    alglib.ap.assert(false, "RBFV3: ACBF solver failed due to extreme degeneracy");
                }
                ablas.rmatrixrighttrsm(batchsize, ncenters, buf.q, 0, 0, false, false, 1, buf.b, 0, 0, _params);
                ablas.rmatrixrighttrsm(batchsize, ncenters, buf.q, 0, 0, false, false, 0, buf.b, 0, 0, _params);
                
                //
                // Now, having RBF coefficients we can compute residual from fitting ACBF targets
                // with pure RBF term and fit polynomial term to this residual. In the ideal world
                // it should result in the nice and precise polynomial coefficients.
                //
                ablasf.rallocv(ncenters, ref buf.z, _params);
                ablasf.rsetallocm(batchsize, ncenters, 0.0, ref buf.c, _params);
                for(i=0; i<=batchsize-1; i++)
                {
                    buf.c[i,i] = 1.0;
                }
                ablas.rmatrixgemm(batchsize, ncenters, ncenters, -1.0, buf.b, 0, 0, 0, buf.atwrk, 0, 0, 1, 1.0, buf.c, 0, 0, _params);
                for(i=0; i<=batchsize-1; i++)
                {
                    ablasf.rcopyrv(ncenters, buf.c, i, buf.z, _params);
                    ablas.rowwisegramschmidt(buf.q1, ortbasissize, ncenters, buf.z, ref buf.y, true, _params);
                    ablas.rmatrixtrsv(ortbasissize, buf.r, 0, 0, true, false, 0, buf.y, 0, _params);
                    for(j=0; j<=nx; j++)
                    {
                        buf.b[i,ncenters+j] = 0.0;
                    }
                    for(j=0; j<=ortbasissize-1; j++)
                    {
                        buf.b[i,ncenters+ortbasismap[j]] = buf.y[j];
                    }
                }
                
                //
                // Trace if needeed
                //
                if( builder.dodetailedtrace )
                {
                    ablasf.rallocm(batchsize, ncenters, ref dbgb, _params);
                    ablas.rmatrixgemm(batchsize, ncenters, ncoeff, -1.0, buf.b, 0, 0, 0, buf.atwrk, 0, 0, 0, 0.0, dbgb, 0, 0, _params);
                    for(i=0; i<=batchsize-1; i++)
                    {
                        dbgb[i,i] = dbgb[i,i]+1.0;
                    }
                    dbgmaxc = 0;
                    for(i=0; i<=batchsize-1; i++)
                    {
                        dbgmaxc = Math.Max(dbgmaxc, ablasf.rmaxabsr(ncenters, buf.b, i, _params));
                    }
                    dbgerrnodes = 0;
                    for(i=0; i<=batchsize-1; i++)
                    {
                        dbgerrnodes = dbgerrnodes+ablasf.rdotrr(ncenters, dbgb, i, dbgb, i, _params);
                    }
                    dbgerrnodes = Math.Sqrt(dbgerrnodes/(batchsize*ncenters));
                    dbgerrort = 0;
                    for(i=0; i<=batchsize-1; i++)
                    {
                        for(j=0; j<=ortbasissize-1; j++)
                        {
                            dbgerrort = Math.Max(dbgerrort, Math.Abs(ablasf.rdotrr(ncenters, buf.b, i, buf.q1, j, _params)));
                        }
                    }
                    alglib.ap.trace(System.String.Format("[ACBF_subprob]    BatchSize={0,3:d}    NCenters={1,4:d}    RadiusExpansions={2,0:d}    cond(Q)={3,0:E2}    max|C|={4,0:E2}    rmsErr={5,0:E2}    OrtErr={6,0:E2}\n", batchsize, ncenters, expansionscount, dbgcondq, dbgmaxc, dbgerrnodes, dbgerrort));
                }
            }
            
            //
            // Solve and save solution to Builder.ChunksPool
            //
            alglib.smp.ae_shared_pool_retrieve(builder.chunksproducer, ref precchunk);
            alglib.ap.assert(precchunk.ntargetrows==-117, "RBFV3: integrity check 9724 failed");
            alglib.ap.assert(precchunk.ntargetcols==-119, "RBFV3: integrity check 9725 failed");
            precchunk.ntargetrows = batchsize;
            precchunk.ntargetcols = ncoeff;
            ablasf.iallocv(precchunk.ntargetrows, ref precchunk.targetrows, _params);
            ablasf.iallocv(precchunk.ntargetcols, ref precchunk.targetcols, _params);
            ablasf.rallocm(batchsize, ncoeff, ref precchunk.s, _params);
            for(widx=0; widx<=batchsize-1; widx++)
            {
                precchunk.targetrows[widx] = builder.wrkidx[wrk0+widx];
            }
            ablasf.iallocv(ncoeff, ref buf.perm, _params);
            for(k=0; k<=ncoeff-1; k++)
            {
                if( k<ncenters )
                {
                    precchunk.targetcols[k] = buf.currentnodes[k];
                }
                else
                {
                    precchunk.targetcols[k] = builder.ntotal+(k-ncenters);
                }
                buf.perm[k] = k;
            }
            tsort.tagsortmiddleii(ref precchunk.targetcols, ref buf.perm, 0, ncoeff, _params);
            for(widx=0; widx<=batchsize-1; widx++)
            {
                for(k=0; k<=ncoeff-1; k++)
                {
                    precchunk.s[widx,k] = buf.b[widx,buf.perm[k]];
                }
            }
            alglib.smp.ae_shared_pool_recycle(builder.chunkspool, ref precchunk);
        }


        /*************************************************************************
        Recursive ACBF preconditioner generation subroutine.

        PARAMETERS:
            Builder             -   ACBF builder object
            Wrk0, Wrk1          -   elements [Wrk0...Wrk1-1] of Builder.WrkIdx[]
                                    array store row indexes of XX that are processed.
            
        OUTPUT:
            Builder.OutputPool is updated with new chunks

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void computeacbfpreconditionerrecv2(acbfbuilder builder,
            int wrk0,
            int wrk1,
            alglib.xparams _params)
        {
            int nx = 0;
            int i = 0;
            int j = 0;
            int k0 = 0;
            int k1 = 0;
            int largestdim = 0;
            double splitval = 0;
            double basecasecomplexity = 0;
            acbfbuffer buf = null;

            nx = builder.nx;
            if( wrk1<=wrk0 )
            {
                return;
            }
            basecasecomplexity = apserv.rmul3(builder.nglobal+builder.nlocal+2*builder.ncorrection, builder.nglobal+builder.nlocal+2*builder.ncorrection, builder.nglobal+builder.nlocal+2*builder.ncorrection, _params);
            
            //
            // Decide on parallelism
            //
            if( (double)(apserv.rmul2(builder.ntotal, basecasecomplexity, _params))>=(double)(apserv.smpactivationlevel(_params)) && builder.ntotal>=acbfparallelthreshold )
            {
                if( _trypexec_computeacbfpreconditionerrecv2(builder,wrk0,wrk1, _params) )
                {
                    return;
                }
            }
            
            //
            // Retrieve temporary buffer
            //
            alglib.smp.ae_shared_pool_retrieve(builder.bufferpool, ref buf);
            
            //
            // Analyze current working set
            //
            ablasf.rallocv(nx, ref buf.tmpboxmin, _params);
            ablasf.rallocv(nx, ref buf.tmpboxmax, _params);
            ablasf.rcopyrv(nx, builder.xx, builder.wrkidx[wrk0], buf.tmpboxmin, _params);
            ablasf.rcopyrv(nx, builder.xx, builder.wrkidx[wrk0], buf.tmpboxmax, _params);
            for(i=wrk0+1; i<=wrk1-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    buf.tmpboxmin[j] = Math.Min(buf.tmpboxmin[j], builder.xx[builder.wrkidx[i],j]);
                    buf.tmpboxmax[j] = Math.Max(buf.tmpboxmax[j], builder.xx[builder.wrkidx[i],j]);
                }
            }
            largestdim = 0;
            for(j=1; j<=nx-1; j++)
            {
                if( (double)(buf.tmpboxmax[j]-buf.tmpboxmin[j])>(double)(buf.tmpboxmax[largestdim]-buf.tmpboxmin[largestdim]) )
                {
                    largestdim = j;
                }
            }
            
            //
            // Perform either batch processing or recursive split
            //
            if( wrk1-wrk0<=builder.batchsize || (double)(buf.tmpboxmax[largestdim])==(double)(buf.tmpboxmin[largestdim]) )
            {
                
                //
                // Either working set size is small enough or all points are non-distinct.
                // Perform batch processing
                //
                computeacbfpreconditionerbasecase(builder, buf, wrk0, wrk1, _params);
                
                //
                // Recycle temporary buffers
                //
                alglib.smp.ae_shared_pool_recycle(builder.bufferpool, ref buf);
            }
            else
            {
                
                //
                // Compute recursive split along largest axis
                //
                splitval = 0.5*(buf.tmpboxmax[largestdim]+buf.tmpboxmin[largestdim]);
                k0 = wrk0;
                k1 = wrk1-1;
                while( k0<=k1 )
                {
                    if( (double)(builder.xx[builder.wrkidx[k0],largestdim])<=(double)(splitval) )
                    {
                        k0 = k0+1;
                        continue;
                    }
                    if( (double)(builder.xx[builder.wrkidx[k1],largestdim])>(double)(splitval) )
                    {
                        k1 = k1-1;
                        continue;
                    }
                    apserv.swapelementsi(builder.wrkidx, k0, k1, _params);
                    k0 = k0+1;
                    k1 = k1-1;
                }
                alglib.ap.assert(k0>wrk0 && k1<wrk1-1, "ACBF: integrity check 2843 in the recursive subdivision code failed");
                alglib.ap.assert(k0==k1+1, "ACBF: integrity check 8364 in the recursive subdivision code failed");
                
                //
                // Recycle temporary buffer, perform recursive calls
                //
                alglib.smp.ae_shared_pool_recycle(builder.bufferpool, ref buf);
                computeacbfpreconditionerrecv2(builder, wrk0, k0, _params);
                computeacbfpreconditionerrecv2(builder, k0, wrk1, _params);
            }
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_computeacbfpreconditionerrecv2(acbfbuilder builder,
            int wrk0,
            int wrk1, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function generates ACBF (approximate cardinal basis functions)
        preconditioner.

        PARAMETERS:
            XX                  -   dataset (X-values), array[N,NX]
            N                   -   points count, N>=1
            NX                  -   dimensions count, NX>=1
            FuncType            -   basis function type
            
        OUTPUT:
            SP                  -   preconditioner, sparse matrix in CRS format

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void computeacbfpreconditioner(double[,] xx,
            int n,
            int nx,
            int functype,
            double funcparam,
            int aterm,
            int batchsize,
            int nglobal,
            int nlocal,
            int ncorrection,
            int correctorgrowth,
            int simplificationfactor,
            double lambdav,
            sparse.sparsematrix sp,
            alglib.xparams _params)
        {
            acbfbuilder builder = new acbfbuilder();
            acbfbuffer bufferseed = new acbfbuffer();
            acbfchunk chunkseed = new acbfchunk();
            acbfchunk precchunk = null;
            int i = 0;
            int j = 0;
            int offs = 0;
            int[] idummy = new int[0];
            int[] rowsizes = new int[0];
            double[] boxmin = new double[0];
            double[] boxmax = new double[0];

            alglib.ap.assert(n>=1, "RBFV3: integrity check 2524 failed");
            
            //
            // Prepare builder
            //
            builder.dodetailedtrace = ap.istraceenabled("RBF.DETAILED", _params);
            builder.functype = functype;
            builder.funcparam = funcparam;
            builder.ntotal = n;
            builder.nx = nx;
            builder.batchsize = batchsize;
            if( nglobal>0 )
            {
                selectglobalnodes(xx, n, nx, idummy, 0, nglobal, ref builder.globalgrid, ref builder.nglobal, ref builder.globalgridseparation, _params);
            }
            else
            {
                builder.nglobal = 0;
            }
            builder.nlocal = nlocal;
            builder.ncorrection = ncorrection;
            builder.correctorgrowth = correctorgrowth;
            builder.lambdav = lambdav;
            builder.aterm = aterm;
            ablasf.rcopyallocm(n, nx, xx, ref builder.xx, _params);
            ablasf.rallocv(nx, ref boxmin, _params);
            ablasf.rallocv(nx, ref boxmax, _params);
            ablasf.rcopyrv(nx, xx, 0, boxmin, _params);
            ablasf.rcopyrv(nx, xx, 0, boxmax, _params);
            for(i=1; i<=n-1; i++)
            {
                ablasf.rmergeminrv(nx, xx, i, boxmin, _params);
                ablasf.rmergemaxrv(nx, xx, i, boxmax, _params);
            }
            builder.roughdatasetdiameter = 0;
            for(i=0; i<=nx-1; i++)
            {
                builder.roughdatasetdiameter = builder.roughdatasetdiameter+math.sqr(boxmax[i]-boxmin[i]);
            }
            builder.roughdatasetdiameter = Math.Sqrt(builder.roughdatasetdiameter);
            ablasf.iallocv(n, ref builder.wrkidx, _params);
            for(i=0; i<=n-1; i++)
            {
                builder.wrkidx[i] = i;
            }
            nearestneighbor.kdtreebuildtagged(xx, builder.wrkidx, n, nx, 0, 2, builder.kdt, _params);
            buildsimplifiedkdtree(xx, n, nx, (int)Math.Round(Math.Pow(simplificationfactor, nx)), (int)Math.Round(Math.Pow(5, nx)), builder.kdt1, _params);
            buildsimplifiedkdtree(xx, n, nx, (int)Math.Round(Math.Pow(simplificationfactor, 2*nx)), (int)Math.Round(Math.Pow(5, nx)), builder.kdt2, _params);
            ablasf.bsetallocv(n, false, ref bufferseed.bflags, _params);
            ablasf.rallocv(nx, ref bufferseed.tmpboxmin, _params);
            ablasf.rallocv(nx, ref bufferseed.tmpboxmax, _params);
            nearestneighbor.kdtreecreaterequestbuffer(builder.kdt, bufferseed.kdtbuf, _params);
            nearestneighbor.kdtreecreaterequestbuffer(builder.kdt1, bufferseed.kdt1buf, _params);
            nearestneighbor.kdtreecreaterequestbuffer(builder.kdt2, bufferseed.kdt2buf, _params);
            alglib.smp.ae_shared_pool_set_seed(builder.bufferpool, bufferseed);
            chunkseed.ntargetrows = -117;
            chunkseed.ntargetcols = -119;
            alglib.smp.ae_shared_pool_set_seed(builder.chunksproducer, chunkseed);
            alglib.smp.ae_shared_pool_set_seed(builder.chunkspool, chunkseed);
            
            //
            // Prepare preconditioner matrix
            //
            computeacbfpreconditionerrecv2(builder, 0, n, _params);
            ablasf.isetallocv(n, -1, ref rowsizes, _params);
            alglib.smp.ae_shared_pool_first_recycled(builder.chunkspool, ref precchunk);
            while( precchunk!=null )
            {
                for(i=0; i<=precchunk.ntargetrows-1; i++)
                {
                    alglib.ap.assert(rowsizes[precchunk.targetrows[i]]==-1, "RBFV3: integrity check 2568 failed");
                    rowsizes[precchunk.targetrows[i]] = precchunk.ntargetcols;
                }
                alglib.smp.ae_shared_pool_next_recycled(builder.chunkspool, ref precchunk);
            }
            sp.matrixtype = 1;
            sp.m = n+nx+1;
            sp.n = n+nx+1;
            ablasf.iallocv(n+nx+2, ref sp.ridx, _params);
            sp.ridx[0] = 0;
            for(i=0; i<=n-1; i++)
            {
                alglib.ap.assert(rowsizes[i]>0, "RBFV3: integrity check 2668 failed");
                sp.ridx[i+1] = sp.ridx[i]+rowsizes[i];
            }
            for(i=n; i<=n+nx; i++)
            {
                sp.ridx[i+1] = sp.ridx[i]+1;
            }
            ablasf.iallocv(sp.ridx[sp.m], ref sp.idx, _params);
            ablasf.rallocv(sp.ridx[sp.m], ref sp.vals, _params);
            for(i=n; i<=n+nx; i++)
            {
                sp.idx[sp.ridx[i]] = i;
                sp.vals[sp.ridx[i]] = 1.0;
            }
            alglib.smp.ae_shared_pool_first_recycled(builder.chunkspool, ref precchunk);
            while( precchunk!=null )
            {
                for(i=0; i<=precchunk.ntargetrows-1; i++)
                {
                    offs = sp.ridx[precchunk.targetrows[i]];
                    for(j=0; j<=precchunk.ntargetcols-1; j++)
                    {
                        sp.idx[offs+j] = precchunk.targetcols[j];
                        sp.vals[offs+j] = precchunk.s[i,j];
                    }
                }
                alglib.smp.ae_shared_pool_next_recycled(builder.chunkspool, ref precchunk);
            }
            sp.ninitialized = sp.ridx[sp.m];
            sparse.sparseinitduidx(sp, _params);
        }


        /*************************************************************************
        Basecase initialization routine for DDM solver.


        Appends an instance of RBF3DDMSubproblem to Solver.SubproblemsPool.

        INPUT PARAMETERS:
            Solver      -   solver object. This function may be  called  from  the
                            multiple threads, so it  is  important  to  work  with
                            Solver object using only thread-safe functions.
            X           -   array[N,NX], dataset points
            N, NX       -   dataset metrics, N>0, NX>0
            BFMatrix    -   basis function matrix object
            LambdaV     -   smoothing parameter
            SP          -   sparse ACBF preconditioner, (N+NX+1)*(N+NX+1) matrix
                            stored in CRS format
            Buf         -   an instance of RBF3DDMBuffer, reusable temporary buffers
            TgtIdx      -   array[], contains indexes of points in the current target
                            set. Elements [Tgt0,Tgt1) are processed by this function.
            NNeighbors  -   neighbors count; NNeighbors nearby nodes are added  to
                            inner points of the chunk
            DoDetailedTrace-whether trace output is needed or not. When trace is
                            activated, solver computes condition numbers. It results
                            in the several-fold slowdown of the algorithm.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void ddmsolverinitbasecase(rbf3ddmsolver solver,
            double[,] x,
            int n,
            int nx,
            rbf3evaluator bfmatrix,
            double lambdav,
            sparse.sparsematrix sp,
            rbf3ddmbuffer buf,
            int[] tgtidx,
            int tgt0,
            int tgt1,
            int nneighbors,
            bool dodetailedtrace,
            alglib.xparams _params)
        {
            rbf3ddmsubproblem subproblem = null;
            int i = 0;
            int j = 0;
            int k = 0;
            int nc = 0;
            int nk = 0;
            double v = 0;
            double reg = 0;
            int nwrk = 0;
            int npreccol = 0;
            int[] neighbors = new int[0];
            int[] workingnodes = new int[0];
            int[] preccolumns = new int[0];
            double[] tau = new double[0];
            double[,] q = new double[0,0];
            double[] x0 = new double[0];
            double lurcond = 0;
            bool lusuccess = new bool();
            int ni = 0;
            int j0 = 0;
            int j1 = 0;
            int jj = 0;
            double[,] suba = new double[0,0];
            double[,] subsp = new double[0,0];
            double[,] dbga = new double[0,0];

            alglib.ap.assert(tgt1-tgt0>0, "RBFV3: integrity check 7364 failed");
            alglib.ap.assert(nneighbors>=1, "RBFV3: integrity check 7365 failed");
            reg = (100+Math.Sqrt(tgt1-tgt0+nneighbors))*math.machineepsilon;
            
            //
            // Retrieve fresh subproblem. We expect that Solver.SubproblemsBuffer contains
            // no recycled entries and that fresh subproblem with Subproblem.IsValid=False
            // is returned.
            //
            // Start initialization
            //
            alglib.smp.ae_shared_pool_retrieve(solver.subproblemsbuffer, ref subproblem);
            alglib.ap.assert(!subproblem.isvalid, "RBFV3: SubproblemsBuffer integrity check failed");
            subproblem.isvalid = true;
            subproblem.ntarget = tgt1-tgt0;
            ablasf.iallocv(tgt1-tgt0, ref subproblem.targetnodes, _params);
            ablasf.icopyvx(tgt1-tgt0, tgtidx, tgt0, subproblem.targetnodes, 0, _params);
            
            //
            // Prepare working arrays
            //
            ablasf.rallocv(nx, ref x0, _params);
            
            //
            // Determine working set: target nodes + neighbors of targets.
            // Prepare mapping from node index to position in WorkingNodes[]
            //
            nwrk = 0;
            ablasf.iallocv(tgt1-tgt0, ref workingnodes, _params);
            for(i=tgt0; i<=tgt1-1; i++)
            {
                nk = tgtidx[i];
                buf.bflags[nk] = true;
                workingnodes[nwrk] = nk;
                nwrk = nwrk+1;
            }
            for(i=tgt0; i<=tgt1-1; i++)
            {
                ablasf.rcopyrv(nx, x, tgtidx[i], x0, _params);
                nc = nearestneighbor.kdtreetsqueryknn(solver.kdt, buf.kdtbuf, x0, nneighbors, true, _params);
                nearestneighbor.kdtreetsqueryresultstags(solver.kdt, buf.kdtbuf, ref neighbors, _params);
                for(k=0; k<=nc-1; k++)
                {
                    nk = neighbors[k];
                    if( !buf.bflags[nk] )
                    {
                        buf.bflags[nk] = true;
                        ablasf.igrowv(nwrk+1, ref workingnodes, _params);
                        workingnodes[nwrk] = nk;
                        nwrk = nwrk+1;
                    }
                }
            }
            for(i=0; i<=nwrk-1; i++)
            {
                buf.bflags[workingnodes[i]] = false;
            }
            alglib.ap.assert(nwrk>0, "ACBF: integrity check for NWrk failed");
            subproblem.nwork = nwrk;
            ablasf.icopyallocv(nwrk, workingnodes, ref subproblem.workingnodes, _params);
            
            //
            // Determine preconditioner columns that have nonzeros in rows corresponding
            // to working nodes. Prepare mapping from [0,N+NX+1) column indexing to [0,NPrecCol)
            // compressed one. Only these columns are extracted from the preconditioner
            // during design system computation.
            //
            // NOTE: we ensure that preconditioner columns N...N+NX which correspond to linear
            //       terms are placed last. It greatly simplifies desi
            //
            npreccol = 0;
            for(i=0; i<=nwrk-1; i++)
            {
                j0 = sp.ridx[workingnodes[i]];
                j1 = sp.ridx[workingnodes[i]+1]-1;
                for(jj=j0; jj<=j1; jj++)
                {
                    j = sp.idx[jj];
                    if( j<n && !buf.bflags[j] )
                    {
                        buf.bflags[j] = true;
                        ablasf.igrowv(npreccol+1, ref preccolumns, _params);
                        preccolumns[npreccol] = j;
                        npreccol = npreccol+1;
                    }
                }
            }
            for(j=n; j<=n+nx; j++)
            {
                alglib.ap.assert(!buf.bflags[j], "RBFV3: integrity check 9435 failed");
                buf.bflags[j] = true;
                ablasf.igrowv(npreccol+1, ref preccolumns, _params);
                preccolumns[npreccol] = j;
                npreccol = npreccol+1;
            }
            for(i=0; i<=npreccol-1; i++)
            {
                buf.idx2preccol[preccolumns[i]] = i;
                buf.bflags[preccolumns[i]] = false;
            }
            
            //
            // Generate working system, apply regularization
            //
            ablasf.rsetallocm(nwrk, npreccol, 0.0, ref suba, _params);
            modelmatrixcomputepartial(bfmatrix, workingnodes, nwrk, preccolumns, npreccol-(nx+1), ref suba, _params);
            for(i=0; i<=nwrk-1; i++)
            {
                ni = workingnodes[i];
                for(j=0; j<=nx-1; j++)
                {
                    suba[i,npreccol-(nx+1)+j] = x[ni,j];
                }
                suba[i,npreccol-1] = 1.0;
            }
            for(i=0; i<=nwrk-1; i++)
            {
                j = buf.idx2preccol[workingnodes[i]];
                suba[i,j] = suba[i,j]+lambdav;
            }
            ablasf.rsetallocm(nwrk, npreccol, 0.0, ref subsp, _params);
            for(i=0; i<=nwrk-1; i++)
            {
                ni = workingnodes[i];
                j0 = sp.ridx[ni];
                j1 = sp.ridx[ni+1]-1;
                for(jj=j0; jj<=j1; jj++)
                {
                    subsp[i,buf.idx2preccol[sp.idx[jj]]] = sp.vals[jj];
                }
            }
            ablasf.rallocm(nwrk, nwrk, ref subproblem.regsystem, _params);
            ablas.rmatrixgemm(nwrk, nwrk, npreccol, 1.0, suba, 0, 0, 0, subsp, 0, 0, 1, 0.0, subproblem.regsystem, 0, 0, _params);
            
            //
            // Try solving with LU decomposition
            //
            ablasf.rcopyallocm(nwrk, nwrk, subproblem.regsystem, ref subproblem.wrklu, _params);
            trfac.rmatrixlu(ref subproblem.wrklu, nwrk, nwrk, ref subproblem.wrkp, _params);
            lurcond = rcond.rmatrixlurcondinf(subproblem.wrklu, nwrk, _params);
            if( (double)(lurcond)>(double)(Math.Sqrt(math.machineepsilon)) )
            {
                
                //
                // LU success
                //
                subproblem.decomposition = 0;
                lusuccess = true;
                if( dodetailedtrace )
                {
                    alglib.ap.trace(System.String.Format(">> DDM subproblem:  LU success, |target|={0,4:d},  |wrk|={1,4:d},  |preccol|={2,4:d}, cond(LU)={3,0:E2}\n", tgt1-tgt0, nwrk, npreccol, 1/(lurcond+math.machineepsilon)));
                }
            }
            else
            {
                lusuccess = false;
            }
            
            //
            // Apply regularized QR if needed
            //
            if( !lusuccess )
            {
                ablasf.rsetallocm(2*nwrk, nwrk, 0.0, ref subproblem.wrkr, _params);
                ablasf.rcopym(nwrk, nwrk, subproblem.regsystem, subproblem.wrkr, _params);
                v = Math.Sqrt(reg);
                for(i=0; i<=nwrk-1; i++)
                {
                    subproblem.wrkr[nwrk+i,i] = v;
                }
                ortfac.rmatrixqr(ref subproblem.wrkr, 2*nwrk, nwrk, ref tau, _params);
                ortfac.rmatrixqrunpackq(subproblem.wrkr, 2*nwrk, nwrk, tau, nwrk, ref subproblem.wrkq, _params);
                subproblem.decomposition = 1;
                if( dodetailedtrace )
                {
                    alglib.ap.trace(System.String.Format(">> DDM subproblem:  LU failure, using reg-QR, |target|={0,4:d},  |wrk|={1,4:d},  |preccol|={2,4:d}, cond(R)={3,0:E2} (cond(LU)={4,0:E2})\n", tgt1-tgt0, nwrk, npreccol, 1/(rcond.rmatrixtrrcondinf(subproblem.wrkr, nwrk, true, false, _params)+math.machineepsilon), 1/(lurcond+math.machineepsilon)));
                }
            }
            
            //
            // Subproblem is ready.
            // Move it to the SubproblemsPool
            //
            alglib.smp.ae_shared_pool_recycle(solver.subproblemspool, ref subproblem);
        }


        /*************************************************************************
        Recursive initialization routine for DDM solver

        INPUT PARAMETERS:
            Solver      -   solver structure
            X           -   array[N,NX], dataset points
            N, NX       -   dataset metrics, N>0, NX>0
            BFMatrix    -   basis function evaluator
            LambdaV     -   smoothing parameter
            SP          -   sparse ACBF preconditioner, (N+NX+1)*(N+NX+1) matrix
                            stored in CRS format
            WrkIdx      -   array[], contains indexes of points in the current working
                            set. Elements [Wrk0,Wrk1) are processed by this function.
            NNeighbors  -   neighbors count; NNeighbors nearby nodes are added  to
                            inner points of the chunk
            NBatch      -   batch size
            DoDetailedTrace-whether trace output is needed or not. When trace is
                            activated, solver computes condition numbers. It results
                            in the several-fold slowdown of the algorithm.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void ddmsolverinitrec(rbf3ddmsolver solver,
            double[,] x,
            int n,
            int nx,
            rbf3evaluator bfmatrix,
            double lambdav,
            sparse.sparsematrix sp,
            int[] wrkidx,
            int wrk0,
            int wrk1,
            int nneighbors,
            int nbatch,
            bool dodetailedtrace,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k0 = 0;
            int k1 = 0;
            int largestdim = 0;
            double splitval = 0;
            double basecasecomplexity = 0;
            rbf3ddmbuffer buf = null;

            if( wrk1<=wrk0 )
            {
                return;
            }
            basecasecomplexity = apserv.rmul3(nbatch+nneighbors+nx+1, nbatch+nneighbors+nx+1, nbatch+nneighbors+nx+1, _params);
            
            //
            // Decide on parallelism
            //
            if( ((double)(basecasecomplexity*((double)n/(double)nbatch))>=(double)(apserv.smpactivationlevel(_params)) && (double)((double)n/(double)nbatch)>=(double)(2)) && n>=ddmparallelthreshold )
            {
                if( _trypexec_ddmsolverinitrec(solver,x,n,nx,bfmatrix,lambdav,sp,wrkidx,wrk0,wrk1,nneighbors,nbatch,dodetailedtrace, _params) )
                {
                    return;
                }
            }
            
            //
            // Retrieve temporary buffer
            //
            alglib.smp.ae_shared_pool_retrieve(solver.bufferpool, ref buf);
            
            //
            // Analyze current working set
            //
            ablasf.rallocv(nx, ref buf.tmpboxmin, _params);
            ablasf.rallocv(nx, ref buf.tmpboxmax, _params);
            ablasf.rcopyrv(nx, x, wrkidx[wrk0], buf.tmpboxmin, _params);
            ablasf.rcopyrv(nx, x, wrkidx[wrk0], buf.tmpboxmax, _params);
            for(i=wrk0+1; i<=wrk1-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    buf.tmpboxmin[j] = Math.Min(buf.tmpboxmin[j], x[wrkidx[i],j]);
                    buf.tmpboxmax[j] = Math.Max(buf.tmpboxmax[j], x[wrkidx[i],j]);
                }
            }
            largestdim = 0;
            for(j=1; j<=nx-1; j++)
            {
                if( (double)(buf.tmpboxmax[j]-buf.tmpboxmin[j])>(double)(buf.tmpboxmax[largestdim]-buf.tmpboxmin[largestdim]) )
                {
                    largestdim = j;
                }
            }
            
            //
            // Perform either batch processing or recursive split
            //
            if( wrk1-wrk0<=nbatch || (double)(buf.tmpboxmax[largestdim])==(double)(buf.tmpboxmin[largestdim]) )
            {
                
                //
                // Either working set size is small enough or all points are non-distinct.
                // Stop recursive subdivision.
                //
                ddmsolverinitbasecase(solver, x, n, nx, bfmatrix, lambdav, sp, buf, wrkidx, wrk0, wrk1, nneighbors, dodetailedtrace, _params);
                
                //
                // Recycle temporary buffers
                //
                alglib.smp.ae_shared_pool_recycle(solver.bufferpool, ref buf);
            }
            else
            {
                
                //
                // Compute recursive split along largest axis
                //
                splitval = 0.5*(buf.tmpboxmax[largestdim]+buf.tmpboxmin[largestdim]);
                k0 = wrk0;
                k1 = wrk1-1;
                while( k0<=k1 )
                {
                    if( (double)(x[wrkidx[k0],largestdim])<=(double)(splitval) )
                    {
                        k0 = k0+1;
                        continue;
                    }
                    if( (double)(x[wrkidx[k1],largestdim])>(double)(splitval) )
                    {
                        k1 = k1-1;
                        continue;
                    }
                    apserv.swapelementsi(wrkidx, k0, k1, _params);
                    k0 = k0+1;
                    k1 = k1-1;
                }
                alglib.ap.assert(k0>wrk0 && k1<wrk1-1, "ACBF: integrity check 2843 in the recursive subdivision code failed");
                alglib.ap.assert(k0==k1+1, "ACBF: integrity check 8364 in the recursive subdivision code failed");
                
                //
                // Recycle temporary buffer, perform recursive calls
                //
                alglib.smp.ae_shared_pool_recycle(solver.bufferpool, ref buf);
                ddmsolverinitrec(solver, x, n, nx, bfmatrix, lambdav, sp, wrkidx, wrk0, k0, nneighbors, nbatch, dodetailedtrace, _params);
                ddmsolverinitrec(solver, x, n, nx, bfmatrix, lambdav, sp, wrkidx, k0, wrk1, nneighbors, nbatch, dodetailedtrace, _params);
            }
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_ddmsolverinitrec(rbf3ddmsolver solver,
            double[,] x,
            int n,
            int nx,
            rbf3evaluator bfmatrix,
            double lambdav,
            sparse.sparsematrix sp,
            int[] wrkidx,
            int wrk0,
            int wrk1,
            int nneighbors,
            int nbatch,
            bool dodetailedtrace, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function prepares domain decomposition method for  RBF  interpolation
        problem  -  it  partitions  problem  into   subproblems   and  precomputes
        factorizations, and prepares a smaller correction spline that is  used  to
        correct distortions introduced by domain decomposition  and  imperfections
        in approximate cardinal basis.

        INPUT PARAMETERS:
            X           -   array[N,NX], dataset points
            RescaledBy  -   additional scaling coefficient that was applied to the
                            dataset by preprocessor. Used ONLY for logging purposes
                            - without it all distances will be reported  in  [0,1]
                            scale, not one set by user.
            N, NX       -   dataset metrics, N>0, NX>0
            BFMatrix    -   RBF evaluator
            BFType      -   basis function type
            BFParam     -   basis function parameter
            LambdaV     -   regularization parameter, >=0
            ATerm       -   polynomial term type (1 for linear, 2 for constant, 3 for zero)
            SP          -   sparse ACBF preconditioner, (N+NX+1)*(N+NX+1) matrix
                            stored in CRS format
            NNeighbors  -   neighbors count; NNeighbors nearby nodes are added  to
                            inner points of the batch
            NBatch      -   batch size
            NCorrector  -   nodes count for correction spline
            DoTrace     -   whether low overhead logging is needed or not
            DoDetailedTrace-whether detailed trace output is needed or not. When trace is
                            activated, solver computes condition numbers. It results
                            in the small slowdown of the algorithm.
            
        OUTPUT PARAMETERS:
            Solver      -   DDM solver
            timeDDMInit-    time used by the DDM part initialization, ms
            timeCorrInit-   time used by the corrector initialization, ms

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void ddmsolverinit(double[,] x,
            double rescaledby,
            int n,
            int nx,
            rbf3evaluator bfmatrix,
            int bftype,
            double bfparam,
            double lambdav,
            int aterm,
            sparse.sparsematrix sp,
            int nneighbors,
            int nbatch,
            int ncorrector,
            bool dotrace,
            bool dodetailedtrace,
            rbf3ddmsolver solver,
            ref int timeddminit,
            ref int timecorrinit,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int[] idx = new int[0];
            rbf3ddmbuffer bufferseed = new rbf3ddmbuffer();
            rbf3ddmsubproblem subproblem = new rbf3ddmsubproblem();
            rbf3ddmsubproblem p = null;
            double correctorgridseparation = 0;
            double[,] corrsys = new double[0,0];
            double[] corrtau = new double[0];
            int[] idummy = new int[0];

            timeddminit = 0;
            timecorrinit = 0;

            alglib.ap.assert((aterm==1 || aterm==2) || aterm==3, "RBF3: integrity check 3320 failed");
            
            //
            // Start DDM part
            //
            timeddminit = unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            
            //
            // Save problem info
            //
            solver.lambdav = lambdav;
            
            //
            // Prepare KD-tree
            //
            ablasf.iallocv(n, ref idx, _params);
            for(i=0; i<=n-1; i++)
            {
                idx[i] = i;
            }
            nearestneighbor.kdtreebuildtagged(x, idx, n, nx, 0, 2, solver.kdt, _params);
            
            //
            // Prepare temporary buffer pool
            //
            ablasf.bsetallocv(n+nx+1, false, ref bufferseed.bflags, _params);
            ablasf.iallocv(n+nx+1, ref bufferseed.idx2preccol, _params);
            ablasf.rallocv(nx, ref bufferseed.tmpboxmin, _params);
            ablasf.rallocv(nx, ref bufferseed.tmpboxmax, _params);
            nearestneighbor.kdtreecreaterequestbuffer(solver.kdt, bufferseed.kdtbuf, _params);
            alglib.smp.ae_shared_pool_set_seed(solver.bufferpool, bufferseed);
            
            //
            // Prepare default subproblems buffer, run recursive procedure
            // and count subproblems in the buffer
            //
            subproblem.isvalid = false;
            alglib.smp.ae_shared_pool_set_seed(solver.subproblemspool, subproblem);
            alglib.smp.ae_shared_pool_set_seed(solver.subproblemsbuffer, subproblem);
            ddmsolverinitrec(solver, x, n, nx, bfmatrix, solver.lambdav, sp, idx, 0, n, nneighbors, nbatch, dodetailedtrace, _params);
            solver.subproblemscnt = 0;
            solver.cntlu = 0;
            solver.cntregqr = 0;
            alglib.smp.ae_shared_pool_first_recycled(solver.subproblemspool, ref p);
            while( p!=null )
            {
                solver.subproblemscnt = solver.subproblemscnt+1;
                if( p.decomposition==0 )
                {
                    apserv.inc(ref solver.cntlu, _params);
                }
                if( p.decomposition==1 )
                {
                    apserv.inc(ref solver.cntregqr, _params);
                }
                alglib.smp.ae_shared_pool_next_recycled(solver.subproblemspool, ref p);
            }
            alglib.ap.assert(solver.cntlu+solver.cntregqr==solver.subproblemscnt, "RBFV3: integrity check 5296 failed");
            alglib.ap.assert(solver.subproblemscnt>0, "RBFV3: subproblems pool is empty, critical integrity check failed");
            
            //
            // DDM part is done
            //
            timeddminit = unchecked((int)(System.DateTime.UtcNow.Ticks/10000))-timeddminit;
            if( dotrace )
            {
                alglib.ap.trace(System.String.Format("> DDM part was prepared in {0,0:d} ms, {1,0:d} subproblems solved ({2,0:d} well-conditioned, {3,0:d} ill-conditioned)\n", timeddminit, solver.subproblemscnt, solver.cntlu, solver.cntregqr));
            }
            
            //
            // Prepare correction spline
            //
            timecorrinit = unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            selectglobalnodes(x, n, nx, idummy, 0, ncorrector, ref solver.corrnodes, ref solver.ncorrector, ref correctorgridseparation, _params);
            ncorrector = solver.ncorrector;
            alglib.ap.assert(ncorrector>0, "RBFV3: NCorrector=0");
            ablasf.rsetallocm(ncorrector+nx+1, ncorrector+nx+1, 0.0, ref corrsys, _params);
            ablasf.rallocm(ncorrector, nx, ref solver.corrx, _params);
            for(i=0; i<=ncorrector-1; i++)
            {
                ablasf.rcopyrr(nx, x, solver.corrnodes[i], solver.corrx, i, _params);
            }
            computebfmatrix(solver.corrx, ncorrector, nx, bftype, bfparam, ref corrsys, _params);
            if( aterm==1 )
            {
                
                //
                // Use linear term
                //
                for(i=0; i<=nx-1; i++)
                {
                    for(j=0; j<=ncorrector-1; j++)
                    {
                        corrsys[ncorrector+i,j] = x[solver.corrnodes[j],i];
                        corrsys[j,ncorrector+i] = x[solver.corrnodes[j],i];
                    }
                }
                for(j=0; j<=ncorrector-1; j++)
                {
                    corrsys[ncorrector+nx,j] = 1.0;
                    corrsys[j,ncorrector+nx] = 1.0;
                }
            }
            if( aterm==2 )
            {
                
                //
                // Use constant term
                //
                for(i=0; i<=nx-1; i++)
                {
                    corrsys[ncorrector+i,ncorrector+i] = 1.0;
                }
                for(j=0; j<=ncorrector-1; j++)
                {
                    corrsys[ncorrector+nx,j] = 1.0;
                    corrsys[j,ncorrector+nx] = 1.0;
                }
            }
            if( aterm==3 )
            {
                
                //
                // Use zero term
                //
                for(i=0; i<=nx; i++)
                {
                    corrsys[ncorrector+i,ncorrector+i] = 1.0;
                }
            }
            for(j=0; j<=ncorrector-1; j++)
            {
                corrsys[j,j] = corrsys[j,j]+solver.lambdav;
            }
            ortfac.rmatrixqr(ref corrsys, ncorrector+nx+1, ncorrector+nx+1, ref corrtau, _params);
            ortfac.rmatrixqrunpackq(corrsys, ncorrector+nx+1, ncorrector+nx+1, corrtau, ncorrector+nx+1, ref solver.corrq, _params);
            ortfac.rmatrixqrunpackr(corrsys, ncorrector+nx+1, ncorrector+nx+1, ref solver.corrr, _params);
            timecorrinit = unchecked((int)(System.DateTime.UtcNow.Ticks/10000))-timecorrinit;
            if( dotrace )
            {
                alglib.ap.trace(System.String.Format("> Corrector spline was prepared in {0,0:d} ms ({1,0:d} nodes, max distance from dataset points to nearest grid node is {2,0:E2})\n", timecorrinit, ncorrector, correctorgridseparation*rescaledby));
            }
            if( dodetailedtrace )
            {
                alglib.ap.trace("> printing condition numbers for correction spline:\n");
                alglib.ap.trace(System.String.Format("cond(A)     = {0,0:E2} (Linf norm, leading NCoarsexNCoarse block)\n", 1/(rcond.rmatrixtrrcondinf(solver.corrr, ncorrector, true, false, _params)+math.machineepsilon)));
                alglib.ap.trace(System.String.Format("cond(A)     = {0,0:E2} (Linf norm, full system)\n", 1/(rcond.rmatrixtrrcondinf(solver.corrr, ncorrector+nx+1, true, false, _params)+math.machineepsilon)));
            }
        }


        /*************************************************************************
        Recursive subroutine for DDM method. Given initial subproblems count  Cnt,
        it perform two recursive calls (spawns children in parallel when possible)
        with Cnt~Cnt/2 until we end up with Cnt=1.

        Case with Cnt=1 is handled by retrieving subproblem from Solver.SubproblemsPool,
        solving it and pushing subproblem to Solver.SubproblemsBuffer.

        INPUT PARAMETERS:
            Solver      -   DDM solver object
            Res         -   array[N,NY], current residuals
            N, NX, NY   -   dataset metrics, N>0, NX>0, NY>0
            C           -   preallocated array[N+NX+1,NY]
            Cnt         -   number of subproblems to process
            
        OUTPUT PARAMETERS:
            C           -   rows 0..N-1  contain spline coefficients
                            rows N..N+NX are filled by zeros

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void ddmsolverrunrec(rbf3ddmsolver solver,
            double[,] res,
            int n,
            int nx,
            int ny,
            double[,] c,
            int cnt,
            alglib.xparams _params)
        {
            int nwrk = 0;
            int ntarget = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            double v = 0;
            rbf3ddmsubproblem subproblem = null;

            
            //
            // Run recursive procedure if needed
            //
            if( cnt>1 )
            {
                k = cnt/2;
                alglib.ap.assert(k<=cnt-k, "RBFV3: integrity check 2733 failed");
                ddmsolverrunrec(solver, res, n, nx, ny, c, cnt-k, _params);
                ddmsolverrunrec(solver, res, n, nx, ny, c, k, _params);
                return;
            }
            
            //
            // Retrieve subproblem from the source pool, solve it
            //
            alglib.smp.ae_shared_pool_retrieve(solver.subproblemspool, ref subproblem);
            alglib.ap.assert(subproblem!=null && subproblem.isvalid, "RBFV3: integrity check 1742 failed");
            nwrk = subproblem.nwork;
            ntarget = subproblem.ntarget;
            if( subproblem.decomposition==0 )
            {
                
                //
                // Solve using LU decomposition (the fastest option)
                //
                ablasf.rallocm(nwrk, ny, ref subproblem.rhs, _params);
                for(i=0; i<=nwrk-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        subproblem.rhs[i,j] = res[subproblem.workingnodes[i],j];
                    }
                }
                for(i=0; i<=nwrk-1; i++)
                {
                    if( subproblem.wrkp[i]!=i )
                    {
                        for(j=0; j<=ny-1; j++)
                        {
                            v = subproblem.rhs[i,j];
                            subproblem.rhs[i,j] = subproblem.rhs[subproblem.wrkp[i],j];
                            subproblem.rhs[subproblem.wrkp[i],j] = v;
                        }
                    }
                }
                ablas.rmatrixlefttrsm(nwrk, ny, subproblem.wrklu, 0, 0, false, true, 0, subproblem.rhs, 0, 0, _params);
                ablas.rmatrixlefttrsm(nwrk, ny, subproblem.wrklu, 0, 0, true, false, 0, subproblem.rhs, 0, 0, _params);
                ablasf.rcopyallocm(nwrk, ny, subproblem.rhs, ref subproblem.sol, _params);
            }
            else
            {
                
                //
                // Solve using regularized QR (well, we tried LU but it failed)
                //
                alglib.ap.assert(subproblem.decomposition==1, "RBFV3: integrity check 1743 failed");
                ablasf.rallocm(nwrk, ny, ref subproblem.rhs, _params);
                for(i=0; i<=nwrk-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        subproblem.rhs[i,j] = res[subproblem.workingnodes[i],j];
                    }
                }
                ablasf.rallocm(nwrk, ny, ref subproblem.qtrhs, _params);
                ablas.rmatrixgemm(nwrk, ny, nwrk, 1.0, subproblem.wrkq, 0, 0, 1, subproblem.rhs, 0, 0, 0, 0.0, subproblem.qtrhs, 0, 0, _params);
                ablas.rmatrixlefttrsm(nwrk, ny, subproblem.wrkr, 0, 0, true, false, 0, subproblem.qtrhs, 0, 0, _params);
                ablasf.rcopyallocm(nwrk, ny, subproblem.qtrhs, ref subproblem.sol, _params);
            }
            for(i=0; i<=ntarget-1; i++)
            {
                for(j=0; j<=ny-1; j++)
                {
                    c[subproblem.targetnodes[i],j] = subproblem.sol[i,j];
                }
            }
            
            //
            // Push to the destination pool
            //
            alglib.smp.ae_shared_pool_recycle(solver.subproblemsbuffer, ref subproblem);
        }


        /*************************************************************************
        This function APPROXIMATELY solves RBF interpolation problem using  domain
        decomposition method. Given current residuals Res, it computes approximate
        basis function coefficients C (but does  NOT  compute linear  coefficients
        - these are set to zero).

        This function is a linear operator with respect to its input RES, thus  it
        can be used as a preconditioner for an iterative linear solver like GMRES.

        INPUT PARAMETERS:
            Solver      -   DDM solver object
            Res         -   array[N,NY], current residuals
            N, NX, NY   -   dataset metrics, N>0, NX>0, NY>0
            SP          -   preconditioner, (N+NX+1)*(N+NX+1) sparse matrix
            BFMatrix    -   basis functions evaluator
            C           -   preallocated array[N+NX+1,NY]
            timeDDMSolve,
            timeCorrSolve-  on input contain already accumulated timings
                            for DDM and CORR parts
            
        OUTPUT PARAMETERS:
            C           -   rows 0..N-1  contain spline coefficients
                            rows N..N+NX are filled by zeros
            timeDDMSolve,
            timeCorrSolve-  updated with new timings
            

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void ddmsolverrun(rbf3ddmsolver solver,
            double[,] res,
            int n,
            int nx,
            int ny,
            sparse.sparsematrix sp,
            rbf3evaluator bfmatrix,
            ref double[,] upd,
            ref int timeddmsolve,
            ref int timecorrsolve,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            rbf3ddmsubproblem subproblem = null;
            double[,] c = new double[0,0];
            double[] x0 = new double[0];
            double[] x1 = new double[0];
            double[] refrhs1 = new double[0];
            double[,] updt = new double[0,0];

            ablasf.rsetallocm(ny, n+nx+1, 0.0, ref updt, _params);
            ablasf.rsetallocm(n+nx+1, ny, 0.0, ref c, _params);
            for(j=0; j<=ny-1; j++)
            {
                for(i=n; i<=n+nx; i++)
                {
                    c[i,j] = 0;
                }
            }
            
            //
            // Solve DDM part:
            // * run recursive procedure that computes DDM part.
            // * clean-up: move processed subproblems from Solver.SubproblemsBuffer back to Solver.SubproblemsPool
            // * multiply solution by the preconditioner matrix
            //
            timeddmsolve = timeddmsolve-unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            ddmsolverrunrec(solver, res, n, nx, ny, c, solver.subproblemscnt, _params);
            for(i=0; i<=solver.subproblemscnt-1; i++)
            {
                alglib.smp.ae_shared_pool_retrieve(solver.subproblemsbuffer, ref subproblem);
                alglib.ap.assert(subproblem!=null && subproblem.isvalid, "RBFV3: integrity check 5223 failed");
                alglib.smp.ae_shared_pool_recycle(solver.subproblemspool, ref subproblem);
            }
            timeddmsolve = timeddmsolve+unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            ablasf.rallocv(n+nx+1, ref x0, _params);
            ablasf.rallocv(n+nx+1, ref x1, _params);
            for(j=0; j<=ny-1; j++)
            {
                ablasf.rcopycv(n+nx+1, c, j, x0, _params);
                sparse.sparsegemv(sp, 1.0, 1, x0, 0, 0.0, x1, 0, _params);
                ablasf.rcopyvr(n+nx+1, x1, updt, j, _params);
            }
            
            //
            // Compute correction spline that fixes oscillations introduced by the DDM part
            //
            timecorrsolve = timecorrsolve-unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            ablasf.rallocv(solver.ncorrector+nx+1, ref x0, _params);
            ablasf.rallocv(n+nx+1, ref x1, _params);
            for(j=0; j<=ny-1; j++)
            {
                
                //
                // Prepare right-hand side for the QR solver
                //
                ablasf.rsetallocv(solver.ncorrector+nx+1, 0.0, ref refrhs1, _params);
                ablasf.rcopyrv(n+nx+1, updt, j, x1, _params);
                modelmatrixcomputeproductatnodes(bfmatrix, x1, solver.corrnodes, solver.ncorrector, ref refrhs1, _params);
                for(i=0; i<=solver.ncorrector-1; i++)
                {
                    refrhs1[i] = res[solver.corrnodes[i],j]-refrhs1[i];
                    for(k=0; k<=nx-1; k++)
                    {
                        refrhs1[i] = refrhs1[i]-solver.corrx[i,k]*x1[n+k];
                    }
                    refrhs1[i] = refrhs1[i]-x1[n+nx];
                    refrhs1[i] = refrhs1[i]-solver.lambdav*x1[solver.corrnodes[i]];
                }
                
                //
                // Solve QR-factorized system
                //
                ablasf.rgemv(solver.ncorrector+nx+1, solver.ncorrector+nx+1, 1.0, solver.corrq, 1, refrhs1, 0.0, x0, _params);
                ablas.rmatrixtrsv(solver.ncorrector+nx+1, solver.corrr, 0, 0, true, false, 0, x0, 0, _params);
                for(i=0; i<=solver.ncorrector-1; i++)
                {
                    updt[j,solver.corrnodes[i]] = updt[j,solver.corrnodes[i]]+x0[i];
                }
                for(i=0; i<=nx; i++)
                {
                    updt[j,n+i] = updt[j,n+i]+x0[solver.ncorrector+i];
                }
            }
            timecorrsolve = timecorrsolve+unchecked((int)(System.DateTime.UtcNow.Ticks/10000));
            ablasf.rallocm(n+nx+1, ny, ref upd, _params);
            ablas.rmatrixtranspose(ny, n+nx+1, updt, 0, 0, upd, 0, 0, _params);
        }


        /*************************************************************************
        This function is a specialized version of DDMSolverRun() for NY=1.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void ddmsolverrun1(rbf3ddmsolver solver,
            double[] res,
            int n,
            int nx,
            sparse.sparsematrix sp,
            rbf3evaluator bfmatrix,
            ref double[] upd,
            ref int timeddmsolve,
            ref int timecorrsolve,
            alglib.xparams _params)
        {
            ablasf.rallocm(n, 1, ref solver.tmpres1, _params);
            ablasf.rcopyvc(n, res, solver.tmpres1, 0, _params);
            ddmsolverrun(solver, solver.tmpres1, n, nx, 1, sp, bfmatrix, ref solver.tmpupd1, ref timeddmsolve, ref timecorrsolve, _params);
            ablasf.rallocv(n+nx+1, ref upd, _params);
            ablasf.rcopycv(n+nx+1, solver.tmpupd1, 0, upd, _params);
        }


        /*************************************************************************
        Automatically detect scale parameter as a mean distance towards nearest
        neighbor (not counting nearest neighbors that are too close)

        PARAMETERS:
            XX                  -   dataset (X-values), array[N,NX]
            N                   -   points count, N>=1
            NX                  -   dimensions count, NX>=1
            
        RESULT:
            suggested scale

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static double autodetectscaleparameter(double[,] xx,
            int n,
            int nx,
            alglib.xparams _params)
        {
            double result = 0;
            int i = 0;
            int j = 0;
            int nq = 0;
            int nlocal = 0;
            nearestneighbor.kdtree kdt = new nearestneighbor.kdtree();
            double[] x = new double[0];
            double[] d = new double[0];

            alglib.ap.assert(n>=1, "RBFV3: integrity check 7624 failed");
            ablasf.rallocv(nx, ref x, _params);
            nearestneighbor.kdtreebuild(xx, n, nx, 0, 2, kdt, _params);
            nlocal = (int)Math.Round(Math.Pow(2, nx)+1);
            result = 0;
            for(i=0; i<=n-1; i++)
            {
                
                //
                // Query a batch of nearest neighbors
                //
                ablasf.rcopyrv(nx, xx, i, x, _params);
                nq = nearestneighbor.kdtreequeryknn(kdt, x, nlocal, true, _params);
                alglib.ap.assert(nq>=1, "RBFV3: integrity check 7625 failed");
                nearestneighbor.kdtreequeryresultsdistances(kdt, ref d, _params);
                
                //
                // In order to filter out nearest neighbors that are too close,
                // we use distance R toward most distant of NQ nearest neighbors as
                // a reference and select nearest neighbor with distance >=0.5*R/NQ
                //
                for(j=0; j<=nq-1; j++)
                {
                    if( (double)(d[j])>=(double)(0.5*d[nq-1]/nq) )
                    {
                        result = result+d[j];
                        break;
                    }
                }
            }
            result = result/n;
            return result;
        }


        /*************************************************************************
        Recursive functions matrix computation

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void computebfmatrixrec(double[,] xx,
            int range0,
            int range1,
            int n,
            int nx,
            int functype,
            double funcparam,
            double[,] f,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            double v = 0;
            double vv = 0;
            double elemcost = 0;
            double alpha2 = 0;

            alglib.ap.assert((functype==1 || functype==2) || functype==3, "RBFV3.ComputeTransposedDesignSystem: unexpected FuncType");
            
            //
            // Try to parallelize
            //
            elemcost = 10.0;
            if( ((range0==0 && range1==n) && (double)(0.5*apserv.rmul3(n, n, elemcost, _params))>=(double)(apserv.smpactivationlevel(_params))) && n>=bfparallelthreshold )
            {
                if( _trypexec_computebfmatrixrec(xx,range0,range1,n,nx,functype,funcparam,f, _params) )
                {
                    return;
                }
            }
            
            //
            // Try recursive splits
            //
            if( range1-range0>16 )
            {
                k = range0+(range1-range0)/2;
                computebfmatrixrec(xx, range0, k, n, nx, functype, funcparam, f, _params);
                computebfmatrixrec(xx, k, range1, n, nx, functype, funcparam, f, _params);
                return;
            }
            
            //
            // Serial processing
            //
            alpha2 = funcparam*funcparam;
            for(i=range0; i<=range1-1; i++)
            {
                for(j=i; j<=n-1; j++)
                {
                    v = 0;
                    for(k=0; k<=nx-1; k++)
                    {
                        vv = xx[i,k]-xx[j,k];
                        v = v+vv*vv;
                    }
                    if( functype==1 )
                    {
                        v = -Math.Sqrt(v+alpha2);
                    }
                    if( functype==2 )
                    {
                        if( v!=0.0 )
                        {
                            v = v*0.5*Math.Log(v);
                        }
                        else
                        {
                            v = 0.0;
                        }
                    }
                    if( functype==3 )
                    {
                        v = v*Math.Sqrt(v);
                    }
                    f[i,j] = v;
                    f[j,i] = v;
                }
            }
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_computebfmatrixrec(double[,] xx,
            int range0,
            int range1,
            int n,
            int nx,
            int functype,
            double funcparam,
            double[,] f, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function computes  basis  functions  matrix  (both  upper  and  lower
        triangles)


              [ f(dist(x0,x0))     ... f(dist(x0,x(n-1)))     ]
              [ f(dist(x1,x0))     ... f(dist(x1,x(n-1)))     ]
              [ ............................................. ]
              [ f(dist(x(n-1),x0)) ... f(dist(x(n-1),x(n-1))) ]
              
        NOTE: if F is large enough to store result, it is not reallocated. Values
              outside of [0,N)x[0,N) range are not modified.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void computebfmatrix(double[,] xx,
            int n,
            int nx,
            int functype,
            double funcparam,
            ref double[,] f,
            alglib.xparams _params)
        {
            ablasf.rallocm(n, n, ref f, _params);
            computebfmatrixrec(xx, 0, n, n, nx, functype, funcparam, f, _params);
        }


        /*************************************************************************
        Initializes model matrix using specified matrix storage format:
        * StorageType=0     a N*N matrix of basis function values is stored 
        * StorageType=1     basis function values are recomputed on demand

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void modelmatrixinit(double[,] xx,
            int n,
            int nx,
            int functype,
            double funcparam,
            int storagetype,
            rbf3evaluator modelmatrix,
            alglib.xparams _params)
        {
            int nchunks = 0;
            int i = 0;
            int j = 0;
            int srcoffs = 0;
            int dstoffs = 0;
            int curlen = 0;
            rbf3evaluatorbuffer bufseed = new rbf3evaluatorbuffer();

            alglib.ap.assert(storagetype==0 || storagetype==1, "RBFV3: unexpected StorageType for ModelMatrixInit()");
            modelmatrix.n = n;
            modelmatrix.storagetype = storagetype;
            if( storagetype==0 )
            {
                computebfmatrix(xx, n, nx, functype, funcparam, ref modelmatrix.f, _params);
                return;
            }
            if( storagetype==1 )
            {
                
                //
                // Save model parameters
                //
                modelmatrix.nx = nx;
                modelmatrix.functype = functype;
                modelmatrix.funcparam = funcparam;
                modelmatrix.chunksize = 128;
                
                //
                // Prepare temporary buffers
                //
                alglib.smp.ae_shared_pool_set_seed(modelmatrix.bufferpool, bufseed);
                ablasf.rsetallocv(modelmatrix.chunksize, 1.0, ref modelmatrix.chunk1, _params);
                
                //
                // Store dataset in the chunked row storage format (rows with size at most ChunkSize, one row per dimension/chunk)
                //
                ablasf.iallocv(n, ref modelmatrix.entireset, _params);
                for(i=0; i<=n-1; i++)
                {
                    modelmatrix.entireset[i] = i;
                }
                ablasf.rcopyallocm(n, nx, xx, ref modelmatrix.x, _params);
                nchunks = apserv.idivup(n, modelmatrix.chunksize, _params);
                ablasf.rsetallocm(nchunks*nx, modelmatrix.chunksize, 0.0, ref modelmatrix.xtchunked, _params);
                srcoffs = 0;
                dstoffs = 0;
                while( srcoffs<n )
                {
                    curlen = Math.Min(modelmatrix.chunksize, n-srcoffs);
                    for(i=0; i<=curlen-1; i++)
                    {
                        for(j=0; j<=nx-1; j++)
                        {
                            modelmatrix.xtchunked[dstoffs+j,i] = xx[srcoffs+i,j];
                        }
                    }
                    srcoffs = srcoffs+curlen;
                    dstoffs = dstoffs+nx;
                }
                return;
            }
            alglib.ap.assert(false, "ModelMatrixInit: integrity check failed");
        }


        /*************************************************************************
        Computes subset of the model matrix (subset of rows, subset of columns) and
        writes result to R.

        NOTE: If R is longer than M0xM1, it is not reallocated and additional elements
              are not modified.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void modelmatrixcomputepartial(rbf3evaluator modelmatrix,
            int[] ridx,
            int m0,
            int[] cidx,
            int m1,
            ref double[,] r,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int ni = 0;
            int nj = 0;
            double v = 0;
            double vv = 0;

            alglib.ap.assert(modelmatrix.storagetype==0 || modelmatrix.storagetype==1, "ModelMatrixComputePartial: unexpected StorageType");
            ablasf.rallocm(m0, m1, ref r, _params);
            if( modelmatrix.storagetype==0 )
            {
                for(i=0; i<=m0-1; i++)
                {
                    ni = ridx[i];
                    for(j=0; j<=m1-1; j++)
                    {
                        r[i,j] = modelmatrix.f[ni,cidx[j]];
                    }
                }
                return;
            }
            if( modelmatrix.storagetype==1 )
            {
                alglib.ap.assert(modelmatrix.functype==1 || modelmatrix.functype==2, "ModelMatrixComputePartial: unexpected FuncType");
                for(i=0; i<=m0-1; i++)
                {
                    ni = ridx[i];
                    for(j=0; j<=m1-1; j++)
                    {
                        nj = cidx[j];
                        v = 0;
                        if( modelmatrix.functype==1 )
                        {
                            v = modelmatrix.funcparam*modelmatrix.funcparam;
                        }
                        if( modelmatrix.functype==2 )
                        {
                            v = 1.0E-50;
                        }
                        for(k=0; k<=modelmatrix.nx-1; k++)
                        {
                            vv = modelmatrix.x[ni,k]-modelmatrix.x[nj,k];
                            v = v+vv*vv;
                        }
                        if( modelmatrix.functype==1 )
                        {
                            v = -Math.Sqrt(v);
                        }
                        if( modelmatrix.functype==2 )
                        {
                            v = v*0.5*Math.Log(v);
                        }
                        r[i,j] = v;
                    }
                }
                return;
            }
            alglib.ap.assert(false, "ModelMatrixComputePartial: integrity check failed");
        }


        /*************************************************************************
        This function computes ChunkSize basis function values and stores them in
        the evaluator buffer. This function does not modify Evaluator object, thus
        it can be used in multiple threads with the same evaluator as long as different
        buffers are used.

        INPUT PARAMETERS:
            Evaluator       -   evaluator object
            X               -   origin point
            Buf             -   preallocated buffers. Following fields are used and
                                must have at least ChunkSize elements:
                                * Buf.FuncBuf
                                * Buf.WrkBuf
                                When NeedGradInfo>=1, additionally we need
                                the following fields to be preallocated:
                                * Buf.MinDist2 - array[ChunkSize], filled by some
                                  positive values; on the very first call it is 1.0E50
                                  or something comparably large
                                * Buf.DeltaBuf - array[NX,ChunkSize]
                                * Buf.DF1 - array[ChunkSize]
                                When NeedGradInfo>=2, additionally we need
                                the following fields to be preallocated:
                                * Buf.DF2 - array[ChunkSize]
            ChunkSize       -   amount of basis functions to compute,
                                0<ChunkSize<=Evaluator.ChunkSize
            ChunkIdx        -   index of the chunk in Evaluator.XTChunked times NX
            Distance0       -   strictly positive value that is added to the
                                squared distance prior to passing it to the multiquadric
                                kernel function. For other kernels - set it to small
                                nonnegative value like 1.0E-50.
            NeedGradInfo    -   whether gradient-related information is needed or
                                not:
                                * if 0, only FuncBuf is set on exit
                                * if 1, MinDist2, DeltaBuf and DF1 are also set on exit
                                * if 2, additionally DF2 is set on exit
            
        OUTPUT PARAMETERS:
            Buf.FuncBuf     -   array[ChunkSize], basis function values
            Buf.MinDist2    -   array[ChunkSize], if NeedGradInfo>=1 then its
                                I-th element is updated as MinDist2[I]:=min(MinDist2[I],DISTANCE_SQUARED(X,CENTER[I]))
            Buf.DeltaBuf    -   array[NX,ChunkSize], if NeedGradInfo>=1 then
                                J-th element of K-th row is set to X[K]-CENTER[J,K]
            Buf.DF1         -   array[ChunkSize], if NeedGradInfo>=1 then
                                J-th element is derivative of the kernel function
                                with respect to its input (squared distance)
            Buf.DF2         -   array[ChunkSize], if NeedGradInfo>=2 then
                                J-th element is derivative of the kernel function
                                with respect to its input (squared distance)
            
          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void computerowchunk(rbf3evaluator evaluator,
            double[] x,
            rbf3evaluatorbuffer buf,
            int chunksize,
            int chunkidx,
            double distance0,
            int needgradinfo,
            alglib.xparams _params)
        {
            int k = 0;
            double r2 = 0;
            double lnr = 0;

            
            //
            // Compute squared distance in Buf.FuncBuf
            //
            ablasf.rsetv(chunksize, distance0, buf.funcbuf, _params);
            for(k=0; k<=evaluator.nx-1; k++)
            {
                ablasf.rsetv(chunksize, x[k], buf.wrkbuf, _params);
                ablasf.raddrv(chunksize, -1.0, evaluator.xtchunked, chunkidx+k, buf.wrkbuf, _params);
                ablasf.rmuladdv(chunksize, buf.wrkbuf, buf.wrkbuf, buf.funcbuf, _params);
                if( needgradinfo>=1 )
                {
                    ablasf.rcopyvr(chunksize, buf.wrkbuf, buf.deltabuf, k, _params);
                }
            }
            if( needgradinfo>=1 )
            {
                ablasf.rmergeminv(chunksize, buf.funcbuf, buf.mindist2, _params);
            }
            
            //
            // Apply kernel function
            //
            if( evaluator.functype==1 )
            {
                
                //
                // f=-sqrt(r^2+alpha^2), including f=-r as a special case
                //
                if( needgradinfo==0 )
                {
                    
                    //
                    // Only target f(r2)=-sqrt(r2) is needed
                    //
                    ablasf.rsqrtv(chunksize, buf.funcbuf, _params);
                    ablasf.rmulv(chunksize, -1.0, buf.funcbuf, _params);
                }
                if( needgradinfo==1 )
                {
                    
                    //
                    // First derivative is needed:
                    //
                    // f(r2)   = -sqrt(r2)
                    // f'(r2)  = -0.5/sqrt(r2)
                    //
                    // NOTE: FuncBuf[] is always positive due to small correction added,
                    //       thus we have no need to handle zero value as a special case
                    //
                    ablasf.rsqrtv(chunksize, buf.funcbuf, _params);
                    ablasf.rmulv(chunksize, -1.0, buf.funcbuf, _params);
                    ablasf.rsetv(chunksize, 0.5, buf.df1, _params);
                    ablasf.rmergedivv(chunksize, buf.funcbuf, buf.df1, _params);
                }
                if( needgradinfo==2 )
                {
                    
                    //
                    // Second derivatives is needed:
                    //
                    // f(r2)   = -sqrt(r2+alpha2)
                    // f'(r2)  = -0.5/sqrt(r2+alpha2)
                    // f''(r2) =  0.25/((r2+alpha2)^(3/2))
                    //
                    // NOTE: FuncBuf[] is always positive due to small correction added,
                    //       thus we have no need to handle zero value as a special case
                    //
                    ablasf.rcopymulv(chunksize, -2.0, buf.funcbuf, buf.wrkbuf, _params);
                    ablasf.rsqrtv(chunksize, buf.funcbuf, _params);
                    ablasf.rmulv(chunksize, -1.0, buf.funcbuf, _params);
                    ablasf.rsetv(chunksize, 0.5, buf.df1, _params);
                    ablasf.rmergedivv(chunksize, buf.funcbuf, buf.df1, _params);
                    ablasf.rcopyv(chunksize, buf.df1, buf.df2, _params);
                    ablasf.rmergedivv(chunksize, buf.wrkbuf, buf.df2, _params);
                }
                return;
            }
            if( evaluator.functype==2 )
            {
                
                //
                // f=r^2*ln(r)
                //
                // NOTE: FuncBuf[] is always positive due to small correction added,
                //       thus we have no need to handle ln(0) as a special case.
                //
                if( needgradinfo==0 )
                {
                    
                    //
                    // No gradient info is required
                    //
                    // NOTE: FuncBuf[] is always positive due to small correction added,
                    //       thus we have no need to handle zero value as a special case
                    //
                    for(k=0; k<=chunksize-1; k++)
                    {
                        buf.funcbuf[k] = buf.funcbuf[k]*0.5*Math.Log(buf.funcbuf[k]);
                    }
                }
                if( needgradinfo==1 )
                {
                    
                    //
                    // First derivative is needed:
                    //
                    // f(r2)  = 0.5*r2*ln(r2)
                    // f'(r2) = 0.5*ln(r2) + 0.5 = 0.5*(ln(r2)+1) =ln(r)+0.5
                    //
                    // NOTE: FuncBuf[] is always positive due to small correction added,
                    //       thus we have no need to handle zero value as a special case
                    //
                    for(k=0; k<=chunksize-1; k++)
                    {
                        r2 = buf.funcbuf[k];
                        lnr = 0.5*Math.Log(r2);
                        buf.funcbuf[k] = r2*lnr;
                        buf.df1[k] = lnr+0.5;
                    }
                }
                if( needgradinfo==2 )
                {
                    
                    //
                    // Second derivative is needed:
                    //
                    // f(r2)  = 0.5*r2*ln(r2)
                    // f'(r2) = 0.5*ln(r2) + 0.5 = 0.5*(ln(r2)+1) =ln(r)+0.5
                    // f''(r2)= 0.5/r2
                    //
                    // NOTE: FuncBuf[] is always positive due to small correction added,
                    //       thus we have no need to handle zero value as a special case
                    //
                    for(k=0; k<=chunksize-1; k++)
                    {
                        r2 = buf.funcbuf[k];
                        lnr = 0.5*Math.Log(r2);
                        buf.funcbuf[k] = r2*lnr;
                        buf.df1[k] = lnr+0.5;
                        buf.df2[k] = 0.5/r2;
                    }
                }
                return;
            }
            alglib.ap.assert(false, "RBFV3: unexpected FuncType in ComputeRowChunk()");
        }


        /*************************************************************************
        Recursive subroutine for parallel divide-and-conquer computation of matrix-
        vector product with coefficients vector. Works only for on-the-fly models
        with StorageType=1

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void modelmatrixcomputeproductrec(rbf3evaluator modelmatrix,
            double[] c,
            int[] rowidx,
            double[] r,
            int idx0,
            int idx1,
            bool toplevelcall,
            alglib.xparams _params)
        {
            int s0 = 0;
            int s1 = 0;
            int i = 0;
            int colidx = 0;
            int curchunk = 0;
            int srcidx = 0;
            double distance0 = 0;
            rbf3evaluatorbuffer buf = null;

            alglib.ap.assert(modelmatrix.storagetype==1, "ModelMatrixComputeProductRec: unexpected StorageType");
            
            //
            // Do we need parallel execution?
            //
            if( (toplevelcall && (double)(apserv.rmul2(modelmatrix.n, idx1-idx0, _params))>(double)(apserv.smpactivationlevel(_params))) && idx1-idx0>modelmatrix.chunksize )
            {
                if( _trypexec_modelmatrixcomputeproductrec(modelmatrix,c,rowidx,r,idx0,idx1,toplevelcall, _params) )
                {
                    return;
                }
            }
            
            //
            // Perform recursive subdivision on the destination indexes until we fit into the chunk size
            //
            if( idx1-idx0>modelmatrix.chunksize )
            {
                apserv.tiledsplit(idx1-idx0, modelmatrix.chunksize, ref s0, ref s1, _params);
                modelmatrixcomputeproductrec(modelmatrix, c, rowidx, r, idx0, idx0+s0, false, _params);
                modelmatrixcomputeproductrec(modelmatrix, c, rowidx, r, idx0+s0, idx1, false, _params);
                return;
            }
            
            //
            // Now split column indexes
            //
            alglib.ap.assert(modelmatrix.functype==1 || modelmatrix.functype==2, "ModelMatrixComputeProductRec: unexpected FuncType");
            alglib.smp.ae_shared_pool_retrieve(modelmatrix.bufferpool, ref buf);
            ablasf.rsetallocv(modelmatrix.nx, 0.0, ref buf.x, _params);
            ablasf.rsetallocv(modelmatrix.chunksize, 0.0, ref buf.coeffbuf, _params);
            ablasf.rsetallocv(modelmatrix.chunksize, 0.0, ref buf.funcbuf, _params);
            ablasf.rsetallocv(modelmatrix.chunksize, 0.0, ref buf.wrkbuf, _params);
            colidx = 0;
            srcidx = 0;
            distance0 = 1.0E-50;
            if( modelmatrix.functype==1 )
            {
                
                //
                // Kernels that add squared parameter to the squared distance
                //
                distance0 = math.sqr(modelmatrix.funcparam);
            }
            while( colidx<modelmatrix.n )
            {
                
                //
                // Handle basecase with size at most ChunkSize*ChunkSize
                //
                curchunk = Math.Min(modelmatrix.chunksize, modelmatrix.n-colidx);
                ablasf.rcopyvx(curchunk, c, colidx, buf.coeffbuf, 0, _params);
                for(i=idx0; i<=idx1-1; i++)
                {
                    ablasf.rcopyrv(modelmatrix.nx, modelmatrix.x, rowidx[i], buf.x, _params);
                    computerowchunk(modelmatrix, buf.x, buf, curchunk, srcidx, distance0, 0, _params);
                    r[i] = r[i]+ablasf.rdotv(curchunk, buf.funcbuf, buf.coeffbuf, _params);
                }
                colidx = colidx+curchunk;
                srcidx = srcidx+modelmatrix.nx;
            }
            alglib.smp.ae_shared_pool_recycle(modelmatrix.bufferpool, ref buf);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_modelmatrixcomputeproductrec(rbf3evaluator modelmatrix,
            double[] c,
            int[] rowidx,
            double[] r,
            int idx0,
            int idx1,
            bool toplevelcall, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        Computes product of the model matrix with vector C, writes result to R.

        NOTE: this function is thread safe and can be used with the same model matrix
              from different threads

        NOTE: If R is longer than M, it is not reallocated and additional elements
              are not modified.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void modelmatrixcomputeproduct(rbf3evaluator modelmatrix,
            double[] c,
            ref double[] r,
            alglib.xparams _params)
        {
            alglib.ap.assert(modelmatrix.storagetype==0 || modelmatrix.storagetype==1, "ModelMatrixComputeProduct: unexpected StorageType");
            ablasf.rallocv(modelmatrix.n, ref r, _params);
            if( modelmatrix.storagetype==0 )
            {
                ablas.rmatrixgemv(modelmatrix.n, modelmatrix.n, 1.0, modelmatrix.f, 0, 0, 0, c, 0, 0.0, r, 0, _params);
                return;
            }
            if( modelmatrix.storagetype==1 )
            {
                ablasf.rsetv(modelmatrix.n, 0.0, r, _params);
                modelmatrixcomputeproductrec(modelmatrix, c, modelmatrix.entireset, r, 0, modelmatrix.n, true, _params);
                return;
            }
            alglib.ap.assert(false, "ModelMatrixComputeProduct: integrity check failed");
        }


        /*************************************************************************
        Computes product of the subset of the model matrix (only rows with indexes
        from Idx[]) with vector C, writes result to R.

        NOTE: this function is thread safe and can be used with the same model matrix
              from different threads

        NOTE: If R is longer than M, it is not reallocated and additional elements
              are not modified.

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static void modelmatrixcomputeproductatnodes(rbf3evaluator modelmatrix,
            double[] c,
            int[] idx,
            int m,
            ref double[] r,
            alglib.xparams _params)
        {
            int i = 0;

            alglib.ap.assert(modelmatrix.storagetype==0 || modelmatrix.storagetype==1, "ModelMatrixComputeProductAtNodes: unexpected StorageType");
            ablasf.rallocv(m, ref r, _params);
            if( modelmatrix.storagetype==0 )
            {
                for(i=0; i<=m-1; i++)
                {
                    r[i] = ablasf.rdotvr(modelmatrix.n, c, modelmatrix.f, idx[i], _params);
                }
                return;
            }
            if( modelmatrix.storagetype==1 )
            {
                ablasf.rsetv(m, 0.0, r, _params);
                modelmatrixcomputeproductrec(modelmatrix, c, idx, r, 0, m, true, _params);
                return;
            }
            alglib.ap.assert(false, "ModelMatrixComputeProductAtNodes: integrity check failed");
        }


        /*************************************************************************
        Checks whether basis function is conditionally positive definite or not,
        given the polynomial term type (ATerm=1 means linear, ATerm=2 means constant,
        ATerm=3 means no polynomial term).

          -- ALGLIB --
             Copyright 12.12.2021 by Sergey Bochkanov
        *************************************************************************/
        private static bool iscpdfunction(int functype,
            int aterm,
            alglib.xparams _params)
        {
            bool result = new bool();

            alglib.ap.assert((aterm==1 || aterm==2) || aterm==3, "RBFV3: integrity check 3563 failed");
            result = false;
            if( functype==1 )
            {
                result = aterm==2 || aterm==1;
                return result;
            }
            if( functype==2 )
            {
                result = aterm==1;
                return result;
            }
            alglib.ap.assert(false, "IsCPDFunction: unexpected FuncType");
            return result;
        }


    }
    public class spline2d
    {
        /*************************************************************************
        2-dimensional spline inteprolant
        *************************************************************************/
        public class spline2dinterpolant : apobject
        {
            public int stype;
            public int n;
            public int m;
            public int d;
            public double[] x;
            public double[] y;
            public double[] f;
            public spline2dinterpolant()
            {
                init();
            }
            public override void init()
            {
                x = new double[0];
                y = new double[0];
                f = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                spline2dinterpolant _result = new spline2dinterpolant();
                _result.stype = stype;
                _result.n = n;
                _result.m = m;
                _result.d = d;
                _result.x = (double[])x.Clone();
                _result.y = (double[])y.Clone();
                _result.f = (double[])f.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Nonlinear least squares solver used to fit 2D splines to data
        *************************************************************************/
        public class spline2dbuilder : apobject
        {
            public int priorterm;
            public double priortermval;
            public int areatype;
            public double xa;
            public double xb;
            public double ya;
            public double yb;
            public int gridtype;
            public int kx;
            public int ky;
            public double smoothing;
            public int nlayers;
            public int solvertype;
            public double lambdabase;
            public double[] xy;
            public int npoints;
            public int d;
            public double sx;
            public double sy;
            public bool adddegreeoffreedom;
            public int interfacesize;
            public int lsqrcnt;
            public int maxcoresize;
            public spline2dbuilder()
            {
                init();
            }
            public override void init()
            {
                xy = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                spline2dbuilder _result = new spline2dbuilder();
                _result.priorterm = priorterm;
                _result.priortermval = priortermval;
                _result.areatype = areatype;
                _result.xa = xa;
                _result.xb = xb;
                _result.ya = ya;
                _result.yb = yb;
                _result.gridtype = gridtype;
                _result.kx = kx;
                _result.ky = ky;
                _result.smoothing = smoothing;
                _result.nlayers = nlayers;
                _result.solvertype = solvertype;
                _result.lambdabase = lambdabase;
                _result.xy = (double[])xy.Clone();
                _result.npoints = npoints;
                _result.d = d;
                _result.sx = sx;
                _result.sy = sy;
                _result.adddegreeoffreedom = adddegreeoffreedom;
                _result.interfacesize = interfacesize;
                _result.lsqrcnt = lsqrcnt;
                _result.maxcoresize = maxcoresize;
                return _result;
            }
        };


        /*************************************************************************
        Spline 2D fitting report:
            rmserror        RMS error
            avgerror        average error
            maxerror        maximum error
            r2              coefficient of determination,  R-squared, 1-RSS/TSS
        *************************************************************************/
        public class spline2dfitreport : apobject
        {
            public double rmserror;
            public double avgerror;
            public double maxerror;
            public double r2;
            public spline2dfitreport()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                spline2dfitreport _result = new spline2dfitreport();
                _result.rmserror = rmserror;
                _result.avgerror = avgerror;
                _result.maxerror = maxerror;
                _result.r2 = r2;
                return _result;
            }
        };


        /*************************************************************************
        Design matrix stored in batch/block sparse format.

        The idea is that design matrix for bicubic spline fitting has very regular
        structure:

        1. I-th row has non-zero entries in elements with indexes starting
        from some IDX, and including: IDX, IDX+1, IDX+2, IDX+3, IDX+KX+0, IDX+KX+1,
        and so on, up to 16 elements in total.

        Rows corresponding to dataset points have 16 non-zero elements, rows
        corresponding to nonlinearity penalty have 9 non-zero elements, and rows
        of regularizer have 1 element.

        For the sake of simplicity, we can use 16 elements for dataset rows and
        penalty rows, and process regularizer explicitly.

        2. points located in the same cell of the grid have same pattern of non-zeros,
        so we can use dense Level 2 and Level 3 linear algebra to work with such
        matrices.
        *************************************************************************/
        public class spline2dxdesignmatrix : apobject
        {
            public int blockwidth;
            public int kx;
            public int ky;
            public int npoints;
            public int nrows;
            public int ndenserows;
            public int ndensebatches;
            public int d;
            public int maxbatch;
            public double[,] vals;
            public int[] batches;
            public int[] batchbases;
            public double lambdareg;
            public double[] tmp0;
            public double[] tmp1;
            public double[,] tmp2;
            public spline2dxdesignmatrix()
            {
                init();
            }
            public override void init()
            {
                vals = new double[0,0];
                batches = new int[0];
                batchbases = new int[0];
                tmp0 = new double[0];
                tmp1 = new double[0];
                tmp2 = new double[0,0];
            }
            public override alglib.apobject make_copy()
            {
                spline2dxdesignmatrix _result = new spline2dxdesignmatrix();
                _result.blockwidth = blockwidth;
                _result.kx = kx;
                _result.ky = ky;
                _result.npoints = npoints;
                _result.nrows = nrows;
                _result.ndenserows = ndenserows;
                _result.ndensebatches = ndensebatches;
                _result.d = d;
                _result.maxbatch = maxbatch;
                _result.vals = (double[,])vals.Clone();
                _result.batches = (int[])batches.Clone();
                _result.batchbases = (int[])batchbases.Clone();
                _result.lambdareg = lambdareg;
                _result.tmp0 = (double[])tmp0.Clone();
                _result.tmp1 = (double[])tmp1.Clone();
                _result.tmp2 = (double[,])tmp2.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Temporaries for BlockLLS solver
        *************************************************************************/
        public class spline2dblockllsbuf : apobject
        {
            public linlsqr.linlsqrstate solver;
            public linlsqr.linlsqrreport solverrep;
            public double[,] blockata;
            public double[,] trsmbuf2;
            public double[,] cholbuf2;
            public double[] cholbuf1;
            public double[] tmp0;
            public double[] tmp1;
            public spline2dblockllsbuf()
            {
                init();
            }
            public override void init()
            {
                solver = new linlsqr.linlsqrstate();
                solverrep = new linlsqr.linlsqrreport();
                blockata = new double[0,0];
                trsmbuf2 = new double[0,0];
                cholbuf2 = new double[0,0];
                cholbuf1 = new double[0];
                tmp0 = new double[0];
                tmp1 = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                spline2dblockllsbuf _result = new spline2dblockllsbuf();
                _result.solver = (linlsqr.linlsqrstate)solver.make_copy();
                _result.solverrep = (linlsqr.linlsqrreport)solverrep.make_copy();
                _result.blockata = (double[,])blockata.Clone();
                _result.trsmbuf2 = (double[,])trsmbuf2.Clone();
                _result.cholbuf2 = (double[,])cholbuf2.Clone();
                _result.cholbuf1 = (double[])cholbuf1.Clone();
                _result.tmp0 = (double[])tmp0.Clone();
                _result.tmp1 = (double[])tmp1.Clone();
                return _result;
            }
        };


        /*************************************************************************
        Temporaries for FastDDM solver
        *************************************************************************/
        public class spline2dfastddmbuf : apobject
        {
            public spline2dxdesignmatrix xdesignmatrix;
            public double[] tmp0;
            public double[] tmpz;
            public spline2dfitreport dummyrep;
            public spline2dinterpolant localmodel;
            public spline2dblockllsbuf blockllsbuf;
            public spline2dfastddmbuf()
            {
                init();
            }
            public override void init()
            {
                xdesignmatrix = new spline2dxdesignmatrix();
                tmp0 = new double[0];
                tmpz = new double[0];
                dummyrep = new spline2dfitreport();
                localmodel = new spline2dinterpolant();
                blockllsbuf = new spline2dblockllsbuf();
            }
            public override alglib.apobject make_copy()
            {
                spline2dfastddmbuf _result = new spline2dfastddmbuf();
                _result.xdesignmatrix = (spline2dxdesignmatrix)xdesignmatrix.make_copy();
                _result.tmp0 = (double[])tmp0.Clone();
                _result.tmpz = (double[])tmpz.Clone();
                _result.dummyrep = (spline2dfitreport)dummyrep.make_copy();
                _result.localmodel = (spline2dinterpolant)localmodel.make_copy();
                _result.blockllsbuf = (spline2dblockllsbuf)blockllsbuf.make_copy();
                return _result;
            }
        };




        public const double cholreg = 1.0E-12;
        public const double lambdaregblocklls = 1.0E-6;
        public const double lambdaregfastddm = 1.0E-4;
        public const double lambdadecay = 0.5;


        /*************************************************************************
        This subroutine calculates the value of the bilinear or bicubic spline  at
        the given point X.

        Input parameters:
            C   -   2D spline object.
                    Built by spline2dbuildbilinearv or spline2dbuildbicubicv.
            X, Y-   point

        Result:
            S(x,y)

          -- ALGLIB PROJECT --
             Copyright 05.07.2007 by Bochkanov Sergey
        *************************************************************************/
        public static double spline2dcalc(spline2dinterpolant c,
            double x,
            double y,
            alglib.xparams _params)
        {
            double result = 0;
            int ix = 0;
            int iy = 0;
            int l = 0;
            int r = 0;
            int h = 0;
            double t = 0;
            double dt = 0;
            double u = 0;
            double du = 0;
            double y1 = 0;
            double y2 = 0;
            double y3 = 0;
            double y4 = 0;
            int s1 = 0;
            int s2 = 0;
            int s3 = 0;
            int s4 = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double t2 = 0;
            double t3 = 0;
            double u2 = 0;
            double u3 = 0;
            double ht00 = 0;
            double ht01 = 0;
            double ht10 = 0;
            double ht11 = 0;
            double hu00 = 0;
            double hu01 = 0;
            double hu10 = 0;
            double hu11 = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline2DCalc: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert(math.isfinite(x) && math.isfinite(y), "Spline2DCalc: X or Y contains NaN or Infinite value");
            if( c.d!=1 )
            {
                result = 0;
                return result;
            }
            
            //
            // Determine evaluation interval
            //
            l = 0;
            r = c.n-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.x[h])>=(double)(x) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            dt = 1.0/(c.x[l+1]-c.x[l]);
            t = (x-c.x[l])*dt;
            ix = l;
            l = 0;
            r = c.m-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.y[h])>=(double)(y) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            du = 1.0/(c.y[l+1]-c.y[l]);
            u = (y-c.y[l])*du;
            iy = l;
            
            //
            // Bilinear interpolation
            //
            if( c.stype==-1 )
            {
                y1 = c.f[c.n*iy+ix];
                y2 = c.f[c.n*iy+(ix+1)];
                y3 = c.f[c.n*(iy+1)+(ix+1)];
                y4 = c.f[c.n*(iy+1)+ix];
                result = (1-t)*(1-u)*y1+t*(1-u)*y2+t*u*y3+(1-t)*u*y4;
                return result;
            }
            
            //
            // Bicubic interpolation:
            // * calculate Hermite basis for dimensions X and Y (variables T and U),
            //   here HTij means basis function whose I-th derivative has value 1 at T=J.
            //   Same for HUij.
            // * after initial calculation, apply scaling by DT/DU to the basis
            // * calculate using stored table of second derivatives
            //
            alglib.ap.assert(c.stype==-3, "Spline2DCalc: integrity check failed");
            sfx = c.n*c.m;
            sfy = 2*c.n*c.m;
            sfxy = 3*c.n*c.m;
            s1 = c.n*iy+ix;
            s2 = c.n*iy+(ix+1);
            s3 = c.n*(iy+1)+ix;
            s4 = c.n*(iy+1)+(ix+1);
            t2 = t*t;
            t3 = t*t2;
            u2 = u*u;
            u3 = u*u2;
            ht00 = 2*t3-3*t2+1;
            ht10 = t3-2*t2+t;
            ht01 = -(2*t3)+3*t2;
            ht11 = t3-t2;
            hu00 = 2*u3-3*u2+1;
            hu10 = u3-2*u2+u;
            hu01 = -(2*u3)+3*u2;
            hu11 = u3-u2;
            ht10 = ht10/dt;
            ht11 = ht11/dt;
            hu10 = hu10/du;
            hu11 = hu11/du;
            result = 0;
            result = result+c.f[s1]*ht00*hu00+c.f[s2]*ht01*hu00+c.f[s3]*ht00*hu01+c.f[s4]*ht01*hu01;
            result = result+c.f[sfx+s1]*ht10*hu00+c.f[sfx+s2]*ht11*hu00+c.f[sfx+s3]*ht10*hu01+c.f[sfx+s4]*ht11*hu01;
            result = result+c.f[sfy+s1]*ht00*hu10+c.f[sfy+s2]*ht01*hu10+c.f[sfy+s3]*ht00*hu11+c.f[sfy+s4]*ht01*hu11;
            result = result+c.f[sfxy+s1]*ht10*hu10+c.f[sfxy+s2]*ht11*hu10+c.f[sfxy+s3]*ht10*hu11+c.f[sfxy+s4]*ht11*hu11;
            return result;
        }


        /*************************************************************************
        This subroutine calculates the value of the bilinear or bicubic spline  at
        the given point X and its derivatives.

        Input parameters:
            C   -   spline interpolant.
            X, Y-   point

        Output parameters:
            F   -   S(x,y)
            FX  -   dS(x,y)/dX
            FY  -   dS(x,y)/dY
            FXY -   d2S(x,y)/dXdY

          -- ALGLIB PROJECT --
             Copyright 05.07.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2ddiff(spline2dinterpolant c,
            double x,
            double y,
            ref double f,
            ref double fx,
            ref double fy,
            ref double fxy,
            alglib.xparams _params)
        {
            double t = 0;
            double dt = 0;
            double u = 0;
            double du = 0;
            int ix = 0;
            int iy = 0;
            int l = 0;
            int r = 0;
            int h = 0;
            int s1 = 0;
            int s2 = 0;
            int s3 = 0;
            int s4 = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double y1 = 0;
            double y2 = 0;
            double y3 = 0;
            double y4 = 0;
            double v0 = 0;
            double v1 = 0;
            double v2 = 0;
            double v3 = 0;
            double t2 = 0;
            double t3 = 0;
            double u2 = 0;
            double u3 = 0;
            double ht00 = 0;
            double ht01 = 0;
            double ht10 = 0;
            double ht11 = 0;
            double hu00 = 0;
            double hu01 = 0;
            double hu10 = 0;
            double hu11 = 0;
            double dht00 = 0;
            double dht01 = 0;
            double dht10 = 0;
            double dht11 = 0;
            double dhu00 = 0;
            double dhu01 = 0;
            double dhu10 = 0;
            double dhu11 = 0;

            f = 0;
            fx = 0;
            fy = 0;
            fxy = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline2DDiff: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert(math.isfinite(x) && math.isfinite(y), "Spline2DDiff: X or Y contains NaN or Infinite value");
            
            //
            // Prepare F, dF/dX, dF/dY, d2F/dXdY
            //
            f = 0;
            fx = 0;
            fy = 0;
            fxy = 0;
            if( c.d!=1 )
            {
                return;
            }
            
            //
            // Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
            //
            l = 0;
            r = c.n-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.x[h])>=(double)(x) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            t = (x-c.x[l])/(c.x[l+1]-c.x[l]);
            dt = 1.0/(c.x[l+1]-c.x[l]);
            ix = l;
            
            //
            // Binary search in the [ y[0], ..., y[m-2] ] (y[m-1] is not included)
            //
            l = 0;
            r = c.m-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.y[h])>=(double)(y) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            u = (y-c.y[l])/(c.y[l+1]-c.y[l]);
            du = 1.0/(c.y[l+1]-c.y[l]);
            iy = l;
            
            //
            // Bilinear interpolation
            //
            if( c.stype==-1 )
            {
                y1 = c.f[c.n*iy+ix];
                y2 = c.f[c.n*iy+(ix+1)];
                y3 = c.f[c.n*(iy+1)+(ix+1)];
                y4 = c.f[c.n*(iy+1)+ix];
                f = (1-t)*(1-u)*y1+t*(1-u)*y2+t*u*y3+(1-t)*u*y4;
                fx = (-((1-u)*y1)+(1-u)*y2+u*y3-u*y4)*dt;
                fy = (-((1-t)*y1)-t*y2+t*y3+(1-t)*y4)*du;
                fxy = (y1-y2+y3-y4)*du*dt;
                return;
            }
            
            //
            // Bicubic interpolation
            //
            if( c.stype==-3 )
            {
                sfx = c.n*c.m;
                sfy = 2*c.n*c.m;
                sfxy = 3*c.n*c.m;
                s1 = c.n*iy+ix;
                s2 = c.n*iy+(ix+1);
                s3 = c.n*(iy+1)+ix;
                s4 = c.n*(iy+1)+(ix+1);
                t2 = t*t;
                t3 = t*t2;
                u2 = u*u;
                u3 = u*u2;
                ht00 = 2*t3-3*t2+1;
                ht10 = t3-2*t2+t;
                ht01 = -(2*t3)+3*t2;
                ht11 = t3-t2;
                hu00 = 2*u3-3*u2+1;
                hu10 = u3-2*u2+u;
                hu01 = -(2*u3)+3*u2;
                hu11 = u3-u2;
                ht10 = ht10/dt;
                ht11 = ht11/dt;
                hu10 = hu10/du;
                hu11 = hu11/du;
                dht00 = 6*t2-6*t;
                dht10 = 3*t2-4*t+1;
                dht01 = -(6*t2)+6*t;
                dht11 = 3*t2-2*t;
                dhu00 = 6*u2-6*u;
                dhu10 = 3*u2-4*u+1;
                dhu01 = -(6*u2)+6*u;
                dhu11 = 3*u2-2*u;
                dht00 = dht00*dt;
                dht01 = dht01*dt;
                dhu00 = dhu00*du;
                dhu01 = dhu01*du;
                f = 0;
                fx = 0;
                fy = 0;
                fxy = 0;
                v0 = c.f[s1];
                v1 = c.f[s2];
                v2 = c.f[s3];
                v3 = c.f[s4];
                f = f+v0*ht00*hu00+v1*ht01*hu00+v2*ht00*hu01+v3*ht01*hu01;
                fx = fx+v0*dht00*hu00+v1*dht01*hu00+v2*dht00*hu01+v3*dht01*hu01;
                fy = fy+v0*ht00*dhu00+v1*ht01*dhu00+v2*ht00*dhu01+v3*ht01*dhu01;
                fxy = fxy+v0*dht00*dhu00+v1*dht01*dhu00+v2*dht00*dhu01+v3*dht01*dhu01;
                v0 = c.f[sfx+s1];
                v1 = c.f[sfx+s2];
                v2 = c.f[sfx+s3];
                v3 = c.f[sfx+s4];
                f = f+v0*ht10*hu00+v1*ht11*hu00+v2*ht10*hu01+v3*ht11*hu01;
                fx = fx+v0*dht10*hu00+v1*dht11*hu00+v2*dht10*hu01+v3*dht11*hu01;
                fy = fy+v0*ht10*dhu00+v1*ht11*dhu00+v2*ht10*dhu01+v3*ht11*dhu01;
                fxy = fxy+v0*dht10*dhu00+v1*dht11*dhu00+v2*dht10*dhu01+v3*dht11*dhu01;
                v0 = c.f[sfy+s1];
                v1 = c.f[sfy+s2];
                v2 = c.f[sfy+s3];
                v3 = c.f[sfy+s4];
                f = f+v0*ht00*hu10+v1*ht01*hu10+v2*ht00*hu11+v3*ht01*hu11;
                fx = fx+v0*dht00*hu10+v1*dht01*hu10+v2*dht00*hu11+v3*dht01*hu11;
                fy = fy+v0*ht00*dhu10+v1*ht01*dhu10+v2*ht00*dhu11+v3*ht01*dhu11;
                fxy = fxy+v0*dht00*dhu10+v1*dht01*dhu10+v2*dht00*dhu11+v3*dht01*dhu11;
                v0 = c.f[sfxy+s1];
                v1 = c.f[sfxy+s2];
                v2 = c.f[sfxy+s3];
                v3 = c.f[sfxy+s4];
                f = f+v0*ht10*hu10+v1*ht11*hu10+v2*ht10*hu11+v3*ht11*hu11;
                fx = fx+v0*dht10*hu10+v1*dht11*hu10+v2*dht10*hu11+v3*dht11*hu11;
                fy = fy+v0*ht10*dhu10+v1*ht11*dhu10+v2*ht10*dhu11+v3*ht11*dhu11;
                fxy = fxy+v0*dht10*dhu10+v1*dht11*dhu10+v2*dht10*dhu11+v3*dht11*dhu11;
                return;
            }
        }


        /*************************************************************************
        This subroutine calculates bilinear or bicubic vector-valued spline at the
        given point (X,Y).

        If you need just some specific component of vector-valued spline, you  can
        use spline2dcalcvi() function.

        INPUT PARAMETERS:
            C   -   spline interpolant.
            X, Y-   point
            F   -   output buffer, possibly preallocated array. In case array size
                    is large enough to store result, it is not reallocated.  Array
                    which is too short will be reallocated

        OUTPUT PARAMETERS:
            F   -   array[D] (or larger) which stores function values

          -- ALGLIB PROJECT --
             Copyright 01.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dcalcvbuf(spline2dinterpolant c,
            double x,
            double y,
            ref double[] f,
            alglib.xparams _params)
        {
            int ix = 0;
            int iy = 0;
            int l = 0;
            int r = 0;
            int h = 0;
            int i = 0;
            double t = 0;
            double dt = 0;
            double u = 0;
            double du = 0;
            double y1 = 0;
            double y2 = 0;
            double y3 = 0;
            double y4 = 0;
            int s1 = 0;
            int s2 = 0;
            int s3 = 0;
            int s4 = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double t2 = 0;
            double t3 = 0;
            double u2 = 0;
            double u3 = 0;
            double ht00 = 0;
            double ht01 = 0;
            double ht10 = 0;
            double ht11 = 0;
            double hu00 = 0;
            double hu01 = 0;
            double hu10 = 0;
            double hu11 = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline2DCalcVBuf: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert(math.isfinite(x) && math.isfinite(y), "Spline2DCalcVBuf: X or Y contains NaN or Infinite value");
            
            //
            // Allocate place for output
            //
            apserv.rvectorsetlengthatleast(ref f, c.d, _params);
            
            //
            // Determine evaluation interval
            //
            l = 0;
            r = c.n-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.x[h])>=(double)(x) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            dt = 1.0/(c.x[l+1]-c.x[l]);
            t = (x-c.x[l])*dt;
            ix = l;
            l = 0;
            r = c.m-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.y[h])>=(double)(y) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            du = 1.0/(c.y[l+1]-c.y[l]);
            u = (y-c.y[l])*du;
            iy = l;
            
            //
            // Bilinear interpolation
            //
            if( c.stype==-1 )
            {
                for(i=0; i<=c.d-1; i++)
                {
                    y1 = c.f[c.d*(c.n*iy+ix)+i];
                    y2 = c.f[c.d*(c.n*iy+(ix+1))+i];
                    y3 = c.f[c.d*(c.n*(iy+1)+(ix+1))+i];
                    y4 = c.f[c.d*(c.n*(iy+1)+ix)+i];
                    f[i] = (1-t)*(1-u)*y1+t*(1-u)*y2+t*u*y3+(1-t)*u*y4;
                }
                return;
            }
            
            //
            // Bicubic interpolation:
            // * calculate Hermite basis for dimensions X and Y (variables T and U),
            //   here HTij means basis function whose I-th derivative has value 1 at T=J.
            //   Same for HUij.
            // * after initial calculation, apply scaling by DT/DU to the basis
            // * calculate using stored table of second derivatives
            //
            alglib.ap.assert(c.stype==-3, "Spline2DCalc: integrity check failed");
            sfx = c.n*c.m*c.d;
            sfy = 2*c.n*c.m*c.d;
            sfxy = 3*c.n*c.m*c.d;
            s1 = (c.n*iy+ix)*c.d;
            s2 = (c.n*iy+(ix+1))*c.d;
            s3 = (c.n*(iy+1)+ix)*c.d;
            s4 = (c.n*(iy+1)+(ix+1))*c.d;
            t2 = t*t;
            t3 = t*t2;
            u2 = u*u;
            u3 = u*u2;
            ht00 = 2*t3-3*t2+1;
            ht10 = t3-2*t2+t;
            ht01 = -(2*t3)+3*t2;
            ht11 = t3-t2;
            hu00 = 2*u3-3*u2+1;
            hu10 = u3-2*u2+u;
            hu01 = -(2*u3)+3*u2;
            hu11 = u3-u2;
            ht10 = ht10/dt;
            ht11 = ht11/dt;
            hu10 = hu10/du;
            hu11 = hu11/du;
            for(i=0; i<=c.d-1; i++)
            {
                
                //
                // Calculate I-th component
                //
                f[i] = 0;
                f[i] = f[i]+c.f[s1]*ht00*hu00+c.f[s2]*ht01*hu00+c.f[s3]*ht00*hu01+c.f[s4]*ht01*hu01;
                f[i] = f[i]+c.f[sfx+s1]*ht10*hu00+c.f[sfx+s2]*ht11*hu00+c.f[sfx+s3]*ht10*hu01+c.f[sfx+s4]*ht11*hu01;
                f[i] = f[i]+c.f[sfy+s1]*ht00*hu10+c.f[sfy+s2]*ht01*hu10+c.f[sfy+s3]*ht00*hu11+c.f[sfy+s4]*ht01*hu11;
                f[i] = f[i]+c.f[sfxy+s1]*ht10*hu10+c.f[sfxy+s2]*ht11*hu10+c.f[sfxy+s3]*ht10*hu11+c.f[sfxy+s4]*ht11*hu11;
                
                //
                // Advance source indexes
                //
                s1 = s1+1;
                s2 = s2+1;
                s3 = s3+1;
                s4 = s4+1;
            }
        }


        /*************************************************************************
        This subroutine calculates specific component of vector-valued bilinear or
        bicubic spline at the given point (X,Y).

        INPUT PARAMETERS:
            C   -   spline interpolant.
            X, Y-   point
            I   -   component index, in [0,D). An exception is generated for out
                    of range values.

        RESULT:
            value of I-th component

          -- ALGLIB PROJECT --
             Copyright 01.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static double spline2dcalcvi(spline2dinterpolant c,
            double x,
            double y,
            int i,
            alglib.xparams _params)
        {
            double result = 0;
            int ix = 0;
            int iy = 0;
            int l = 0;
            int r = 0;
            int h = 0;
            double t = 0;
            double dt = 0;
            double u = 0;
            double du = 0;
            double y1 = 0;
            double y2 = 0;
            double y3 = 0;
            double y4 = 0;
            int s1 = 0;
            int s2 = 0;
            int s3 = 0;
            int s4 = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double t2 = 0;
            double t3 = 0;
            double u2 = 0;
            double u3 = 0;
            double ht00 = 0;
            double ht01 = 0;
            double ht10 = 0;
            double ht11 = 0;
            double hu00 = 0;
            double hu01 = 0;
            double hu10 = 0;
            double hu11 = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline2DCalcVi: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert(math.isfinite(x) && math.isfinite(y), "Spline2DCalcVi: X or Y contains NaN or Infinite value");
            alglib.ap.assert(i>=0 && i<c.d, "Spline2DCalcVi: incorrect I (I<0 or I>=D)");
            
            //
            // Determine evaluation interval
            //
            l = 0;
            r = c.n-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.x[h])>=(double)(x) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            dt = 1.0/(c.x[l+1]-c.x[l]);
            t = (x-c.x[l])*dt;
            ix = l;
            l = 0;
            r = c.m-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.y[h])>=(double)(y) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            du = 1.0/(c.y[l+1]-c.y[l]);
            u = (y-c.y[l])*du;
            iy = l;
            
            //
            // Bilinear interpolation
            //
            if( c.stype==-1 )
            {
                y1 = c.f[c.d*(c.n*iy+ix)+i];
                y2 = c.f[c.d*(c.n*iy+(ix+1))+i];
                y3 = c.f[c.d*(c.n*(iy+1)+(ix+1))+i];
                y4 = c.f[c.d*(c.n*(iy+1)+ix)+i];
                result = (1-t)*(1-u)*y1+t*(1-u)*y2+t*u*y3+(1-t)*u*y4;
                return result;
            }
            
            //
            // Bicubic interpolation:
            // * calculate Hermite basis for dimensions X and Y (variables T and U),
            //   here HTij means basis function whose I-th derivative has value 1 at T=J.
            //   Same for HUij.
            // * after initial calculation, apply scaling by DT/DU to the basis
            // * calculate using stored table of second derivatives
            //
            alglib.ap.assert(c.stype==-3, "Spline2DCalc: integrity check failed");
            sfx = c.n*c.m*c.d;
            sfy = 2*c.n*c.m*c.d;
            sfxy = 3*c.n*c.m*c.d;
            s1 = (c.n*iy+ix)*c.d;
            s2 = (c.n*iy+(ix+1))*c.d;
            s3 = (c.n*(iy+1)+ix)*c.d;
            s4 = (c.n*(iy+1)+(ix+1))*c.d;
            t2 = t*t;
            t3 = t*t2;
            u2 = u*u;
            u3 = u*u2;
            ht00 = 2*t3-3*t2+1;
            ht10 = t3-2*t2+t;
            ht01 = -(2*t3)+3*t2;
            ht11 = t3-t2;
            hu00 = 2*u3-3*u2+1;
            hu10 = u3-2*u2+u;
            hu01 = -(2*u3)+3*u2;
            hu11 = u3-u2;
            ht10 = ht10/dt;
            ht11 = ht11/dt;
            hu10 = hu10/du;
            hu11 = hu11/du;
            
            //
            // Advance source indexes to I-th position
            //
            s1 = s1+i;
            s2 = s2+i;
            s3 = s3+i;
            s4 = s4+i;
            
            //
            // Calculate I-th component
            //
            result = 0;
            result = result+c.f[s1]*ht00*hu00+c.f[s2]*ht01*hu00+c.f[s3]*ht00*hu01+c.f[s4]*ht01*hu01;
            result = result+c.f[sfx+s1]*ht10*hu00+c.f[sfx+s2]*ht11*hu00+c.f[sfx+s3]*ht10*hu01+c.f[sfx+s4]*ht11*hu01;
            result = result+c.f[sfy+s1]*ht00*hu10+c.f[sfy+s2]*ht01*hu10+c.f[sfy+s3]*ht00*hu11+c.f[sfy+s4]*ht01*hu11;
            result = result+c.f[sfxy+s1]*ht10*hu10+c.f[sfxy+s2]*ht11*hu10+c.f[sfxy+s3]*ht10*hu11+c.f[sfxy+s4]*ht11*hu11;
            return result;
        }


        /*************************************************************************
        This subroutine calculates bilinear or bicubic vector-valued spline at the
        given point (X,Y).

        INPUT PARAMETERS:
            C   -   spline interpolant.
            X, Y-   point

        OUTPUT PARAMETERS:
            F   -   array[D] which stores function values.  F is out-parameter and
                    it  is  reallocated  after  call to this function. In case you
                    want  to    reuse  previously  allocated  F,   you   may   use
                    Spline2DCalcVBuf(),  which  reallocates  F only when it is too
                    small.

          -- ALGLIB PROJECT --
             Copyright 16.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dcalcv(spline2dinterpolant c,
            double x,
            double y,
            ref double[] f,
            alglib.xparams _params)
        {
            f = new double[0];

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline2DCalcV: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert(math.isfinite(x) && math.isfinite(y), "Spline2DCalcV: either X=NaN/Infinite or Y=NaN/Infinite");
            spline2dcalcvbuf(c, x, y, ref f, _params);
        }


        /*************************************************************************
        This subroutine calculates value of  specific  component  of  bilinear  or
        bicubic vector-valued spline and its derivatives.

        Input parameters:
            C   -   spline interpolant.
            X, Y-   point
            I   -   component index, in [0,D)

        Output parameters:
            F   -   S(x,y)
            FX  -   dS(x,y)/dX
            FY  -   dS(x,y)/dY
            FXY -   d2S(x,y)/dXdY

          -- ALGLIB PROJECT --
             Copyright 05.07.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2ddiffvi(spline2dinterpolant c,
            double x,
            double y,
            int i,
            ref double f,
            ref double fx,
            ref double fy,
            ref double fxy,
            alglib.xparams _params)
        {
            int d = 0;
            double t = 0;
            double dt = 0;
            double u = 0;
            double du = 0;
            int ix = 0;
            int iy = 0;
            int l = 0;
            int r = 0;
            int h = 0;
            int s1 = 0;
            int s2 = 0;
            int s3 = 0;
            int s4 = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double y1 = 0;
            double y2 = 0;
            double y3 = 0;
            double y4 = 0;
            double v0 = 0;
            double v1 = 0;
            double v2 = 0;
            double v3 = 0;
            double t2 = 0;
            double t3 = 0;
            double u2 = 0;
            double u3 = 0;
            double ht00 = 0;
            double ht01 = 0;
            double ht10 = 0;
            double ht11 = 0;
            double hu00 = 0;
            double hu01 = 0;
            double hu10 = 0;
            double hu11 = 0;
            double dht00 = 0;
            double dht01 = 0;
            double dht10 = 0;
            double dht11 = 0;
            double dhu00 = 0;
            double dhu01 = 0;
            double dhu10 = 0;
            double dhu11 = 0;

            f = 0;
            fx = 0;
            fy = 0;
            fxy = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline2DDiffVI: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert(math.isfinite(x) && math.isfinite(y), "Spline2DDiffVI: X or Y contains NaN or Infinite value");
            alglib.ap.assert(i>=0 && i<c.d, "Spline2DDiffVI: I<0 or I>=D");
            
            //
            // Prepare F, dF/dX, dF/dY, d2F/dXdY
            //
            f = 0;
            fx = 0;
            fy = 0;
            fxy = 0;
            d = c.d;
            
            //
            // Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
            //
            l = 0;
            r = c.n-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.x[h])>=(double)(x) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            t = (x-c.x[l])/(c.x[l+1]-c.x[l]);
            dt = 1.0/(c.x[l+1]-c.x[l]);
            ix = l;
            
            //
            // Binary search in the [ y[0], ..., y[m-2] ] (y[m-1] is not included)
            //
            l = 0;
            r = c.m-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.y[h])>=(double)(y) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            u = (y-c.y[l])/(c.y[l+1]-c.y[l]);
            du = 1.0/(c.y[l+1]-c.y[l]);
            iy = l;
            
            //
            // Bilinear interpolation
            //
            if( c.stype==-1 )
            {
                y1 = c.f[d*(c.n*iy+ix)+i];
                y2 = c.f[d*(c.n*iy+(ix+1))+i];
                y3 = c.f[d*(c.n*(iy+1)+(ix+1))+i];
                y4 = c.f[d*(c.n*(iy+1)+ix)+i];
                f = (1-t)*(1-u)*y1+t*(1-u)*y2+t*u*y3+(1-t)*u*y4;
                fx = (-((1-u)*y1)+(1-u)*y2+u*y3-u*y4)*dt;
                fy = (-((1-t)*y1)-t*y2+t*y3+(1-t)*y4)*du;
                fxy = (y1-y2+y3-y4)*du*dt;
                return;
            }
            
            //
            // Bicubic interpolation
            //
            if( c.stype==-3 )
            {
                sfx = c.n*c.m*d;
                sfy = 2*c.n*c.m*d;
                sfxy = 3*c.n*c.m*d;
                s1 = d*(c.n*iy+ix)+i;
                s2 = d*(c.n*iy+(ix+1))+i;
                s3 = d*(c.n*(iy+1)+ix)+i;
                s4 = d*(c.n*(iy+1)+(ix+1))+i;
                t2 = t*t;
                t3 = t*t2;
                u2 = u*u;
                u3 = u*u2;
                ht00 = 2*t3-3*t2+1;
                ht10 = t3-2*t2+t;
                ht01 = -(2*t3)+3*t2;
                ht11 = t3-t2;
                hu00 = 2*u3-3*u2+1;
                hu10 = u3-2*u2+u;
                hu01 = -(2*u3)+3*u2;
                hu11 = u3-u2;
                ht10 = ht10/dt;
                ht11 = ht11/dt;
                hu10 = hu10/du;
                hu11 = hu11/du;
                dht00 = 6*t2-6*t;
                dht10 = 3*t2-4*t+1;
                dht01 = -(6*t2)+6*t;
                dht11 = 3*t2-2*t;
                dhu00 = 6*u2-6*u;
                dhu10 = 3*u2-4*u+1;
                dhu01 = -(6*u2)+6*u;
                dhu11 = 3*u2-2*u;
                dht00 = dht00*dt;
                dht01 = dht01*dt;
                dhu00 = dhu00*du;
                dhu01 = dhu01*du;
                f = 0;
                fx = 0;
                fy = 0;
                fxy = 0;
                v0 = c.f[s1];
                v1 = c.f[s2];
                v2 = c.f[s3];
                v3 = c.f[s4];
                f = f+v0*ht00*hu00+v1*ht01*hu00+v2*ht00*hu01+v3*ht01*hu01;
                fx = fx+v0*dht00*hu00+v1*dht01*hu00+v2*dht00*hu01+v3*dht01*hu01;
                fy = fy+v0*ht00*dhu00+v1*ht01*dhu00+v2*ht00*dhu01+v3*ht01*dhu01;
                fxy = fxy+v0*dht00*dhu00+v1*dht01*dhu00+v2*dht00*dhu01+v3*dht01*dhu01;
                v0 = c.f[sfx+s1];
                v1 = c.f[sfx+s2];
                v2 = c.f[sfx+s3];
                v3 = c.f[sfx+s4];
                f = f+v0*ht10*hu00+v1*ht11*hu00+v2*ht10*hu01+v3*ht11*hu01;
                fx = fx+v0*dht10*hu00+v1*dht11*hu00+v2*dht10*hu01+v3*dht11*hu01;
                fy = fy+v0*ht10*dhu00+v1*ht11*dhu00+v2*ht10*dhu01+v3*ht11*dhu01;
                fxy = fxy+v0*dht10*dhu00+v1*dht11*dhu00+v2*dht10*dhu01+v3*dht11*dhu01;
                v0 = c.f[sfy+s1];
                v1 = c.f[sfy+s2];
                v2 = c.f[sfy+s3];
                v3 = c.f[sfy+s4];
                f = f+v0*ht00*hu10+v1*ht01*hu10+v2*ht00*hu11+v3*ht01*hu11;
                fx = fx+v0*dht00*hu10+v1*dht01*hu10+v2*dht00*hu11+v3*dht01*hu11;
                fy = fy+v0*ht00*dhu10+v1*ht01*dhu10+v2*ht00*dhu11+v3*ht01*dhu11;
                fxy = fxy+v0*dht00*dhu10+v1*dht01*dhu10+v2*dht00*dhu11+v3*dht01*dhu11;
                v0 = c.f[sfxy+s1];
                v1 = c.f[sfxy+s2];
                v2 = c.f[sfxy+s3];
                v3 = c.f[sfxy+s4];
                f = f+v0*ht10*hu10+v1*ht11*hu10+v2*ht10*hu11+v3*ht11*hu11;
                fx = fx+v0*dht10*hu10+v1*dht11*hu10+v2*dht10*hu11+v3*dht11*hu11;
                fy = fy+v0*ht10*dhu10+v1*ht11*dhu10+v2*ht10*dhu11+v3*ht11*dhu11;
                fxy = fxy+v0*dht10*dhu10+v1*dht11*dhu10+v2*dht10*dhu11+v3*dht11*dhu11;
                return;
            }
        }


        /*************************************************************************
        This subroutine performs linear transformation of the spline argument.

        Input parameters:
            C       -   spline interpolant
            AX, BX  -   transformation coefficients: x = A*t + B
            AY, BY  -   transformation coefficients: y = A*u + B
        Result:
            C   -   transformed spline

          -- ALGLIB PROJECT --
             Copyright 30.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dlintransxy(spline2dinterpolant c,
            double ax,
            double bx,
            double ay,
            double by,
            alglib.xparams _params)
        {
            double[] x = new double[0];
            double[] y = new double[0];
            double[] f = new double[0];
            double[] v = new double[0];
            int i = 0;
            int j = 0;
            int k = 0;

            alglib.ap.assert(c.stype==-3 || c.stype==-1, "Spline2DLinTransXY: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert(math.isfinite(ax), "Spline2DLinTransXY: AX is infinite or NaN");
            alglib.ap.assert(math.isfinite(bx), "Spline2DLinTransXY: BX is infinite or NaN");
            alglib.ap.assert(math.isfinite(ay), "Spline2DLinTransXY: AY is infinite or NaN");
            alglib.ap.assert(math.isfinite(by), "Spline2DLinTransXY: BY is infinite or NaN");
            x = new double[c.n];
            y = new double[c.m];
            f = new double[c.m*c.n*c.d];
            for(j=0; j<=c.n-1; j++)
            {
                x[j] = c.x[j];
            }
            for(i=0; i<=c.m-1; i++)
            {
                y[i] = c.y[i];
            }
            for(i=0; i<=c.m-1; i++)
            {
                for(j=0; j<=c.n-1; j++)
                {
                    for(k=0; k<=c.d-1; k++)
                    {
                        f[c.d*(i*c.n+j)+k] = c.f[c.d*(i*c.n+j)+k];
                    }
                }
            }
            
            //
            // Handle different combinations of AX/AY
            //
            if( (double)(ax)==(double)(0) && (double)(ay)!=(double)(0) )
            {
                for(i=0; i<=c.m-1; i++)
                {
                    spline2dcalcvbuf(c, bx, y[i], ref v, _params);
                    y[i] = (y[i]-by)/ay;
                    for(j=0; j<=c.n-1; j++)
                    {
                        for(k=0; k<=c.d-1; k++)
                        {
                            f[c.d*(i*c.n+j)+k] = v[k];
                        }
                    }
                }
            }
            if( (double)(ax)!=(double)(0) && (double)(ay)==(double)(0) )
            {
                for(j=0; j<=c.n-1; j++)
                {
                    spline2dcalcvbuf(c, x[j], by, ref v, _params);
                    x[j] = (x[j]-bx)/ax;
                    for(i=0; i<=c.m-1; i++)
                    {
                        for(k=0; k<=c.d-1; k++)
                        {
                            f[c.d*(i*c.n+j)+k] = v[k];
                        }
                    }
                }
            }
            if( (double)(ax)!=(double)(0) && (double)(ay)!=(double)(0) )
            {
                for(j=0; j<=c.n-1; j++)
                {
                    x[j] = (x[j]-bx)/ax;
                }
                for(i=0; i<=c.m-1; i++)
                {
                    y[i] = (y[i]-by)/ay;
                }
            }
            if( (double)(ax)==(double)(0) && (double)(ay)==(double)(0) )
            {
                spline2dcalcvbuf(c, bx, by, ref v, _params);
                for(i=0; i<=c.m-1; i++)
                {
                    for(j=0; j<=c.n-1; j++)
                    {
                        for(k=0; k<=c.d-1; k++)
                        {
                            f[c.d*(i*c.n+j)+k] = v[k];
                        }
                    }
                }
            }
            
            //
            // Rebuild spline
            //
            if( c.stype==-3 )
            {
                spline2dbuildbicubicv(x, c.n, y, c.m, f, c.d, c, _params);
            }
            if( c.stype==-1 )
            {
                spline2dbuildbilinearv(x, c.n, y, c.m, f, c.d, c, _params);
            }
        }


        /*************************************************************************
        This subroutine performs linear transformation of the spline.

        Input parameters:
            C   -   spline interpolant.
            A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B
            
        Output parameters:
            C   -   transformed spline

          -- ALGLIB PROJECT --
             Copyright 30.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dlintransf(spline2dinterpolant c,
            double a,
            double b,
            alglib.xparams _params)
        {
            double[] x = new double[0];
            double[] y = new double[0];
            double[] f = new double[0];
            int i = 0;
            int j = 0;

            alglib.ap.assert(c.stype==-3 || c.stype==-1, "Spline2DLinTransF: incorrect C (incorrect parameter C.SType)");
            x = new double[c.n];
            y = new double[c.m];
            f = new double[c.m*c.n*c.d];
            for(j=0; j<=c.n-1; j++)
            {
                x[j] = c.x[j];
            }
            for(i=0; i<=c.m-1; i++)
            {
                y[i] = c.y[i];
            }
            for(i=0; i<=c.m*c.n*c.d-1; i++)
            {
                f[i] = a*c.f[i]+b;
            }
            if( c.stype==-3 )
            {
                spline2dbuildbicubicv(x, c.n, y, c.m, f, c.d, c, _params);
            }
            if( c.stype==-1 )
            {
                spline2dbuildbilinearv(x, c.n, y, c.m, f, c.d, c, _params);
            }
        }


        /*************************************************************************
        This subroutine makes the copy of the spline model.

        Input parameters:
            C   -   spline interpolant

        Output parameters:
            CC  -   spline copy

          -- ALGLIB PROJECT --
             Copyright 29.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dcopy(spline2dinterpolant c,
            spline2dinterpolant cc,
            alglib.xparams _params)
        {
            int tblsize = 0;
            int i_ = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline2DCopy: incorrect C (incorrect parameter C.SType)");
            cc.n = c.n;
            cc.m = c.m;
            cc.d = c.d;
            cc.stype = c.stype;
            tblsize = -1;
            if( c.stype==-3 )
            {
                tblsize = 4*c.n*c.m*c.d;
            }
            if( c.stype==-1 )
            {
                tblsize = c.n*c.m*c.d;
            }
            alglib.ap.assert(tblsize>0, "Spline2DCopy: internal error");
            cc.x = new double[cc.n];
            cc.y = new double[cc.m];
            cc.f = new double[tblsize];
            for(i_=0; i_<=cc.n-1;i_++)
            {
                cc.x[i_] = c.x[i_];
            }
            for(i_=0; i_<=cc.m-1;i_++)
            {
                cc.y[i_] = c.y[i_];
            }
            for(i_=0; i_<=tblsize-1;i_++)
            {
                cc.f[i_] = c.f[i_];
            }
        }


        /*************************************************************************
        Bicubic spline resampling

        Input parameters:
            A           -   function values at the old grid,
                            array[0..OldHeight-1, 0..OldWidth-1]
            OldHeight   -   old grid height, OldHeight>1
            OldWidth    -   old grid width, OldWidth>1
            NewHeight   -   new grid height, NewHeight>1
            NewWidth    -   new grid width, NewWidth>1
            
        Output parameters:
            B           -   function values at the new grid,
                            array[0..NewHeight-1, 0..NewWidth-1]

          -- ALGLIB routine --
             15 May, 2007
             Copyright by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dresamplebicubic(double[,] a,
            int oldheight,
            int oldwidth,
            ref double[,] b,
            int newheight,
            int newwidth,
            alglib.xparams _params)
        {
            double[,] buf = new double[0,0];
            double[] x = new double[0];
            double[] y = new double[0];
            spline1d.spline1dinterpolant c = new spline1d.spline1dinterpolant();
            int mw = 0;
            int mh = 0;
            int i = 0;
            int j = 0;

            b = new double[0,0];

            alglib.ap.assert(oldwidth>1 && oldheight>1, "Spline2DResampleBicubic: width/height less than 1");
            alglib.ap.assert(newwidth>1 && newheight>1, "Spline2DResampleBicubic: width/height less than 1");
            
            //
            // Prepare
            //
            mw = Math.Max(oldwidth, newwidth);
            mh = Math.Max(oldheight, newheight);
            b = new double[newheight, newwidth];
            buf = new double[oldheight, newwidth];
            x = new double[Math.Max(mw, mh)];
            y = new double[Math.Max(mw, mh)];
            
            //
            // Horizontal interpolation
            //
            for(i=0; i<=oldheight-1; i++)
            {
                
                //
                // Fill X, Y
                //
                for(j=0; j<=oldwidth-1; j++)
                {
                    x[j] = (double)j/(double)(oldwidth-1);
                    y[j] = a[i,j];
                }
                
                //
                // Interpolate and place result into temporary matrix
                //
                spline1d.spline1dbuildcubic(x, y, oldwidth, 0, 0.0, 0, 0.0, c, _params);
                for(j=0; j<=newwidth-1; j++)
                {
                    buf[i,j] = spline1d.spline1dcalc(c, (double)j/(double)(newwidth-1), _params);
                }
            }
            
            //
            // Vertical interpolation
            //
            for(j=0; j<=newwidth-1; j++)
            {
                
                //
                // Fill X, Y
                //
                for(i=0; i<=oldheight-1; i++)
                {
                    x[i] = (double)i/(double)(oldheight-1);
                    y[i] = buf[i,j];
                }
                
                //
                // Interpolate and place result into B
                //
                spline1d.spline1dbuildcubic(x, y, oldheight, 0, 0.0, 0, 0.0, c, _params);
                for(i=0; i<=newheight-1; i++)
                {
                    b[i,j] = spline1d.spline1dcalc(c, (double)i/(double)(newheight-1), _params);
                }
            }
        }


        /*************************************************************************
        Bilinear spline resampling

        Input parameters:
            A           -   function values at the old grid,
                            array[0..OldHeight-1, 0..OldWidth-1]
            OldHeight   -   old grid height, OldHeight>1
            OldWidth    -   old grid width, OldWidth>1
            NewHeight   -   new grid height, NewHeight>1
            NewWidth    -   new grid width, NewWidth>1

        Output parameters:
            B           -   function values at the new grid,
                            array[0..NewHeight-1, 0..NewWidth-1]

          -- ALGLIB routine --
             09.07.2007
             Copyright by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dresamplebilinear(double[,] a,
            int oldheight,
            int oldwidth,
            ref double[,] b,
            int newheight,
            int newwidth,
            alglib.xparams _params)
        {
            int l = 0;
            int c = 0;
            double t = 0;
            double u = 0;
            int i = 0;
            int j = 0;

            b = new double[0,0];

            alglib.ap.assert(oldwidth>1 && oldheight>1, "Spline2DResampleBilinear: width/height less than 1");
            alglib.ap.assert(newwidth>1 && newheight>1, "Spline2DResampleBilinear: width/height less than 1");
            b = new double[newheight, newwidth];
            for(i=0; i<=newheight-1; i++)
            {
                for(j=0; j<=newwidth-1; j++)
                {
                    l = i*(oldheight-1)/(newheight-1);
                    if( l==oldheight-1 )
                    {
                        l = oldheight-2;
                    }
                    u = (double)i/(double)(newheight-1)*(oldheight-1)-l;
                    c = j*(oldwidth-1)/(newwidth-1);
                    if( c==oldwidth-1 )
                    {
                        c = oldwidth-2;
                    }
                    t = (double)(j*(oldwidth-1))/(double)(newwidth-1)-c;
                    b[i,j] = (1-t)*(1-u)*a[l,c]+t*(1-u)*a[l,c+1]+t*u*a[l+1,c+1]+(1-t)*u*a[l+1,c];
                }
            }
        }


        /*************************************************************************
        This subroutine builds bilinear vector-valued spline.

        Input parameters:
            X   -   spline abscissas, array[0..N-1]
            Y   -   spline ordinates, array[0..M-1]
            F   -   function values, array[0..M*N*D-1]:
                    * first D elements store D values at (X[0],Y[0])
                    * next D elements store D values at (X[1],Y[0])
                    * general form - D function values at (X[i],Y[j]) are stored
                      at F[D*(J*N+I)...D*(J*N+I)+D-1].
            M,N -   grid size, M>=2, N>=2
            D   -   vector dimension, D>=1

        Output parameters:
            C   -   spline interpolant

          -- ALGLIB PROJECT --
             Copyright 16.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildbilinearv(double[] x,
            int n,
            double[] y,
            int m,
            double[] f,
            int d,
            spline2dinterpolant c,
            alglib.xparams _params)
        {
            double t = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int i0 = 0;

            alglib.ap.assert(n>=2, "Spline2DBuildBilinearV: N is less then 2");
            alglib.ap.assert(m>=2, "Spline2DBuildBilinearV: M is less then 2");
            alglib.ap.assert(d>=1, "Spline2DBuildBilinearV: invalid argument D (D<1)");
            alglib.ap.assert(alglib.ap.len(x)>=n && alglib.ap.len(y)>=m, "Spline2DBuildBilinearV: length of X or Y is too short (Length(X/Y)<N/M)");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params) && apserv.isfinitevector(y, m, _params), "Spline2DBuildBilinearV: X or Y contains NaN or Infinite value");
            k = n*m*d;
            alglib.ap.assert(alglib.ap.len(f)>=k, "Spline2DBuildBilinearV: length of F is too short (Length(F)<N*M*D)");
            alglib.ap.assert(apserv.isfinitevector(f, k, _params), "Spline2DBuildBilinearV: F contains NaN or Infinite value");
            
            //
            // Fill interpolant
            //
            c.n = n;
            c.m = m;
            c.d = d;
            c.stype = -1;
            c.x = new double[c.n];
            c.y = new double[c.m];
            c.f = new double[k];
            for(i=0; i<=c.n-1; i++)
            {
                c.x[i] = x[i];
            }
            for(i=0; i<=c.m-1; i++)
            {
                c.y[i] = y[i];
            }
            for(i=0; i<=k-1; i++)
            {
                c.f[i] = f[i];
            }
            
            //
            // Sort points
            //
            for(j=0; j<=c.n-1; j++)
            {
                k = j;
                for(i=j+1; i<=c.n-1; i++)
                {
                    if( (double)(c.x[i])<(double)(c.x[k]) )
                    {
                        k = i;
                    }
                }
                if( k!=j )
                {
                    for(i=0; i<=c.m-1; i++)
                    {
                        for(i0=0; i0<=c.d-1; i0++)
                        {
                            t = c.f[c.d*(i*c.n+j)+i0];
                            c.f[c.d*(i*c.n+j)+i0] = c.f[c.d*(i*c.n+k)+i0];
                            c.f[c.d*(i*c.n+k)+i0] = t;
                        }
                    }
                    t = c.x[j];
                    c.x[j] = c.x[k];
                    c.x[k] = t;
                }
            }
            for(i=0; i<=c.m-1; i++)
            {
                k = i;
                for(j=i+1; j<=c.m-1; j++)
                {
                    if( (double)(c.y[j])<(double)(c.y[k]) )
                    {
                        k = j;
                    }
                }
                if( k!=i )
                {
                    for(j=0; j<=c.n-1; j++)
                    {
                        for(i0=0; i0<=c.d-1; i0++)
                        {
                            t = c.f[c.d*(i*c.n+j)+i0];
                            c.f[c.d*(i*c.n+j)+i0] = c.f[c.d*(k*c.n+j)+i0];
                            c.f[c.d*(k*c.n+j)+i0] = t;
                        }
                    }
                    t = c.y[i];
                    c.y[i] = c.y[k];
                    c.y[k] = t;
                }
            }
        }


        /*************************************************************************
        This subroutine builds bicubic vector-valued spline.

        Input parameters:
            X   -   spline abscissas, array[0..N-1]
            Y   -   spline ordinates, array[0..M-1]
            F   -   function values, array[0..M*N*D-1]:
                    * first D elements store D values at (X[0],Y[0])
                    * next D elements store D values at (X[1],Y[0])
                    * general form - D function values at (X[i],Y[j]) are stored
                      at F[D*(J*N+I)...D*(J*N+I)+D-1].
            M,N -   grid size, M>=2, N>=2
            D   -   vector dimension, D>=1

        Output parameters:
            C   -   spline interpolant

          -- ALGLIB PROJECT --
             Copyright 16.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildbicubicv(double[] x,
            int n,
            double[] y,
            int m,
            double[] f,
            int d,
            spline2dinterpolant c,
            alglib.xparams _params)
        {
            double[,] tf = new double[0,0];
            double[,] dx = new double[0,0];
            double[,] dy = new double[0,0];
            double[,] dxy = new double[0,0];
            double t = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int di = 0;

            f = (double[])f.Clone();

            alglib.ap.assert(n>=2, "Spline2DBuildBicubicV: N is less than 2");
            alglib.ap.assert(m>=2, "Spline2DBuildBicubicV: M is less than 2");
            alglib.ap.assert(d>=1, "Spline2DBuildBicubicV: invalid argument D (D<1)");
            alglib.ap.assert(alglib.ap.len(x)>=n && alglib.ap.len(y)>=m, "Spline2DBuildBicubicV: length of X or Y is too short (Length(X/Y)<N/M)");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params) && apserv.isfinitevector(y, m, _params), "Spline2DBuildBicubicV: X or Y contains NaN or Infinite value");
            k = n*m*d;
            alglib.ap.assert(alglib.ap.len(f)>=k, "Spline2DBuildBicubicV: length of F is too short (Length(F)<N*M*D)");
            alglib.ap.assert(apserv.isfinitevector(f, k, _params), "Spline2DBuildBicubicV: F contains NaN or Infinite value");
            
            //
            // Fill interpolant:
            //  F[0]...F[N*M*D-1]:
            //      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
            //  F[N*M*D]...F[2*N*M*D-1]:
            //      df(i,j)/dx table.
            //  F[2*N*M*D]...F[3*N*M*D-1]:
            //      df(i,j)/dy table.
            //  F[3*N*M*D]...F[4*N*M*D-1]:
            //      d2f(i,j)/dxdy table.
            //
            c.d = d;
            c.n = n;
            c.m = m;
            c.stype = -3;
            k = 4*k;
            c.x = new double[c.n];
            c.y = new double[c.m];
            c.f = new double[k];
            tf = new double[c.m, c.n];
            for(i=0; i<=c.n-1; i++)
            {
                c.x[i] = x[i];
            }
            for(i=0; i<=c.m-1; i++)
            {
                c.y[i] = y[i];
            }
            
            //
            // Sort points
            //
            for(j=0; j<=c.n-1; j++)
            {
                k = j;
                for(i=j+1; i<=c.n-1; i++)
                {
                    if( (double)(c.x[i])<(double)(c.x[k]) )
                    {
                        k = i;
                    }
                }
                if( k!=j )
                {
                    for(i=0; i<=c.m-1; i++)
                    {
                        for(di=0; di<=c.d-1; di++)
                        {
                            t = f[c.d*(i*c.n+j)+di];
                            f[c.d*(i*c.n+j)+di] = f[c.d*(i*c.n+k)+di];
                            f[c.d*(i*c.n+k)+di] = t;
                        }
                    }
                    t = c.x[j];
                    c.x[j] = c.x[k];
                    c.x[k] = t;
                }
            }
            for(i=0; i<=c.m-1; i++)
            {
                k = i;
                for(j=i+1; j<=c.m-1; j++)
                {
                    if( (double)(c.y[j])<(double)(c.y[k]) )
                    {
                        k = j;
                    }
                }
                if( k!=i )
                {
                    for(j=0; j<=c.n-1; j++)
                    {
                        for(di=0; di<=c.d-1; di++)
                        {
                            t = f[c.d*(i*c.n+j)+di];
                            f[c.d*(i*c.n+j)+di] = f[c.d*(k*c.n+j)+di];
                            f[c.d*(k*c.n+j)+di] = t;
                        }
                    }
                    t = c.y[i];
                    c.y[i] = c.y[k];
                    c.y[k] = t;
                }
            }
            for(di=0; di<=c.d-1; di++)
            {
                for(i=0; i<=c.m-1; i++)
                {
                    for(j=0; j<=c.n-1; j++)
                    {
                        tf[i,j] = f[c.d*(i*c.n+j)+di];
                    }
                }
                bicubiccalcderivatives(tf, c.x, c.y, c.m, c.n, ref dx, ref dy, ref dxy, _params);
                for(i=0; i<=c.m-1; i++)
                {
                    for(j=0; j<=c.n-1; j++)
                    {
                        k = c.d*(i*c.n+j)+di;
                        c.f[k] = tf[i,j];
                        c.f[c.n*c.m*c.d+k] = dx[i,j];
                        c.f[2*c.n*c.m*c.d+k] = dy[i,j];
                        c.f[3*c.n*c.m*c.d+k] = dxy[i,j];
                    }
                }
            }
        }


        /*************************************************************************
        This subroutine unpacks two-dimensional spline into the coefficients table

        Input parameters:
            C   -   spline interpolant.

        Result:
            M, N-   grid size (x-axis and y-axis)
            D   -   number of components
            Tbl -   coefficients table, unpacked format,
                    D - components: [0..(N-1)*(M-1)*D-1, 0..19].
                    For T=0..D-1 (component index), I = 0...N-2 (x index),
                    J=0..M-2 (y index):
                        K :=  T + I*D + J*D*(N-1)
                        
                        K-th row stores decomposition for T-th component of the
                        vector-valued function
                        
                        Tbl[K,0] = X[i]
                        Tbl[K,1] = X[i+1]
                        Tbl[K,2] = Y[j]
                        Tbl[K,3] = Y[j+1]
                        Tbl[K,4] = C00
                        Tbl[K,5] = C01
                        Tbl[K,6] = C02
                        Tbl[K,7] = C03
                        Tbl[K,8] = C10
                        Tbl[K,9] = C11
                        ...
                        Tbl[K,19] = C33
                    On each grid square spline is equals to:
                        S(x) = SUM(c[i,j]*(t^i)*(u^j), i=0..3, j=0..3)
                        t = x-x[j]
                        u = y-y[i]

          -- ALGLIB PROJECT --
             Copyright 16.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dunpackv(spline2dinterpolant c,
            ref int m,
            ref int n,
            ref int d,
            ref double[,] tbl,
            alglib.xparams _params)
        {
            int k = 0;
            int p = 0;
            int ci = 0;
            int cj = 0;
            int s1 = 0;
            int s2 = 0;
            int s3 = 0;
            int s4 = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double y1 = 0;
            double y2 = 0;
            double y3 = 0;
            double y4 = 0;
            double dt = 0;
            double du = 0;
            int i = 0;
            int j = 0;
            int k0 = 0;

            m = 0;
            n = 0;
            d = 0;
            tbl = new double[0,0];

            alglib.ap.assert(c.stype==-3 || c.stype==-1, "Spline2DUnpackV: incorrect C (incorrect parameter C.SType)");
            n = c.n;
            m = c.m;
            d = c.d;
            tbl = new double[(n-1)*(m-1)*d, 20];
            sfx = n*m*d;
            sfy = 2*n*m*d;
            sfxy = 3*n*m*d;
            for(i=0; i<=m-2; i++)
            {
                for(j=0; j<=n-2; j++)
                {
                    for(k=0; k<=d-1; k++)
                    {
                        p = d*(i*(n-1)+j)+k;
                        tbl[p,0] = c.x[j];
                        tbl[p,1] = c.x[j+1];
                        tbl[p,2] = c.y[i];
                        tbl[p,3] = c.y[i+1];
                        dt = 1/(tbl[p,1]-tbl[p,0]);
                        du = 1/(tbl[p,3]-tbl[p,2]);
                        
                        //
                        // Bilinear interpolation
                        //
                        if( c.stype==-1 )
                        {
                            for(k0=4; k0<=19; k0++)
                            {
                                tbl[p,k0] = 0;
                            }
                            y1 = c.f[d*(n*i+j)+k];
                            y2 = c.f[d*(n*i+(j+1))+k];
                            y3 = c.f[d*(n*(i+1)+(j+1))+k];
                            y4 = c.f[d*(n*(i+1)+j)+k];
                            tbl[p,4] = y1;
                            tbl[p,4+1*4+0] = y2-y1;
                            tbl[p,4+0*4+1] = y4-y1;
                            tbl[p,4+1*4+1] = y3-y2-y4+y1;
                        }
                        
                        //
                        // Bicubic interpolation
                        //
                        if( c.stype==-3 )
                        {
                            s1 = d*(n*i+j)+k;
                            s2 = d*(n*i+(j+1))+k;
                            s3 = d*(n*(i+1)+(j+1))+k;
                            s4 = d*(n*(i+1)+j)+k;
                            tbl[p,4+0*4+0] = c.f[s1];
                            tbl[p,4+0*4+1] = c.f[sfy+s1]/du;
                            tbl[p,4+0*4+2] = -(3*c.f[s1])+3*c.f[s4]-2*c.f[sfy+s1]/du-c.f[sfy+s4]/du;
                            tbl[p,4+0*4+3] = 2*c.f[s1]-2*c.f[s4]+c.f[sfy+s1]/du+c.f[sfy+s4]/du;
                            tbl[p,4+1*4+0] = c.f[sfx+s1]/dt;
                            tbl[p,4+1*4+1] = c.f[sfxy+s1]/(dt*du);
                            tbl[p,4+1*4+2] = -(3*c.f[sfx+s1]/dt)+3*c.f[sfx+s4]/dt-2*c.f[sfxy+s1]/(dt*du)-c.f[sfxy+s4]/(dt*du);
                            tbl[p,4+1*4+3] = 2*c.f[sfx+s1]/dt-2*c.f[sfx+s4]/dt+c.f[sfxy+s1]/(dt*du)+c.f[sfxy+s4]/(dt*du);
                            tbl[p,4+2*4+0] = -(3*c.f[s1])+3*c.f[s2]-2*c.f[sfx+s1]/dt-c.f[sfx+s2]/dt;
                            tbl[p,4+2*4+1] = -(3*c.f[sfy+s1]/du)+3*c.f[sfy+s2]/du-2*c.f[sfxy+s1]/(dt*du)-c.f[sfxy+s2]/(dt*du);
                            tbl[p,4+2*4+2] = 9*c.f[s1]-9*c.f[s2]+9*c.f[s3]-9*c.f[s4]+6*c.f[sfx+s1]/dt+3*c.f[sfx+s2]/dt-3*c.f[sfx+s3]/dt-6*c.f[sfx+s4]/dt+6*c.f[sfy+s1]/du-6*c.f[sfy+s2]/du-3*c.f[sfy+s3]/du+3*c.f[sfy+s4]/du+4*c.f[sfxy+s1]/(dt*du)+2*c.f[sfxy+s2]/(dt*du)+c.f[sfxy+s3]/(dt*du)+2*c.f[sfxy+s4]/(dt*du);
                            tbl[p,4+2*4+3] = -(6*c.f[s1])+6*c.f[s2]-6*c.f[s3]+6*c.f[s4]-4*c.f[sfx+s1]/dt-2*c.f[sfx+s2]/dt+2*c.f[sfx+s3]/dt+4*c.f[sfx+s4]/dt-3*c.f[sfy+s1]/du+3*c.f[sfy+s2]/du+3*c.f[sfy+s3]/du-3*c.f[sfy+s4]/du-2*c.f[sfxy+s1]/(dt*du)-c.f[sfxy+s2]/(dt*du)-c.f[sfxy+s3]/(dt*du)-2*c.f[sfxy+s4]/(dt*du);
                            tbl[p,4+3*4+0] = 2*c.f[s1]-2*c.f[s2]+c.f[sfx+s1]/dt+c.f[sfx+s2]/dt;
                            tbl[p,4+3*4+1] = 2*c.f[sfy+s1]/du-2*c.f[sfy+s2]/du+c.f[sfxy+s1]/(dt*du)+c.f[sfxy+s2]/(dt*du);
                            tbl[p,4+3*4+2] = -(6*c.f[s1])+6*c.f[s2]-6*c.f[s3]+6*c.f[s4]-3*c.f[sfx+s1]/dt-3*c.f[sfx+s2]/dt+3*c.f[sfx+s3]/dt+3*c.f[sfx+s4]/dt-4*c.f[sfy+s1]/du+4*c.f[sfy+s2]/du+2*c.f[sfy+s3]/du-2*c.f[sfy+s4]/du-2*c.f[sfxy+s1]/(dt*du)-2*c.f[sfxy+s2]/(dt*du)-c.f[sfxy+s3]/(dt*du)-c.f[sfxy+s4]/(dt*du);
                            tbl[p,4+3*4+3] = 4*c.f[s1]-4*c.f[s2]+4*c.f[s3]-4*c.f[s4]+2*c.f[sfx+s1]/dt+2*c.f[sfx+s2]/dt-2*c.f[sfx+s3]/dt-2*c.f[sfx+s4]/dt+2*c.f[sfy+s1]/du-2*c.f[sfy+s2]/du-2*c.f[sfy+s3]/du+2*c.f[sfy+s4]/du+c.f[sfxy+s1]/(dt*du)+c.f[sfxy+s2]/(dt*du)+c.f[sfxy+s3]/(dt*du)+c.f[sfxy+s4]/(dt*du);
                        }
                        
                        //
                        // Rescale Cij
                        //
                        for(ci=0; ci<=3; ci++)
                        {
                            for(cj=0; cj<=3; cj++)
                            {
                                tbl[p,4+ci*4+cj] = tbl[p,4+ci*4+cj]*Math.Pow(dt, ci)*Math.Pow(du, cj);
                            }
                        }
                    }
                }
            }
        }


        /*************************************************************************
        This subroutine was deprecated in ALGLIB 3.6.0

        We recommend you to switch  to  Spline2DBuildBilinearV(),  which  is  more
        flexible and accepts its arguments in more convenient order.

          -- ALGLIB PROJECT --
             Copyright 05.07.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildbilinear(double[] x,
            double[] y,
            double[,] f,
            int m,
            int n,
            spline2dinterpolant c,
            alglib.xparams _params)
        {
            double t = 0;
            int i = 0;
            int j = 0;
            int k = 0;

            alglib.ap.assert(n>=2, "Spline2DBuildBilinear: N<2");
            alglib.ap.assert(m>=2, "Spline2DBuildBilinear: M<2");
            alglib.ap.assert(alglib.ap.len(x)>=n && alglib.ap.len(y)>=m, "Spline2DBuildBilinear: length of X or Y is too short (Length(X/Y)<N/M)");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params) && apserv.isfinitevector(y, m, _params), "Spline2DBuildBilinear: X or Y contains NaN or Infinite value");
            alglib.ap.assert(alglib.ap.rows(f)>=m && alglib.ap.cols(f)>=n, "Spline2DBuildBilinear: size of F is too small (rows(F)<M or cols(F)<N)");
            alglib.ap.assert(apserv.apservisfinitematrix(f, m, n, _params), "Spline2DBuildBilinear: F contains NaN or Infinite value");
            
            //
            // Fill interpolant
            //
            c.n = n;
            c.m = m;
            c.d = 1;
            c.stype = -1;
            c.x = new double[c.n];
            c.y = new double[c.m];
            c.f = new double[c.n*c.m];
            for(i=0; i<=c.n-1; i++)
            {
                c.x[i] = x[i];
            }
            for(i=0; i<=c.m-1; i++)
            {
                c.y[i] = y[i];
            }
            for(i=0; i<=c.m-1; i++)
            {
                for(j=0; j<=c.n-1; j++)
                {
                    c.f[i*c.n+j] = f[i,j];
                }
            }
            
            //
            // Sort points
            //
            for(j=0; j<=c.n-1; j++)
            {
                k = j;
                for(i=j+1; i<=c.n-1; i++)
                {
                    if( (double)(c.x[i])<(double)(c.x[k]) )
                    {
                        k = i;
                    }
                }
                if( k!=j )
                {
                    for(i=0; i<=c.m-1; i++)
                    {
                        t = c.f[i*c.n+j];
                        c.f[i*c.n+j] = c.f[i*c.n+k];
                        c.f[i*c.n+k] = t;
                    }
                    t = c.x[j];
                    c.x[j] = c.x[k];
                    c.x[k] = t;
                }
            }
            for(i=0; i<=c.m-1; i++)
            {
                k = i;
                for(j=i+1; j<=c.m-1; j++)
                {
                    if( (double)(c.y[j])<(double)(c.y[k]) )
                    {
                        k = j;
                    }
                }
                if( k!=i )
                {
                    for(j=0; j<=c.n-1; j++)
                    {
                        t = c.f[i*c.n+j];
                        c.f[i*c.n+j] = c.f[k*c.n+j];
                        c.f[k*c.n+j] = t;
                    }
                    t = c.y[i];
                    c.y[i] = c.y[k];
                    c.y[k] = t;
                }
            }
        }


        /*************************************************************************
        This subroutine was deprecated in ALGLIB 3.6.0

        We recommend you to switch  to  Spline2DBuildBicubicV(),  which  is  more
        flexible and accepts its arguments in more convenient order.

          -- ALGLIB PROJECT --
             Copyright 05.07.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildbicubic(double[] x,
            double[] y,
            double[,] f,
            int m,
            int n,
            spline2dinterpolant c,
            alglib.xparams _params)
        {
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double[,] dx = new double[0,0];
            double[,] dy = new double[0,0];
            double[,] dxy = new double[0,0];
            double t = 0;
            int i = 0;
            int j = 0;
            int k = 0;

            f = (double[,])f.Clone();

            alglib.ap.assert(n>=2, "Spline2DBuildBicubicSpline: N<2");
            alglib.ap.assert(m>=2, "Spline2DBuildBicubicSpline: M<2");
            alglib.ap.assert(alglib.ap.len(x)>=n && alglib.ap.len(y)>=m, "Spline2DBuildBicubic: length of X or Y is too short (Length(X/Y)<N/M)");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params) && apserv.isfinitevector(y, m, _params), "Spline2DBuildBicubic: X or Y contains NaN or Infinite value");
            alglib.ap.assert(alglib.ap.rows(f)>=m && alglib.ap.cols(f)>=n, "Spline2DBuildBicubic: size of F is too small (rows(F)<M or cols(F)<N)");
            alglib.ap.assert(apserv.apservisfinitematrix(f, m, n, _params), "Spline2DBuildBicubic: F contains NaN or Infinite value");
            
            //
            // Fill interpolant:
            //  F[0]...F[N*M-1]:
            //      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
            //  F[N*M]...F[2*N*M-1]:
            //      df(i,j)/dx table.
            //  F[2*N*M]...F[3*N*M-1]:
            //      df(i,j)/dy table.
            //  F[3*N*M]...F[4*N*M-1]:
            //      d2f(i,j)/dxdy table.
            //
            c.d = 1;
            c.n = n;
            c.m = m;
            c.stype = -3;
            sfx = c.n*c.m;
            sfy = 2*c.n*c.m;
            sfxy = 3*c.n*c.m;
            c.x = new double[c.n];
            c.y = new double[c.m];
            c.f = new double[4*c.n*c.m];
            for(i=0; i<=c.n-1; i++)
            {
                c.x[i] = x[i];
            }
            for(i=0; i<=c.m-1; i++)
            {
                c.y[i] = y[i];
            }
            
            //
            // Sort points
            //
            for(j=0; j<=c.n-1; j++)
            {
                k = j;
                for(i=j+1; i<=c.n-1; i++)
                {
                    if( (double)(c.x[i])<(double)(c.x[k]) )
                    {
                        k = i;
                    }
                }
                if( k!=j )
                {
                    for(i=0; i<=c.m-1; i++)
                    {
                        t = f[i,j];
                        f[i,j] = f[i,k];
                        f[i,k] = t;
                    }
                    t = c.x[j];
                    c.x[j] = c.x[k];
                    c.x[k] = t;
                }
            }
            for(i=0; i<=c.m-1; i++)
            {
                k = i;
                for(j=i+1; j<=c.m-1; j++)
                {
                    if( (double)(c.y[j])<(double)(c.y[k]) )
                    {
                        k = j;
                    }
                }
                if( k!=i )
                {
                    for(j=0; j<=c.n-1; j++)
                    {
                        t = f[i,j];
                        f[i,j] = f[k,j];
                        f[k,j] = t;
                    }
                    t = c.y[i];
                    c.y[i] = c.y[k];
                    c.y[k] = t;
                }
            }
            bicubiccalcderivatives(f, c.x, c.y, c.m, c.n, ref dx, ref dy, ref dxy, _params);
            for(i=0; i<=c.m-1; i++)
            {
                for(j=0; j<=c.n-1; j++)
                {
                    k = i*c.n+j;
                    c.f[k] = f[i,j];
                    c.f[sfx+k] = dx[i,j];
                    c.f[sfy+k] = dy[i,j];
                    c.f[sfxy+k] = dxy[i,j];
                }
            }
        }


        /*************************************************************************
        This subroutine was deprecated in ALGLIB 3.6.0

        We recommend you to switch  to  Spline2DUnpackV(),  which is more flexible
        and accepts its arguments in more convenient order.

          -- ALGLIB PROJECT --
             Copyright 29.06.2007 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dunpack(spline2dinterpolant c,
            ref int m,
            ref int n,
            ref double[,] tbl,
            alglib.xparams _params)
        {
            int k = 0;
            int p = 0;
            int ci = 0;
            int cj = 0;
            int s1 = 0;
            int s2 = 0;
            int s3 = 0;
            int s4 = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double y1 = 0;
            double y2 = 0;
            double y3 = 0;
            double y4 = 0;
            double dt = 0;
            double du = 0;
            int i = 0;
            int j = 0;

            m = 0;
            n = 0;
            tbl = new double[0,0];

            alglib.ap.assert(c.stype==-3 || c.stype==-1, "Spline2DUnpack: incorrect C (incorrect parameter C.SType)");
            if( c.d!=1 )
            {
                n = 0;
                m = 0;
                return;
            }
            n = c.n;
            m = c.m;
            tbl = new double[(n-1)*(m-1), 20];
            sfx = n*m;
            sfy = 2*n*m;
            sfxy = 3*n*m;
            
            //
            // Fill
            //
            for(i=0; i<=m-2; i++)
            {
                for(j=0; j<=n-2; j++)
                {
                    p = i*(n-1)+j;
                    tbl[p,0] = c.x[j];
                    tbl[p,1] = c.x[j+1];
                    tbl[p,2] = c.y[i];
                    tbl[p,3] = c.y[i+1];
                    dt = 1/(tbl[p,1]-tbl[p,0]);
                    du = 1/(tbl[p,3]-tbl[p,2]);
                    
                    //
                    // Bilinear interpolation
                    //
                    if( c.stype==-1 )
                    {
                        for(k=4; k<=19; k++)
                        {
                            tbl[p,k] = 0;
                        }
                        y1 = c.f[n*i+j];
                        y2 = c.f[n*i+(j+1)];
                        y3 = c.f[n*(i+1)+(j+1)];
                        y4 = c.f[n*(i+1)+j];
                        tbl[p,4] = y1;
                        tbl[p,4+1*4+0] = y2-y1;
                        tbl[p,4+0*4+1] = y4-y1;
                        tbl[p,4+1*4+1] = y3-y2-y4+y1;
                    }
                    
                    //
                    // Bicubic interpolation
                    //
                    if( c.stype==-3 )
                    {
                        s1 = n*i+j;
                        s2 = n*i+(j+1);
                        s3 = n*(i+1)+(j+1);
                        s4 = n*(i+1)+j;
                        tbl[p,4+0*4+0] = c.f[s1];
                        tbl[p,4+0*4+1] = c.f[sfy+s1]/du;
                        tbl[p,4+0*4+2] = -(3*c.f[s1])+3*c.f[s4]-2*c.f[sfy+s1]/du-c.f[sfy+s4]/du;
                        tbl[p,4+0*4+3] = 2*c.f[s1]-2*c.f[s4]+c.f[sfy+s1]/du+c.f[sfy+s4]/du;
                        tbl[p,4+1*4+0] = c.f[sfx+s1]/dt;
                        tbl[p,4+1*4+1] = c.f[sfxy+s1]/(dt*du);
                        tbl[p,4+1*4+2] = -(3*c.f[sfx+s1]/dt)+3*c.f[sfx+s4]/dt-2*c.f[sfxy+s1]/(dt*du)-c.f[sfxy+s4]/(dt*du);
                        tbl[p,4+1*4+3] = 2*c.f[sfx+s1]/dt-2*c.f[sfx+s4]/dt+c.f[sfxy+s1]/(dt*du)+c.f[sfxy+s4]/(dt*du);
                        tbl[p,4+2*4+0] = -(3*c.f[s1])+3*c.f[s2]-2*c.f[sfx+s1]/dt-c.f[sfx+s2]/dt;
                        tbl[p,4+2*4+1] = -(3*c.f[sfy+s1]/du)+3*c.f[sfy+s2]/du-2*c.f[sfxy+s1]/(dt*du)-c.f[sfxy+s2]/(dt*du);
                        tbl[p,4+2*4+2] = 9*c.f[s1]-9*c.f[s2]+9*c.f[s3]-9*c.f[s4]+6*c.f[sfx+s1]/dt+3*c.f[sfx+s2]/dt-3*c.f[sfx+s3]/dt-6*c.f[sfx+s4]/dt+6*c.f[sfy+s1]/du-6*c.f[sfy+s2]/du-3*c.f[sfy+s3]/du+3*c.f[sfy+s4]/du+4*c.f[sfxy+s1]/(dt*du)+2*c.f[sfxy+s2]/(dt*du)+c.f[sfxy+s3]/(dt*du)+2*c.f[sfxy+s4]/(dt*du);
                        tbl[p,4+2*4+3] = -(6*c.f[s1])+6*c.f[s2]-6*c.f[s3]+6*c.f[s4]-4*c.f[sfx+s1]/dt-2*c.f[sfx+s2]/dt+2*c.f[sfx+s3]/dt+4*c.f[sfx+s4]/dt-3*c.f[sfy+s1]/du+3*c.f[sfy+s2]/du+3*c.f[sfy+s3]/du-3*c.f[sfy+s4]/du-2*c.f[sfxy+s1]/(dt*du)-c.f[sfxy+s2]/(dt*du)-c.f[sfxy+s3]/(dt*du)-2*c.f[sfxy+s4]/(dt*du);
                        tbl[p,4+3*4+0] = 2*c.f[s1]-2*c.f[s2]+c.f[sfx+s1]/dt+c.f[sfx+s2]/dt;
                        tbl[p,4+3*4+1] = 2*c.f[sfy+s1]/du-2*c.f[sfy+s2]/du+c.f[sfxy+s1]/(dt*du)+c.f[sfxy+s2]/(dt*du);
                        tbl[p,4+3*4+2] = -(6*c.f[s1])+6*c.f[s2]-6*c.f[s3]+6*c.f[s4]-3*c.f[sfx+s1]/dt-3*c.f[sfx+s2]/dt+3*c.f[sfx+s3]/dt+3*c.f[sfx+s4]/dt-4*c.f[sfy+s1]/du+4*c.f[sfy+s2]/du+2*c.f[sfy+s3]/du-2*c.f[sfy+s4]/du-2*c.f[sfxy+s1]/(dt*du)-2*c.f[sfxy+s2]/(dt*du)-c.f[sfxy+s3]/(dt*du)-c.f[sfxy+s4]/(dt*du);
                        tbl[p,4+3*4+3] = 4*c.f[s1]-4*c.f[s2]+4*c.f[s3]-4*c.f[s4]+2*c.f[sfx+s1]/dt+2*c.f[sfx+s2]/dt-2*c.f[sfx+s3]/dt-2*c.f[sfx+s4]/dt+2*c.f[sfy+s1]/du-2*c.f[sfy+s2]/du-2*c.f[sfy+s3]/du+2*c.f[sfy+s4]/du+c.f[sfxy+s1]/(dt*du)+c.f[sfxy+s2]/(dt*du)+c.f[sfxy+s3]/(dt*du)+c.f[sfxy+s4]/(dt*du);
                    }
                    
                    //
                    // Rescale Cij
                    //
                    for(ci=0; ci<=3; ci++)
                    {
                        for(cj=0; cj<=3; cj++)
                        {
                            tbl[p,4+ci*4+cj] = tbl[p,4+ci*4+cj]*Math.Pow(dt, ci)*Math.Pow(du, cj);
                        }
                    }
                }
            }
        }


        /*************************************************************************
        This subroutine creates least squares solver used to  fit  2D  splines  to
        irregularly sampled (scattered) data.

        Solver object is used to perform spline fits as follows:
        * solver object is created with spline2dbuildercreate() function
        * dataset is added with spline2dbuildersetpoints() function
        * fit area is chosen:
          * spline2dbuildersetarea()     - for user-defined area
          * spline2dbuildersetareaauto() - for automatically chosen area
        * number of grid nodes is chosen with spline2dbuildersetgrid()
        * prior term is chosen with one of the following functions:
          * spline2dbuildersetlinterm()   to set linear prior
          * spline2dbuildersetconstterm() to set constant prior
          * spline2dbuildersetzeroterm()  to set zero prior
          * spline2dbuildersetuserterm()  to set user-defined constant prior
        * solver algorithm is chosen with either:
          * spline2dbuildersetalgoblocklls() - BlockLLS algorithm, medium-scale problems
          * spline2dbuildersetalgofastddm()  - FastDDM algorithm, large-scale problems
        * finally, fitting itself is performed with spline2dfit() function.

        Most of the steps above can be omitted,  solver  is  configured with  good
        defaults. The minimum is to call:
        * spline2dbuildercreate() to create solver object
        * spline2dbuildersetpoints() to specify dataset
        * spline2dbuildersetgrid() to tell how many nodes you need
        * spline2dfit() to perform fit

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        INPUT PARAMETERS:
            D   -   positive number, number of Y-components: D=1 for simple scalar
                    fit, D>1 for vector-valued spline fitting.
            
        OUTPUT PARAMETERS:
            S   -   solver object

          -- ALGLIB PROJECT --
             Copyright 29.01.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildercreate(int d,
            spline2dbuilder state,
            alglib.xparams _params)
        {
            alglib.ap.assert(d>=1, "Spline2DBuilderCreate: D<=0");
            
            //
            // NOTES:
            //
            // 1. Prior term is set to linear one (good default option)
            // 2. Solver is set to BlockLLS - good enough for small-scale problems.
            // 3. Refinement rounds: 5; enough to get good convergence.
            //
            state.priorterm = 1;
            state.priortermval = 0;
            state.areatype = 0;
            state.gridtype = 0;
            state.smoothing = 0.0;
            state.nlayers = 0;
            state.solvertype = 1;
            state.npoints = 0;
            state.d = d;
            state.sx = 1.0;
            state.sy = 1.0;
            state.lsqrcnt = 5;
            
            //
            // Algorithm settings
            //
            state.adddegreeoffreedom = true;
            state.maxcoresize = 16;
            state.interfacesize = 5;
        }


        /*************************************************************************
        This function sets constant prior term (model is a sum of  bicubic  spline
        and global prior, which can be linear, constant, user-defined  constant or
        zero).

        Constant prior term is determined by least squares fitting.

        INPUT PARAMETERS:
            S       -   spline builder
            V       -   value for user-defined prior

          -- ALGLIB --
             Copyright 01.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetuserterm(spline2dbuilder state,
            double v,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(v), "Spline2DBuilderSetUserTerm: infinite/NAN value passed");
            state.priorterm = 0;
            state.priortermval = v;
        }


        /*************************************************************************
        This function sets linear prior term (model is a sum of bicubic spline and
        global  prior,  which  can  be  linear, constant, user-defined constant or
        zero).

        Linear prior term is determined by least squares fitting.

        INPUT PARAMETERS:
            S       -   spline builder

          -- ALGLIB --
             Copyright 01.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetlinterm(spline2dbuilder state,
            alglib.xparams _params)
        {
            state.priorterm = 1;
        }


        /*************************************************************************
        This function sets constant prior term (model is a sum of  bicubic  spline
        and global prior, which can be linear, constant, user-defined  constant or
        zero).

        Constant prior term is determined by least squares fitting.

        INPUT PARAMETERS:
            S       -   spline builder

          -- ALGLIB --
             Copyright 01.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetconstterm(spline2dbuilder state,
            alglib.xparams _params)
        {
            state.priorterm = 2;
        }


        /*************************************************************************
        This function sets zero prior term (model is a sum of bicubic  spline  and
        global  prior,  which  can  be  linear, constant, user-defined constant or
        zero).

        INPUT PARAMETERS:
            S       -   spline builder

          -- ALGLIB --
             Copyright 01.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetzeroterm(spline2dbuilder state,
            alglib.xparams _params)
        {
            state.priorterm = 3;
        }


        /*************************************************************************
        This function adds dataset to the builder object.

        This function overrides results of the previous calls, i.e. multiple calls
        of this function will result in only the last set being added.

        INPUT PARAMETERS:
            S       -   spline 2D builder object
            XY      -   points, array[N,2+D]. One  row  corresponds to  one  point
                        in the dataset. First 2  elements  are  coordinates,  next
                        D  elements are function values. Array may  be larger than 
                        specified, in  this  case  only leading [N,NX+NY] elements 
                        will be used.
            N       -   number of points in the dataset

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetpoints(spline2dbuilder state,
            double[,] xy,
            int n,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int ew = 0;

            alglib.ap.assert(n>0, "Spline2DBuilderSetPoints: N<0");
            alglib.ap.assert(alglib.ap.rows(xy)>=n, "Spline2DBuilderSetPoints: Rows(XY)<N");
            alglib.ap.assert(alglib.ap.cols(xy)>=2+state.d, "Spline2DBuilderSetPoints: Cols(XY)<NX+NY");
            alglib.ap.assert(apserv.apservisfinitematrix(xy, n, 2+state.d, _params), "Spline2DBuilderSetPoints: XY contains infinite or NaN values!");
            state.npoints = n;
            ew = 2+state.d;
            apserv.rvectorsetlengthatleast(ref state.xy, n*ew, _params);
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=ew-1; j++)
                {
                    state.xy[i*ew+j] = xy[i,j];
                }
            }
        }


        /*************************************************************************
        This function sets area where 2D spline interpolant is built. "Auto" means
        that area extent is determined automatically from dataset extent.

        INPUT PARAMETERS:
            S       -   spline 2D builder object

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetareaauto(spline2dbuilder state,
            alglib.xparams _params)
        {
            state.areatype = 0;
        }


        /*************************************************************************
        This  function  sets  area  where  2D  spline  interpolant  is   built  to
        user-defined one: [XA,XB]*[YA,YB]

        INPUT PARAMETERS:
            S       -   spline 2D builder object
            XA,XB   -   spatial extent in the first (X) dimension, XA<XB
            YA,YB   -   spatial extent in the second (Y) dimension, YA<YB

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetarea(spline2dbuilder state,
            double xa,
            double xb,
            double ya,
            double yb,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(xa), "Spline2DBuilderSetArea: XA is not finite");
            alglib.ap.assert(math.isfinite(xb), "Spline2DBuilderSetArea: XB is not finite");
            alglib.ap.assert(math.isfinite(ya), "Spline2DBuilderSetArea: YA is not finite");
            alglib.ap.assert(math.isfinite(yb), "Spline2DBuilderSetArea: YB is not finite");
            alglib.ap.assert((double)(xa)<(double)(xb), "Spline2DBuilderSetArea: XA>=XB");
            alglib.ap.assert((double)(ya)<(double)(yb), "Spline2DBuilderSetArea: YA>=YB");
            state.areatype = 1;
            state.xa = xa;
            state.xb = xb;
            state.ya = ya;
            state.yb = yb;
        }


        /*************************************************************************
        This  function  sets  nodes  count  for  2D spline interpolant. Fitting is
        performed on area defined with one of the "setarea"  functions;  this  one
        sets number of nodes placed upon the fitting area.

        INPUT PARAMETERS:
            S       -   spline 2D builder object
            KX      -   nodes count for the first (X) dimension; fitting  interval
                        [XA,XB] is separated into KX-1 subintervals, with KX nodes
                        created at the boundaries.
            KY      -   nodes count for the first (Y) dimension; fitting  interval
                        [YA,YB] is separated into KY-1 subintervals, with KY nodes
                        created at the boundaries.

        NOTE: at  least  4  nodes  is  created in each dimension, so KX and KY are
              silently increased if needed.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetgrid(spline2dbuilder state,
            int kx,
            int ky,
            alglib.xparams _params)
        {
            alglib.ap.assert(kx>0, "Spline2DBuilderSetGridSizePrecisely: KX<=0");
            alglib.ap.assert(ky>0, "Spline2DBuilderSetGridSizePrecisely: KY<=0");
            state.gridtype = 1;
            state.kx = Math.Max(kx, 4);
            state.ky = Math.Max(ky, 4);
        }


        /*************************************************************************
        This  function  allows  you to choose least squares solver used to perform
        fitting. This function sets solver algorithm to "FastDDM", which  performs
        fast parallel fitting by splitting problem into smaller chunks and merging
        results together.

        This solver is optimized for large-scale problems, starting  from  256x256
        grids, and up to 10000x10000 grids. Of course, it will  work  for  smaller
        grids too.

        More detailed description of the algorithm is given below:
        * algorithm generates hierarchy  of  nested  grids,  ranging  from  ~16x16
          (topmost "layer" of the model) to ~KX*KY one (final layer). Upper layers
          model global behavior of the function, lower layers are  used  to  model
          fine details. Moving from layer to layer doubles grid density.
        * fitting  is  started  from  topmost  layer, subsequent layers are fitted
          using residuals from previous ones.
        * user may choose to skip generation of upper layers and generate  only  a
          few bottom ones, which  will  result  in  much  better  performance  and
          parallelization efficiency, at the cost of algorithm inability to "patch"
          large holes in the dataset.
        * every layer is regularized using progressively increasing regularization
          coefficient; thus, increasing  LambdaV  penalizes  fine  details  first,
          leaving lower frequencies almost intact for a while.
        * after fitting is done, all layers are merged together into  one  bicubic
          spline
          
        IMPORTANT: regularization coefficient used by  this  solver  is  different
                   from the one used by  BlockLLS.  Latter  utilizes  nonlinearity
                   penalty,  which  is  global  in  nature  (large  regularization
                   results in global linear trend being  extracted);  this  solver
                   uses another, localized form of penalty, which is suitable  for
                   parallel processing.

        Notes on memory and performance:
        * memory requirements: most memory is consumed  during  modeling   of  the
          higher layers; ~[512*NPoints] bytes is required for a  model  with  full
          hierarchy of grids being generated. However, if you skip a  few  topmost
          layers, you will get nearly constant (wrt. points count and  grid  size)
          memory consumption.
        * serial running time: O(K*K)+O(NPoints) for a KxK grid
        * parallelism potential: good. You may get  nearly  linear  speed-up  when
          performing fitting with just a few layers. Adding more layers results in
          model becoming more global, which somewhat  reduces  efficiency  of  the
          parallel code.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        INPUT PARAMETERS:
            S       -   spline 2D builder object
            NLayers -   number of layers in the model:
                        * NLayers>=1 means that up  to  chosen  number  of  bottom
                          layers is fitted
                        * NLayers=0 means that maximum number of layers is  chosen
                          (according to current grid size)
                        * NLayers<=-1 means that up to |NLayers| topmost layers is
                          skipped
                        Recommendations:
                        * good "default" value is 2 layers
                        * you may need  more  layers,  if  your  dataset  is  very
                          irregular and you want to "patch"  large  holes.  For  a
                          grid step H (equal to AreaWidth/GridSize) you may expect
                          that last layer reproduces variations at distance H (and
                          can patch holes that wide); that higher  layers  operate
                          at distances 2*H, 4*H, 8*H and so on.
                        * good value for "bullletproof" mode is  NLayers=0,  which
                          results in complete hierarchy of layers being generated.
            LambdaV -   regularization coefficient, chosen in such a way  that  it
                        penalizes bottom layers (fine details) first.
                        LambdaV>=0, zero value means that no penalty is applied.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetalgofastddm(spline2dbuilder state,
            int nlayers,
            double lambdav,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(lambdav), "Spline2DBuilderSetAlgoFastDDM: LambdaV is not finite value");
            alglib.ap.assert((double)(lambdav)>=(double)(0), "Spline2DBuilderSetAlgoFastDDM: LambdaV<0");
            state.solvertype = 3;
            state.nlayers = nlayers;
            state.smoothing = lambdav;
        }


        /*************************************************************************
        This  function  allows  you to choose least squares solver used to perform
        fitting. This function sets solver algorithm to "BlockLLS", which performs
        least squares fitting  with  fast  sparse  direct  solver,  with  optional
        nonsmoothness penalty being applied.

        Nonlinearity penalty has the following form:

                                  [                                            ]
            P() ~ Lambda* integral[ (d2S/dx2)^2 + 2*(d2S/dxdy)^2 + (d2S/dy2)^2 ]dxdy
                                  [                                            ]
                          
        here integral is calculated over entire grid, and "~" means "proportional"
        because integral is normalized after calcilation. Extremely  large  values
        of Lambda result in linear fit being performed.

        NOTE: this algorithm is the most robust and controllable one,  but  it  is
              limited by 512x512 grids and (say) up to 1.000.000 points.  However,
              ALGLIB has one more  spline  solver:  FastDDM  algorithm,  which  is
              intended for really large-scale problems (in 10M-100M range). FastDDM
              algorithm also has better parallelism properties.
              
        More information on BlockLLS solver:
        * memory requirements: ~[32*K^3+256*NPoints]  bytes  for  KxK  grid   with
          NPoints-sized dataset
        * serial running time: O(K^4+NPoints)
        * parallelism potential: limited. You may get some sublinear gain when
          working with large grids (K's in 256..512 range)

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        INPUT PARAMETERS:
            S       -   spline 2D builder object
            LambdaNS-   non-negative value:
                        * positive value means that some smoothing is applied
                        * zero value means  that  no  smoothing  is  applied,  and
                          corresponding entries of design matrix  are  numerically
                          zero and dropped from consideration.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetalgoblocklls(spline2dbuilder state,
            double lambdans,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(lambdans), "Spline2DBuilderSetAlgoBlockLLS: LambdaNS is not finite value");
            alglib.ap.assert((double)(lambdans)>=(double)(0), "Spline2DBuilderSetAlgoBlockLLS: LambdaNS<0");
            state.solvertype = 1;
            state.smoothing = lambdans;
        }


        /*************************************************************************
        This  function  allows  you to choose least squares solver used to perform
        fitting. This function sets solver algorithm to "NaiveLLS".

        IMPORTANT: NaiveLLS is NOT intended to be used in  real  life  code!  This
                   algorithm solves problem by generated dense (K^2)x(K^2+NPoints)
                   matrix and solves  linear  least  squares  problem  with  dense
                   solver.
                   
                   It is here just  to  test  BlockLLS  against  reference  solver
                   (and maybe for someone trying to compare well optimized  solver
                   against straightforward approach to the LLS problem).

        More information on naive LLS solver:
        * memory requirements: ~[8*K^4+256*NPoints] bytes for KxK grid.
        * serial running time: O(K^6+NPoints) for KxK grid
        * when compared with BlockLLS,  NaiveLLS  has ~K  larger memory demand and
          ~K^2  larger running time.

        INPUT PARAMETERS:
            S       -   spline 2D builder object
            LambdaNS-   nonsmoothness penalty

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dbuildersetalgonaivells(spline2dbuilder state,
            double lambdans,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(lambdans), "Spline2DBuilderSetAlgoBlockLLS: LambdaNS is not finite value");
            alglib.ap.assert((double)(lambdans)>=(double)(0), "Spline2DBuilderSetAlgoBlockLLS: LambdaNS<0");
            state.solvertype = 2;
            state.smoothing = lambdans;
        }


        /*************************************************************************
        This function fits bicubic spline to current dataset, using current  area/
        grid and current LLS solver.

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! * hardware vendor (Intel) implementations of linear algebra primitives
          !   (C++ and C# versions, x86/x64 platform)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        INPUT PARAMETERS:
            State   -   spline 2D builder object

        OUTPUT PARAMETERS:
            S       -   2D spline, fit result
            Rep     -   fitting report, which provides some additional info  about
                        errors, R2 coefficient and so on.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dfit(spline2dbuilder state,
            spline2dinterpolant s,
            spline2dfitreport rep,
            alglib.xparams _params)
        {
            double xa = 0;
            double xb = 0;
            double ya = 0;
            double yb = 0;
            double xaraw = 0;
            double xbraw = 0;
            double yaraw = 0;
            double ybraw = 0;
            int kx = 0;
            int ky = 0;
            double hx = 0;
            double hy = 0;
            double invhx = 0;
            double invhy = 0;
            int gridexpansion = 0;
            int nzwidth = 0;
            int bfrad = 0;
            int npoints = 0;
            int d = 0;
            int ew = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            double v = 0;
            int k0 = 0;
            int k1 = 0;
            double vx = 0;
            double vy = 0;
            int arows = 0;
            int acopied = 0;
            int basecasex = 0;
            int basecasey = 0;
            double eps = 0;
            double[] xywork = new double[0];
            double[,] vterm = new double[0,0];
            double[] tmpx = new double[0];
            double[] tmpy = new double[0];
            double[] tmp0 = new double[0];
            double[] tmp1 = new double[0];
            double[] meany = new double[0];
            int[] xyindex = new int[0];
            int[] tmpi = new int[0];
            spline1d.spline1dinterpolant basis1 = new spline1d.spline1dinterpolant();
            sparse.sparsematrix av = new sparse.sparsematrix();
            sparse.sparsematrix ah = new sparse.sparsematrix();
            spline2dxdesignmatrix xdesignmatrix = new spline2dxdesignmatrix();
            double[] z = new double[0];
            spline2dblockllsbuf blockllsbuf = new spline2dblockllsbuf();
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double tss = 0;
            int dstidx = 0;

            nzwidth = 4;
            bfrad = 2;
            npoints = state.npoints;
            d = state.d;
            ew = 2+d;
            
            //
            // Integrity checks
            //
            alglib.ap.assert((double)(state.sx)==(double)(1), "Spline2DFit: integrity error");
            alglib.ap.assert((double)(state.sy)==(double)(1), "Spline2DFit: integrity error");
            
            //
            // Determine actual area size and grid step
            //
            // NOTE: initialize vars by zeros in order to avoid spurious
            //       compiler warnings.
            //
            xa = 0;
            xb = 0;
            ya = 0;
            yb = 0;
            if( state.areatype==0 )
            {
                if( npoints>0 )
                {
                    xa = state.xy[0];
                    xb = state.xy[0];
                    ya = state.xy[1];
                    yb = state.xy[1];
                    for(i=1; i<=npoints-1; i++)
                    {
                        xa = Math.Min(xa, state.xy[i*ew+0]);
                        xb = Math.Max(xb, state.xy[i*ew+0]);
                        ya = Math.Min(ya, state.xy[i*ew+1]);
                        yb = Math.Max(yb, state.xy[i*ew+1]);
                    }
                }
                else
                {
                    xa = -1;
                    xb = 1;
                    ya = -1;
                    yb = 1;
                }
            }
            else
            {
                if( state.areatype==1 )
                {
                    xa = state.xa;
                    xb = state.xb;
                    ya = state.ya;
                    yb = state.yb;
                }
                else
                {
                    alglib.ap.assert(false);
                }
            }
            if( (double)(xa)==(double)(xb) )
            {
                v = xa;
                if( (double)(v)>=(double)(0) )
                {
                    xa = v/2-1;
                    xb = v*2+1;
                }
                else
                {
                    xa = v*2-1;
                    xb = v/2+1;
                }
            }
            if( (double)(ya)==(double)(yb) )
            {
                v = ya;
                if( (double)(v)>=(double)(0) )
                {
                    ya = v/2-1;
                    yb = v*2+1;
                }
                else
                {
                    ya = v*2-1;
                    yb = v/2+1;
                }
            }
            alglib.ap.assert((double)(xa)<(double)(xb), "Spline2DFit: integrity error");
            alglib.ap.assert((double)(ya)<(double)(yb), "Spline2DFit: integrity error");
            kx = 0;
            ky = 0;
            if( state.gridtype==0 )
            {
                kx = 4;
                ky = 4;
            }
            else
            {
                if( state.gridtype==1 )
                {
                    kx = state.kx;
                    ky = state.ky;
                }
                else
                {
                    alglib.ap.assert(false);
                }
            }
            alglib.ap.assert(kx>0, "Spline2DFit: integrity error");
            alglib.ap.assert(ky>0, "Spline2DFit: integrity error");
            basecasex = -1;
            basecasey = -1;
            if( state.solvertype==3 )
            {
                
                //
                // Large-scale solver with special requirements to grid size.
                //
                kx = Math.Max(kx, nzwidth);
                ky = Math.Max(ky, nzwidth);
                k = 1;
                while( apserv.imin2(kx, ky, _params)>state.maxcoresize+1 )
                {
                    kx = apserv.idivup(kx-1, 2, _params)+1;
                    ky = apserv.idivup(ky-1, 2, _params)+1;
                    k = k+1;
                }
                basecasex = kx-1;
                k0 = 1;
                while( kx>state.maxcoresize+1 )
                {
                    basecasex = apserv.idivup(kx-1, 2, _params);
                    kx = basecasex+1;
                    k0 = k0+1;
                }
                while( k0>1 )
                {
                    kx = (kx-1)*2+1;
                    k0 = k0-1;
                }
                basecasey = ky-1;
                k1 = 1;
                while( ky>state.maxcoresize+1 )
                {
                    basecasey = apserv.idivup(ky-1, 2, _params);
                    ky = basecasey+1;
                    k1 = k1+1;
                }
                while( k1>1 )
                {
                    ky = (ky-1)*2+1;
                    k1 = k1-1;
                }
                while( k>1 )
                {
                    kx = (kx-1)*2+1;
                    ky = (ky-1)*2+1;
                    k = k-1;
                }
                
                //
                // Grid is NOT expanded. We have very strict requirements on
                // grid size, and we do not want to overcomplicate it by
                // playing with grid size in order to add one more degree of
                // freedom. It is not relevant for such large tasks.
                //
                gridexpansion = 0;
            }
            else
            {
                
                //
                // Medium-scale solvers which are tolerant to grid size.
                //
                kx = Math.Max(kx, nzwidth);
                ky = Math.Max(ky, nzwidth);
                
                //
                // Grid is expanded by 1 in order to add one more effective degree
                // of freedom to the spline. Having additional nodes outside of the
                // area allows us to emulate changes in the derivative at the bound
                // without having specialized "boundary" version of the basis function.
                //
                if( state.adddegreeoffreedom )
                {
                    gridexpansion = 1;
                }
                else
                {
                    gridexpansion = 0;
                }
            }
            hx = apserv.coalesce(xb-xa, 1.0, _params)/(kx-1);
            hy = apserv.coalesce(yb-ya, 1.0, _params)/(ky-1);
            invhx = 1/hx;
            invhy = 1/hy;
            
            //
            // We determined "raw" grid size. Now perform a grid correction according
            // to current grid expansion size.
            //
            xaraw = xa;
            yaraw = ya;
            xbraw = xb;
            ybraw = yb;
            xa = xa-hx*gridexpansion;
            ya = ya-hy*gridexpansion;
            xb = xb+hx*gridexpansion;
            yb = yb+hy*gridexpansion;
            kx = kx+2*gridexpansion;
            ky = ky+2*gridexpansion;
            
            //
            // Create output spline using transformed (unit-scale)
            // coordinates, fill by zero values
            //
            s.d = d;
            s.n = kx;
            s.m = ky;
            s.stype = -3;
            sfx = s.n*s.m*d;
            sfy = 2*s.n*s.m*d;
            sfxy = 3*s.n*s.m*d;
            s.x = new double[s.n];
            s.y = new double[s.m];
            s.f = new double[4*s.n*s.m*d];
            for(i=0; i<=s.n-1; i++)
            {
                s.x[i] = i;
            }
            for(i=0; i<=s.m-1; i++)
            {
                s.y[i] = i;
            }
            for(i=0; i<=4*s.n*s.m*d-1; i++)
            {
                s.f[i] = 0.0;
            }
            
            //
            // Create local copy of dataset (only points in the grid are copied;
            // we allow small step out of the grid, by Eps*H, in order to deal
            // with numerical rounding errors).
            //
            // An additional copy of Y-values is created at columns beyond 2+J;
            // it is preserved during all transformations. This copy is used
            // to calculate error-related metrics.
            //
            // Calculate mean(Y), TSS
            //
            meany = new double[d];
            for(j=0; j<=d-1; j++)
            {
                meany[j] = 0;
            }
            apserv.rvectorsetlengthatleast(ref xywork, npoints*ew, _params);
            acopied = 0;
            eps = 1.0E-6;
            for(i=0; i<=npoints-1; i++)
            {
                vx = state.xy[i*ew+0];
                vy = state.xy[i*ew+1];
                if( (((double)(xaraw-eps*hx)<=(double)(vx) && (double)(vx)<=(double)(xbraw+eps*hx)) && (double)(yaraw-eps*hy)<=(double)(vy)) && (double)(vy)<=(double)(ybraw+eps*hy) )
                {
                    xywork[acopied*ew+0] = (vx-xa)*invhx;
                    xywork[acopied*ew+1] = (vy-ya)*invhy;
                    for(j=0; j<=d-1; j++)
                    {
                        v = state.xy[i*ew+2+j];
                        xywork[acopied*ew+2+j] = v;
                        meany[j] = meany[j]+v;
                    }
                    acopied = acopied+1;
                }
            }
            npoints = acopied;
            for(j=0; j<=d-1; j++)
            {
                meany[j] = meany[j]/apserv.coalesce(npoints, 1, _params);
            }
            tss = 0.0;
            for(i=0; i<=npoints-1; i++)
            {
                for(j=0; j<=d-1; j++)
                {
                    tss = tss+math.sqr(xywork[i*ew+2+j]-meany[j]);
                }
            }
            tss = apserv.coalesce(tss, 1.0, _params);
            
            //
            // Handle prior term.
            // Modify output spline.
            // Quick exit if dataset is empty.
            //
            intfitserv.buildpriorterm1(xywork, npoints, 2, d, state.priorterm, state.priortermval, ref vterm, _params);
            if( npoints==0 )
            {
                
                //
                // Quick exit
                //
                for(k=0; k<=s.n*s.m-1; k++)
                {
                    k0 = k%s.n;
                    k1 = k/s.n;
                    for(j=0; j<=d-1; j++)
                    {
                        dstidx = d*(k1*s.n+k0)+j;
                        s.f[dstidx] = s.f[dstidx]+vterm[j,0]*s.x[k0]+vterm[j,1]*s.y[k1]+vterm[j,2];
                        s.f[sfx+dstidx] = s.f[sfx+dstidx]+vterm[j,0];
                        s.f[sfy+dstidx] = s.f[sfy+dstidx]+vterm[j,1];
                    }
                }
                for(i=0; i<=s.n-1; i++)
                {
                    s.x[i] = s.x[i]*hx+xa;
                }
                for(i=0; i<=s.m-1; i++)
                {
                    s.y[i] = s.y[i]*hy+ya;
                }
                for(i=0; i<=s.n*s.m*d-1; i++)
                {
                    s.f[sfx+i] = s.f[sfx+i]*invhx;
                    s.f[sfy+i] = s.f[sfy+i]*invhy;
                    s.f[sfxy+i] = s.f[sfxy+i]*invhx*invhy;
                }
                rep.rmserror = 0;
                rep.avgerror = 0;
                rep.maxerror = 0;
                rep.r2 = 1.0;
                return;
            }
            
            //
            // Build 1D compact basis function
            // Generate design matrix
            //
            tmpx = new double[7];
            tmpy = new double[7];
            tmpx[0] = -3;
            tmpx[1] = -2;
            tmpx[2] = -1;
            tmpx[3] = 0;
            tmpx[4] = 1;
            tmpx[5] = 2;
            tmpx[6] = 3;
            tmpy[0] = 0;
            tmpy[1] = 0;
            tmpy[2] = (double)1/(double)12;
            tmpy[3] = (double)2/(double)6;
            tmpy[4] = (double)1/(double)12;
            tmpy[5] = 0;
            tmpy[6] = 0;
            spline1d.spline1dbuildcubic(tmpx, tmpy, alglib.ap.len(tmpx), 2, 0.0, 2, 0.0, basis1, _params);
            
            //
            // Solve.
            // Update spline.
            //
            if( state.solvertype==1 )
            {
                
                //
                // BlockLLS
                //
                reorderdatasetandbuildindex(xywork, npoints, d, tmp0, 0, kx, ky, ref xyindex, ref tmpi, _params);
                xdesigngenerate(xywork, xyindex, 0, kx, kx, 0, ky, ky, d, lambdaregblocklls, state.smoothing, basis1, xdesignmatrix, _params);
                blockllsfit(xdesignmatrix, state.lsqrcnt, ref z, rep, tss, blockllsbuf, _params);
                updatesplinetable(z, kx, ky, d, basis1, bfrad, s.f, s.m, s.n, 1, _params);
            }
            else
            {
                if( state.solvertype==2 )
                {
                    
                    //
                    // NaiveLLS, reference implementation
                    //
                    generatedesignmatrix(xywork, npoints, d, kx, ky, state.smoothing, lambdaregblocklls, basis1, av, ah, ref arows, _params);
                    naivellsfit(av, ah, arows, xywork, kx, ky, npoints, d, state.lsqrcnt, ref z, rep, tss, _params);
                    updatesplinetable(z, kx, ky, d, basis1, bfrad, s.f, s.m, s.n, 1, _params);
                }
                else
                {
                    if( state.solvertype==3 )
                    {
                        
                        //
                        // FastDDM method
                        //
                        alglib.ap.assert(basecasex>0, "Spline2DFit: integrity error");
                        alglib.ap.assert(basecasey>0, "Spline2DFit: integrity error");
                        fastddmfit(xywork, npoints, d, kx, ky, basecasex, basecasey, state.maxcoresize, state.interfacesize, state.nlayers, state.smoothing, state.lsqrcnt, basis1, s, rep, tss, _params);
                    }
                    else
                    {
                        alglib.ap.assert(false, "Spline2DFit: integrity error");
                    }
                }
            }
            
            //
            // Append prior term.
            // Transform spline to original coordinates
            //
            for(k=0; k<=s.n*s.m-1; k++)
            {
                k0 = k%s.n;
                k1 = k/s.n;
                for(j=0; j<=d-1; j++)
                {
                    dstidx = d*(k1*s.n+k0)+j;
                    s.f[dstidx] = s.f[dstidx]+vterm[j,0]*s.x[k0]+vterm[j,1]*s.y[k1]+vterm[j,2];
                    s.f[sfx+dstidx] = s.f[sfx+dstidx]+vterm[j,0];
                    s.f[sfy+dstidx] = s.f[sfy+dstidx]+vterm[j,1];
                }
            }
            for(i=0; i<=s.n-1; i++)
            {
                s.x[i] = s.x[i]*hx+xa;
            }
            for(i=0; i<=s.m-1; i++)
            {
                s.y[i] = s.y[i]*hy+ya;
            }
            for(i=0; i<=s.n*s.m*d-1; i++)
            {
                s.f[sfx+i] = s.f[sfx+i]*invhx;
                s.f[sfy+i] = s.f[sfy+i]*invhy;
                s.f[sfxy+i] = s.f[sfxy+i]*invhx*invhy;
            }
        }


        /*************************************************************************
        Serializer: allocation

          -- ALGLIB --
             Copyright 28.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dalloc(alglib.serializer s,
            spline2dinterpolant spline,
            alglib.xparams _params)
        {
            
            //
            // Header
            //
            s.alloc_entry();
            
            //
            // Data
            //
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            apserv.allocrealarray(s, spline.x, -1, _params);
            apserv.allocrealarray(s, spline.y, -1, _params);
            apserv.allocrealarray(s, spline.f, -1, _params);
        }


        /*************************************************************************
        Serializer: serialization

          -- ALGLIB --
             Copyright 28.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dserialize(alglib.serializer s,
            spline2dinterpolant spline,
            alglib.xparams _params)
        {
            
            //
            // Header
            //
            s.serialize_int(scodes.getspline2dserializationcode(_params));
            
            //
            // Data
            //
            s.serialize_int(spline.stype);
            s.serialize_int(spline.n);
            s.serialize_int(spline.m);
            s.serialize_int(spline.d);
            apserv.serializerealarray(s, spline.x, -1, _params);
            apserv.serializerealarray(s, spline.y, -1, _params);
            apserv.serializerealarray(s, spline.f, -1, _params);
        }


        /*************************************************************************
        Serializer: unserialization

          -- ALGLIB --
             Copyright 28.02.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void spline2dunserialize(alglib.serializer s,
            spline2dinterpolant spline,
            alglib.xparams _params)
        {
            int scode = 0;

            
            //
            // Header
            //
            scode = s.unserialize_int();
            alglib.ap.assert(scode==scodes.getspline2dserializationcode(_params), "Spline2DUnserialize: stream header corrupted");
            
            //
            // Data
            //
            spline.stype = s.unserialize_int();
            spline.n = s.unserialize_int();
            spline.m = s.unserialize_int();
            spline.d = s.unserialize_int();
            apserv.unserializerealarray(s, ref spline.x, _params);
            apserv.unserializerealarray(s, ref spline.y, _params);
            apserv.unserializerealarray(s, ref spline.f, _params);
        }


        /*************************************************************************
        Internal subroutine.
        Calculation of the first derivatives and the cross-derivative.
        *************************************************************************/
        private static void bicubiccalcderivatives(double[,] a,
            double[] x,
            double[] y,
            int m,
            int n,
            ref double[,] dx,
            ref double[,] dy,
            ref double[,] dxy,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double[] xt = new double[0];
            double[] ft = new double[0];
            double s = 0;
            double ds = 0;
            double d2s = 0;
            spline1d.spline1dinterpolant c = new spline1d.spline1dinterpolant();

            dx = new double[0,0];
            dy = new double[0,0];
            dxy = new double[0,0];

            dx = new double[m, n];
            dy = new double[m, n];
            dxy = new double[m, n];
            
            //
            // dF/dX
            //
            xt = new double[n];
            ft = new double[n];
            for(i=0; i<=m-1; i++)
            {
                for(j=0; j<=n-1; j++)
                {
                    xt[j] = x[j];
                    ft[j] = a[i,j];
                }
                spline1d.spline1dbuildcubic(xt, ft, n, 0, 0.0, 0, 0.0, c, _params);
                for(j=0; j<=n-1; j++)
                {
                    spline1d.spline1ddiff(c, x[j], ref s, ref ds, ref d2s, _params);
                    dx[i,j] = ds;
                }
            }
            
            //
            // dF/dY
            //
            xt = new double[m];
            ft = new double[m];
            for(j=0; j<=n-1; j++)
            {
                for(i=0; i<=m-1; i++)
                {
                    xt[i] = y[i];
                    ft[i] = a[i,j];
                }
                spline1d.spline1dbuildcubic(xt, ft, m, 0, 0.0, 0, 0.0, c, _params);
                for(i=0; i<=m-1; i++)
                {
                    spline1d.spline1ddiff(c, y[i], ref s, ref ds, ref d2s, _params);
                    dy[i,j] = ds;
                }
            }
            
            //
            // d2F/dXdY
            //
            xt = new double[n];
            ft = new double[n];
            for(i=0; i<=m-1; i++)
            {
                for(j=0; j<=n-1; j++)
                {
                    xt[j] = x[j];
                    ft[j] = dy[i,j];
                }
                spline1d.spline1dbuildcubic(xt, ft, n, 0, 0.0, 0, 0.0, c, _params);
                for(j=0; j<=n-1; j++)
                {
                    spline1d.spline1ddiff(c, x[j], ref s, ref ds, ref d2s, _params);
                    dxy[i,j] = ds;
                }
            }
        }


        /*************************************************************************
        This function generates design matrix for the problem (in fact, two design
        matrices are generated: "vertical" one and transposed (horizontal) one.

        INPUT PARAMETERS:
            XY          -   array[NPoints*(2+D)]; dataset after scaling  in  such
                            way that grid step is equal to 1.0 in both dimensions.
            NPoints     -   dataset size, NPoints>=1
            KX, KY      -   grid size, KX,KY>=4
            Smoothing   -   nonlinearity penalty coefficient, >=0
            LambdaReg   -   regularization coefficient, >=0
            Basis1      -   basis spline, expected to be non-zero only at [-2,+2]
            AV, AH      -   possibly preallocated buffers

        OUTPUT PARAMETERS:
            AV          -   sparse matrix[ARows,KX*KY]; design matrix
            AH          -   transpose of AV
            ARows       -   number of rows in design matrix
            
          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void generatedesignmatrix(double[] xy,
            int npoints,
            int d,
            int kx,
            int ky,
            double smoothing,
            double lambdareg,
            spline1d.spline1dinterpolant basis1,
            sparse.sparsematrix av,
            sparse.sparsematrix ah,
            ref int arows,
            alglib.xparams _params)
        {
            int nzwidth = 0;
            int nzshift = 0;
            int ew = 0;
            int i = 0;
            int j0 = 0;
            int j1 = 0;
            int k0 = 0;
            int k1 = 0;
            int dstidx = 0;
            double v = 0;
            double v0 = 0;
            double v1 = 0;
            double v2 = 0;
            double w0 = 0;
            double w1 = 0;
            double w2 = 0;
            int[] crx = new int[0];
            int[] cry = new int[0];
            int[] nrs = new int[0];
            double[,] d2x = new double[0,0];
            double[,] d2y = new double[0,0];
            double[,] dxy = new double[0,0];

            arows = 0;

            nzwidth = 4;
            nzshift = 1;
            alglib.ap.assert(npoints>0, "Spline2DFit: integrity check failed");
            alglib.ap.assert(kx>=nzwidth, "Spline2DFit: integrity check failed");
            alglib.ap.assert(ky>=nzwidth, "Spline2DFit: integrity check failed");
            ew = 2+d;
            
            //
            // Determine canonical rectangle for every point. Every point of the dataset is
            // influenced by at most NZWidth*NZWidth basis functions, which form NZWidth*NZWidth
            // canonical rectangle.
            //
            // Thus, we have (KX-NZWidth+1)*(KY-NZWidth+1) overlapping canonical rectangles.
            // Assigning every point to its rectangle simplifies creation of sparse basis
            // matrix at the next steps.
            //
            crx = new int[npoints];
            cry = new int[npoints];
            for(i=0; i<=npoints-1; i++)
            {
                crx[i] = apserv.iboundval((int)Math.Floor(xy[i*ew+0])-nzshift, 0, kx-nzwidth, _params);
                cry[i] = apserv.iboundval((int)Math.Floor(xy[i*ew+1])-nzshift, 0, ky-nzwidth, _params);
            }
            
            //
            // Create vertical and horizontal design matrices 
            //
            arows = npoints+kx*ky;
            if( (double)(smoothing)!=(double)(0.0) )
            {
                alglib.ap.assert((double)(smoothing)>(double)(0.0), "Spline2DFit: integrity check failed");
                arows = arows+3*(kx-2)*(ky-2);
            }
            nrs = new int[arows];
            dstidx = 0;
            for(i=0; i<=npoints-1; i++)
            {
                nrs[dstidx+i] = nzwidth*nzwidth;
            }
            dstidx = dstidx+npoints;
            for(i=0; i<=kx*ky-1; i++)
            {
                nrs[dstidx+i] = 1;
            }
            dstidx = dstidx+kx*ky;
            if( (double)(smoothing)!=(double)(0.0) )
            {
                for(i=0; i<=3*(kx-2)*(ky-2)-1; i++)
                {
                    nrs[dstidx+i] = 3*3;
                }
                dstidx = dstidx+3*(kx-2)*(ky-2);
            }
            alglib.ap.assert(dstidx==arows, "Spline2DFit: integrity check failed");
            sparse.sparsecreatecrs(arows, kx*ky, nrs, av, _params);
            dstidx = 0;
            for(i=0; i<=npoints-1; i++)
            {
                for(j1=0; j1<=nzwidth-1; j1++)
                {
                    for(j0=0; j0<=nzwidth-1; j0++)
                    {
                        v0 = spline1d.spline1dcalc(basis1, xy[i*ew+0]-(crx[i]+j0), _params);
                        v1 = spline1d.spline1dcalc(basis1, xy[i*ew+1]-(cry[i]+j1), _params);
                        sparse.sparseset(av, dstidx+i, (cry[i]+j1)*kx+(crx[i]+j0), v0*v1, _params);
                    }
                }
            }
            dstidx = dstidx+npoints;
            for(i=0; i<=kx*ky-1; i++)
            {
                sparse.sparseset(av, dstidx+i, i, lambdareg, _params);
            }
            dstidx = dstidx+kx*ky;
            if( (double)(smoothing)!=(double)(0.0) )
            {
                
                //
                // Smoothing is applied. Because all grid nodes are same,
                // we apply same smoothing kernel, which is calculated only
                // once at the beginning of design matrix generation.
                //
                d2x = new double[3, 3];
                d2y = new double[3, 3];
                dxy = new double[3, 3];
                for(j1=0; j1<=2; j1++)
                {
                    for(j0=0; j0<=2; j0++)
                    {
                        d2x[j0,j1] = 0.0;
                        d2y[j0,j1] = 0.0;
                        dxy[j0,j1] = 0.0;
                    }
                }
                for(k1=0; k1<=2; k1++)
                {
                    for(k0=0; k0<=2; k0++)
                    {
                        spline1d.spline1ddiff(basis1, -(k0-1), ref v0, ref v1, ref v2, _params);
                        spline1d.spline1ddiff(basis1, -(k1-1), ref w0, ref w1, ref w2, _params);
                        d2x[k0,k1] = d2x[k0,k1]+v2*w0;
                        d2y[k0,k1] = d2y[k0,k1]+w2*v0;
                        dxy[k0,k1] = dxy[k0,k1]+v1*w1;
                    }
                }
                
                //
                // Now, kernel is ready - apply it to all inner nodes of the grid.
                //
                for(j1=1; j1<=ky-2; j1++)
                {
                    for(j0=1; j0<=kx-2; j0++)
                    {
                        
                        //
                        // d2F/dx2 term
                        //
                        v = smoothing;
                        for(k1=-1; k1<=1; k1++)
                        {
                            for(k0=-1; k0<=1; k0++)
                            {
                                sparse.sparseset(av, dstidx, (j1+k1)*kx+(j0+k0), v*d2x[1+k0,1+k1], _params);
                            }
                        }
                        dstidx = dstidx+1;
                        
                        //
                        // d2F/dy2 term
                        //
                        v = smoothing;
                        for(k1=-1; k1<=1; k1++)
                        {
                            for(k0=-1; k0<=1; k0++)
                            {
                                sparse.sparseset(av, dstidx, (j1+k1)*kx+(j0+k0), v*d2y[1+k0,1+k1], _params);
                            }
                        }
                        dstidx = dstidx+1;
                        
                        //
                        // 2*d2F/dxdy term
                        //
                        v = Math.Sqrt(2)*smoothing;
                        for(k1=-1; k1<=1; k1++)
                        {
                            for(k0=-1; k0<=1; k0++)
                            {
                                sparse.sparseset(av, dstidx, (j1+k1)*kx+(j0+k0), v*dxy[1+k0,1+k1], _params);
                            }
                        }
                        dstidx = dstidx+1;
                    }
                }
            }
            alglib.ap.assert(dstidx==arows, "Spline2DFit: integrity check failed");
            sparse.sparsecopy(av, ah, _params);
            sparse.sparsetransposecrs(ah, _params);
        }


        /*************************************************************************
        This function updates table of spline values/derivatives using coefficients
        for a layer of basis functions.
            
          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void updatesplinetable(double[] z,
            int kx,
            int ky,
            int d,
            spline1d.spline1dinterpolant basis1,
            int bfrad,
            double[] ftbl,
            int m,
            int n,
            int scalexy,
            alglib.xparams _params)
        {
            int k = 0;
            int k0 = 0;
            int k1 = 0;
            int j = 0;
            int j0 = 0;
            int j1 = 0;
            int j0a = 0;
            int j0b = 0;
            int j1a = 0;
            int j1b = 0;
            double v = 0;
            double v0 = 0;
            double v1 = 0;
            double v01 = 0;
            double v11 = 0;
            double rdummy = 0;
            int dstidx = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double invscalexy = 0;

            alglib.ap.assert(n==(kx-1)*scalexy+1, "Spline2DFit.UpdateSplineTable: integrity check failed");
            alglib.ap.assert(m==(ky-1)*scalexy+1, "Spline2DFit.UpdateSplineTable: integrity check failed");
            invscalexy = (double)1/(double)scalexy;
            sfx = n*m*d;
            sfy = 2*n*m*d;
            sfxy = 3*n*m*d;
            for(k=0; k<=kx*ky-1; k++)
            {
                k0 = k%kx;
                k1 = k/kx;
                j0a = apserv.iboundval(k0*scalexy-(bfrad*scalexy-1), 0, n-1, _params);
                j0b = apserv.iboundval(k0*scalexy+(bfrad*scalexy-1), 0, n-1, _params);
                j1a = apserv.iboundval(k1*scalexy-(bfrad*scalexy-1), 0, m-1, _params);
                j1b = apserv.iboundval(k1*scalexy+(bfrad*scalexy-1), 0, m-1, _params);
                for(j1=j1a; j1<=j1b; j1++)
                {
                    spline1d.spline1ddiff(basis1, (j1-k1*scalexy)*invscalexy, ref v1, ref v11, ref rdummy, _params);
                    v11 = v11*invscalexy;
                    for(j0=j0a; j0<=j0b; j0++)
                    {
                        spline1d.spline1ddiff(basis1, (j0-k0*scalexy)*invscalexy, ref v0, ref v01, ref rdummy, _params);
                        v01 = v01*invscalexy;
                        for(j=0; j<=d-1; j++)
                        {
                            dstidx = d*(j1*n+j0)+j;
                            v = z[j*kx*ky+k];
                            ftbl[dstidx] = ftbl[dstidx]+v0*v1*v;
                            ftbl[sfx+dstidx] = ftbl[sfx+dstidx]+v01*v1*v;
                            ftbl[sfy+dstidx] = ftbl[sfy+dstidx]+v0*v11*v;
                            ftbl[sfxy+dstidx] = ftbl[sfxy+dstidx]+v01*v11*v;
                        }
                    }
                }
            }
        }


        /*************************************************************************
        This function performs fitting with FastDDM solver.
        Internal function, never use it directly.

        INPUT PARAMETERS:
            XY          -   array[NPoints*(2+D)], dataset; destroyed in process
            KX, KY      -   grid size
            TileSize    -   tile size
            InterfaceSize-  interface size
            NPoints     -   points count
            D           -   number of components in vector-valued spline, D>=1
            LSQRCnt     -   number of iterations, non-zero:
                            * LSQRCnt>0 means that specified amount of  preconditioned
                              LSQR  iterations  will  be  performed  to solve problem;
                              usually  we  need  2..5  its.  Recommended option - best
                              convergence and stability/quality.
                            * LSQRCnt<0 means that instead of LSQR  we  use  iterative
                              refinement on normal equations. Again, 2..5 its is enough.
            Basis1      -   basis spline, expected to be non-zero only at [-2,+2]
            Z           -   possibly preallocated buffer for solution
            Residuals   -   possibly preallocated buffer for residuals at dataset points
            Rep         -   report structure; fields which are not set by this function
                            are left intact
            TSS         -   total sum of squares; used to calculate R2
            

        OUTPUT PARAMETERS:
            XY          -   destroyed in process
            Z           -   array[KX*KY*D], filled by solution; KX*KY coefficients
                            corresponding to each of D dimensions are stored contiguously.
            Rep         -   following fields are set:
                            * Rep.RMSError
                            * Rep.AvgError
                            * Rep.MaxError
                            * Rep.R2

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void fastddmfit(double[] xy,
            int npoints,
            int d,
            int kx,
            int ky,
            int basecasex,
            int basecasey,
            int maxcoresize,
            int interfacesize,
            int nlayers,
            double smoothing,
            int lsqrcnt,
            spline1d.spline1dinterpolant basis1,
            spline2dinterpolant spline,
            spline2dfitreport rep,
            double tss,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int nzwidth = 0;
            int xew = 0;
            int ntotallayers = 0;
            int scaleidx = 0;
            int scalexy = 0;
            double invscalexy = 0;
            int kxcur = 0;
            int kycur = 0;
            int tilescount0 = 0;
            int tilescount1 = 0;
            double v = 0;
            double rss = 0;
            double[] yraw = new double[0];
            int[] xyindex = new int[0];
            double[] tmp0 = new double[0];
            int[] bufi = new int[0];
            spline2dfastddmbuf seed = new spline2dfastddmbuf();
            alglib.smp.shared_pool pool = new alglib.smp.shared_pool();
            spline2dxdesignmatrix xdesignmatrix = new spline2dxdesignmatrix();
            spline2dblockllsbuf blockllsbuf = new spline2dblockllsbuf();
            spline2dfitreport dummyrep = new spline2dfitreport();

            
            //
            // Dataset metrics and integrity checks
            //
            nzwidth = 4;
            xew = 2+d;
            alglib.ap.assert(maxcoresize>=2, "Spline2DFit: integrity check failed");
            alglib.ap.assert(interfacesize>=1, "Spline2DFit: integrity check failed");
            alglib.ap.assert(kx>=nzwidth, "Spline2DFit: integrity check failed");
            alglib.ap.assert(ky>=nzwidth, "Spline2DFit: integrity check failed");
            
            //
            // Verify consistency of the grid size (KX,KY) with basecase sizes.
            // Determine full number of layers.
            //
            alglib.ap.assert(basecasex<=maxcoresize, "Spline2DFit: integrity error");
            alglib.ap.assert(basecasey<=maxcoresize, "Spline2DFit: integrity error");
            ntotallayers = 1;
            scalexy = 1;
            kxcur = kx;
            kycur = ky;
            while( kxcur>basecasex+1 && kycur>basecasey+1 )
            {
                alglib.ap.assert(kxcur%2==1, "Spline2DFit: integrity error");
                alglib.ap.assert(kycur%2==1, "Spline2DFit: integrity error");
                kxcur = (kxcur-1)/2+1;
                kycur = (kycur-1)/2+1;
                scalexy = scalexy*2;
                apserv.inc(ref ntotallayers, _params);
            }
            invscalexy = (double)1/(double)scalexy;
            alglib.ap.assert((kxcur<=maxcoresize+1 && kxcur==basecasex+1) || kxcur%basecasex==1, "Spline2DFit: integrity error");
            alglib.ap.assert((kycur<=maxcoresize+1 && kycur==basecasey+1) || kycur%basecasey==1, "Spline2DFit: integrity error");
            alglib.ap.assert(kxcur==basecasex+1 || kycur==basecasey+1, "Spline2DFit: integrity error");
            
            //
            // Initial scaling of dataset.
            // Store original target values to YRaw.
            //
            apserv.rvectorsetlengthatleast(ref yraw, npoints*d, _params);
            for(i=0; i<=npoints-1; i++)
            {
                xy[xew*i+0] = xy[xew*i+0]*invscalexy;
                xy[xew*i+1] = xy[xew*i+1]*invscalexy;
                for(j=0; j<=d-1; j++)
                {
                    yraw[i*d+j] = xy[xew*i+2+j];
                }
            }
            kxcur = (kx-1)/scalexy+1;
            kycur = (ky-1)/scalexy+1;
            
            //
            // Build initial dataset index; area is divided into (KXCur-1)*(KYCur-1)
            // cells, with contiguous storage of points in the same cell.
            // Iterate over different scales
            //
            alglib.smp.ae_shared_pool_set_seed(pool, seed);
            reorderdatasetandbuildindex(xy, npoints, d, yraw, d, kxcur, kycur, ref xyindex, ref bufi, _params);
            for(scaleidx=ntotallayers-1; scaleidx>=0; scaleidx--)
            {
                if( (nlayers>0 && scaleidx<nlayers) || (nlayers<=0 && scaleidx<apserv.imax2(ntotallayers+nlayers, 1, _params)) )
                {
                    
                    //
                    // Fit current layer
                    //
                    alglib.ap.assert(kxcur%basecasex==1, "Spline2DFit: integrity error");
                    alglib.ap.assert(kycur%basecasey==1, "Spline2DFit: integrity error");
                    tilescount0 = kxcur/basecasex;
                    tilescount1 = kycur/basecasey;
                    fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, 0, tilescount0, tilescount0, basecasey, 0, tilescount1, tilescount1, maxcoresize, interfacesize, lsqrcnt, lambdaregfastddm+smoothing*Math.Pow(lambdadecay, scaleidx), basis1, pool, spline, _params);
                    
                    //
                    // Compute residuals and update XY
                    //
                    computeresidualsfromscratch(xy, yraw, npoints, d, scalexy, spline, _params);
                }
                
                //
                // Move to the next level
                //
                if( scaleidx!=0 )
                {
                    
                    //
                    // Transform dataset (multply everything by 2.0) and refine grid.
                    //
                    kxcur = 2*kxcur-1;
                    kycur = 2*kycur-1;
                    scalexy = scalexy/2;
                    invscalexy = (double)1/(double)scalexy;
                    rescaledatasetandrefineindex(xy, npoints, d, yraw, d, kxcur, kycur, ref xyindex, ref bufi, _params);
                    
                    //
                    // Clear temporaries from previous round.
                    //
                    // We have to do it because upper layer of the multilevel spline
                    // needs more memory then subsequent layers, and we want to free
                    // this memory as soon as possible.
                    //
                    alglib.smp.ae_shared_pool_clear_recycled(pool);
                }
            }
            
            //
            // Post-check
            //
            alglib.ap.assert(kxcur==kx, "Spline2DFit: integrity check failed");
            alglib.ap.assert(kycur==ky, "Spline2DFit: integrity check failed");
            alglib.ap.assert(scalexy==1, "Spline2DFit: integrity check failed");
            
            //
            // Report
            //
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.maxerror = 0;
            rss = 0.0;
            for(i=0; i<=npoints-1; i++)
            {
                for(j=0; j<=d-1; j++)
                {
                    v = xy[i*xew+2+j];
                    rss = rss+v*v;
                    rep.rmserror = rep.rmserror+math.sqr(v);
                    rep.avgerror = rep.avgerror+Math.Abs(v);
                    rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v));
                }
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/apserv.coalesce(npoints*d, 1.0, _params));
            rep.avgerror = rep.avgerror/apserv.coalesce(npoints*d, 1.0, _params);
            rep.r2 = 1.0-rss/apserv.coalesce(tss, 1.0, _params);
        }


        /*************************************************************************
        Recursive fitting function for FastDDM algorithm.

        Works with KX*KY grid, with KX=BasecaseX*TilesCountX+1 and KY=BasecaseY*TilesCountY+1,
        which is partitioned into TilesCountX*TilesCountY tiles, each having size
        BasecaseX*BasecaseY.

        This function processes tiles in range [TileX0,TileX1)x[TileY0,TileY1) and
        recursively divides this range until we move down to single tile, which
        is processed with BlockLLS solver.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void fastddmfitlayer(double[] xy,
            int d,
            int scalexy,
            int[] xyindex,
            int basecasex,
            int tilex0,
            int tilex1,
            int tilescountx,
            int basecasey,
            int tiley0,
            int tiley1,
            int tilescounty,
            int maxcoresize,
            int interfacesize,
            int lsqrcnt,
            double lambdareg,
            spline1d.spline1dinterpolant basis1,
            alglib.smp.shared_pool pool,
            spline2dinterpolant spline,
            alglib.xparams _params)
        {
            int kx = 0;
            int ky = 0;
            int i = 0;
            int j = 0;
            int j0 = 0;
            int j1 = 0;
            int bfrad = 0;
            int xa = 0;
            int xb = 0;
            int ya = 0;
            int yb = 0;
            int tile0 = 0;
            int tile1 = 0;
            int tilesize0 = 0;
            int tilesize1 = 0;
            int sfx = 0;
            int sfy = 0;
            int sfxy = 0;
            double dummytss = 0;
            double invscalexy = 0;
            int cnt0 = 0;
            int cnt1 = 0;
            int offs = 0;
            double vs = 0;
            double vsx = 0;
            double vsy = 0;
            double vsxy = 0;
            spline2dfastddmbuf buf = null;

            
            //
            // Dataset metrics and fast integrity checks;
            // no code with side effects is allowed before parallel split.
            //
            bfrad = 2;
            invscalexy = (double)1/(double)scalexy;
            kx = basecasex*tilescountx+1;
            ky = basecasey*tilescounty+1;
            
            //
            // Parallelism; because this function is intended for
            // large-scale problems, we always try to:
            // * invoke parallel execution mode
            // * activate spawn support
            //
            if( _trypexec_fastddmfitlayer(xy,d,scalexy,xyindex,basecasex,tilex0,tilex1,tilescountx,basecasey,tiley0,tiley1,tilescounty,maxcoresize,interfacesize,lsqrcnt,lambdareg,basis1,pool,spline, _params) )
            {
                return;
            }
            if( apserv.imax2(tiley1-tiley0, tilex1-tilex0, _params)>=2 )
            {
                if( tiley1-tiley0>tilex1-tilex0 )
                {
                    
                    //
                    // Split problem in Y dimension
                    //
                    // NOTE: recursive calls to FastDDMFitLayer() compute
                    //       residuals in the inner cells defined by XYIndex[],
                    //       but we still have to compute residuals for cells
                    //       BETWEEN two recursive subdivisions of the task.
                    //
                    apserv.tiledsplit(tiley1-tiley0, 1, ref j0, ref j1, _params);
                    fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, tilex0, tilex1, tilescountx, basecasey, tiley0, tiley0+j0, tilescounty, maxcoresize, interfacesize, lsqrcnt, lambdareg, basis1, pool, spline, _params);
                    fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, tilex0, tilex1, tilescountx, basecasey, tiley0+j0, tiley1, tilescounty, maxcoresize, interfacesize, lsqrcnt, lambdareg, basis1, pool, spline, _params);
                }
                else
                {
                    
                    //
                    // Split problem in X dimension
                    //
                    // NOTE: recursive calls to FastDDMFitLayer() compute
                    //       residuals in the inner cells defined by XYIndex[],
                    //       but we still have to compute residuals for cells
                    //       BETWEEN two recursive subdivisions of the task.
                    //
                    apserv.tiledsplit(tilex1-tilex0, 1, ref j0, ref j1, _params);
                    fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, tilex0, tilex0+j0, tilescountx, basecasey, tiley0, tiley1, tilescounty, maxcoresize, interfacesize, lsqrcnt, lambdareg, basis1, pool, spline, _params);
                    fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, tilex0+j0, tilex1, tilescountx, basecasey, tiley0, tiley1, tilescounty, maxcoresize, interfacesize, lsqrcnt, lambdareg, basis1, pool, spline, _params);
                }
                return;
            }
            alglib.ap.assert(tiley0==tiley1-1, "Spline2DFit.FastDDMFitLayer: integrity check failed");
            alglib.ap.assert(tilex0==tilex1-1, "Spline2DFit.FastDDMFitLayer: integrity check failed");
            tile1 = tiley0;
            tile0 = tilex0;
            
            //
            // Retrieve temporaries
            //
            alglib.smp.ae_shared_pool_retrieve(pool, ref buf);
            
            //
            // Analyze dataset
            //
            xa = apserv.iboundval(tile0*basecasex-interfacesize, 0, kx, _params);
            xb = apserv.iboundval((tile0+1)*basecasex+interfacesize, 0, kx, _params);
            ya = apserv.iboundval(tile1*basecasey-interfacesize, 0, ky, _params);
            yb = apserv.iboundval((tile1+1)*basecasey+interfacesize, 0, ky, _params);
            tilesize0 = xb-xa;
            tilesize1 = yb-ya;
            
            //
            // Solve current chunk with BlockLLS
            //
            dummytss = 1.0;
            xdesigngenerate(xy, xyindex, xa, xb, kx, ya, yb, ky, d, lambdareg, 0.0, basis1, buf.xdesignmatrix, _params);
            blockllsfit(buf.xdesignmatrix, lsqrcnt, ref buf.tmpz, buf.dummyrep, dummytss, buf.blockllsbuf, _params);
            buf.localmodel.d = d;
            buf.localmodel.m = tilesize1;
            buf.localmodel.n = tilesize0;
            buf.localmodel.stype = -3;
            apserv.rvectorsetlengthatleast(ref buf.localmodel.x, tilesize0, _params);
            apserv.rvectorsetlengthatleast(ref buf.localmodel.y, tilesize1, _params);
            apserv.rvectorsetlengthatleast(ref buf.localmodel.f, tilesize0*tilesize1*d*4, _params);
            for(i=0; i<=tilesize0-1; i++)
            {
                buf.localmodel.x[i] = xa+i;
            }
            for(i=0; i<=tilesize1-1; i++)
            {
                buf.localmodel.y[i] = ya+i;
            }
            for(i=0; i<=tilesize0*tilesize1*d*4-1; i++)
            {
                buf.localmodel.f[i] = 0.0;
            }
            updatesplinetable(buf.tmpz, tilesize0, tilesize1, d, basis1, bfrad, buf.localmodel.f, tilesize1, tilesize0, 1, _params);
            
            //
            // Transform local spline to original coordinates
            //
            sfx = buf.localmodel.n*buf.localmodel.m*d;
            sfy = 2*buf.localmodel.n*buf.localmodel.m*d;
            sfxy = 3*buf.localmodel.n*buf.localmodel.m*d;
            for(i=0; i<=tilesize0-1; i++)
            {
                buf.localmodel.x[i] = buf.localmodel.x[i]*scalexy;
            }
            for(i=0; i<=tilesize1-1; i++)
            {
                buf.localmodel.y[i] = buf.localmodel.y[i]*scalexy;
            }
            for(i=0; i<=tilesize0*tilesize1*d-1; i++)
            {
                buf.localmodel.f[sfx+i] = buf.localmodel.f[sfx+i]*invscalexy;
                buf.localmodel.f[sfy+i] = buf.localmodel.f[sfy+i]*invscalexy;
                buf.localmodel.f[sfxy+i] = buf.localmodel.f[sfxy+i]*(invscalexy*invscalexy);
            }
            
            //
            // Output results; for inner and topmost/leftmost tiles we output only BasecaseX*BasecaseY
            // inner elements; for rightmost/bottom ones we also output one column/row of the interface
            // part.
            //
            // Such complexity is explained by the fact that area size (by design) is not evenly divisible
            // by the tile size; it is divisible with remainder=1, and we expect that interface size is
            // at least 1, so we can fill the missing rightmost/bottom elements of Z by the interface
            // values.
            //
            alglib.ap.assert(interfacesize>=1, "Spline2DFit: integrity check failed");
            sfx = spline.n*spline.m*d;
            sfy = 2*spline.n*spline.m*d;
            sfxy = 3*spline.n*spline.m*d;
            cnt0 = basecasex*scalexy;
            cnt1 = basecasey*scalexy;
            if( tile0==tilescountx-1 )
            {
                apserv.inc(ref cnt0, _params);
            }
            if( tile1==tilescounty-1 )
            {
                apserv.inc(ref cnt1, _params);
            }
            offs = d*(spline.n*tile1*basecasey*scalexy+tile0*basecasex*scalexy);
            for(j1=0; j1<=cnt1-1; j1++)
            {
                for(j0=0; j0<=cnt0-1; j0++)
                {
                    for(j=0; j<=d-1; j++)
                    {
                        spline2ddiffvi(buf.localmodel, tile0*basecasex*scalexy+j0, tile1*basecasey*scalexy+j1, j, ref vs, ref vsx, ref vsy, ref vsxy, _params);
                        spline.f[offs+d*(spline.n*j1+j0)+j] = spline.f[offs+d*(spline.n*j1+j0)+j]+vs;
                        spline.f[sfx+offs+d*(spline.n*j1+j0)+j] = spline.f[sfx+offs+d*(spline.n*j1+j0)+j]+vsx;
                        spline.f[sfy+offs+d*(spline.n*j1+j0)+j] = spline.f[sfy+offs+d*(spline.n*j1+j0)+j]+vsy;
                        spline.f[sfxy+offs+d*(spline.n*j1+j0)+j] = spline.f[sfxy+offs+d*(spline.n*j1+j0)+j]+vsxy;
                    }
                }
            }
            
            //
            // Recycle temporaries
            //
            alglib.smp.ae_shared_pool_recycle(pool, ref buf);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_fastddmfitlayer(double[] xy,
            int d,
            int scalexy,
            int[] xyindex,
            int basecasex,
            int tilex0,
            int tilex1,
            int tilescountx,
            int basecasey,
            int tiley0,
            int tiley1,
            int tilescounty,
            int maxcoresize,
            int interfacesize,
            int lsqrcnt,
            double lambdareg,
            spline1d.spline1dinterpolant basis1,
            alglib.smp.shared_pool pool,
            spline2dinterpolant spline, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function performs fitting with  BlockLLS solver.  Internal  function,
        never use it directly.

        IMPORTANT: performance  and  memory  requirements  of  this  function  are
                   asymmetric w.r.t. KX and KY: it has
                   * O(KY*KX^2) memory requirements
                   * O(KY*KX^3) running time
                   Thus, if you have large KY and small KX,  simple  transposition
                   of your dataset may give you great speedup.

        INPUT PARAMETERS:
            AV      -   sparse matrix, [ARows,KX*KY] in size.  "Vertical"  version
                        of design matrix, rows [0,NPoints) contain values of basis
                        functions at dataset  points.  Other  rows  are  used  for
                        nonlinearity penalty and other stuff like that.
            AH      -   transpose(AV), "horizontal" version of AV
            ARows   -   rows count
            XY      -   array[NPoints*(2+D)], dataset
            KX, KY  -   grid size
            NPoints -   points count
            D       -   number of components in vector-valued spline, D>=1
            LSQRCnt -   number of iterations, non-zero:
                        * LSQRCnt>0 means that specified amount of  preconditioned
                          LSQR  iterations  will  be  performed  to solve problem;
                          usually  we  need  2..5  its.  Recommended option - best
                          convergence and stability/quality.
                        * LSQRCnt<0 means that instead of LSQR  we  use  iterative
                          refinement on normal equations. Again, 2..5 its is enough.
            Z       -   possibly preallocated buffer for solution
            Rep     -   report structure; fields which are not set by this function
                        are left intact
            TSS     -   total sum of squares; used to calculate R2
            

        OUTPUT PARAMETERS:
            XY      -   destroyed in process
            Z       -   array[KX*KY*D], filled by solution; KX*KY coefficients
                        corresponding to each of D dimensions are stored contiguously.
            Rep         -   following fields are set:
                            * Rep.RMSError
                            * Rep.AvgError
                            * Rep.MaxError
                            * Rep.R2

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void blockllsfit(spline2dxdesignmatrix xdesign,
            int lsqrcnt,
            ref double[] z,
            spline2dfitreport rep,
            double tss,
            spline2dblockllsbuf buf,
            alglib.xparams _params)
        {
            int blockbandwidth = 0;
            int d = 0;
            int i = 0;
            int j = 0;
            double lambdachol = 0;
            apserv.sreal mxata = new apserv.sreal();
            double v = 0;
            int celloffset = 0;
            int i0 = 0;
            int i1 = 0;
            double rss = 0;
            int arows = 0;
            int bw2 = 0;
            int kx = 0;
            int ky = 0;

            alglib.ap.assert(xdesign.blockwidth==4, "Spline2DFit: integrity check failed");
            blockbandwidth = 3;
            d = xdesign.d;
            arows = xdesign.nrows;
            kx = xdesign.kx;
            ky = xdesign.ky;
            bw2 = xdesign.blockwidth*xdesign.blockwidth;
            
            //
            // Initial values for Z/Residuals
            //
            apserv.rvectorsetlengthatleast(ref z, kx*ky*d, _params);
            for(i=0; i<=kx*ky*d-1; i++)
            {
                z[i] = 0;
            }
            
            //
            // Create and factorize design matrix. Add regularizer if
            // factorization failed (happens sometimes with zero
            // smoothing and sparsely populated datasets).
            //
            // The algorithm below is refactoring of NaiveLLS algorithm,
            // which uses sparsity properties and compressed block storage.
            //
            // Problem sparsity pattern results in block-band-diagonal
            // matrix (block matrix with limited bandwidth, equal to 3
            // for bicubic splines). Thus, we have KY*KY blocks, each
            // of them is KX*KX in size. Design matrix is stored in
            // large NROWS*KX matrix, with NROWS=(BlockBandwidth+1)*KY*KX.
            //
            // We use adaptation of block skyline storage format, with
            // TOWERSIZE*KX skyline bands (towers) stored sequentially;
            // here TOWERSIZE=(BlockBandwidth+1)*KX. So, we have KY
            // "towers", stored one below other, in BlockATA matrix.
            // Every "tower" is a sequence of BlockBandwidth+1 cells,
            // each of them being KX*KX in size.
            //
            lambdachol = cholreg;
            apserv.rmatrixsetlengthatleast(ref buf.blockata, (blockbandwidth+1)*ky*kx, kx, _params);
            while( true )
            {
                
                //
                // Parallel generation of squared design matrix.
                //
                xdesignblockata(xdesign, buf.blockata, ref mxata.val, _params);
                
                //
                // Regularization
                //
                v = apserv.coalesce(mxata.val, 1.0, _params)*lambdachol;
                for(i1=0; i1<=ky-1; i1++)
                {
                    celloffset = getcelloffset(kx, ky, blockbandwidth, i1, i1, _params);
                    for(i0=0; i0<=kx-1; i0++)
                    {
                        buf.blockata[celloffset+i0,i0] = buf.blockata[celloffset+i0,i0]+v;
                    }
                }
                
                //
                // Try Cholesky factorization.
                //
                if( !blockllscholesky(buf.blockata, kx, ky, ref buf.trsmbuf2, ref buf.cholbuf2, ref buf.cholbuf1, _params) )
                {
                    
                    //
                    // Factorization failed, increase regularizer and repeat
                    //
                    lambdachol = apserv.coalesce(10*lambdachol, 1.0E-12, _params);
                    continue;
                }
                break;
            }
            
            //
            // Solve
            //
            rss = 0.0;
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.maxerror = 0;
            alglib.ap.assert(lsqrcnt>0, "Spline2DFit: integrity failure");
            apserv.rvectorsetlengthatleast(ref buf.tmp0, arows, _params);
            apserv.rvectorsetlengthatleast(ref buf.tmp1, kx*ky, _params);
            linlsqr.linlsqrcreatebuf(arows, kx*ky, buf.solver, _params);
            for(j=0; j<=d-1; j++)
            {
                
                //
                // Preconditioned LSQR:
                //
                // use Cholesky factor U of squared design matrix A'*A to
                // transform min|A*x-b| to min|[A*inv(U)]*y-b| with y=U*x.
                //
                // Preconditioned problem is solved with LSQR solver, which
                // gives superior results than normal equations.
                //
                for(i=0; i<=arows-1; i++)
                {
                    if( i<xdesign.npoints )
                    {
                        buf.tmp0[i] = xdesign.vals[i,bw2+j];
                    }
                    else
                    {
                        buf.tmp0[i] = 0.0;
                    }
                }
                linlsqr.linlsqrrestart(buf.solver, _params);
                linlsqr.linlsqrsetb(buf.solver, buf.tmp0, _params);
                linlsqr.linlsqrsetcond(buf.solver, 1.0E-14, 1.0E-14, lsqrcnt, _params);
                while( linlsqr.linlsqriteration(buf.solver, _params) )
                {
                    if( buf.solver.needmv )
                    {
                        
                        //
                        // Use Cholesky factorization of the system matrix
                        // as preconditioner: solve TRSV(U,Solver.X)
                        //
                        for(i=0; i<=kx*ky-1; i++)
                        {
                            buf.tmp1[i] = buf.solver.x[i];
                        }
                        blockllstrsv(buf.blockata, kx, ky, false, buf.tmp1, _params);
                        
                        //
                        // After preconditioning is done, multiply by A
                        //
                        xdesignmv(xdesign, buf.tmp1, ref buf.solver.mv, _params);
                    }
                    if( buf.solver.needmtv )
                    {
                        
                        //
                        // Multiply by design matrix A
                        //
                        xdesignmtv(xdesign, buf.solver.x, ref buf.solver.mtv, _params);
                        
                        //
                        // Multiply by preconditioner: solve TRSV(U',A*Solver.X)
                        //
                        blockllstrsv(buf.blockata, kx, ky, true, buf.solver.mtv, _params);
                    }
                }
                
                //
                // Get results and post-multiply by preconditioner to get
                // original variables.
                //
                linlsqr.linlsqrresults(buf.solver, ref buf.tmp1, buf.solverrep, _params);
                blockllstrsv(buf.blockata, kx, ky, false, buf.tmp1, _params);
                for(i=0; i<=kx*ky-1; i++)
                {
                    z[kx*ky*j+i] = buf.tmp1[i];
                }
                
                //
                // Calculate model values
                //
                xdesignmv(xdesign, buf.tmp1, ref buf.tmp0, _params);
                for(i=0; i<=xdesign.npoints-1; i++)
                {
                    v = xdesign.vals[i,bw2+j]-buf.tmp0[i];
                    rss = rss+v*v;
                    rep.rmserror = rep.rmserror+math.sqr(v);
                    rep.avgerror = rep.avgerror+Math.Abs(v);
                    rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v));
                }
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/apserv.coalesce(xdesign.npoints*d, 1.0, _params));
            rep.avgerror = rep.avgerror/apserv.coalesce(xdesign.npoints*d, 1.0, _params);
            rep.r2 = 1.0-rss/apserv.coalesce(tss, 1.0, _params);
        }


        /*************************************************************************
        This function performs fitting with  NaiveLLS solver.  Internal  function,
        never use it directly.

        INPUT PARAMETERS:
            AV      -   sparse matrix, [ARows,KX*KY] in size.  "Vertical"  version
                        of design matrix, rows [0,NPoints] contain values of basis
                        functions at dataset  points.  Other  rows  are  used  for
                        nonlinearity penalty and other stuff like that.
            AH      -   transpose(AV), "horizontal" version of AV
            ARows   -   rows count
            XY      -   array[NPoints*(2+D)], dataset
            KX, KY  -   grid size
            NPoints -   points count
            D       -   number of components in vector-valued spline, D>=1
            LSQRCnt -   number of iterations, non-zero:
                        * LSQRCnt>0 means that specified amount of  preconditioned
                          LSQR  iterations  will  be  performed  to solve problem;
                          usually  we  need  2..5  its.  Recommended option - best
                          convergence and stability/quality.
                        * LSQRCnt<0 means that instead of LSQR  we  use  iterative
                          refinement on normal equations. Again, 2..5 its is enough.
            Z       -   possibly preallocated buffer for solution
            Rep     -   report structure; fields which are not set by this function
                        are left intact
            TSS     -   total sum of squares; used to calculate R2
            

        OUTPUT PARAMETERS:
            XY      -   destroyed in process
            Z       -   array[KX*KY*D], filled by solution; KX*KY coefficients
                        corresponding to each of D dimensions are stored contiguously.
            Rep     -   following fields are set:
                            * Rep.RMSError
                            * Rep.AvgError
                            * Rep.MaxError
                            * Rep.R2

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void naivellsfit(sparse.sparsematrix av,
            sparse.sparsematrix ah,
            int arows,
            double[] xy,
            int kx,
            int ky,
            int npoints,
            int d,
            int lsqrcnt,
            ref double[] z,
            spline2dfitreport rep,
            double tss,
            alglib.xparams _params)
        {
            int ew = 0;
            int i = 0;
            int j = 0;
            int i0 = 0;
            int i1 = 0;
            int j0 = 0;
            int j1 = 0;
            double v = 0;
            int blockbandwidth = 0;
            double lambdareg = 0;
            int srci = 0;
            int srcj = 0;
            int idxi = 0;
            int idxj = 0;
            int endi = 0;
            int endj = 0;
            int rfsidx = 0;
            double[,] ata = new double[0,0];
            double[] tmp0 = new double[0];
            double[] tmp1 = new double[0];
            double mxata = 0;
            linlsqr.linlsqrstate solver = new linlsqr.linlsqrstate();
            linlsqr.linlsqrreport solverrep = new linlsqr.linlsqrreport();
            double rss = 0;

            blockbandwidth = 3;
            ew = 2+d;
            
            //
            // Initial values for Z/Residuals
            //
            apserv.rvectorsetlengthatleast(ref z, kx*ky*d, _params);
            for(i=0; i<=kx*ky*d-1; i++)
            {
                z[i] = 0;
            }
            
            //
            // Create and factorize design matrix.
            //
            // Add regularizer if factorization failed (happens sometimes
            // with zero smoothing and sparsely populated datasets).
            //
            lambdareg = cholreg;
            apserv.rmatrixsetlengthatleast(ref ata, kx*ky, kx*ky, _params);
            while( true )
            {
                mxata = 0.0;
                for(i=0; i<=kx*ky-1; i++)
                {
                    for(j=i; j<=kx*ky-1; j++)
                    {
                        
                        //
                        // Initialize by zero
                        //
                        ata[i,j] = 0;
                        
                        //
                        // Determine grid nodes corresponding to I and J;
                        // skip if too far away
                        //
                        i0 = i%kx;
                        i1 = i/kx;
                        j0 = j%kx;
                        j1 = j/kx;
                        if( Math.Abs(i0-j0)>blockbandwidth || Math.Abs(i1-j1)>blockbandwidth )
                        {
                            continue;
                        }
                        
                        //
                        // Nodes are close enough, calculate product of columns I and J of A.
                        //
                        v = 0;
                        srci = ah.ridx[i];
                        srcj = ah.ridx[j];
                        endi = ah.ridx[i+1];
                        endj = ah.ridx[j+1];
                        while( true )
                        {
                            if( srci>=endi || srcj>=endj )
                            {
                                break;
                            }
                            idxi = ah.idx[srci];
                            idxj = ah.idx[srcj];
                            if( idxi==idxj )
                            {
                                v = v+ah.vals[srci]*ah.vals[srcj];
                                srci = srci+1;
                                srcj = srcj+1;
                                continue;
                            }
                            if( idxi<idxj )
                            {
                                srci = srci+1;
                            }
                            else
                            {
                                srcj = srcj+1;
                            }
                        }
                        ata[i,j] = v;
                        mxata = Math.Max(mxata, Math.Abs(v));
                    }
                }
                v = apserv.coalesce(mxata, 1.0, _params)*lambdareg;
                for(i=0; i<=kx*ky-1; i++)
                {
                    ata[i,i] = ata[i,i]+v;
                }
                if( trfac.spdmatrixcholesky(ref ata, kx*ky, true, _params) )
                {
                    
                    //
                    // Success!
                    //
                    break;
                }
                
                //
                // Factorization failed, increase regularizer and repeat
                //
                lambdareg = apserv.coalesce(10*lambdareg, 1.0E-12, _params);
            }
            
            //
            // Solve
            //
            // NOTE: we expect that Z is zero-filled, and we treat it
            //       like initial approximation to solution.
            //
            apserv.rvectorsetlengthatleast(ref tmp0, arows, _params);
            apserv.rvectorsetlengthatleast(ref tmp1, kx*ky, _params);
            if( lsqrcnt>0 )
            {
                linlsqr.linlsqrcreate(arows, kx*ky, solver, _params);
            }
            for(j=0; j<=d-1; j++)
            {
                alglib.ap.assert(lsqrcnt!=0, "Spline2DFit: integrity failure");
                if( lsqrcnt>0 )
                {
                    
                    //
                    // Preconditioned LSQR:
                    //
                    // use Cholesky factor U of squared design matrix A'*A to
                    // transform min|A*x-b| to min|[A*inv(U)]*y-b| with y=U*x.
                    //
                    // Preconditioned problem is solved with LSQR solver, which
                    // gives superior results than normal equations.
                    //
                    linlsqr.linlsqrcreate(arows, kx*ky, solver, _params);
                    for(i=0; i<=arows-1; i++)
                    {
                        if( i<npoints )
                        {
                            tmp0[i] = xy[i*ew+2+j];
                        }
                        else
                        {
                            tmp0[i] = 0.0;
                        }
                    }
                    linlsqr.linlsqrsetb(solver, tmp0, _params);
                    linlsqr.linlsqrsetcond(solver, 1.0E-14, 1.0E-14, lsqrcnt, _params);
                    while( linlsqr.linlsqriteration(solver, _params) )
                    {
                        if( solver.needmv )
                        {
                            
                            //
                            // Use Cholesky factorization of the system matrix
                            // as preconditioner: solve TRSV(U,Solver.X)
                            //
                            for(i=0; i<=kx*ky-1; i++)
                            {
                                tmp1[i] = solver.x[i];
                            }
                            ablas.rmatrixtrsv(kx*ky, ata, 0, 0, true, false, 0, tmp1, 0, _params);
                            
                            //
                            // After preconditioning is done, multiply by A
                            //
                            sparse.sparsemv(av, tmp1, ref solver.mv, _params);
                        }
                        if( solver.needmtv )
                        {
                            
                            //
                            // Multiply by design matrix A
                            //
                            sparse.sparsemv(ah, solver.x, ref solver.mtv, _params);
                            
                            //
                            // Multiply by preconditioner: solve TRSV(U',A*Solver.X)
                            //
                            ablas.rmatrixtrsv(kx*ky, ata, 0, 0, true, false, 1, solver.mtv, 0, _params);
                        }
                    }
                    linlsqr.linlsqrresults(solver, ref tmp1, solverrep, _params);
                    ablas.rmatrixtrsv(kx*ky, ata, 0, 0, true, false, 0, tmp1, 0, _params);
                    for(i=0; i<=kx*ky-1; i++)
                    {
                        z[kx*ky*j+i] = tmp1[i];
                    }
                    
                    //
                    // Calculate model values
                    //
                    sparse.sparsemv(av, tmp1, ref tmp0, _params);
                    for(i=0; i<=npoints-1; i++)
                    {
                        xy[i*ew+2+j] = xy[i*ew+2+j]-tmp0[i];
                    }
                }
                else
                {
                    
                    //
                    // Iterative refinement, inferior to LSQR
                    //
                    // For each dimension D:
                    // * fetch current estimate for solution from Z to Tmp1
                    // * calculate residual r for current estimate, store in Tmp0
                    // * calculate product of residual and design matrix A'*r, store it in Tmp1
                    // * Cholesky solver
                    // * update current estimate
                    //
                    for(rfsidx=1; rfsidx<=-lsqrcnt; rfsidx++)
                    {
                        for(i=0; i<=kx*ky-1; i++)
                        {
                            tmp1[i] = z[kx*ky*j+i];
                        }
                        sparse.sparsemv(av, tmp1, ref tmp0, _params);
                        for(i=0; i<=arows-1; i++)
                        {
                            if( i<npoints )
                            {
                                v = xy[i*ew+2+j];
                            }
                            else
                            {
                                v = 0;
                            }
                            tmp0[i] = v-tmp0[i];
                        }
                        sparse.sparsemv(ah, tmp0, ref tmp1, _params);
                        ablas.rmatrixtrsv(kx*ky, ata, 0, 0, true, false, 1, tmp1, 0, _params);
                        ablas.rmatrixtrsv(kx*ky, ata, 0, 0, true, false, 0, tmp1, 0, _params);
                        for(i=0; i<=kx*ky-1; i++)
                        {
                            z[kx*ky*j+i] = z[kx*ky*j+i]+tmp1[i];
                        }
                    }
                    
                    //
                    // Calculate model values
                    //
                    for(i=0; i<=kx*ky-1; i++)
                    {
                        tmp1[i] = z[kx*ky*j+i];
                    }
                    sparse.sparsemv(av, tmp1, ref tmp0, _params);
                    for(i=0; i<=npoints-1; i++)
                    {
                        xy[i*ew+2+j] = xy[i*ew+2+j]-tmp0[i];
                    }
                }
            }
            
            //
            // Generate report
            //
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.maxerror = 0;
            rss = 0.0;
            for(i=0; i<=npoints-1; i++)
            {
                for(j=0; j<=d-1; j++)
                {
                    v = xy[i*ew+2+j];
                    rss = rss+v*v;
                    rep.rmserror = rep.rmserror+math.sqr(v);
                    rep.avgerror = rep.avgerror+Math.Abs(v);
                    rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v));
                }
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/apserv.coalesce(npoints*d, 1.0, _params));
            rep.avgerror = rep.avgerror/apserv.coalesce(npoints*d, 1.0, _params);
            rep.r2 = 1.0-rss/apserv.coalesce(tss, 1.0, _params);
        }


        /*************************************************************************
        This  is  convenience  function  for band block storage format; it returns
        offset of KX*KX-sized block (I,J) in a compressed 2D array.

        For specific offset=OFFSET,
        block (I,J) will be stored in entries BlockMatrix[OFFSET:OFFSET+KX-1,0:KX-1]

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static int getcelloffset(int kx,
            int ky,
            int blockbandwidth,
            int i,
            int j,
            alglib.xparams _params)
        {
            int result = 0;

            alglib.ap.assert(i>=0 && i<ky, "Spline2DFit: GetCellOffset() integrity error");
            alglib.ap.assert(j>=0 && j<ky, "Spline2DFit: GetCellOffset() integrity error");
            alglib.ap.assert(j>=i && j<=i+blockbandwidth, "Spline2DFit: GetCellOffset() integrity error");
            result = j*(blockbandwidth+1)*kx;
            result = result+(blockbandwidth-(j-i))*kx;
            return result;
        }


        /*************************************************************************
        This  is  convenience  function  for band block storage format; it  copies
        cell (I,J) from compressed format to uncompressed general matrix, at desired
        position.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void copycellto(int kx,
            int ky,
            int blockbandwidth,
            double[,] blockata,
            int i,
            int j,
            double[,] dst,
            int dst0,
            int dst1,
            alglib.xparams _params)
        {
            int celloffset = 0;
            int idx0 = 0;
            int idx1 = 0;

            celloffset = getcelloffset(kx, ky, blockbandwidth, i, j, _params);
            for(idx0=0; idx0<=kx-1; idx0++)
            {
                for(idx1=0; idx1<=kx-1; idx1++)
                {
                    dst[dst0+idx0,dst1+idx1] = blockata[celloffset+idx0,idx1];
                }
            }
        }


        /*************************************************************************
        This  is  convenience  function  for band block storage format; it
        truncates all elements of  cell (I,J) which are less than Eps in magnitude.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void flushtozerocell(int kx,
            int ky,
            int blockbandwidth,
            double[,] blockata,
            int i,
            int j,
            double eps,
            alglib.xparams _params)
        {
            int celloffset = 0;
            int idx0 = 0;
            int idx1 = 0;
            double eps2 = 0;
            double v = 0;

            celloffset = getcelloffset(kx, ky, blockbandwidth, i, j, _params);
            eps2 = eps*eps;
            for(idx0=0; idx0<=kx-1; idx0++)
            {
                for(idx1=0; idx1<=kx-1; idx1++)
                {
                    v = blockata[celloffset+idx0,idx1];
                    if( v*v<eps2 )
                    {
                        blockata[celloffset+idx0,idx1] = 0;
                    }
                }
            }
        }


        /*************************************************************************
        This function generates squared design matrix stored in block band format.

        We use adaptation of block skyline storage format, with
        TOWERSIZE*KX skyline bands (towers) stored sequentially;
        here TOWERSIZE=(BlockBandwidth+1)*KX. So, we have KY
        "towers", stored one below other, in BlockATA matrix.
        Every "tower" is a sequence of BlockBandwidth+1 cells,
        each of them being KX*KX in size.

        INPUT PARAMETERS:
            AH      -   sparse matrix, [KX*KY,ARows] in size. "Horizontal" version
                        of design matrix, cols [0,NPoints] contain values of basis
                        functions at dataset  points.  Other  cols  are  used  for
                        nonlinearity penalty and other stuff like that.
            KY0, KY1-   subset of output matrix bands to process; on entry it MUST
                        be set to 0 and KY respectively.
            KX, KY  -   grid size
            BlockATA-   array[KY*(BlockBandwidth+1)*KX,KX],  preallocated  storage
                        for output matrix in compressed block band format
            MXATA   -   on entry MUST be zero

        OUTPUT PARAMETERS:
            BlockATA-   AH*AH', stored in compressed block band format

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void blockllsgenerateata(sparse.sparsematrix ah,
            int ky0,
            int ky1,
            int kx,
            int ky,
            double[,] blockata,
            apserv.sreal mxata,
            alglib.xparams _params)
        {
            int blockbandwidth = 0;
            double avgrowlen = 0;
            double cellcost = 0;
            double totalcost = 0;
            apserv.sreal tmpmxata = new apserv.sreal();
            int i = 0;
            int j = 0;
            int i0 = 0;
            int i1 = 0;
            int j0 = 0;
            int j1 = 0;
            int celloffset = 0;
            double v = 0;
            int srci = 0;
            int srcj = 0;
            int idxi = 0;
            int idxj = 0;
            int endi = 0;
            int endj = 0;

            alglib.ap.assert((double)(mxata.val)>=(double)(0), "BlockLLSGenerateATA: integrity check failed");
            blockbandwidth = 3;
            
            //
            // Determine problem cost, perform recursive subdivision
            // (with optional parallelization)
            //
            avgrowlen = (double)ah.ridx[kx*ky]/(double)(kx*ky);
            cellcost = apserv.rmul3(kx, 1+2*blockbandwidth, avgrowlen, _params);
            totalcost = apserv.rmul3(ky1-ky0, 1+2*blockbandwidth, cellcost, _params);
            if( ky1-ky0>=2 && (double)(totalcost)>(double)(apserv.smpactivationlevel(_params)) )
            {
                if( _trypexec_blockllsgenerateata(ah,ky0,ky1,kx,ky,blockata,mxata, _params) )
                {
                    return;
                }
            }
            if( ky1-ky0>=2 )
            {
                
                //
                // Split X: X*A = (X1 X2)^T*A
                //
                j = (ky1-ky0)/2;
                blockllsgenerateata(ah, ky0, ky0+j, kx, ky, blockata, tmpmxata, _params);
                blockllsgenerateata(ah, ky0+j, ky1, kx, ky, blockata, mxata, _params);
                mxata.val = Math.Max(mxata.val, tmpmxata.val);
                return;
            }
            
            //
            // Splitting in Y-dimension is done, fill I1-th "tower"
            //
            alglib.ap.assert(ky1==ky0+1, "BlockLLSGenerateATA: integrity check failed");
            i1 = ky0;
            for(j1=i1; j1<=Math.Min(ky-1, i1+blockbandwidth); j1++)
            {
                celloffset = getcelloffset(kx, ky, blockbandwidth, i1, j1, _params);
                
                //
                // Clear cell (I1,J1)
                //
                for(i0=0; i0<=kx-1; i0++)
                {
                    for(j0=0; j0<=kx-1; j0++)
                    {
                        blockata[celloffset+i0,j0] = 0.0;
                    }
                }
                
                //
                // Initialize cell internals
                //
                for(i0=0; i0<=kx-1; i0++)
                {
                    for(j0=0; j0<=kx-1; j0++)
                    {
                        if( Math.Abs(i0-j0)<=blockbandwidth )
                        {
                            
                            //
                            // Nodes are close enough, calculate product of columns I and J of A.
                            //
                            v = 0;
                            i = i1*kx+i0;
                            j = j1*kx+j0;
                            srci = ah.ridx[i];
                            srcj = ah.ridx[j];
                            endi = ah.ridx[i+1];
                            endj = ah.ridx[j+1];
                            while( true )
                            {
                                if( srci>=endi || srcj>=endj )
                                {
                                    break;
                                }
                                idxi = ah.idx[srci];
                                idxj = ah.idx[srcj];
                                if( idxi==idxj )
                                {
                                    v = v+ah.vals[srci]*ah.vals[srcj];
                                    srci = srci+1;
                                    srcj = srcj+1;
                                    continue;
                                }
                                if( idxi<idxj )
                                {
                                    srci = srci+1;
                                }
                                else
                                {
                                    srcj = srcj+1;
                                }
                            }
                            blockata[celloffset+i0,j0] = v;
                            mxata.val = Math.Max(mxata.val, Math.Abs(v));
                        }
                    }
                }
            }
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_blockllsgenerateata(sparse.sparsematrix ah,
            int ky0,
            int ky1,
            int kx,
            int ky,
            double[,] blockata,
            apserv.sreal mxata, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function performs Cholesky decomposition of squared design matrix
        stored in block band format.

        INPUT PARAMETERS:
            BlockATA        -   array[KY*(BlockBandwidth+1)*KX,KX], matrix in compressed
                                block band format
            KX, KY          -   grid size
            TrsmBuf2,
            CholBuf2,
            CholBuf1        -   buffers; reused by this function on subsequent calls,
                                automatically preallocated on the first call

        OUTPUT PARAMETERS:
            BlockATA-   Cholesky factor, in compressed block band format

        Result:
            True on success, False on Cholesky failure

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static bool blockllscholesky(double[,] blockata,
            int kx,
            int ky,
            ref double[,] trsmbuf2,
            ref double[,] cholbuf2,
            ref double[] cholbuf1,
            alglib.xparams _params)
        {
            bool result = new bool();
            int blockbandwidth = 0;
            int blockidx = 0;
            int i = 0;
            int j = 0;
            int celloffset = 0;
            int celloffset1 = 0;

            blockbandwidth = 3;
            apserv.rmatrixsetlengthatleast(ref trsmbuf2, (blockbandwidth+1)*kx, (blockbandwidth+1)*kx, _params);
            apserv.rmatrixsetlengthatleast(ref cholbuf2, kx, kx, _params);
            apserv.rvectorsetlengthatleast(ref cholbuf1, kx, _params);
            result = true;
            for(blockidx=0; blockidx<=ky-1; blockidx++)
            {
                
                //
                // TRSM for TRAIL*TRAIL block matrix before current cell;
                // here TRAIL=MinInt(BlockIdx,BlockBandwidth).
                //
                for(i=0; i<=Math.Min(blockidx, blockbandwidth)-1; i++)
                {
                    for(j=i; j<=Math.Min(blockidx, blockbandwidth)-1; j++)
                    {
                        copycellto(kx, ky, blockbandwidth, blockata, Math.Max(blockidx-blockbandwidth, 0)+i, Math.Max(blockidx-blockbandwidth, 0)+j, trsmbuf2, i*kx, j*kx, _params);
                    }
                }
                celloffset = getcelloffset(kx, ky, blockbandwidth, Math.Max(blockidx-blockbandwidth, 0), blockidx, _params);
                ablas.rmatrixlefttrsm(Math.Min(blockidx, blockbandwidth)*kx, kx, trsmbuf2, 0, 0, true, false, 1, blockata, celloffset, 0, _params);
                
                //
                // SYRK for diagonal cell: MaxInt(BlockIdx-BlockBandwidth,0)
                // cells above diagonal one are used for update.
                //
                celloffset = getcelloffset(kx, ky, blockbandwidth, Math.Max(blockidx-blockbandwidth, 0), blockidx, _params);
                celloffset1 = getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx, _params);
                ablas.rmatrixsyrk(kx, Math.Min(blockidx, blockbandwidth)*kx, -1.0, blockata, celloffset, 0, 1, 1.0, blockata, celloffset1, 0, true, _params);
                
                //
                // Factorize diagonal cell
                //
                celloffset = getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx, _params);
                ablas.rmatrixcopy(kx, kx, blockata, celloffset, 0, cholbuf2, 0, 0, _params);
                if( !trfac.spdmatrixcholeskyrec(ref cholbuf2, 0, kx, true, ref cholbuf1, _params) )
                {
                    result = false;
                    return result;
                }
                ablas.rmatrixcopy(kx, kx, cholbuf2, 0, 0, blockata, celloffset, 0, _params);
                
                //
                // PERFORMANCE TWEAK: drop nearly-denormals from last "tower".
                //
                // Sparse matrices like these may produce denormal numbers on
                // sparse datasets, with significant (10x!) performance penalty
                // on Intel chips. In order to avoid it, we manually truncate
                // small enough numbers.
                //
                // We use 1.0E-50 as clipping level (not really denormal, but
                // such small numbers are not actually important anyway).
                //
                for(i=Math.Max(blockidx-blockbandwidth, 0); i<=blockidx; i++)
                {
                    flushtozerocell(kx, ky, blockbandwidth, blockata, i, blockidx, 1.0E-50, _params);
                }
            }
            return result;
        }


        /*************************************************************************
        This function performs TRSV on upper triangular Cholesky factor U, solving
        either U*x=b or U'*x=b.

        INPUT PARAMETERS:
            BlockATA        -   array[KY*(BlockBandwidth+1)*KX,KX], matrix U
                                in compressed block band format
            KX, KY          -   grid size
            TransU          -   whether to transpose U or not
            B               -   array[KX*KY], on entry - stores right part B

        OUTPUT PARAMETERS:
            B               -   replaced by X

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void blockllstrsv(double[,] blockata,
            int kx,
            int ky,
            bool transu,
            double[] b,
            alglib.xparams _params)
        {
            int blockbandwidth = 0;
            int blockidx = 0;
            int blockidx1 = 0;
            int celloffset = 0;

            blockbandwidth = 3;
            if( !transu )
            {
                
                //
                // Solve U*x=b
                //
                for(blockidx=ky-1; blockidx>=0; blockidx--)
                {
                    for(blockidx1=1; blockidx1<=Math.Min(ky-(blockidx+1), blockbandwidth); blockidx1++)
                    {
                        celloffset = getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx+blockidx1, _params);
                        ablas.rmatrixgemv(kx, kx, -1.0, blockata, celloffset, 0, 0, b, (blockidx+blockidx1)*kx, 1.0, b, blockidx*kx, _params);
                    }
                    celloffset = getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx, _params);
                    ablas.rmatrixtrsv(kx, blockata, celloffset, 0, true, false, 0, b, blockidx*kx, _params);
                }
            }
            else
            {
                
                //
                // Solve U'*x=b
                //
                for(blockidx=0; blockidx<=ky-1; blockidx++)
                {
                    celloffset = getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx, _params);
                    ablas.rmatrixtrsv(kx, blockata, celloffset, 0, true, false, 1, b, blockidx*kx, _params);
                    for(blockidx1=1; blockidx1<=Math.Min(ky-(blockidx+1), blockbandwidth); blockidx1++)
                    {
                        celloffset = getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx+blockidx1, _params);
                        ablas.rmatrixgemv(kx, kx, -1.0, blockata, celloffset, 0, 1, b, blockidx*kx, 1.0, b, (blockidx+blockidx1)*kx, _params);
                    }
                }
            }
        }


        /*************************************************************************
        This function computes residuals for dataset XY[], using array of original
        values YRaw[], and loads residuals to XY.

        Processing is performed in parallel manner.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void computeresidualsfromscratch(double[] xy,
            double[] yraw,
            int npoints,
            int d,
            int scalexy,
            spline2dinterpolant spline,
            alglib.xparams _params)
        {
            apserv.srealarray seed = new apserv.srealarray();
            alglib.smp.shared_pool pool = new alglib.smp.shared_pool();
            int chunksize = 0;
            double pointcost = 0;

            
            //
            // Setting up
            //
            chunksize = 1000;
            pointcost = 100.0;
            if( (double)(npoints*pointcost)>(double)(apserv.smpactivationlevel(_params)) )
            {
                if( _trypexec_computeresidualsfromscratch(xy,yraw,npoints,d,scalexy,spline, _params) )
                {
                    return;
                }
            }
            alglib.smp.ae_shared_pool_set_seed(pool, seed);
            
            //
            // Call compute workhorse
            //
            computeresidualsfromscratchrec(xy, yraw, 0, npoints, chunksize, d, scalexy, spline, pool, _params);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_computeresidualsfromscratch(double[] xy,
            double[] yraw,
            int npoints,
            int d,
            int scalexy,
            spline2dinterpolant spline, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        Recursive workhorse for ComputeResidualsFromScratch.

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void computeresidualsfromscratchrec(double[] xy,
            double[] yraw,
            int pt0,
            int pt1,
            int chunksize,
            int d,
            int scalexy,
            spline2dinterpolant spline,
            alglib.smp.shared_pool pool,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            apserv.srealarray pbuf = null;
            int xew = 0;

            xew = 2+d;
            
            //
            // Parallelism
            //
            if( pt1-pt0>chunksize )
            {
                apserv.tiledsplit(pt1-pt0, chunksize, ref i, ref j, _params);
                computeresidualsfromscratchrec(xy, yraw, pt0, pt0+i, chunksize, d, scalexy, spline, pool, _params);
                computeresidualsfromscratchrec(xy, yraw, pt0+i, pt1, chunksize, d, scalexy, spline, pool, _params);
                return;
            }
            
            //
            // Serial execution
            //
            alglib.smp.ae_shared_pool_retrieve(pool, ref pbuf);
            for(i=pt0; i<=pt1-1; i++)
            {
                spline2dcalcvbuf(spline, xy[i*xew+0]*scalexy, xy[i*xew+1]*scalexy, ref pbuf.val, _params);
                for(j=0; j<=d-1; j++)
                {
                    xy[i*xew+2+j] = yraw[i*d+j]-pbuf.val[j];
                }
            }
            alglib.smp.ae_shared_pool_recycle(pool, ref pbuf);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_computeresidualsfromscratchrec(double[] xy,
            double[] yraw,
            int pt0,
            int pt1,
            int chunksize,
            int d,
            int scalexy,
            spline2dinterpolant spline,
            alglib.smp.shared_pool pool, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function reorders dataset and builds index:
        * it is assumed that all points have X in [0,KX-1], Y in [0,KY-1]
        * area is divided into (KX-1)*(KY-1) cells
        * all points are reordered in such way that points in same cell are stored
          contiguously
        * dataset index, array[(KX-1)*(KY-1)+1], is generated. Points of cell I
          now have indexes XYIndex[I]..XYIndex[I+1]-1;

        INPUT PARAMETERS:
            XY              -   array[NPoints*(2+D)], dataset
            KX, KY, D       -   grid size and dimensionality of the outputs
            Shadow          -   shadow array[NPoints*NS], which is sorted together
                                with XY; if NS=0, it is not referenced at all.
            NS              -   entry width of shadow array
            BufI            -   possibly preallocated temporary buffer; resized if
                                needed.

        OUTPUT PARAMETERS:
            XY              -   reordered
            XYIndex         -   array[(KX-1)*(KY-1)+1], dataset index

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void reorderdatasetandbuildindex(double[] xy,
            int npoints,
            int d,
            double[] shadow,
            int ns,
            int kx,
            int ky,
            ref int[] xyindex,
            ref int[] bufi,
            alglib.xparams _params)
        {
            int i = 0;
            int i0 = 0;
            int i1 = 0;
            int entrywidth = 0;

            
            //
            // Set up
            //
            alglib.ap.assert(kx>=2, "Spline2DFit.ReorderDatasetAndBuildIndex: integrity check failed");
            alglib.ap.assert(ky>=2, "Spline2DFit.ReorderDatasetAndBuildIndex: integrity check failed");
            entrywidth = 2+d;
            apserv.ivectorsetlengthatleast(ref xyindex, (kx-1)*(ky-1)+1, _params);
            apserv.ivectorsetlengthatleast(ref bufi, npoints, _params);
            for(i=0; i<=npoints-1; i++)
            {
                i0 = apserv.iboundval((int)Math.Floor(xy[i*entrywidth+0]), 0, kx-2, _params);
                i1 = apserv.iboundval((int)Math.Floor(xy[i*entrywidth+1]), 0, ky-2, _params);
                bufi[i] = i1*(kx-1)+i0;
            }
            
            //
            // Reorder
            //
            reorderdatasetandbuildindexrec(xy, d, shadow, ns, bufi, 0, npoints, xyindex, 0, (kx-1)*(ky-1), true, _params);
            xyindex[(kx-1)*(ky-1)] = npoints;
        }


        /*************************************************************************
        This function multiplies all points in dataset by 2.0 and rebuilds  index,
        given previous index built for KX_prev=(KX-1)/2 and KY_prev=(KY-1)/2

        INPUT PARAMETERS:
            XY              -   array[NPoints*(2+D)], dataset BEFORE scaling
            NPoints, D      -   dataset size and dimensionality of the outputs
            Shadow          -   shadow array[NPoints*NS], which is sorted together
                                with XY; if NS=0, it is not referenced at all.
            NS              -   entry width of shadow array
            KX, KY          -   new grid dimensionality
            XYIndex         -   index built for previous values of KX and KY
            BufI            -   possibly preallocated temporary buffer; resized if
                                needed.

        OUTPUT PARAMETERS:
            XY              -   reordered and multiplied by 2.0
            XYIndex         -   array[(KX-1)*(KY-1)+1], dataset index

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void rescaledatasetandrefineindex(double[] xy,
            int npoints,
            int d,
            double[] shadow,
            int ns,
            int kx,
            int ky,
            ref int[] xyindex,
            ref int[] bufi,
            alglib.xparams _params)
        {
            int[] xyindexprev = new int[0];

            
            //
            // Set up
            //
            alglib.ap.assert(kx>=2, "Spline2DFit.RescaleDataset2AndRefineIndex: integrity check failed");
            alglib.ap.assert(ky>=2, "Spline2DFit.RescaleDataset2AndRefineIndex: integrity check failed");
            alglib.ap.assert((kx-1)%2==0, "Spline2DFit.RescaleDataset2AndRefineIndex: integrity check failed");
            alglib.ap.assert((ky-1)%2==0, "Spline2DFit.RescaleDataset2AndRefineIndex: integrity check failed");
            alglib.ap.swap(ref xyindex, ref xyindexprev);
            apserv.ivectorsetlengthatleast(ref xyindex, (kx-1)*(ky-1)+1, _params);
            apserv.ivectorsetlengthatleast(ref bufi, npoints, _params);
            
            //
            // Refine
            //
            expandindexrows(xy, d, shadow, ns, bufi, 0, npoints, xyindexprev, 0, (ky+1)/2-1, xyindex, kx, ky, true, _params);
            xyindex[(kx-1)*(ky-1)] = npoints;
            
            //
            // Integrity check
            //
        }


        /*************************************************************************
        Recurrent divide-and-conquer indexing function

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void expandindexrows(double[] xy,
            int d,
            double[] shadow,
            int ns,
            int[] cidx,
            int pt0,
            int pt1,
            int[] xyindexprev,
            int row0,
            int row1,
            int[] xyindexnew,
            int kxnew,
            int kynew,
            bool rootcall,
            alglib.xparams _params)
        {
            int i = 0;
            int entrywidth = 0;
            int kxprev = 0;
            double v = 0;
            int i0 = 0;
            int i1 = 0;
            double efficiency = 0;
            double cost = 0;
            int rowmid = 0;

            kxprev = (kxnew+1)/2;
            entrywidth = 2+d;
            efficiency = 0.1;
            cost = d*(pt1-pt0+1)*(Math.Log(kxnew)/Math.Log(2))/efficiency;
            alglib.ap.assert(xyindexprev[row0*(kxprev-1)+0]==pt0, "Spline2DFit.ExpandIndexRows: integrity check failed");
            alglib.ap.assert(xyindexprev[row1*(kxprev-1)+0]==pt1, "Spline2DFit.ExpandIndexRows: integrity check failed");
            
            //
            // Parallelism
            //
            if( ((rootcall && pt1-pt0>10000) && row1-row0>=2) && (double)(cost)>(double)(apserv.smpactivationlevel(_params)) )
            {
                if( _trypexec_expandindexrows(xy,d,shadow,ns,cidx,pt0,pt1,xyindexprev,row0,row1,xyindexnew,kxnew,kynew,rootcall, _params) )
                {
                    return;
                }
            }
            
            //
            // Partition
            //
            if( row1-row0>=2 )
            {
                apserv.tiledsplit(row1-row0, 1, ref i0, ref i1, _params);
                rowmid = row0+i0;
                expandindexrows(xy, d, shadow, ns, cidx, pt0, xyindexprev[rowmid*(kxprev-1)+0], xyindexprev, row0, rowmid, xyindexnew, kxnew, kynew, false, _params);
                expandindexrows(xy, d, shadow, ns, cidx, xyindexprev[rowmid*(kxprev-1)+0], pt1, xyindexprev, rowmid, row1, xyindexnew, kxnew, kynew, false, _params);
                return;
            }
            
            //
            // Serial execution
            //
            for(i=pt0; i<=pt1-1; i++)
            {
                v = 2*xy[i*entrywidth+0];
                xy[i*entrywidth+0] = v;
                i0 = apserv.iboundval((int)Math.Floor(v), 0, kxnew-2, _params);
                v = 2*xy[i*entrywidth+1];
                xy[i*entrywidth+1] = v;
                i1 = apserv.iboundval((int)Math.Floor(v), 0, kynew-2, _params);
                cidx[i] = i1*(kxnew-1)+i0;
            }
            reorderdatasetandbuildindexrec(xy, d, shadow, ns, cidx, pt0, pt1, xyindexnew, 2*row0*(kxnew-1)+0, 2*row1*(kxnew-1)+0, false, _params);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_expandindexrows(double[] xy,
            int d,
            double[] shadow,
            int ns,
            int[] cidx,
            int pt0,
            int pt1,
            int[] xyindexprev,
            int row0,
            int row1,
            int[] xyindexnew,
            int kxnew,
            int kynew,
            bool rootcall, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        Recurrent divide-and-conquer indexing function

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void reorderdatasetandbuildindexrec(double[] xy,
            int d,
            double[] shadow,
            int ns,
            int[] cidx,
            int pt0,
            int pt1,
            int[] xyindex,
            int idx0,
            int idx1,
            bool rootcall,
            alglib.xparams _params)
        {
            int entrywidth = 0;
            int idxmid = 0;
            int wrk0 = 0;
            int wrk1 = 0;
            double efficiency = 0;
            double cost = 0;

            
            //
            // Efficiency - performance of the code when compared with that
            // of linear algebra code.
            //
            entrywidth = 2+d;
            efficiency = 0.1;
            cost = d*(pt1-pt0+1)*Math.Log(idx1-idx0+1)/Math.Log(2)/efficiency;
            
            //
            // Parallelism
            //
            if( ((rootcall && pt1-pt0>10000) && idx1-idx0>=2) && (double)(cost)>(double)(apserv.smpactivationlevel(_params)) )
            {
                if( _trypexec_reorderdatasetandbuildindexrec(xy,d,shadow,ns,cidx,pt0,pt1,xyindex,idx0,idx1,rootcall, _params) )
                {
                    return;
                }
            }
            
            //
            // Store left bound to XYIndex
            //
            xyindex[idx0] = pt0;
            
            //
            // Quick exit strategies
            //
            if( idx1<=idx0+1 )
            {
                return;
            }
            if( pt0==pt1 )
            {
                for(idxmid=idx0+1; idxmid<=idx1-1; idxmid++)
                {
                    xyindex[idxmid] = pt1;
                }
                return;
            }
            
            //
            // Select middle element
            //
            idxmid = idx0+(idx1-idx0)/2;
            alglib.ap.assert(idx0<idxmid && idxmid<idx1, "Spline2D: integrity check failed");
            wrk0 = pt0;
            wrk1 = pt1-1;
            while( true )
            {
                while( wrk0<pt1 && cidx[wrk0]<idxmid )
                {
                    wrk0 = wrk0+1;
                }
                while( wrk1>=pt0 && cidx[wrk1]>=idxmid )
                {
                    wrk1 = wrk1-1;
                }
                if( wrk1<=wrk0 )
                {
                    break;
                }
                apserv.swapentries(xy, wrk0, wrk1, entrywidth, _params);
                if( ns>0 )
                {
                    apserv.swapentries(shadow, wrk0, wrk1, ns, _params);
                }
                apserv.swapelementsi(cidx, wrk0, wrk1, _params);
            }
            reorderdatasetandbuildindexrec(xy, d, shadow, ns, cidx, pt0, wrk0, xyindex, idx0, idxmid, false, _params);
            reorderdatasetandbuildindexrec(xy, d, shadow, ns, cidx, wrk0, pt1, xyindex, idxmid, idx1, false, _params);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_reorderdatasetandbuildindexrec(double[] xy,
            int d,
            double[] shadow,
            int ns,
            int[] cidx,
            int pt0,
            int pt1,
            int[] xyindex,
            int idx0,
            int idx1,
            bool rootcall, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function performs fitting with  BlockLLS solver.  Internal  function,
        never use it directly.

        INPUT PARAMETERS:
            XY      -   dataset, array[NPoints,2+D]
            XYIndex -   dataset index, see ReorderDatasetAndBuildIndex() for more info
            KX0, KX1-   X-indices of basis functions to select and fit;
                        range [KX0,KX1) is processed
            KXTotal -   total number of indexes in the entire grid
            KY0, KY1-   Y-indices of basis functions to select and fit;
                        range [KY0,KY1) is processed
            KYTotal -   total number of indexes in the entire grid
            D       -   number of components in vector-valued spline, D>=1
            LambdaReg-  regularization coefficient
            LambdaNS-   nonlinearity penalty, exactly zero value is specially handled
                        (entire set of rows is not added to the matrix)
            Basis1  -   single-dimensional B-spline
            

        OUTPUT PARAMETERS:
            A       -   design matrix

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void xdesigngenerate(double[] xy,
            int[] xyindex,
            int kx0,
            int kx1,
            int kxtotal,
            int ky0,
            int ky1,
            int kytotal,
            int d,
            double lambdareg,
            double lambdans,
            spline1d.spline1dinterpolant basis1,
            spline2dxdesignmatrix a,
            alglib.xparams _params)
        {
            int entrywidth = 0;
            int i = 0;
            int j = 0;
            int j0 = 0;
            int j1 = 0;
            int k0 = 0;
            int k1 = 0;
            int kx = 0;
            int ky = 0;
            int rowsdone = 0;
            int batchesdone = 0;
            int pt0 = 0;
            int pt1 = 0;
            int base0 = 0;
            int base1 = 0;
            int baseidx = 0;
            int nzshift = 0;
            int nzwidth = 0;
            double[,] d2x = new double[0,0];
            double[,] d2y = new double[0,0];
            double[,] dxy = new double[0,0];
            double v = 0;
            double v0 = 0;
            double v1 = 0;
            double v2 = 0;
            double w0 = 0;
            double w1 = 0;
            double w2 = 0;

            nzshift = 1;
            nzwidth = 4;
            entrywidth = 2+d;
            kx = kx1-kx0;
            ky = ky1-ky0;
            a.lambdareg = lambdareg;
            a.blockwidth = 4;
            a.kx = kx;
            a.ky = ky;
            a.d = d;
            a.npoints = 0;
            a.ndenserows = 0;
            a.ndensebatches = 0;
            a.maxbatch = 0;
            for(j1=ky0; j1<=ky1-2; j1++)
            {
                for(j0=kx0; j0<=kx1-2; j0++)
                {
                    i = xyindex[j1*(kxtotal-1)+j0+1]-xyindex[j1*(kxtotal-1)+j0];
                    a.npoints = a.npoints+i;
                    a.ndenserows = a.ndenserows+i;
                    a.ndensebatches = a.ndensebatches+1;
                    a.maxbatch = Math.Max(a.maxbatch, i);
                }
            }
            if( (double)(lambdans)!=(double)(0) )
            {
                alglib.ap.assert((double)(lambdans)>=(double)(0), "Spline2DFit: integrity check failed");
                a.ndenserows = a.ndenserows+3*(kx-2)*(ky-2);
                a.ndensebatches = a.ndensebatches+(kx-2)*(ky-2);
                a.maxbatch = Math.Max(a.maxbatch, 3);
            }
            a.nrows = a.ndenserows+kx*ky;
            apserv.rmatrixsetlengthatleast(ref a.vals, a.ndenserows, a.blockwidth*a.blockwidth+d, _params);
            apserv.ivectorsetlengthatleast(ref a.batches, a.ndensebatches+1, _params);
            apserv.ivectorsetlengthatleast(ref a.batchbases, a.ndensebatches, _params);
            
            //
            // Setup output counters
            //
            batchesdone = 0;
            rowsdone = 0;
            
            //
            // Generate rows corresponding to dataset points
            //
            alglib.ap.assert(kx>=nzwidth, "Spline2DFit: integrity check failed");
            alglib.ap.assert(ky>=nzwidth, "Spline2DFit: integrity check failed");
            apserv.rvectorsetlengthatleast(ref a.tmp0, nzwidth, _params);
            apserv.rvectorsetlengthatleast(ref a.tmp1, nzwidth, _params);
            a.batches[batchesdone] = 0;
            for(j1=ky0; j1<=ky1-2; j1++)
            {
                for(j0=kx0; j0<=kx1-2; j0++)
                {
                    pt0 = xyindex[j1*(kxtotal-1)+j0];
                    pt1 = xyindex[j1*(kxtotal-1)+j0+1];
                    base0 = apserv.iboundval(j0-kx0-nzshift, 0, kx-nzwidth, _params);
                    base1 = apserv.iboundval(j1-ky0-nzshift, 0, ky-nzwidth, _params);
                    baseidx = base1*kx+base0;
                    a.batchbases[batchesdone] = baseidx;
                    for(i=pt0; i<=pt1-1; i++)
                    {
                        for(k0=0; k0<=nzwidth-1; k0++)
                        {
                            a.tmp0[k0] = spline1d.spline1dcalc(basis1, xy[i*entrywidth+0]-(base0+kx0+k0), _params);
                        }
                        for(k1=0; k1<=nzwidth-1; k1++)
                        {
                            a.tmp1[k1] = spline1d.spline1dcalc(basis1, xy[i*entrywidth+1]-(base1+ky0+k1), _params);
                        }
                        for(k1=0; k1<=nzwidth-1; k1++)
                        {
                            for(k0=0; k0<=nzwidth-1; k0++)
                            {
                                a.vals[rowsdone,k1*nzwidth+k0] = a.tmp0[k0]*a.tmp1[k1];
                            }
                        }
                        for(j=0; j<=d-1; j++)
                        {
                            a.vals[rowsdone,nzwidth*nzwidth+j] = xy[i*entrywidth+2+j];
                        }
                        rowsdone = rowsdone+1;
                    }
                    batchesdone = batchesdone+1;
                    a.batches[batchesdone] = rowsdone;
                }
            }
            
            //
            // Generate rows corresponding to nonlinearity penalty
            //
            if( (double)(lambdans)>(double)(0) )
            {
                
                //
                // Smoothing is applied. Because all grid nodes are same,
                // we apply same smoothing kernel, which is calculated only
                // once at the beginning of design matrix generation.
                //
                d2x = new double[3, 3];
                d2y = new double[3, 3];
                dxy = new double[3, 3];
                for(j1=0; j1<=2; j1++)
                {
                    for(j0=0; j0<=2; j0++)
                    {
                        d2x[j0,j1] = 0.0;
                        d2y[j0,j1] = 0.0;
                        dxy[j0,j1] = 0.0;
                    }
                }
                for(k1=0; k1<=2; k1++)
                {
                    for(k0=0; k0<=2; k0++)
                    {
                        spline1d.spline1ddiff(basis1, -(k0-1), ref v0, ref v1, ref v2, _params);
                        spline1d.spline1ddiff(basis1, -(k1-1), ref w0, ref w1, ref w2, _params);
                        d2x[k0,k1] = d2x[k0,k1]+v2*w0;
                        d2y[k0,k1] = d2y[k0,k1]+w2*v0;
                        dxy[k0,k1] = dxy[k0,k1]+v1*w1;
                    }
                }
                
                //
                // Now, kernel is ready - apply it to all inner nodes of the grid.
                //
                for(j1=1; j1<=ky-2; j1++)
                {
                    for(j0=1; j0<=kx-2; j0++)
                    {
                        base0 = apserv.imax2(j0-2, 0, _params);
                        base1 = apserv.imax2(j1-2, 0, _params);
                        baseidx = base1*kx+base0;
                        a.batchbases[batchesdone] = baseidx;
                        
                        //
                        // d2F/dx2 term
                        //
                        v = lambdans;
                        for(j=0; j<=nzwidth*nzwidth+d-1; j++)
                        {
                            a.vals[rowsdone,j] = 0;
                        }
                        for(k1=j1-1; k1<=j1+1; k1++)
                        {
                            for(k0=j0-1; k0<=j0+1; k0++)
                            {
                                a.vals[rowsdone,nzwidth*(k1-base1)+(k0-base0)] = v*d2x[1+(k0-j0),1+(k1-j1)];
                            }
                        }
                        rowsdone = rowsdone+1;
                        
                        //
                        // d2F/dy2 term
                        //
                        v = lambdans;
                        for(j=0; j<=nzwidth*nzwidth+d-1; j++)
                        {
                            a.vals[rowsdone,j] = 0;
                        }
                        for(k1=j1-1; k1<=j1+1; k1++)
                        {
                            for(k0=j0-1; k0<=j0+1; k0++)
                            {
                                a.vals[rowsdone,nzwidth*(k1-base1)+(k0-base0)] = v*d2y[1+(k0-j0),1+(k1-j1)];
                            }
                        }
                        rowsdone = rowsdone+1;
                        
                        //
                        // 2*d2F/dxdy term
                        //
                        v = Math.Sqrt(2)*lambdans;
                        for(j=0; j<=nzwidth*nzwidth+d-1; j++)
                        {
                            a.vals[rowsdone,j] = 0;
                        }
                        for(k1=j1-1; k1<=j1+1; k1++)
                        {
                            for(k0=j0-1; k0<=j0+1; k0++)
                            {
                                a.vals[rowsdone,nzwidth*(k1-base1)+(k0-base0)] = v*dxy[1+(k0-j0),1+(k1-j1)];
                            }
                        }
                        rowsdone = rowsdone+1;
                        batchesdone = batchesdone+1;
                        a.batches[batchesdone] = rowsdone;
                    }
                }
            }
            
            //
            // Integrity post-check
            //
            alglib.ap.assert(batchesdone==a.ndensebatches, "Spline2DFit: integrity check failed");
            alglib.ap.assert(rowsdone==a.ndenserows, "Spline2DFit: integrity check failed");
        }


        /*************************************************************************
        This function performs matrix-vector product of design matrix and dense
        vector.

        INPUT PARAMETERS:
            A       -   design matrix, (a.nrows) X (a.kx*a.ky);
                        some fields of A are used for temporaries,
                        so it is non-constant.
            X       -   array[A.KX*A.KY]
            

        OUTPUT PARAMETERS:
            Y       -   product, array[A.NRows], automatically allocated

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void xdesignmv(spline2dxdesignmatrix a,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int bidx = 0;
            int i = 0;
            int cnt = 0;
            double v = 0;
            int baseidx = 0;
            int outidx = 0;
            int batchsize = 0;
            int kx = 0;
            int k0 = 0;
            int k1 = 0;
            int nzwidth = 0;

            nzwidth = 4;
            alglib.ap.assert(a.blockwidth==nzwidth, "Spline2DFit: integrity check failed");
            alglib.ap.assert(alglib.ap.len(x)>=a.kx*a.ky, "Spline2DFit: integrity check failed");
            
            //
            // Prepare
            //
            apserv.rvectorsetlengthatleast(ref y, a.nrows, _params);
            apserv.rvectorsetlengthatleast(ref a.tmp0, nzwidth*nzwidth, _params);
            apserv.rvectorsetlengthatleast(ref a.tmp1, a.maxbatch, _params);
            kx = a.kx;
            outidx = 0;
            
            //
            // Process dense part
            //
            for(bidx=0; bidx<=a.ndensebatches-1; bidx++)
            {
                if( a.batches[bidx+1]-a.batches[bidx]>0 )
                {
                    batchsize = a.batches[bidx+1]-a.batches[bidx];
                    baseidx = a.batchbases[bidx];
                    for(k1=0; k1<=nzwidth-1; k1++)
                    {
                        for(k0=0; k0<=nzwidth-1; k0++)
                        {
                            a.tmp0[k1*nzwidth+k0] = x[baseidx+k1*kx+k0];
                        }
                    }
                    ablas.rmatrixgemv(batchsize, nzwidth*nzwidth, 1.0, a.vals, a.batches[bidx], 0, 0, a.tmp0, 0, 0.0, a.tmp1, 0, _params);
                    for(i=0; i<=batchsize-1; i++)
                    {
                        y[outidx+i] = a.tmp1[i];
                    }
                    outidx = outidx+batchsize;
                }
            }
            alglib.ap.assert(outidx==a.ndenserows, "Spline2DFit: integrity check failed");
            
            //
            // Process regularizer 
            //
            v = a.lambdareg;
            cnt = a.kx*a.ky;
            for(i=0; i<=cnt-1; i++)
            {
                y[outidx+i] = v*x[i];
            }
            outidx = outidx+cnt;
            
            //
            // Post-check
            //
            alglib.ap.assert(outidx==a.nrows, "Spline2DFit: integrity check failed");
        }


        /*************************************************************************
        This function performs matrix-vector product of transposed design matrix and dense
        vector.

        INPUT PARAMETERS:
            A       -   design matrix, (a.nrows) X (a.kx*a.ky);
                        some fields of A are used for temporaries,
                        so it is non-constant.
            X       -   array[A.NRows]
            

        OUTPUT PARAMETERS:
            Y       -   product, array[A.KX*A.KY], automatically allocated

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void xdesignmtv(spline2dxdesignmatrix a,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int bidx = 0;
            int i = 0;
            int cnt = 0;
            double v = 0;
            int baseidx = 0;
            int inidx = 0;
            int batchsize = 0;
            int kx = 0;
            int k0 = 0;
            int k1 = 0;
            int nzwidth = 0;

            nzwidth = 4;
            alglib.ap.assert(a.blockwidth==nzwidth, "Spline2DFit: integrity check failed");
            alglib.ap.assert(alglib.ap.len(x)>=a.nrows, "Spline2DFit: integrity check failed");
            
            //
            // Prepare
            //
            apserv.rvectorsetlengthatleast(ref y, a.kx*a.ky, _params);
            apserv.rvectorsetlengthatleast(ref a.tmp0, nzwidth*nzwidth, _params);
            apserv.rvectorsetlengthatleast(ref a.tmp1, a.maxbatch, _params);
            kx = a.kx;
            inidx = 0;
            cnt = a.kx*a.ky;
            for(i=0; i<=cnt-1; i++)
            {
                y[i] = 0;
            }
            
            //
            // Process dense part
            //
            for(bidx=0; bidx<=a.ndensebatches-1; bidx++)
            {
                if( a.batches[bidx+1]-a.batches[bidx]>0 )
                {
                    batchsize = a.batches[bidx+1]-a.batches[bidx];
                    baseidx = a.batchbases[bidx];
                    for(i=0; i<=batchsize-1; i++)
                    {
                        a.tmp1[i] = x[inidx+i];
                    }
                    ablas.rmatrixgemv(nzwidth*nzwidth, batchsize, 1.0, a.vals, a.batches[bidx], 0, 1, a.tmp1, 0, 0.0, a.tmp0, 0, _params);
                    for(k1=0; k1<=nzwidth-1; k1++)
                    {
                        for(k0=0; k0<=nzwidth-1; k0++)
                        {
                            y[baseidx+k1*kx+k0] = y[baseidx+k1*kx+k0]+a.tmp0[k1*nzwidth+k0];
                        }
                    }
                    inidx = inidx+batchsize;
                }
            }
            alglib.ap.assert(inidx==a.ndenserows, "Spline2DFit: integrity check failed");
            
            //
            // Process regularizer 
            //
            v = a.lambdareg;
            cnt = a.kx*a.ky;
            for(i=0; i<=cnt-1; i++)
            {
                y[i] = y[i]+v*x[inidx+i];
            }
            inidx = inidx+cnt;
            
            //
            // Post-check
            //
            alglib.ap.assert(inidx==a.nrows, "Spline2DFit: integrity check failed");
        }


        /*************************************************************************
        This function generates squared design matrix stored in block band format.

        We  use  an   adaptation   of   block   skyline   storage   format,   with
        TOWERSIZE*KX   skyline    bands   (towers)   stored   sequentially;   here
        TOWERSIZE=(BlockBandwidth+1)*KX. So, we have KY "towers", stored one below
        other, in BlockATA matrix. Every "tower" is a sequence of BlockBandwidth+1
        cells, each of them being KX*KX in size.

        INPUT PARAMETERS:
            A       -   design matrix; some of its fields are used for temporaries
            BlockATA-   array[KY*(BlockBandwidth+1)*KX,KX],  preallocated  storage
                        for output matrix in compressed block band format

        OUTPUT PARAMETERS:
            BlockATA-   AH*AH', stored in compressed block band format
            MXATA   -   max(|AH*AH'|), elementwise

          -- ALGLIB --
             Copyright 05.02.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void xdesignblockata(spline2dxdesignmatrix a,
            double[,] blockata,
            ref double mxata,
            alglib.xparams _params)
        {
            int blockbandwidth = 0;
            int nzwidth = 0;
            int kx = 0;
            int ky = 0;
            int i0 = 0;
            int i1 = 0;
            int j0 = 0;
            int j1 = 0;
            int celloffset = 0;
            int bidx = 0;
            int baseidx = 0;
            int batchsize = 0;
            int offs0 = 0;
            int offs1 = 0;
            double v = 0;

            blockbandwidth = 3;
            nzwidth = 4;
            kx = a.kx;
            ky = a.ky;
            alglib.ap.assert(a.blockwidth==nzwidth, "Spline2DFit: integrity check failed");
            apserv.rmatrixsetlengthatleast(ref a.tmp2, nzwidth*nzwidth, nzwidth*nzwidth, _params);
            
            //
            // Initial zero-fill:
            // * zero-fill ALL elements of BlockATA
            // * zero-fill ALL elements of Tmp2
            //
            // Filling ALL elements, including unused ones, is essential for the
            // purposes of calculating max(BlockATA).
            //
            for(i1=0; i1<=ky-1; i1++)
            {
                for(i0=i1; i0<=Math.Min(ky-1, i1+blockbandwidth); i0++)
                {
                    celloffset = getcelloffset(kx, ky, blockbandwidth, i1, i0, _params);
                    for(j1=0; j1<=kx-1; j1++)
                    {
                        for(j0=0; j0<=kx-1; j0++)
                        {
                            blockata[celloffset+j1,j0] = 0.0;
                        }
                    }
                }
            }
            for(j1=0; j1<=nzwidth*nzwidth-1; j1++)
            {
                for(j0=0; j0<=nzwidth*nzwidth-1; j0++)
                {
                    a.tmp2[j1,j0] = 0.0;
                }
            }
            
            //
            // Process dense part of A
            //
            for(bidx=0; bidx<=a.ndensebatches-1; bidx++)
            {
                if( a.batches[bidx+1]-a.batches[bidx]>0 )
                {
                    
                    //
                    // Generate 16x16 U = BATCH'*BATCH and add it to ATA.
                    //
                    // NOTE: it is essential that lower triangle of Tmp2 is
                    //       filled by zeros.
                    //
                    batchsize = a.batches[bidx+1]-a.batches[bidx];
                    ablas.rmatrixsyrk(nzwidth*nzwidth, batchsize, 1.0, a.vals, a.batches[bidx], 0, 2, 0.0, a.tmp2, 0, 0, true, _params);
                    baseidx = a.batchbases[bidx];
                    for(i1=0; i1<=nzwidth-1; i1++)
                    {
                        for(j1=i1; j1<=nzwidth-1; j1++)
                        {
                            celloffset = getcelloffset(kx, ky, blockbandwidth, baseidx/kx+i1, baseidx/kx+j1, _params);
                            offs0 = baseidx%kx;
                            offs1 = baseidx%kx;
                            for(i0=0; i0<=nzwidth-1; i0++)
                            {
                                for(j0=0; j0<=nzwidth-1; j0++)
                                {
                                    v = a.tmp2[i1*nzwidth+i0,j1*nzwidth+j0];
                                    blockata[celloffset+offs1+i0,offs0+j0] = blockata[celloffset+offs1+i0,offs0+j0]+v;
                                }
                            }
                        }
                    }
                }
            }
            
            //
            // Process regularizer term
            //
            for(i1=0; i1<=ky-1; i1++)
            {
                celloffset = getcelloffset(kx, ky, blockbandwidth, i1, i1, _params);
                for(j1=0; j1<=kx-1; j1++)
                {
                    blockata[celloffset+j1,j1] = blockata[celloffset+j1,j1]+math.sqr(a.lambdareg);
                }
            }
            
            //
            // Calculate max(ATA)
            //
            // NOTE: here we rely on zero initialization of unused parts of
            //       BlockATA and Tmp2.
            //
            mxata = 0.0;
            for(i1=0; i1<=ky-1; i1++)
            {
                for(i0=i1; i0<=Math.Min(ky-1, i1+blockbandwidth); i0++)
                {
                    celloffset = getcelloffset(kx, ky, blockbandwidth, i1, i0, _params);
                    for(j1=0; j1<=kx-1; j1++)
                    {
                        for(j0=0; j0<=kx-1; j0++)
                        {
                            mxata = Math.Max(mxata, Math.Abs(blockata[celloffset+j1,j0]));
                        }
                    }
                }
            }
        }


    }
    public class rbfv2
    {
        /*************************************************************************
        Buffer object which is used to perform nearest neighbor  requests  in  the
        multithreaded mode (multiple threads working with same KD-tree object).

        This object should be created with KDTreeCreateBuffer().
        *************************************************************************/
        public class rbfv2calcbuffer : apobject
        {
            public double[] x;
            public double[] curboxmin;
            public double[] curboxmax;
            public double curdist2;
            public double[] x123;
            public double[] y123;
            public rbfv2calcbuffer()
            {
                init();
            }
            public override void init()
            {
                x = new double[0];
                curboxmin = new double[0];
                curboxmax = new double[0];
                x123 = new double[0];
                y123 = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                rbfv2calcbuffer _result = new rbfv2calcbuffer();
                _result.x = (double[])x.Clone();
                _result.curboxmin = (double[])curboxmin.Clone();
                _result.curboxmax = (double[])curboxmax.Clone();
                _result.curdist2 = curdist2;
                _result.x123 = (double[])x123.Clone();
                _result.y123 = (double[])y123.Clone();
                return _result;
            }
        };


        /*************************************************************************
        RBF model.

        Never try to work with fields of this object directly - always use  ALGLIB
        functions to use this object.
        *************************************************************************/
        public class rbfv2model : apobject
        {
            public int ny;
            public int nx;
            public int bf;
            public int nh;
            public double[] ri;
            public double[] s;
            public int[] kdroots;
            public int[] kdnodes;
            public double[] kdsplits;
            public double[] kdboxmin;
            public double[] kdboxmax;
            public double[] cw;
            public double[,] v;
            public double lambdareg;
            public int maxits;
            public double supportr;
            public int basisfunction;
            public rbfv2calcbuffer calcbuf;
            public rbfv2model()
            {
                init();
            }
            public override void init()
            {
                ri = new double[0];
                s = new double[0];
                kdroots = new int[0];
                kdnodes = new int[0];
                kdsplits = new double[0];
                kdboxmin = new double[0];
                kdboxmax = new double[0];
                cw = new double[0];
                v = new double[0,0];
                calcbuf = new rbfv2calcbuffer();
            }
            public override alglib.apobject make_copy()
            {
                rbfv2model _result = new rbfv2model();
                _result.ny = ny;
                _result.nx = nx;
                _result.bf = bf;
                _result.nh = nh;
                _result.ri = (double[])ri.Clone();
                _result.s = (double[])s.Clone();
                _result.kdroots = (int[])kdroots.Clone();
                _result.kdnodes = (int[])kdnodes.Clone();
                _result.kdsplits = (double[])kdsplits.Clone();
                _result.kdboxmin = (double[])kdboxmin.Clone();
                _result.kdboxmax = (double[])kdboxmax.Clone();
                _result.cw = (double[])cw.Clone();
                _result.v = (double[,])v.Clone();
                _result.lambdareg = lambdareg;
                _result.maxits = maxits;
                _result.supportr = supportr;
                _result.basisfunction = basisfunction;
                _result.calcbuf = (rbfv2calcbuffer)calcbuf.make_copy();
                return _result;
            }
        };


        /*************************************************************************
        Internal buffer for GridCalc3
        *************************************************************************/
        public class rbfv2gridcalcbuffer : apobject
        {
            public rbfv2calcbuffer calcbuf;
            public double[] cx;
            public double[] rx;
            public double[] ry;
            public double[] tx;
            public double[] ty;
            public bool[] rf;
            public rbfv2gridcalcbuffer()
            {
                init();
            }
            public override void init()
            {
                calcbuf = new rbfv2calcbuffer();
                cx = new double[0];
                rx = new double[0];
                ry = new double[0];
                tx = new double[0];
                ty = new double[0];
                rf = new bool[0];
            }
            public override alglib.apobject make_copy()
            {
                rbfv2gridcalcbuffer _result = new rbfv2gridcalcbuffer();
                _result.calcbuf = (rbfv2calcbuffer)calcbuf.make_copy();
                _result.cx = (double[])cx.Clone();
                _result.rx = (double[])rx.Clone();
                _result.ry = (double[])ry.Clone();
                _result.tx = (double[])tx.Clone();
                _result.ty = (double[])ty.Clone();
                _result.rf = (bool[])rf.Clone();
                return _result;
            }
        };


        /*************************************************************************
        RBF solution report:
        * TerminationType   -   termination type, positive values - success,
                                non-positive - failure.
        *************************************************************************/
        public class rbfv2report : apobject
        {
            public int terminationtype;
            public double maxerror;
            public double rmserror;
            public rbfv2report()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                rbfv2report _result = new rbfv2report();
                _result.terminationtype = terminationtype;
                _result.maxerror = maxerror;
                _result.rmserror = rmserror;
                return _result;
            }
        };




        public const double defaultlambdareg = 1.0E-6;
        public const double defaultsupportr = 0.10;
        public const int defaultmaxits = 400;
        public const int defaultbf = 1;
        public const int maxnodesize = 6;
        public const double complexitymultiplier = 100.0;


        /*************************************************************************
        This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
        function in a NX-dimensional space (NX=2 or NX=3).

        INPUT PARAMETERS:
            NX      -   dimension of the space, NX=2 or NX=3
            NY      -   function dimension, NY>=1

        OUTPUT PARAMETERS:
            S       -   RBF model (initially equals to zero)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2create(int nx,
            int ny,
            rbfv2model s,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;

            alglib.ap.assert(nx>=1, "RBFCreate: NX<1");
            alglib.ap.assert(ny>=1, "RBFCreate: NY<1");
            
            //
            // Serializable parameters
            //
            s.nx = nx;
            s.ny = ny;
            s.bf = 0;
            s.nh = 0;
            s.v = new double[ny, nx+1];
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx; j++)
                {
                    s.v[i,j] = 0;
                }
            }
            
            //
            // Non-serializable parameters
            //
            s.lambdareg = defaultlambdareg;
            s.maxits = defaultmaxits;
            s.supportr = defaultsupportr;
            s.basisfunction = defaultbf;
        }


        /*************************************************************************
        This function creates buffer  structure  which  can  be  used  to  perform
        parallel  RBF  model  evaluations  (with  one  RBF  model  instance  being
        used from multiple threads, as long as  different  threads  use  different
        instances of buffer).

        This buffer object can be used with  rbftscalcbuf()  function  (here  "ts"
        stands for "thread-safe", "buf" is a suffix which denotes  function  which
        reuses previously allocated output space).

        How to use it:
        * create RBF model structure with rbfcreate()
        * load data, tune parameters
        * call rbfbuildmodel()
        * call rbfcreatecalcbuffer(), once per thread working with RBF model  (you
          should call this function only AFTER call to rbfbuildmodel(), see  below
          for more information)
        * call rbftscalcbuf() from different threads,  with  each  thread  working
          with its own copy of buffer object.

        INPUT PARAMETERS
            S           -   RBF model

        OUTPUT PARAMETERS
            Buf         -   external buffer.
            
            
        IMPORTANT: buffer object should be used only with  RBF model object  which
                   was used to initialize buffer. Any attempt to use buffer   with
                   different object is dangerous - you may  get  memory  violation
                   error because sizes of internal arrays do not fit to dimensions
                   of RBF structure.
                   
        IMPORTANT: you  should  call  this function only for model which was built
                   with rbfbuildmodel() function, after successful  invocation  of
                   rbfbuildmodel().  Sizes   of   some   internal  structures  are
                   determined only after model is built, so buffer object  created
                   before model  construction  stage  will  be  useless  (and  any
                   attempt to use it will result in exception).

          -- ALGLIB --
             Copyright 02.04.2016 by Sergey Bochkanov
        *************************************************************************/
        public static void rbfv2createcalcbuffer(rbfv2model s,
            rbfv2calcbuffer buf,
            alglib.xparams _params)
        {
            allocatecalcbuffer(s, buf, _params);
        }


        /*************************************************************************
        This   function  builds hierarchical RBF model.

        INPUT PARAMETERS:
            X       -   array[N,S.NX], X-values
            Y       -   array[N,S.NY], Y-values
            ScaleVec-   array[S.NX], vector of per-dimension scales
            N       -   points count
            ATerm   -   linear term type, 1 for linear, 2 for constant, 3 for zero.
            NH      -   hierarchy height
            RBase   -   base RBF radius
            BF      -   basis function type: 0 for Gaussian, 1 for compact
            LambdaNS-   non-smoothness penalty coefficient. Exactly zero value means
                        that no penalty is applied, and even system matrix does not
                        contain penalty-related rows. Value of 1 means
            S       -   RBF model, initialized by RBFCreate() call.
            progress10000- variable used for progress reports, it is regularly set
                        to the current progress multiplied by 10000, in order to
                        get value in [0,10000] range. The rationale for such scaling
                        is that it allows us to use integer type to store progress,
                        which has less potential for non-atomic corruption on unprotected
                        reads from another threads.
                        You can read this variable from some other thread to get
                        estimate of the current progress.
                        Initial value of this variable is ignored, it is written by
                        this function, but not read.
            terminationrequest - variable used for termination requests; its initial
                        value must be False, and you can set it to True from some
                        other thread. This routine regularly checks this variable
                        and will terminate model construction shortly upon discovering
                        that termination was requested.
            
        OUTPUT PARAMETERS:
            S       -   updated model (for rep.terminationtype>0, unchanged otherwise)
            Rep     -   report:
                        * Rep.TerminationType:
                          * -5 - non-distinct basis function centers were detected,
                                 interpolation aborted
                          * -4 - nonconvergence of the internal SVD solver
                          *  1 - successful termination
                          *  8 terminated by user via rbfrequesttermination()
                        Fields are used for debugging purposes:
                        * Rep.IterationsCount - iterations count of the LSQR solver
                        * Rep.NMV - number of matrix-vector products
                        * Rep.ARows - rows count for the system matrix
                        * Rep.ACols - columns count for the system matrix
                        * Rep.ANNZ - number of significantly non-zero elements
                          (elements above some algorithm-determined threshold)

        NOTE:  failure  to  build  model will leave current state of the structure
        unchanged.

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2buildhierarchical(double[,] x,
            double[,] y,
            int n,
            double[] scalevec,
            int aterm,
            int nh,
            double rbase,
            double lambdans,
            rbfv2model s,
            ref int progress10000,
            ref bool terminationrequest,
            rbfv2report rep,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;
            int bf = 0;
            double[,] rhs = new double[0,0];
            double[,] residualy = new double[0,0];
            double[,] v = new double[0,0];
            int rowsperpoint = 0;
            int[] hidx = new int[0];
            double[] xr = new double[0];
            double[] ri = new double[0];
            int[] kdroots = new int[0];
            int[] kdnodes = new int[0];
            double[] kdsplits = new double[0];
            double[] kdboxmin = new double[0];
            double[] kdboxmax = new double[0];
            double[] cw = new double[0];
            int[] cwrange = new int[0];
            double[,] curxy = new double[0,0];
            int curn = 0;
            int nbasis = 0;
            nearestneighbor.kdtree curtree = new nearestneighbor.kdtree();
            nearestneighbor.kdtree globaltree = new nearestneighbor.kdtree();
            double[] x0 = new double[0];
            double[] x1 = new double[0];
            int[] tags = new int[0];
            double[] dist = new double[0];
            int[] nncnt = new int[0];
            int[] rowsizes = new int[0];
            double[] diagata = new double[0];
            double[] prec = new double[0];
            double[] tmpx = new double[0];
            int i = 0;
            int j = 0;
            int k = 0;
            int k2 = 0;
            int levelidx = 0;
            int offsi = 0;
            int offsj = 0;
            double val = 0;
            double criticalr = 0;
            int cnt = 0;
            double avgdiagata = 0;
            double[] avgrowsize = new double[0];
            double sumrowsize = 0;
            double rprogress = 0;
            int maxits = 0;
            linlsqr.linlsqrstate linstate = new linlsqr.linlsqrstate();
            linlsqr.linlsqrreport lsqrrep = new linlsqr.linlsqrreport();
            sparse.sparsematrix sparseacrs = new sparse.sparsematrix();
            double[] densew1 = new double[0];
            double[] denseb1 = new double[0];
            rbfv2calcbuffer calcbuf = new rbfv2calcbuffer();
            double[] vr2 = new double[0];
            int[] voffs = new int[0];
            int[] rowindexes = new int[0];
            double[] rowvals = new double[0];
            double penalty = 0;

            alglib.ap.assert(s.nx>0, "RBFV2BuildHierarchical: incorrect NX");
            alglib.ap.assert(s.ny>0, "RBFV2BuildHierarchical: incorrect NY");
            alglib.ap.assert((double)(lambdans)>=(double)(0), "RBFV2BuildHierarchical: incorrect LambdaNS");
            for(j=0; j<=s.nx-1; j++)
            {
                alglib.ap.assert((double)(scalevec[j])>(double)(0), "RBFV2BuildHierarchical: incorrect ScaleVec");
            }
            nx = s.nx;
            ny = s.ny;
            bf = s.basisfunction;
            alglib.ap.assert(bf==0 || bf==1, "RBFV2BuildHierarchical: incorrect BF");
            
            //
            // Clean up communication and report fields
            //
            progress10000 = 0;
            rep.maxerror = 0;
            rep.rmserror = 0;
            
            //
            // Quick exit when we have no points
            //
            if( n==0 )
            {
                zerofill(s, nx, ny, bf, _params);
                rep.terminationtype = 1;
                progress10000 = 10000;
                return;
            }
            
            //
            // First model in a sequence - linear model.
            // Residuals from linear regression are stored in the ResidualY variable
            // (used later to build RBF models).
            //
            residualy = new double[n, ny];
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=ny-1; j++)
                {
                    residualy[i,j] = y[i,j];
                }
            }
            if( !rbfv2buildlinearmodel(x, ref residualy, n, nx, ny, aterm, ref v, _params) )
            {
                zerofill(s, nx, ny, bf, _params);
                rep.terminationtype = -5;
                progress10000 = 10000;
                return;
            }
            
            //
            // Handle special case: multilayer model with NLayers=0.
            // Quick exit.
            //
            if( nh==0 )
            {
                rep.terminationtype = 1;
                zerofill(s, nx, ny, bf, _params);
                for(i=0; i<=ny-1; i++)
                {
                    for(j=0; j<=nx; j++)
                    {
                        s.v[i,j] = v[i,j];
                    }
                }
                rep.maxerror = 0;
                rep.rmserror = 0;
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=ny-1; j++)
                    {
                        rep.maxerror = Math.Max(rep.maxerror, Math.Abs(residualy[i,j]));
                        rep.rmserror = rep.rmserror+math.sqr(residualy[i,j]);
                    }
                }
                rep.rmserror = Math.Sqrt(rep.rmserror/(n*ny));
                progress10000 = 10000;
                return;
            }
            
            //
            // Penalty coefficient is set to LambdaNS*RBase^2.
            //
            // We use such normalization because VALUES of radial basis
            // functions have roughly unit magnitude, but their DERIVATIVES
            // are (roughly) inversely proportional to the radius. Thus,
            // without additional scaling, regularization coefficient
            // looses invariancy w.r.t. scaling of variables.
            //
            if( (double)(lambdans)==(double)(0) )
            {
                rowsperpoint = 1;
            }
            else
            {
                
                //
                // NOTE: simplified penalty function is used, which does not provide rotation invariance
                //
                rowsperpoint = 1+nx;
            }
            penalty = lambdans*math.sqr(rbase);
            
            //
            // Prepare temporary structures
            //
            rhs = new double[n*rowsperpoint, ny];
            curxy = new double[n, nx+ny];
            x0 = new double[nx];
            x1 = new double[nx];
            tags = new int[n];
            dist = new double[n];
            vr2 = new double[n];
            voffs = new int[n];
            nncnt = new int[n];
            rowsizes = new int[n*rowsperpoint];
            denseb1 = new double[n*rowsperpoint];
            for(i=0; i<=n*rowsperpoint-1; i++)
            {
                for(j=0; j<=ny-1; j++)
                {
                    rhs[i,j] = 0;
                }
            }
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    curxy[i,j] = x[i,j]/scalevec[j];
                }
                for(j=0; j<=ny-1; j++)
                {
                    rhs[i*rowsperpoint,j] = residualy[i,j];
                }
                tags[i] = i;
            }
            nearestneighbor.kdtreebuildtagged(curxy, tags, n, nx, 0, 2, globaltree, _params);
            
            //
            // Generate sequence of layer radii.
            // Prepare assignment of different levels to points.
            //
            alglib.ap.assert(n>0, "RBFV2BuildHierarchical: integrity check failed");
            ri = new double[nh];
            for(levelidx=0; levelidx<=nh-1; levelidx++)
            {
                ri[levelidx] = rbase*Math.Pow(2, -levelidx);
            }
            hidx = new int[n];
            xr = new double[n];
            for(i=0; i<=n-1; i++)
            {
                hidx[i] = nh;
                xr[i] = math.maxrealnumber;
                alglib.ap.assert((double)(xr[i])>(double)(ri[0]), "RBFV2BuildHierarchical: integrity check failed");
            }
            for(levelidx=0; levelidx<=nh-1; levelidx++)
            {
                
                //
                // Scan dataset points, for each such point that distance to nearest
                // "support" point is larger than SupportR*Ri[LevelIdx] we:
                // * set distance of current point to 0 (it is support now) and update HIdx
                // * perform R-NN request with radius SupportR*Ri[LevelIdx]
                // * for each point in request update its distance
                //
                criticalr = s.supportr*ri[levelidx];
                for(i=0; i<=n-1; i++)
                {
                    if( (double)(xr[i])>(double)(criticalr) )
                    {
                        
                        //
                        // Mark point as support
                        //
                        alglib.ap.assert(hidx[i]==nh, "RBFV2BuildHierarchical: integrity check failed");
                        hidx[i] = levelidx;
                        xr[i] = 0;
                        
                        //
                        // Update neighbors
                        //
                        for(j=0; j<=nx-1; j++)
                        {
                            x0[j] = x[i,j]/scalevec[j];
                        }
                        k = nearestneighbor.kdtreequeryrnn(globaltree, x0, criticalr, true, _params);
                        nearestneighbor.kdtreequeryresultstags(globaltree, ref tags, _params);
                        nearestneighbor.kdtreequeryresultsdistances(globaltree, ref dist, _params);
                        for(j=0; j<=k-1; j++)
                        {
                            xr[tags[j]] = Math.Min(xr[tags[j]], dist[j]);
                        }
                    }
                }
            }
            
            //
            // Build multitree (with zero weights) according to hierarchy.
            //
            // NOTE: this code assumes that during every iteration kdNodes,
            //       kdSplits and CW have size which EXACTLY fits their
            //       contents, and that these variables are resized at each
            //       iteration when we add new hierarchical model.
            //
            kdroots = new int[nh+1];
            kdnodes = new int[0];
            kdsplits = new double[0];
            kdboxmin = new double[nx];
            kdboxmax = new double[nx];
            cw = new double[0];
            cwrange = new int[nh+1];
            nearestneighbor.kdtreeexplorebox(globaltree, ref kdboxmin, ref kdboxmax, _params);
            cwrange[0] = 0;
            for(levelidx=0; levelidx<=nh-1; levelidx++)
            {
                
                //
                // Prepare radius and root offset
                //
                kdroots[levelidx] = alglib.ap.len(kdnodes);
                
                //
                // Generate LevelIdx-th tree and append to multi-tree
                //
                curn = 0;
                for(i=0; i<=n-1; i++)
                {
                    if( hidx[i]<=levelidx )
                    {
                        for(j=0; j<=nx-1; j++)
                        {
                            curxy[curn,j] = x[i,j]/scalevec[j];
                        }
                        for(j=0; j<=ny-1; j++)
                        {
                            curxy[curn,nx+j] = 0;
                        }
                        apserv.inc(ref curn, _params);
                    }
                }
                alglib.ap.assert(curn>0, "RBFV2BuildHierarchical: integrity check failed");
                nearestneighbor.kdtreebuild(curxy, curn, nx, ny, 2, curtree, _params);
                convertandappendtree(curtree, curn, nx, ny, ref kdnodes, ref kdsplits, ref cw, _params);
                
                //
                // Fill entry of CWRange (we assume that length of CW exactly fits its actual size)
                //
                cwrange[levelidx+1] = alglib.ap.len(cw);
            }
            kdroots[nh] = alglib.ap.len(kdnodes);
            
            //
            // Prepare buffer and scaled dataset
            //
            allocatecalcbuffer(s, calcbuf, _params);
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    curxy[i,j] = x[i,j]/scalevec[j];
                }
            }
            
            //
            // Calculate average row sizes for each layer; these values are used
            // for smooth progress reporting (it adds some overhead, but in most
            // cases - insignificant one).
            //
            apserv.rvectorsetlengthatleast(ref avgrowsize, nh, _params);
            sumrowsize = 0;
            for(levelidx=0; levelidx<=nh-1; levelidx++)
            {
                cnt = 0;
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        x0[j] = curxy[i,j];
                    }
                    cnt = cnt+designmatrixrowsize(kdnodes, kdsplits, cw, ri, kdroots, kdboxmin, kdboxmax, nx, ny, nh, levelidx, rbfv2nearradius(bf, _params), x0, calcbuf, _params);
                }
                avgrowsize[levelidx] = apserv.coalesce(cnt, 1, _params)/apserv.coalesce(n, 1, _params);
                sumrowsize = sumrowsize+avgrowsize[levelidx];
            }
            
            //
            // Build unconstrained model with LSQR solver, applied layer by layer
            //
            for(levelidx=0; levelidx<=nh-1; levelidx++)
            {
                
                //
                // Generate A - matrix of basis functions (near radius is used)
                //
                // NOTE: AvgDiagATA is average value of diagonal element of A^T*A.
                //       It is used to calculate value of Tikhonov regularization
                //       coefficient.
                //
                nbasis = (cwrange[levelidx+1]-cwrange[levelidx])/(nx+ny);
                alglib.ap.assert(cwrange[levelidx+1]-cwrange[levelidx]==nbasis*(nx+ny));
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        x0[j] = curxy[i,j];
                    }
                    cnt = designmatrixrowsize(kdnodes, kdsplits, cw, ri, kdroots, kdboxmin, kdboxmax, nx, ny, nh, levelidx, rbfv2nearradius(bf, _params), x0, calcbuf, _params);
                    nncnt[i] = cnt;
                    for(j=0; j<=rowsperpoint-1; j++)
                    {
                        rowsizes[i*rowsperpoint+j] = cnt;
                    }
                }
                apserv.ivectorsetlengthatleast(ref rowindexes, nbasis, _params);
                apserv.rvectorsetlengthatleast(ref rowvals, nbasis*rowsperpoint, _params);
                apserv.rvectorsetlengthatleast(ref diagata, nbasis, _params);
                sparse.sparsecreatecrsbuf(n*rowsperpoint, nbasis, rowsizes, sparseacrs, _params);
                avgdiagata = 0.0;
                for(j=0; j<=nbasis-1; j++)
                {
                    diagata[j] = 0;
                }
                for(i=0; i<=n-1; i++)
                {
                    
                    //
                    // Fill design matrix row, diagonal of A^T*A
                    //
                    for(j=0; j<=nx-1; j++)
                    {
                        x0[j] = curxy[i,j];
                    }
                    designmatrixgeneraterow(kdnodes, kdsplits, cw, ri, kdroots, kdboxmin, kdboxmax, cwrange, nx, ny, nh, levelidx, bf, rbfv2nearradius(bf, _params), rowsperpoint, penalty, x0, calcbuf, vr2, voffs, rowindexes, rowvals, ref cnt, _params);
                    alglib.ap.assert(cnt==nncnt[i], "RBFV2BuildHierarchical: integrity check failed");
                    for(k=0; k<=rowsperpoint-1; k++)
                    {
                        for(j=0; j<=cnt-1; j++)
                        {
                            val = rowvals[j*rowsperpoint+k];
                            sparse.sparseset(sparseacrs, i*rowsperpoint+k, rowindexes[j], val, _params);
                            avgdiagata = avgdiagata+math.sqr(val);
                            diagata[rowindexes[j]] = diagata[rowindexes[j]]+math.sqr(val);
                        }
                    }
                    
                    //
                    // Handle possible termination requests
                    //
                    if( terminationrequest )
                    {
                        
                        //
                        // Request for termination was submitted, terminate immediately
                        //
                        zerofill(s, nx, ny, bf, _params);
                        rep.terminationtype = 8;
                        progress10000 = 10000;
                        return;
                    }
                }
                avgdiagata = avgdiagata/nbasis;
                apserv.rvectorsetlengthatleast(ref prec, nbasis, _params);
                for(j=0; j<=nbasis-1; j++)
                {
                    prec[j] = 1/apserv.coalesce(Math.Sqrt(diagata[j]), 1, _params);
                }
                
                //
                // solve
                //
                maxits = apserv.coalescei(s.maxits, defaultmaxits, _params);
                apserv.rvectorsetlengthatleast(ref tmpx, nbasis, _params);
                linlsqr.linlsqrcreate(n*rowsperpoint, nbasis, linstate, _params);
                linlsqr.linlsqrsetcond(linstate, 0.0, 0.0, maxits, _params);
                linlsqr.linlsqrsetlambdai(linstate, Math.Sqrt(s.lambdareg*avgdiagata), _params);
                for(j=0; j<=ny-1; j++)
                {
                    for(i=0; i<=n*rowsperpoint-1; i++)
                    {
                        denseb1[i] = rhs[i,j];
                    }
                    linlsqr.linlsqrsetb(linstate, denseb1, _params);
                    linlsqr.linlsqrrestart(linstate, _params);
                    linlsqr.linlsqrsetxrep(linstate, true, _params);
                    while( linlsqr.linlsqriteration(linstate, _params) )
                    {
                        if( terminationrequest )
                        {
                            
                            //
                            // Request for termination was submitted, terminate immediately
                            //
                            zerofill(s, nx, ny, bf, _params);
                            rep.terminationtype = 8;
                            progress10000 = 10000;
                            return;
                        }
                        if( linstate.needmv )
                        {
                            for(i=0; i<=nbasis-1; i++)
                            {
                                tmpx[i] = prec[i]*linstate.x[i];
                            }
                            sparse.sparsemv(sparseacrs, tmpx, ref linstate.mv, _params);
                            continue;
                        }
                        if( linstate.needmtv )
                        {
                            sparse.sparsemtv(sparseacrs, linstate.x, ref linstate.mtv, _params);
                            for(i=0; i<=nbasis-1; i++)
                            {
                                linstate.mtv[i] = prec[i]*linstate.mtv[i];
                            }
                            continue;
                        }
                        if( linstate.xupdated )
                        {
                            rprogress = 0;
                            for(i=0; i<=levelidx-1; i++)
                            {
                                rprogress = rprogress+maxits*ny*avgrowsize[i];
                            }
                            rprogress = rprogress+(linlsqr.linlsqrpeekiterationscount(linstate, _params)+j*maxits)*avgrowsize[levelidx];
                            rprogress = rprogress/(sumrowsize*maxits*ny);
                            rprogress = 10000*rprogress;
                            rprogress = Math.Max(rprogress, 0);
                            rprogress = Math.Min(rprogress, 10000);
                            alglib.ap.assert(progress10000<=(int)Math.Round(rprogress)+1, "HRBF: integrity check failed (progress indicator) even after +1 safeguard correction");
                            progress10000 = (int)Math.Round(rprogress);
                            continue;
                        }
                        alglib.ap.assert(false, "HRBF: unexpected request from LSQR solver");
                    }
                    linlsqr.linlsqrresults(linstate, ref densew1, lsqrrep, _params);
                    alglib.ap.assert(lsqrrep.terminationtype>0, "RBFV2BuildHierarchical: integrity check failed");
                    for(i=0; i<=nbasis-1; i++)
                    {
                        densew1[i] = prec[i]*densew1[i];
                    }
                    for(i=0; i<=nbasis-1; i++)
                    {
                        offsi = cwrange[levelidx]+(nx+ny)*i;
                        cw[offsi+nx+j] = densew1[i];
                    }
                }
                
                //
                // Update residuals (far radius is used)
                //
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        x0[j] = curxy[i,j];
                    }
                    designmatrixgeneraterow(kdnodes, kdsplits, cw, ri, kdroots, kdboxmin, kdboxmax, cwrange, nx, ny, nh, levelidx, bf, rbfv2farradius(bf, _params), rowsperpoint, penalty, x0, calcbuf, vr2, voffs, rowindexes, rowvals, ref cnt, _params);
                    for(j=0; j<=cnt-1; j++)
                    {
                        offsj = cwrange[levelidx]+(nx+ny)*rowindexes[j]+nx;
                        for(k=0; k<=rowsperpoint-1; k++)
                        {
                            val = rowvals[j*rowsperpoint+k];
                            for(k2=0; k2<=ny-1; k2++)
                            {
                                rhs[i*rowsperpoint+k,k2] = rhs[i*rowsperpoint+k,k2]-val*cw[offsj+k2];
                            }
                        }
                    }
                }
            }
            
            //
            // Model is built.
            //
            // Copy local variables by swapping, global ones (ScaleVec) are copied
            // explicitly.
            //
            s.bf = bf;
            s.nh = nh;
            alglib.ap.swap(ref s.ri, ref ri);
            alglib.ap.swap(ref s.kdroots, ref kdroots);
            alglib.ap.swap(ref s.kdnodes, ref kdnodes);
            alglib.ap.swap(ref s.kdsplits, ref kdsplits);
            alglib.ap.swap(ref s.kdboxmin, ref kdboxmin);
            alglib.ap.swap(ref s.kdboxmax, ref kdboxmax);
            alglib.ap.swap(ref s.cw, ref cw);
            alglib.ap.swap(ref s.v, ref v);
            s.s = new double[nx];
            for(i=0; i<=nx-1; i++)
            {
                s.s[i] = scalevec[i];
            }
            rep.terminationtype = 1;
            
            //
            // Calculate maximum and RMS errors
            //
            rep.maxerror = 0;
            rep.rmserror = 0;
            for(i=0; i<=n-1; i++)
            {
                for(j=0; j<=ny-1; j++)
                {
                    rep.maxerror = Math.Max(rep.maxerror, Math.Abs(rhs[i*rowsperpoint,j]));
                    rep.rmserror = rep.rmserror+math.sqr(rhs[i*rowsperpoint,j]);
                }
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/(n*ny));
            
            //
            // Update progress reports
            //
            progress10000 = 10000;
        }


        /*************************************************************************
        Serializer: allocation

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2alloc(alglib.serializer s,
            rbfv2model model,
            alglib.xparams _params)
        {
            
            //
            // Data
            //
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            s.alloc_entry();
            apserv.allocrealarray(s, model.ri, -1, _params);
            apserv.allocrealarray(s, model.s, -1, _params);
            apserv.allocintegerarray(s, model.kdroots, -1, _params);
            apserv.allocintegerarray(s, model.kdnodes, -1, _params);
            apserv.allocrealarray(s, model.kdsplits, -1, _params);
            apserv.allocrealarray(s, model.kdboxmin, -1, _params);
            apserv.allocrealarray(s, model.kdboxmax, -1, _params);
            apserv.allocrealarray(s, model.cw, -1, _params);
            apserv.allocrealmatrix(s, model.v, -1, -1, _params);
        }


        /*************************************************************************
        Serializer: serialization

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2serialize(alglib.serializer s,
            rbfv2model model,
            alglib.xparams _params)
        {
            
            //
            // Data
            //
            s.serialize_int(model.nx);
            s.serialize_int(model.ny);
            s.serialize_int(model.nh);
            s.serialize_int(model.bf);
            apserv.serializerealarray(s, model.ri, -1, _params);
            apserv.serializerealarray(s, model.s, -1, _params);
            apserv.serializeintegerarray(s, model.kdroots, -1, _params);
            apserv.serializeintegerarray(s, model.kdnodes, -1, _params);
            apserv.serializerealarray(s, model.kdsplits, -1, _params);
            apserv.serializerealarray(s, model.kdboxmin, -1, _params);
            apserv.serializerealarray(s, model.kdboxmax, -1, _params);
            apserv.serializerealarray(s, model.cw, -1, _params);
            apserv.serializerealmatrix(s, model.v, -1, -1, _params);
        }


        /*************************************************************************
        Serializer: unserialization

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2unserialize(alglib.serializer s,
            rbfv2model model,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;

            
            //
            // Unserialize primary model parameters, initialize model.
            //
            // It is necessary to call RBFCreate() because some internal fields
            // which are NOT unserialized will need initialization.
            //
            nx = s.unserialize_int();
            ny = s.unserialize_int();
            rbfv2create(nx, ny, model, _params);
            model.nh = s.unserialize_int();
            model.bf = s.unserialize_int();
            apserv.unserializerealarray(s, ref model.ri, _params);
            apserv.unserializerealarray(s, ref model.s, _params);
            apserv.unserializeintegerarray(s, ref model.kdroots, _params);
            apserv.unserializeintegerarray(s, ref model.kdnodes, _params);
            apserv.unserializerealarray(s, ref model.kdsplits, _params);
            apserv.unserializerealarray(s, ref model.kdboxmin, _params);
            apserv.unserializerealarray(s, ref model.kdboxmax, _params);
            apserv.unserializerealarray(s, ref model.cw, _params);
            apserv.unserializerealmatrix(s, ref model.v, _params);
        }


        /*************************************************************************
        Returns far radius for basis function type
        *************************************************************************/
        public static double rbfv2farradius(int bf,
            alglib.xparams _params)
        {
            double result = 0;

            result = 1;
            if( bf==0 )
            {
                result = 5.0;
            }
            if( bf==1 )
            {
                result = 3;
            }
            return result;
        }


        /*************************************************************************
        Returns near radius for basis function type
        *************************************************************************/
        public static double rbfv2nearradius(int bf,
            alglib.xparams _params)
        {
            double result = 0;

            result = 1;
            if( bf==0 )
            {
                result = 3.0;
            }
            if( bf==1 )
            {
                result = 3;
            }
            return result;
        }


        /*************************************************************************
        Returns basis function value.
        Assumes that D2>=0
        *************************************************************************/
        public static double rbfv2basisfunc(int bf,
            double d2,
            alglib.xparams _params)
        {
            double result = 0;
            double v = 0;

            result = 0;
            if( bf==0 )
            {
                result = Math.Exp(-d2);
                return result;
            }
            if( bf==1 )
            {
                
                //
                // if D2<3:
                //     Exp(1)*Exp(-D2)*Exp(-1/(1-D2/9))
                // else:
                //     0
                //
                v = 1-d2/9;
                if( (double)(v)<=(double)(0) )
                {
                    result = 0;
                    return result;
                }
                result = 2.718281828459045*Math.Exp(-d2)*Math.Exp(-(1/v));
                return result;
            }
            alglib.ap.assert(false, "RBFV2BasisFunc: unknown BF type");
            return result;
        }


        /*************************************************************************
        Returns basis function value, first and second derivatives
        Assumes that D2>=0
        *************************************************************************/
        public static void rbfv2basisfuncdiff2(int bf,
            double d2,
            ref double f,
            ref double df,
            ref double d2f,
            alglib.xparams _params)
        {
            double v = 0;

            f = 0;
            df = 0;
            d2f = 0;

            if( bf==0 )
            {
                f = Math.Exp(-d2);
                df = -f;
                d2f = f;
                return;
            }
            if( bf==1 )
            {
                
                //
                // if D2<3:
                //       F = Exp(1)*Exp(-D2)*Exp(-1/(1-D2/9))
                //      dF =  -F * [pow(D2/9-1,-2)/9 + 1]
                //     d2F = -dF * [pow(D2/9-1,-2)/9 + 1] - F*(2/81)*pow(D2/9-1,-3)
                // else:
                //     0
                //
                v = 1-d2/9;
                if( (double)(v)<=(double)(0) )
                {
                    f = 0;
                    df = 0;
                    d2f = 0;
                    return;
                }
                f = Math.Exp(1)*Math.Exp(-d2)*Math.Exp(-(1/v));
                df = -(f*(1/(9*v*v)+1));
                d2f = -(df*(1/(9*v*v)+1))-f*((double)2/(double)81)/(v*v*v);
                return;
            }
            alglib.ap.assert(false, "RBFV2BasisFuncDiff2: unknown BF type");
        }


        /*************************************************************************
        This function calculates values of the RBF model in the given point.

        This function should be used when we have NY=1 (scalar function) and  NX=1
        (1-dimensional space).

        This function returns 0.0 when:
        * model is not initialized
        * NX<>1
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   X-coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfv2calc1(rbfv2model s,
            double x0,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc1: invalid value for X0 (X0 is Inf)!");
            if( s.ny!=1 || s.nx!=1 )
            {
                result = 0;
                return result;
            }
            result = s.v[0,0]*x0-s.v[0,1];
            if( s.nh==0 )
            {
                return result;
            }
            allocatecalcbuffer(s, s.calcbuf, _params);
            s.calcbuf.x123[0] = x0;
            rbfv2tscalcbuf(s, s.calcbuf, s.calcbuf.x123, ref s.calcbuf.y123, _params);
            result = s.calcbuf.y123[0];
            return result;
        }


        /*************************************************************************
        This function calculates values of the RBF model in the given point.

        This function should be used when we have NY=1 (scalar function) and  NX=2
        (2-dimensional space). If you have 3-dimensional space, use RBFCalc3(). If
        you have general situation (NX-dimensional space, NY-dimensional function)
        you should use general, less efficient implementation RBFCalc().

        If  you  want  to  calculate  function  values  many times, consider using 
        RBFGridCalc2(), which is far more efficient than many subsequent calls  to
        RBFCalc2().

        This function returns 0.0 when:
        * model is not initialized
        * NX<>2
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfv2calc2(rbfv2model s,
            double x0,
            double x1,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc2: invalid value for X0 (X0 is Inf)!");
            alglib.ap.assert(math.isfinite(x1), "RBFCalc2: invalid value for X1 (X1 is Inf)!");
            if( s.ny!=1 || s.nx!=2 )
            {
                result = 0;
                return result;
            }
            result = s.v[0,0]*x0+s.v[0,1]*x1+s.v[0,2];
            if( s.nh==0 )
            {
                return result;
            }
            allocatecalcbuffer(s, s.calcbuf, _params);
            s.calcbuf.x123[0] = x0;
            s.calcbuf.x123[1] = x1;
            rbfv2tscalcbuf(s, s.calcbuf, s.calcbuf.x123, ref s.calcbuf.y123, _params);
            result = s.calcbuf.y123[0];
            return result;
        }


        /*************************************************************************
        This function calculates values of the RBF model in the given point.

        This function should be used when we have NY=1 (scalar function) and  NX=3
        (3-dimensional space). If you have 2-dimensional space, use RBFCalc2(). If
        you have general situation (NX-dimensional space, NY-dimensional function)
        you should use general, less efficient implementation RBFCalc().

        This function returns 0.0 when:
        * model is not initialized
        * NX<>3
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number
            X2      -   third coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfv2calc3(rbfv2model s,
            double x0,
            double x1,
            double x2,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc3: invalid value for X0 (X0 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x1), "RBFCalc3: invalid value for X1 (X1 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x2), "RBFCalc3: invalid value for X2 (X2 is Inf or NaN)!");
            if( s.ny!=1 || s.nx!=3 )
            {
                result = 0;
                return result;
            }
            result = s.v[0,0]*x0+s.v[0,1]*x1+s.v[0,2]*x2+s.v[0,3];
            if( s.nh==0 )
            {
                return result;
            }
            allocatecalcbuffer(s, s.calcbuf, _params);
            s.calcbuf.x123[0] = x0;
            s.calcbuf.x123[1] = x1;
            s.calcbuf.x123[2] = x2;
            rbfv2tscalcbuf(s, s.calcbuf, s.calcbuf.x123, ref s.calcbuf.y123, _params);
            result = s.calcbuf.y123[0];
            return result;
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point.

        Same as RBFCalc(), but does not reallocate Y when in is large enough to 
        store function values.

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2calcbuf(rbfv2model s,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            rbfv2tscalcbuf(s, s.calcbuf, x, ref y, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point, using
        external  buffer  object  (internal  temporaries  of  RBF  model  are  not
        modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2tscalcbuf(rbfv2model s,
            rbfv2calcbuffer buf,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int levelidx = 0;
            double rcur = 0;
            double rquery2 = 0;
            double invrc2 = 0;
            int nx = 0;
            int ny = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFCalcBuf: X contains infinite or NaN values");
            nx = s.nx;
            ny = s.ny;
            
            //
            // Handle linear term
            //
            if( alglib.ap.len(y)<ny )
            {
                y = new double[ny];
            }
            for(i=0; i<=ny-1; i++)
            {
                y[i] = s.v[i,nx];
                for(j=0; j<=nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                }
            }
            if( s.nh==0 )
            {
                return;
            }
            
            //
            // Handle nonlinear term
            //
            allocatecalcbuffer(s, buf, _params);
            for(j=0; j<=nx-1; j++)
            {
                buf.x[j] = x[j]/s.s[j];
            }
            for(levelidx=0; levelidx<=s.nh-1; levelidx++)
            {
                
                //
                // Prepare fields of Buf required by PartialCalcRec()
                //
                buf.curdist2 = 0;
                for(j=0; j<=nx-1; j++)
                {
                    buf.curboxmin[j] = s.kdboxmin[j];
                    buf.curboxmax[j] = s.kdboxmax[j];
                    if( (double)(buf.x[j])<(double)(buf.curboxmin[j]) )
                    {
                        buf.curdist2 = buf.curdist2+math.sqr(buf.curboxmin[j]-buf.x[j]);
                    }
                    else
                    {
                        if( (double)(buf.x[j])>(double)(buf.curboxmax[j]) )
                        {
                            buf.curdist2 = buf.curdist2+math.sqr(buf.x[j]-buf.curboxmax[j]);
                        }
                    }
                }
                
                //
                // Call PartialCalcRec()
                //
                rcur = s.ri[levelidx];
                invrc2 = 1/(rcur*rcur);
                rquery2 = math.sqr(rcur*rbfv2farradius(s.bf, _params));
                partialcalcrec(s, buf, s.kdroots[levelidx], invrc2, rquery2, buf.x, y, y, y, 0, _params);
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the  given  point  and
        its derivatives, using external buffer object (internal temporaries of the
        RBF model are not modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y, DY   -   possibly preallocated arrays

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.
            DY      -   derivatives, array[NY*NX]. DY is not reallocated when it
                        is larger than NY*NX.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2tsdiffbuf(rbfv2model s,
            rbfv2calcbuffer buf,
            double[] x,
            ref double[] y,
            ref double[] dy,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int levelidx = 0;
            double rcur = 0;
            double rquery2 = 0;
            double invrc2 = 0;
            int nx = 0;
            int ny = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFDiffBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFDiffBuf: X contains infinite or NaN values");
            nx = s.nx;
            ny = s.ny;
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            
            //
            // Handle linear term
            //
            for(i=0; i<=ny-1; i++)
            {
                y[i] = s.v[i,nx];
                for(j=0; j<=nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                    dy[i*nx+j] = s.v[i,j];
                }
            }
            if( s.nh==0 )
            {
                return;
            }
            
            //
            // Handle nonlinear term
            //
            allocatecalcbuffer(s, buf, _params);
            for(j=0; j<=nx-1; j++)
            {
                buf.x[j] = x[j]/s.s[j];
            }
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    dy[i*nx+j] = dy[i*nx+j]*s.s[j];
                }
            }
            for(levelidx=0; levelidx<=s.nh-1; levelidx++)
            {
                
                //
                // Prepare fields of Buf required by PartialCalcRec()
                //
                buf.curdist2 = 0;
                for(j=0; j<=nx-1; j++)
                {
                    buf.curboxmin[j] = s.kdboxmin[j];
                    buf.curboxmax[j] = s.kdboxmax[j];
                    if( (double)(buf.x[j])<(double)(buf.curboxmin[j]) )
                    {
                        buf.curdist2 = buf.curdist2+math.sqr(buf.curboxmin[j]-buf.x[j]);
                    }
                    else
                    {
                        if( (double)(buf.x[j])>(double)(buf.curboxmax[j]) )
                        {
                            buf.curdist2 = buf.curdist2+math.sqr(buf.x[j]-buf.curboxmax[j]);
                        }
                    }
                }
                
                //
                // Call PartialCalcRec()
                //
                rcur = s.ri[levelidx];
                invrc2 = 1/(rcur*rcur);
                rquery2 = math.sqr(rcur*rbfv2farradius(s.bf, _params));
                partialcalcrec(s, buf, s.kdroots[levelidx], invrc2, rquery2, buf.x, y, dy, dy, 1, _params);
            }
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    dy[i*nx+j] = dy[i*nx+j]/s.s[j];
                }
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the  given  point  and
        its first and second derivatives, using external buffer  object  (internal
        temporaries of the RBF model are not modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y,DY,D2Y -  possibly preallocated arrays

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.
            DY      -   derivatives, array[NY*NX]. DY is not reallocated when it
                        is larger than NY*NX.
            D2Y     -   second derivatives, array[NY*NX*NX]

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2tshessbuf(rbfv2model s,
            rbfv2calcbuffer buf,
            double[] x,
            ref double[] y,
            ref double[] dy,
            ref double[] d2y,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int levelidx = 0;
            double rcur = 0;
            double rquery2 = 0;
            double invrc2 = 0;
            int nx = 0;
            int ny = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFDiffBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFDiffBuf: X contains infinite or NaN values");
            nx = s.nx;
            ny = s.ny;
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            if( alglib.ap.len(d2y)<ny*nx*nx )
            {
                d2y = new double[ny*nx*nx];
            }
            
            //
            // Handle linear term
            //
            for(i=0; i<=ny-1; i++)
            {
                y[i] = s.v[i,nx];
                for(j=0; j<=nx-1; j++)
                {
                    y[i] = y[i]+s.v[i,j]*x[j];
                    dy[i*nx+j] = s.v[i,j];
                }
            }
            ablasf.rsetv(ny*nx*nx, 0.0, d2y, _params);
            if( s.nh==0 )
            {
                return;
            }
            
            //
            // Handle nonlinear term
            //
            allocatecalcbuffer(s, buf, _params);
            for(j=0; j<=nx-1; j++)
            {
                buf.x[j] = x[j]/s.s[j];
            }
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    dy[i*nx+j] = dy[i*nx+j]*s.s[j];
                }
            }
            for(levelidx=0; levelidx<=s.nh-1; levelidx++)
            {
                
                //
                // Prepare fields of Buf required by PartialCalcRec()
                //
                buf.curdist2 = 0;
                for(j=0; j<=nx-1; j++)
                {
                    buf.curboxmin[j] = s.kdboxmin[j];
                    buf.curboxmax[j] = s.kdboxmax[j];
                    if( (double)(buf.x[j])<(double)(buf.curboxmin[j]) )
                    {
                        buf.curdist2 = buf.curdist2+math.sqr(buf.curboxmin[j]-buf.x[j]);
                    }
                    else
                    {
                        if( (double)(buf.x[j])>(double)(buf.curboxmax[j]) )
                        {
                            buf.curdist2 = buf.curdist2+math.sqr(buf.x[j]-buf.curboxmax[j]);
                        }
                    }
                }
                
                //
                // Call PartialCalcRec()
                //
                rcur = s.ri[levelidx];
                invrc2 = 1/(rcur*rcur);
                rquery2 = math.sqr(rcur*rbfv2farradius(s.bf, _params));
                partialcalcrec(s, buf, s.kdroots[levelidx], invrc2, rquery2, buf.x, y, dy, d2y, 2, _params);
            }
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    dy[i*nx+j] = dy[i*nx+j]/s.s[j];
                }
            }
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx-1; j++)
                {
                    for(k=0; k<=nx-1; k++)
                    {
                        d2y[i*nx*nx+j*nx+k] = d2y[i*nx*nx+j*nx+k]/(s.s[j]*s.s[k]);
                    }
                }
            }
        }


        /*************************************************************************
        This function calculates values of the RBF model at the regular grid.

        Grid have N0*N1 points, with Point[I,J] = (X0[I], X1[J])

        This function returns 0.0 when:
        * model is not initialized
        * NX<>2
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   array of grid nodes, first coordinates, array[N0]
            N0      -   grid size (number of nodes) in the first dimension
            X1      -   array of grid nodes, second coordinates, array[N1]
            N1      -   grid size (number of nodes) in the second dimension

        OUTPUT PARAMETERS:
            Y       -   function values, array[N0,N1]. Y is out-variable and 
                        is reallocated by this function.
                        
        NOTE: as a special exception, this function supports unordered  arrays  X0
              and X1. However, future versions may be  more  efficient  for  X0/X1
              ordered by ascending.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2gridcalc2(rbfv2model s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            ref double[,] y,
            alglib.xparams _params)
        {
            double[] cpx0 = new double[0];
            double[] cpx1 = new double[0];
            double[] dummyx2 = new double[0];
            double[] dummyx3 = new double[0];
            bool[] dummyflag = new bool[0];
            int[] p01 = new int[0];
            int[] p11 = new int[0];
            int[] p2 = new int[0];
            double[] vy = new double[0];
            int i = 0;
            int j = 0;

            y = new double[0,0];

            alglib.ap.assert(n0>0, "RBFGridCalc2: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc2: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc2: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc2: Length(X1)<N1");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc2: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc2: X1 contains infinite or NaN values!");
            y = new double[n0, n1];
            for(i=0; i<=n0-1; i++)
            {
                for(j=0; j<=n1-1; j++)
                {
                    y[i,j] = 0;
                }
            }
            if( s.ny!=1 || s.nx!=2 )
            {
                return;
            }
            
            //
            //create and sort arrays
            //
            cpx0 = new double[n0];
            for(i=0; i<=n0-1; i++)
            {
                cpx0[i] = x0[i];
            }
            tsort.tagsort(ref cpx0, n0, ref p01, ref p2, _params);
            cpx1 = new double[n1];
            for(i=0; i<=n1-1; i++)
            {
                cpx1[i] = x1[i];
            }
            tsort.tagsort(ref cpx1, n1, ref p11, ref p2, _params);
            dummyx2 = new double[1];
            dummyx2[0] = 0;
            dummyx3 = new double[1];
            dummyx3[0] = 0;
            vy = new double[n0*n1];
            rbfv2gridcalcvx(s, cpx0, n0, cpx1, n1, dummyx2, 1, dummyx3, 1, dummyflag, false, vy, _params);
            for(i=0; i<=n0-1; i++)
            {
                for(j=0; j<=n1-1; j++)
                {
                    y[i,j] = vy[i+j*n0];
                }
            }
        }


        /*************************************************************************
        This function is used to perform gridded calculation  for  2D,  3D  or  4D
        problems. It accepts parameters X0...X3 and counters N0...N3. If RBF model
        has dimensionality less than 4, corresponding arrays should  contain  just
        one element equal to zero, and corresponding N's should be equal to 1.

        NOTE: array Y should be preallocated by caller.

          -- ALGLIB --
             Copyright 12.07.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2gridcalcvx(rbfv2model s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            double[] x3,
            int n3,
            bool[] flagy,
            bool sparsey,
            double[] y,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            double[] tx = new double[0];
            double[] ty = new double[0];
            double[] z = new double[0];
            int dstoffs = 0;
            int dummy = 0;
            rbfv2gridcalcbuffer bufseedv2 = new rbfv2gridcalcbuffer();
            alglib.smp.shared_pool bufpool = new alglib.smp.shared_pool();
            int rowidx = 0;
            int rowcnt = 0;
            double v = 0;
            double rcur = 0;
            int levelidx = 0;
            double searchradius2 = 0;
            int ntrials = 0;
            double avgfuncpernode = 0;
            hqrnd.hqrndstate rs = new hqrnd.hqrndstate();
            int[] blocks0 = new int[0];
            int[] blocks1 = new int[0];
            int[] blocks2 = new int[0];
            int[] blocks3 = new int[0];
            int blockscnt0 = 0;
            int blockscnt1 = 0;
            int blockscnt2 = 0;
            int blockscnt3 = 0;
            double blockwidth0 = 0;
            double blockwidth1 = 0;
            double blockwidth2 = 0;
            double blockwidth3 = 0;
            int maxblocksize = 0;

            nx = s.nx;
            ny = s.ny;
            hqrnd.hqrndseed(532, 54734, rs, _params);
            
            //
            // Perform integrity checks
            //
            alglib.ap.assert(s.nx==2 || s.nx==3, "RBFGridCalcVX: integrity check failed");
            alglib.ap.assert(s.nx>=4 || ((alglib.ap.len(x3)>=1 && (double)(x3[0])==(double)(0)) && n3==1), "RBFGridCalcVX: integrity check failed");
            alglib.ap.assert(s.nx>=3 || ((alglib.ap.len(x2)>=1 && (double)(x2[0])==(double)(0)) && n2==1), "RBFGridCalcVX: integrity check failed");
            alglib.ap.assert(s.nx>=2 || ((alglib.ap.len(x1)>=1 && (double)(x1[0])==(double)(0)) && n1==1), "RBFGridCalcVX: integrity check failed");
            
            //
            // Allocate arrays
            //
            alglib.ap.assert(s.nx<=4, "RBFGridCalcVX: integrity check failed");
            z = new double[ny];
            tx = new double[4];
            ty = new double[ny];
            
            //
            // Calculate linear term
            //
            rowcnt = n1*n2*n3;
            for(rowidx=0; rowidx<=rowcnt-1; rowidx++)
            {
                
                //
                // Calculate TX - current position
                //
                k = rowidx;
                tx[0] = 0;
                tx[1] = x1[k%n1];
                k = k/n1;
                tx[2] = x2[k%n2];
                k = k/n2;
                tx[3] = x3[k%n3];
                k = k/n3;
                alglib.ap.assert(k==0, "RBFGridCalcVX: integrity check failed");
                for(j=0; j<=ny-1; j++)
                {
                    v = s.v[j,nx];
                    for(k=1; k<=nx-1; k++)
                    {
                        v = v+tx[k]*s.v[j,k];
                    }
                    z[j] = v;
                }
                for(i=0; i<=n0-1; i++)
                {
                    dstoffs = ny*(rowidx*n0+i);
                    if( sparsey && !flagy[rowidx*n0+i] )
                    {
                        for(j=0; j<=ny-1; j++)
                        {
                            y[j+dstoffs] = 0;
                        }
                        continue;
                    }
                    v = x0[i];
                    for(j=0; j<=ny-1; j++)
                    {
                        y[j+dstoffs] = z[j]+v*s.v[j,0];
                    }
                }
            }
            if( s.nh==0 )
            {
                return;
            }
            
            //
            // Process RBF terms, layer by layer
            //
            for(levelidx=0; levelidx<=s.nh-1; levelidx++)
            {
                rcur = s.ri[levelidx];
                blockwidth0 = 1;
                blockwidth1 = 1;
                blockwidth2 = 1;
                blockwidth3 = 1;
                if( nx>=1 )
                {
                    blockwidth0 = rcur*s.s[0];
                }
                if( nx>=2 )
                {
                    blockwidth1 = rcur*s.s[1];
                }
                if( nx>=3 )
                {
                    blockwidth2 = rcur*s.s[2];
                }
                if( nx>=4 )
                {
                    blockwidth3 = rcur*s.s[3];
                }
                maxblocksize = 8;
                
                //
                // Group grid nodes into blocks according to current radius
                //
                blocks0 = new int[n0+1];
                blockscnt0 = 0;
                blocks0[0] = 0;
                for(i=1; i<=n0-1; i++)
                {
                    if( (double)(x0[i]-x0[blocks0[blockscnt0]])>(double)(blockwidth0) || i-blocks0[blockscnt0]>=maxblocksize )
                    {
                        apserv.inc(ref blockscnt0, _params);
                        blocks0[blockscnt0] = i;
                    }
                }
                apserv.inc(ref blockscnt0, _params);
                blocks0[blockscnt0] = n0;
                blocks1 = new int[n1+1];
                blockscnt1 = 0;
                blocks1[0] = 0;
                for(i=1; i<=n1-1; i++)
                {
                    if( (double)(x1[i]-x1[blocks1[blockscnt1]])>(double)(blockwidth1) || i-blocks1[blockscnt1]>=maxblocksize )
                    {
                        apserv.inc(ref blockscnt1, _params);
                        blocks1[blockscnt1] = i;
                    }
                }
                apserv.inc(ref blockscnt1, _params);
                blocks1[blockscnt1] = n1;
                blocks2 = new int[n2+1];
                blockscnt2 = 0;
                blocks2[0] = 0;
                for(i=1; i<=n2-1; i++)
                {
                    if( (double)(x2[i]-x2[blocks2[blockscnt2]])>(double)(blockwidth2) || i-blocks2[blockscnt2]>=maxblocksize )
                    {
                        apserv.inc(ref blockscnt2, _params);
                        blocks2[blockscnt2] = i;
                    }
                }
                apserv.inc(ref blockscnt2, _params);
                blocks2[blockscnt2] = n2;
                blocks3 = new int[n3+1];
                blockscnt3 = 0;
                blocks3[0] = 0;
                for(i=1; i<=n3-1; i++)
                {
                    if( (double)(x3[i]-x3[blocks3[blockscnt3]])>(double)(blockwidth3) || i-blocks3[blockscnt3]>=maxblocksize )
                    {
                        apserv.inc(ref blockscnt3, _params);
                        blocks3[blockscnt3] = i;
                    }
                }
                apserv.inc(ref blockscnt3, _params);
                blocks3[blockscnt3] = n3;
                
                //
                // Prepare seed for shared pool
                //
                allocatecalcbuffer(s, bufseedv2.calcbuf, _params);
                alglib.smp.ae_shared_pool_set_seed(bufpool, bufseedv2);
                
                //
                // Determine average number of neighbor per node
                //
                searchradius2 = math.sqr(rcur*rbfv2farradius(s.bf, _params));
                ntrials = 100;
                avgfuncpernode = 0.0;
                for(i=0; i<=ntrials-1; i++)
                {
                    tx[0] = x0[hqrnd.hqrnduniformi(rs, n0, _params)];
                    tx[1] = x1[hqrnd.hqrnduniformi(rs, n1, _params)];
                    tx[2] = x2[hqrnd.hqrnduniformi(rs, n2, _params)];
                    tx[3] = x3[hqrnd.hqrnduniformi(rs, n3, _params)];
                    preparepartialquery(tx, s.kdboxmin, s.kdboxmax, nx, bufseedv2.calcbuf, ref dummy, _params);
                    avgfuncpernode = avgfuncpernode+(double)partialcountrec(s.kdnodes, s.kdsplits, s.cw, nx, ny, bufseedv2.calcbuf, s.kdroots[levelidx], searchradius2, tx, _params)/(double)ntrials;
                }
                
                //
                // Perform calculation in multithreaded mode
                //
                rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, 0, blockscnt0, blocks1, 0, blockscnt1, blocks2, 0, blockscnt2, blocks3, 0, blockscnt3, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
            }
        }


        public static void rbfv2partialgridcalcrec(rbfv2model s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            double[] x3,
            int n3,
            int[] blocks0,
            int block0a,
            int block0b,
            int[] blocks1,
            int block1a,
            int block1b,
            int[] blocks2,
            int block2a,
            int block2b,
            int[] blocks3,
            int block3a,
            int block3b,
            bool[] flagy,
            bool sparsey,
            int levelidx,
            double avgfuncpernode,
            alglib.smp.shared_pool bufpool,
            double[] y,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;
            int k = 0;
            int l = 0;
            int blkidx = 0;
            int blkcnt = 0;
            int nodeidx = 0;
            int nodescnt = 0;
            int rowidx = 0;
            int rowscnt = 0;
            int i0 = 0;
            int i1 = 0;
            int i2 = 0;
            int i3 = 0;
            int j0 = 0;
            int j1 = 0;
            int j2 = 0;
            int j3 = 0;
            double rcur = 0;
            double invrc2 = 0;
            double rquery2 = 0;
            double rfar2 = 0;
            int dstoffs = 0;
            int srcoffs = 0;
            int dummy = 0;
            double rowwidth = 0;
            double maxrowwidth = 0;
            double problemcost = 0;
            int maxbs = 0;
            int midpoint = 0;
            bool emptyrow = new bool();
            rbfv2gridcalcbuffer buf = null;

            nx = s.nx;
            ny = s.ny;
            
            //
            // Integrity checks
            //
            alglib.ap.assert(s.nx==2 || s.nx==3, "RBFV2PartialGridCalcRec: integrity check failed");
            
            //
            // Try to split large problem
            //
            problemcost = s.ny*2*(avgfuncpernode+1);
            problemcost = problemcost*(blocks0[block0b]-blocks0[block0a]);
            problemcost = problemcost*(blocks1[block1b]-blocks1[block1a]);
            problemcost = problemcost*(blocks2[block2b]-blocks2[block2a]);
            problemcost = problemcost*(blocks3[block3b]-blocks3[block3a]);
            maxbs = 0;
            maxbs = Math.Max(maxbs, block0b-block0a);
            maxbs = Math.Max(maxbs, block1b-block1a);
            maxbs = Math.Max(maxbs, block2b-block2a);
            maxbs = Math.Max(maxbs, block3b-block3a);
            if( (double)(problemcost*complexitymultiplier)>=(double)(apserv.smpactivationlevel(_params)) )
            {
                if( _trypexec_rbfv2partialgridcalcrec(s,x0,n0,x1,n1,x2,n2,x3,n3,blocks0,block0a,block0b,blocks1,block1a,block1b,blocks2,block2a,block2b,blocks3,block3a,block3b,flagy,sparsey,levelidx,avgfuncpernode,bufpool,y, _params) )
                {
                    return;
                }
            }
            if( (double)(problemcost*complexitymultiplier)>=(double)(apserv.spawnlevel(_params)) && maxbs>=2 )
            {
                if( block0b-block0a==maxbs )
                {
                    midpoint = block0a+maxbs/2;
                    rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, midpoint, blocks1, block1a, block1b, blocks2, block2a, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
                    rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, midpoint, block0b, blocks1, block1a, block1b, blocks2, block2a, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
                    return;
                }
                if( block1b-block1a==maxbs )
                {
                    midpoint = block1a+maxbs/2;
                    rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, midpoint, blocks2, block2a, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
                    rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, midpoint, block1b, blocks2, block2a, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
                    return;
                }
                if( block2b-block2a==maxbs )
                {
                    midpoint = block2a+maxbs/2;
                    rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a, midpoint, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
                    rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, midpoint, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
                    return;
                }
                if( block3b-block3a==maxbs )
                {
                    midpoint = block3a+maxbs/2;
                    rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a, block2b, blocks3, block3a, midpoint, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
                    rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a, block2b, blocks3, midpoint, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _params);
                    return;
                }
                alglib.ap.assert(false, "RBFV2PartialGridCalcRec: integrity check failed");
            }
            
            //
            // Retrieve buffer object from pool (it will be returned later)
            //
            alglib.smp.ae_shared_pool_retrieve(bufpool, ref buf);
            
            //
            // Calculate RBF model
            //
            alglib.ap.assert(nx<=4, "RBFV2PartialGridCalcRec: integrity check failed");
            buf.tx = new double[4];
            buf.cx = new double[4];
            buf.ty = new double[ny];
            rcur = s.ri[levelidx];
            invrc2 = 1/(rcur*rcur);
            blkcnt = (block3b-block3a)*(block2b-block2a)*(block1b-block1a)*(block0b-block0a);
            for(blkidx=0; blkidx<=blkcnt-1; blkidx++)
            {
                
                //
                // Select block (I0,I1,I2,I3).
                //
                // NOTE: for problems with NX<4 corresponding I_? are zero.
                //
                k = blkidx;
                i0 = block0a+k%(block0b-block0a);
                k = k/(block0b-block0a);
                i1 = block1a+k%(block1b-block1a);
                k = k/(block1b-block1a);
                i2 = block2a+k%(block2b-block2a);
                k = k/(block2b-block2a);
                i3 = block3a+k%(block3b-block3a);
                k = k/(block3b-block3a);
                alglib.ap.assert(k==0, "RBFV2PartialGridCalcRec: integrity check failed");
                
                //
                // We partitioned grid into blocks and selected block with
                // index (I0,I1,I2,I3). This block is a 4D cube (some dimensions
                // may be zero) of nodes with indexes (J0,J1,J2,J3), which is
                // further partitioned into a set of rows, each row corresponding
                // to indexes J1...J3 being fixed.
                //
                // We process block row by row, and each row may be handled
                // by either "generic" (nodes are processed separately) or
                // batch algorithm (that's the reason to use rows, after all).
                //
                //
                // Process nodes of the block
                //
                rowscnt = (blocks3[i3+1]-blocks3[i3])*(blocks2[i2+1]-blocks2[i2])*(blocks1[i1+1]-blocks1[i1]);
                for(rowidx=0; rowidx<=rowscnt-1; rowidx++)
                {
                    
                    //
                    // Find out node indexes (*,J1,J2,J3).
                    //
                    // NOTE: for problems with NX<4 corresponding J_? are zero.
                    //
                    k = rowidx;
                    j1 = blocks1[i1]+k%(blocks1[i1+1]-blocks1[i1]);
                    k = k/(blocks1[i1+1]-blocks1[i1]);
                    j2 = blocks2[i2]+k%(blocks2[i2+1]-blocks2[i2]);
                    k = k/(blocks2[i2+1]-blocks2[i2]);
                    j3 = blocks3[i3]+k%(blocks3[i3+1]-blocks3[i3]);
                    k = k/(blocks3[i3+1]-blocks3[i3]);
                    alglib.ap.assert(k==0, "RBFV2PartialGridCalcRec: integrity check failed");
                    
                    //
                    // Analyze row, skip completely empty rows
                    //
                    nodescnt = blocks0[i0+1]-blocks0[i0];
                    srcoffs = blocks0[i0]+(j1+(j2+j3*n2)*n1)*n0;
                    emptyrow = true;
                    for(nodeidx=0; nodeidx<=nodescnt-1; nodeidx++)
                    {
                        emptyrow = emptyrow && (sparsey && !flagy[srcoffs+nodeidx]);
                    }
                    if( emptyrow )
                    {
                        continue;
                    }
                    
                    //
                    // Process row - use either "batch" (rowsize>1) or "generic"
                    // (row size is 1) algorithm.
                    //
                    // NOTE: "generic" version may also be used as fallback code for
                    //       situations when we do not want to use batch code.
                    //
                    maxrowwidth = 0.5*rbfv2nearradius(s.bf, _params)*rcur*s.s[0];
                    rowwidth = x0[blocks0[i0+1]-1]-x0[blocks0[i0]];
                    if( nodescnt>1 && (double)(rowwidth)<=(double)(maxrowwidth) )
                    {
                        
                        //
                        // "Batch" code which processes entire row at once, saving
                        // some time in kd-tree search code.
                        //
                        rquery2 = math.sqr(rcur*rbfv2farradius(s.bf, _params)+0.5*rowwidth/s.s[0]);
                        rfar2 = math.sqr(rcur*rbfv2farradius(s.bf, _params));
                        j0 = blocks0[i0];
                        if( nx>0 )
                        {
                            buf.cx[0] = (x0[j0]+0.5*rowwidth)/s.s[0];
                        }
                        if( nx>1 )
                        {
                            buf.cx[1] = x1[j1]/s.s[1];
                        }
                        if( nx>2 )
                        {
                            buf.cx[2] = x2[j2]/s.s[2];
                        }
                        if( nx>3 )
                        {
                            buf.cx[3] = x3[j3]/s.s[3];
                        }
                        srcoffs = j0+(j1+(j2+j3*n2)*n1)*n0;
                        dstoffs = ny*srcoffs;
                        apserv.rvectorsetlengthatleast(ref buf.rx, nodescnt, _params);
                        apserv.bvectorsetlengthatleast(ref buf.rf, nodescnt, _params);
                        apserv.rvectorsetlengthatleast(ref buf.ry, nodescnt*ny, _params);
                        for(nodeidx=0; nodeidx<=nodescnt-1; nodeidx++)
                        {
                            buf.rx[nodeidx] = x0[j0+nodeidx]/s.s[0];
                            buf.rf[nodeidx] = !sparsey || flagy[srcoffs+nodeidx];
                        }
                        for(k=0; k<=nodescnt*ny-1; k++)
                        {
                            buf.ry[k] = 0;
                        }
                        preparepartialquery(buf.cx, s.kdboxmin, s.kdboxmax, nx, buf.calcbuf, ref dummy, _params);
                        partialrowcalcrec(s, buf.calcbuf, s.kdroots[levelidx], invrc2, rquery2, rfar2, buf.cx, buf.rx, buf.rf, nodescnt, buf.ry, _params);
                        for(k=0; k<=nodescnt*ny-1; k++)
                        {
                            y[dstoffs+k] = y[dstoffs+k]+buf.ry[k];
                        }
                    }
                    else
                    {
                        
                        //
                        // "Generic" code. Although we usually move here
                        // only when NodesCnt=1, we still use a loop on
                        // NodeIdx just to be able to use this branch as
                        // fallback code without any modifications.
                        //
                        rquery2 = math.sqr(rcur*rbfv2farradius(s.bf, _params));
                        for(nodeidx=0; nodeidx<=nodescnt-1; nodeidx++)
                        {
                            
                            //
                            // Prepare TX - current point
                            //
                            j0 = blocks0[i0]+nodeidx;
                            if( nx>0 )
                            {
                                buf.tx[0] = x0[j0]/s.s[0];
                            }
                            if( nx>1 )
                            {
                                buf.tx[1] = x1[j1]/s.s[1];
                            }
                            if( nx>2 )
                            {
                                buf.tx[2] = x2[j2]/s.s[2];
                            }
                            if( nx>3 )
                            {
                                buf.tx[3] = x3[j3]/s.s[3];
                            }
                            
                            //
                            // Evaluate and add to Y
                            //
                            srcoffs = j0+(j1+(j2+j3*n2)*n1)*n0;
                            dstoffs = ny*srcoffs;
                            for(l=0; l<=ny-1; l++)
                            {
                                buf.ty[l] = 0;
                            }
                            if( !sparsey || flagy[srcoffs] )
                            {
                                preparepartialquery(buf.tx, s.kdboxmin, s.kdboxmax, nx, buf.calcbuf, ref dummy, _params);
                                partialcalcrec(s, buf.calcbuf, s.kdroots[levelidx], invrc2, rquery2, buf.tx, buf.ty, buf.ty, buf.ty, 0, _params);
                            }
                            for(l=0; l<=ny-1; l++)
                            {
                                y[dstoffs+l] = y[dstoffs+l]+buf.ty[l];
                            }
                        }
                    }
                }
            }
            
            //
            // Recycle buffer object back to pool
            //
            alglib.smp.ae_shared_pool_recycle(bufpool, ref buf);
        }


        /*************************************************************************
        Serial stub for GPL edition.
        *************************************************************************/
        public static bool _trypexec_rbfv2partialgridcalcrec(rbfv2model s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            double[] x3,
            int n3,
            int[] blocks0,
            int block0a,
            int block0b,
            int[] blocks1,
            int block1a,
            int block1b,
            int[] blocks2,
            int block2a,
            int block2b,
            int[] blocks3,
            int block3a,
            int block3b,
            bool[] flagy,
            bool sparsey,
            int levelidx,
            double avgfuncpernode,
            alglib.smp.shared_pool bufpool,
            double[] y, alglib.xparams _params)
        {
            return false;
        }


        /*************************************************************************
        This function "unpacks" RBF model by extracting its coefficients.

        INPUT PARAMETERS:
            S       -   RBF model

        OUTPUT PARAMETERS:
            NX      -   dimensionality of argument
            NY      -   dimensionality of the target function
            XWR     -   model information, array[NC,NX+NY+1].
                        One row of the array corresponds to one basis function:
                        * first NX columns  - coordinates of the center 
                        * next NY columns   - weights, one per dimension of the 
                                              function being modelled
                        * last NX columns   - radii, per dimension
            NC      -   number of the centers
            V       -   polynomial  term , array[NY,NX+1]. One row per one 
                        dimension of the function being modelled. First NX 
                        elements are linear coefficients, V[NX] is equal to the 
                        constant part.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfv2unpack(rbfv2model s,
            ref int nx,
            ref int ny,
            ref double[,] xwr,
            ref int nc,
            ref double[,] v,
            alglib.xparams _params)
        {
            int i = 0;
            int ncactual = 0;
            int i_ = 0;

            nx = 0;
            ny = 0;
            xwr = new double[0,0];
            nc = 0;
            v = new double[0,0];

            nx = s.nx;
            ny = s.ny;
            nc = 0;
            
            //
            // Fill V
            //
            v = new double[s.ny, s.nx+1];
            for(i=0; i<=s.ny-1; i++)
            {
                for(i_=0; i_<=s.nx;i_++)
                {
                    v[i,i_] = s.v[i,i_];
                }
            }
            
            //
            // Fill XWR
            //
            alglib.ap.assert(alglib.ap.len(s.cw)%(s.nx+s.ny)==0, "RBFV2Unpack: integrity error");
            nc = alglib.ap.len(s.cw)/(s.nx+s.ny);
            ncactual = 0;
            if( nc>0 )
            {
                xwr = new double[nc, s.nx+s.ny+s.nx];
                for(i=0; i<=s.nh-1; i++)
                {
                    partialunpackrec(s.kdnodes, s.kdsplits, s.cw, s.s, s.nx, s.ny, s.kdroots[i], s.ri[i], xwr, ref ncactual, _params);
                }
            }
            alglib.ap.assert(nc==ncactual, "RBFV2Unpack: integrity error");
        }


        private static bool rbfv2buildlinearmodel(double[,] x,
            ref double[,] y,
            int n,
            int nx,
            int ny,
            int modeltype,
            ref double[,] v,
            alglib.xparams _params)
        {
            bool result = new bool();
            double[] tmpy = new double[0];
            double[,] a = new double[0,0];
            double scaling = 0;
            double[] shifting = new double[0];
            double mn = 0;
            double mx = 0;
            double[] c = new double[0];
            lsfit.lsfitreport rep = new lsfit.lsfitreport();
            int i = 0;
            int j = 0;
            int k = 0;
            int info = 0;

            v = new double[0,0];

            alglib.ap.assert(n>=0, "BuildLinearModel: N<0");
            alglib.ap.assert(nx>0, "BuildLinearModel: NX<=0");
            alglib.ap.assert(ny>0, "BuildLinearModel: NY<=0");
            
            //
            // Handle degenerate case (N=0)
            //
            result = true;
            v = new double[ny, nx+1];
            if( n==0 )
            {
                for(j=0; j<=nx; j++)
                {
                    for(i=0; i<=ny-1; i++)
                    {
                        v[i,j] = 0;
                    }
                }
                return result;
            }
            
            //
            // Allocate temporaries
            //
            tmpy = new double[n];
            
            //
            // General linear model.
            //
            if( modeltype==1 )
            {
                
                //
                // Calculate scaling/shifting, transform variables, prepare LLS problem
                //
                a = new double[n, nx+1];
                shifting = new double[nx];
                scaling = 0;
                for(i=0; i<=nx-1; i++)
                {
                    mn = x[0,i];
                    mx = mn;
                    for(j=1; j<=n-1; j++)
                    {
                        if( (double)(mn)>(double)(x[j,i]) )
                        {
                            mn = x[j,i];
                        }
                        if( (double)(mx)<(double)(x[j,i]) )
                        {
                            mx = x[j,i];
                        }
                    }
                    scaling = Math.Max(scaling, mx-mn);
                    shifting[i] = 0.5*(mx+mn);
                }
                if( (double)(scaling)==(double)(0) )
                {
                    scaling = 1;
                }
                else
                {
                    scaling = 0.5*scaling;
                }
                for(i=0; i<=n-1; i++)
                {
                    for(j=0; j<=nx-1; j++)
                    {
                        a[i,j] = (x[i,j]-shifting[j])/scaling;
                    }
                }
                for(i=0; i<=n-1; i++)
                {
                    a[i,nx] = 1;
                }
                
                //
                // Solve linear system in transformed variables, make backward 
                //
                for(i=0; i<=ny-1; i++)
                {
                    for(j=0; j<=n-1; j++)
                    {
                        tmpy[j] = y[j,i];
                    }
                    lsfit.lsfitlinear(tmpy, a, n, nx+1, ref info, ref c, rep, _params);
                    if( info<=0 )
                    {
                        result = false;
                        return result;
                    }
                    for(j=0; j<=nx-1; j++)
                    {
                        v[i,j] = c[j]/scaling;
                    }
                    v[i,nx] = c[nx];
                    for(j=0; j<=nx-1; j++)
                    {
                        v[i,nx] = v[i,nx]-shifting[j]*v[i,j];
                    }
                    for(j=0; j<=n-1; j++)
                    {
                        for(k=0; k<=nx-1; k++)
                        {
                            y[j,i] = y[j,i]-x[j,k]*v[i,k];
                        }
                        y[j,i] = y[j,i]-v[i,nx];
                    }
                }
                return result;
            }
            
            //
            // Constant model, very simple
            //
            if( modeltype==2 )
            {
                for(i=0; i<=ny-1; i++)
                {
                    for(j=0; j<=nx; j++)
                    {
                        v[i,j] = 0;
                    }
                    for(j=0; j<=n-1; j++)
                    {
                        v[i,nx] = v[i,nx]+y[j,i];
                    }
                    if( n>0 )
                    {
                        v[i,nx] = v[i,nx]/n;
                    }
                    for(j=0; j<=n-1; j++)
                    {
                        y[j,i] = y[j,i]-v[i,nx];
                    }
                }
                return result;
            }
            
            //
            // Zero model
            //
            alglib.ap.assert(modeltype==3, "BuildLinearModel: unknown model type");
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx; j++)
                {
                    v[i,j] = 0;
                }
            }
            return result;
        }


        /*************************************************************************
        Reallocates calcBuf if necessary, reuses previously allocated space if
        possible.

          -- ALGLIB --
             Copyright 20.06.2016 by Sergey Bochkanov
        *************************************************************************/
        private static void allocatecalcbuffer(rbfv2model s,
            rbfv2calcbuffer buf,
            alglib.xparams _params)
        {
            if( alglib.ap.len(buf.x)<s.nx )
            {
                buf.x = new double[s.nx];
            }
            if( alglib.ap.len(buf.curboxmin)<s.nx )
            {
                buf.curboxmin = new double[s.nx];
            }
            if( alglib.ap.len(buf.curboxmax)<s.nx )
            {
                buf.curboxmax = new double[s.nx];
            }
            if( alglib.ap.len(buf.x123)<s.nx )
            {
                buf.x123 = new double[s.nx];
            }
            if( alglib.ap.len(buf.y123)<s.ny )
            {
                buf.y123 = new double[s.ny];
            }
        }


        /*************************************************************************
        Extracts structure (and XY-values too) from  kd-tree  built  for  a  small
        subset of points and appends it to multi-tree.


          -- ALGLIB --
             Copyright 20.06.2016 by Sergey Bochkanov
        *************************************************************************/
        private static void convertandappendtree(nearestneighbor.kdtree curtree,
            int n,
            int nx,
            int ny,
            ref int[] kdnodes,
            ref double[] kdsplits,
            ref double[] cw,
            alglib.xparams _params)
        {
            int nodesbase = 0;
            int splitsbase = 0;
            int cwbase = 0;
            int[] localnodes = new int[0];
            double[] localsplits = new double[0];
            double[] localcw = new double[0];
            double[,] xybuf = new double[0,0];
            int localnodessize = 0;
            int localsplitssize = 0;
            int localcwsize = 0;
            int i = 0;

            
            //
            // Calculate base offsets
            //
            nodesbase = alglib.ap.len(kdnodes);
            splitsbase = alglib.ap.len(kdsplits);
            cwbase = alglib.ap.len(cw);
            
            //
            // Prepare local copy of tree
            //
            localnodes = new int[n*maxnodesize];
            localsplits = new double[n];
            localcw = new double[(nx+ny)*n];
            localnodessize = 0;
            localsplitssize = 0;
            localcwsize = 0;
            converttreerec(curtree, n, nx, ny, 0, nodesbase, splitsbase, cwbase, localnodes, ref localnodessize, localsplits, ref localsplitssize, localcw, ref localcwsize, ref xybuf, _params);
            
            //
            // Append to multi-tree
            //
            apserv.ivectorresize(ref kdnodes, alglib.ap.len(kdnodes)+localnodessize, _params);
            apserv.rvectorresize(ref kdsplits, alglib.ap.len(kdsplits)+localsplitssize, _params);
            apserv.rvectorresize(ref cw, alglib.ap.len(cw)+localcwsize, _params);
            for(i=0; i<=localnodessize-1; i++)
            {
                kdnodes[nodesbase+i] = localnodes[i];
            }
            for(i=0; i<=localsplitssize-1; i++)
            {
                kdsplits[splitsbase+i] = localsplits[i];
            }
            for(i=0; i<=localcwsize-1; i++)
            {
                cw[cwbase+i] = localcw[i];
            }
        }


        /*************************************************************************
        Recurrent tree conversion

            CurTree         -   tree to convert
            N, NX, NY       -   dataset metrics
            NodeOffset      -   offset of current tree node, 0 for root
            NodesBase       -   a value which is added to intra-tree node indexes;
                                although this tree is stored in separate array, it
                                is intended to be stored in the larger tree,  with
                                localNodes being moved to offset NodesBase.
            SplitsBase      -   similarly, offset of localSplits in the final tree
            CWBase          -   similarly, offset of localCW in the final tree
        *************************************************************************/
        private static void converttreerec(nearestneighbor.kdtree curtree,
            int n,
            int nx,
            int ny,
            int nodeoffset,
            int nodesbase,
            int splitsbase,
            int cwbase,
            int[] localnodes,
            ref int localnodessize,
            double[] localsplits,
            ref int localsplitssize,
            double[] localcw,
            ref int localcwsize,
            ref double[,] xybuf,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int nodetype = 0;
            int cnt = 0;
            int d = 0;
            double s = 0;
            int nodele = 0;
            int nodege = 0;
            int oldnodessize = 0;

            nearestneighbor.kdtreeexplorenodetype(curtree, nodeoffset, ref nodetype, _params);
            
            //
            // Leaf node
            //
            if( nodetype==0 )
            {
                nearestneighbor.kdtreeexploreleaf(curtree, nodeoffset, ref xybuf, ref cnt, _params);
                alglib.ap.assert(alglib.ap.len(localnodes)>=localnodessize+2, "ConvertTreeRec: integrity check failed");
                alglib.ap.assert(alglib.ap.len(localcw)>=localcwsize+cnt*(nx+ny), "ConvertTreeRec: integrity check failed");
                localnodes[localnodessize+0] = cnt;
                localnodes[localnodessize+1] = cwbase+localcwsize;
                localnodessize = localnodessize+2;
                for(i=0; i<=cnt-1; i++)
                {
                    for(j=0; j<=nx+ny-1; j++)
                    {
                        localcw[localcwsize+i*(nx+ny)+j] = xybuf[i,j];
                    }
                }
                localcwsize = localcwsize+cnt*(nx+ny);
                return;
            }
            
            //
            // Split node
            //
            if( nodetype==1 )
            {
                nearestneighbor.kdtreeexploresplit(curtree, nodeoffset, ref d, ref s, ref nodele, ref nodege, _params);
                alglib.ap.assert(alglib.ap.len(localnodes)>=localnodessize+maxnodesize, "ConvertTreeRec: integrity check failed");
                alglib.ap.assert(alglib.ap.len(localsplits)>=localsplitssize+1, "ConvertTreeRec: integrity check failed");
                oldnodessize = localnodessize;
                localnodes[localnodessize+0] = 0;
                localnodes[localnodessize+1] = d;
                localnodes[localnodessize+2] = splitsbase+localsplitssize;
                localnodes[localnodessize+3] = -1;
                localnodes[localnodessize+4] = -1;
                localnodessize = localnodessize+5;
                localsplits[localsplitssize+0] = s;
                localsplitssize = localsplitssize+1;
                localnodes[oldnodessize+3] = nodesbase+localnodessize;
                converttreerec(curtree, n, nx, ny, nodele, nodesbase, splitsbase, cwbase, localnodes, ref localnodessize, localsplits, ref localsplitssize, localcw, ref localcwsize, ref xybuf, _params);
                localnodes[oldnodessize+4] = nodesbase+localnodessize;
                converttreerec(curtree, n, nx, ny, nodege, nodesbase, splitsbase, cwbase, localnodes, ref localnodessize, localsplits, ref localsplitssize, localcw, ref localcwsize, ref xybuf, _params);
                return;
            }
            
            //
            // Integrity error
            //
            alglib.ap.assert(false, "ConvertTreeRec: integrity check failed");
        }


        /*************************************************************************
        This function performs partial calculation of  hierarchical  model:  given
        evaluation point X and partially computed value Y, it updates Y by  values
        computed using part of multi-tree given by RootIdx.

        INPUT PARAMETERS:
            S       -   V2 model
            Buf     -   calc-buffer, this function uses following fields:
                        * Buf.CurBoxMin - should be set by caller
                        * Buf.CurBoxMax - should be set by caller
                        * Buf.CurDist2  - squared distance from X to current bounding box,
                          should be set by caller
            RootIdx -   offset of partial kd-tree
            InvR2   -   1/R^2, where R is basis function radius
            QueryR2 -   squared query radius, usually it is (R*FarRadius(BasisFunction))^2
            X       -   evaluation point, array[NX]
            Y       -   current value for target, array[NY]
            DY      -   current value for derivative, array[NY*NX], if NeedDY>=1
            D2Y     -   current value for derivative, array[NY*NX*NX], if NeedDY>=2
            NeedDY  -   whether derivatives are required or not:
                        * 0 if only Y is needed
                        * 1 if Y and DY are needed
                        * 2 if Y, DY, D2Y are needed
            
        OUTPUT PARAMETERS
            Y       -   updated partial value
            DY      -   updated derivatives, if NeedDY>=1
            D2Y     -   updated Hessian, if NeedDY>=2

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void partialcalcrec(rbfv2model s,
            rbfv2calcbuffer buf,
            int rootidx,
            double invr2,
            double queryr2,
            double[] x,
            double[] y,
            double[] dy,
            double[] d2y,
            int needdy,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int k = 0;
            int k0 = 0;
            int k1 = 0;
            double ptdist2 = 0;
            double w = 0;
            double v = 0;
            double v0 = 0;
            double v1 = 0;
            int cwoffs = 0;
            int cwcnt = 0;
            int itemoffs = 0;
            double arg = 0;
            double val = 0;
            double df = 0;
            double d2f = 0;
            int d = 0;
            double split = 0;
            int childle = 0;
            int childge = 0;
            int childoffs = 0;
            bool updatemin = new bool();
            double prevdist2 = 0;
            double t1 = 0;
            int nx = 0;
            int ny = 0;

            nx = s.nx;
            ny = s.ny;
            
            //
            // Helps to avoid spurious warnings
            //
            val = 0;
            
            //
            // Leaf node.
            //
            if( s.kdnodes[rootidx]>0 )
            {
                cwcnt = s.kdnodes[rootidx+0];
                cwoffs = s.kdnodes[rootidx+1];
                for(i=0; i<=cwcnt-1; i++)
                {
                    
                    //
                    // Calculate distance
                    //
                    itemoffs = cwoffs+i*(nx+ny);
                    ptdist2 = 0;
                    for(j=0; j<=nx-1; j++)
                    {
                        v = s.cw[itemoffs+j]-x[j];
                        ptdist2 = ptdist2+v*v;
                    }
                    
                    //
                    // Skip points if distance too large
                    //
                    if( ptdist2>=queryr2 )
                    {
                        continue;
                    }
                    
                    //
                    // Update Y
                    //
                    arg = ptdist2*invr2;
                    val = 0;
                    df = 0;
                    d2f = 0;
                    if( needdy==2 )
                    {
                        if( s.bf==0 )
                        {
                            val = Math.Exp(-arg);
                            df = -val;
                            d2f = val;
                        }
                        else
                        {
                            if( s.bf==1 )
                            {
                                rbfv2basisfuncdiff2(s.bf, arg, ref val, ref df, ref d2f, _params);
                            }
                            else
                            {
                                alglib.ap.assert(false, "PartialCalcRec: integrity check failed");
                            }
                        }
                        for(j=0; j<=ny-1; j++)
                        {
                            y[j] = y[j]+val*s.cw[itemoffs+nx+j];
                            w = s.cw[itemoffs+nx+j];
                            v = w*df*invr2*2;
                            for(k0=0; k0<=nx-1; k0++)
                            {
                                for(k1=0; k1<=nx-1; k1++)
                                {
                                    if( k0==k1 )
                                    {
                                        
                                        //
                                        // Compute derivative and diagonal element of the Hessian
                                        //
                                        dy[j*nx+k0] = dy[j*nx+k0]+v*(x[k0]-s.cw[itemoffs+k0]);
                                        d2y[j*nx*nx+k0*nx+k1] = d2y[j*nx*nx+k0*nx+k1]+w*(d2f*invr2*invr2*4*math.sqr(x[k0]-s.cw[itemoffs+k0])+df*invr2*2);
                                    }
                                    else
                                    {
                                        
                                        //
                                        // Compute offdiagonal element of the Hessian
                                        //
                                        d2y[j*nx*nx+k0*nx+k1] = d2y[j*nx*nx+k0*nx+k1]+w*d2f*invr2*invr2*4*(x[k0]-s.cw[itemoffs+k0])*(x[k1]-s.cw[itemoffs+k1]);
                                    }
                                }
                            }
                        }
                    }
                    if( needdy==1 )
                    {
                        if( s.bf==0 )
                        {
                            val = Math.Exp(-arg);
                            df = -val;
                        }
                        else
                        {
                            if( s.bf==1 )
                            {
                                rbfv2basisfuncdiff2(s.bf, arg, ref val, ref df, ref d2f, _params);
                            }
                            else
                            {
                                alglib.ap.assert(false, "PartialCalcRec: integrity check failed");
                            }
                        }
                        for(j=0; j<=ny-1; j++)
                        {
                            y[j] = y[j]+val*s.cw[itemoffs+nx+j];
                            v = s.cw[itemoffs+nx+j]*df*invr2*2;
                            for(k=0; k<=nx-1; k++)
                            {
                                dy[j*nx+k] = dy[j*nx+k]+v*(x[k]-s.cw[itemoffs+k]);
                            }
                        }
                    }
                    if( needdy==0 )
                    {
                        if( s.bf==0 )
                        {
                            val = Math.Exp(-arg);
                        }
                        else
                        {
                            if( s.bf==1 )
                            {
                                val = rbfv2basisfunc(s.bf, arg, _params);
                            }
                            else
                            {
                                alglib.ap.assert(false, "PartialCalcRec: integrity check failed");
                            }
                        }
                        for(j=0; j<=ny-1; j++)
                        {
                            y[j] = y[j]+val*s.cw[itemoffs+nx+j];
                        }
                    }
                }
                return;
            }
            
            //
            // Simple split
            //
            if( s.kdnodes[rootidx]==0 )
            {
                
                //
                // Load:
                // * D      dimension to split
                // * Split  split position
                // * ChildLE, ChildGE - indexes of childs
                //
                d = s.kdnodes[rootidx+1];
                split = s.kdsplits[s.kdnodes[rootidx+2]];
                childle = s.kdnodes[rootidx+3];
                childge = s.kdnodes[rootidx+4];
                
                //
                // Navigate through childs
                //
                for(i=0; i<=1; i++)
                {
                    
                    //
                    // Select child to process:
                    // * ChildOffs      current child offset in Nodes[]
                    // * UpdateMin      whether minimum or maximum value
                    //                  of bounding box is changed on update
                    //
                    updatemin = i!=0;
                    if( i==0 )
                    {
                        childoffs = childle;
                    }
                    else
                    {
                        childoffs = childge;
                    }
                    
                    //
                    // Update bounding box and current distance
                    //
                    prevdist2 = buf.curdist2;
                    t1 = x[d];
                    if( updatemin )
                    {
                        v = buf.curboxmin[d];
                        if( t1<=split )
                        {
                            v0 = v-t1;
                            if( v0<0 )
                            {
                                v0 = 0;
                            }
                            v1 = split-t1;
                            buf.curdist2 = buf.curdist2-v0*v0+v1*v1;
                        }
                        buf.curboxmin[d] = split;
                    }
                    else
                    {
                        v = buf.curboxmax[d];
                        if( t1>=split )
                        {
                            v0 = t1-v;
                            if( v0<0 )
                            {
                                v0 = 0;
                            }
                            v1 = t1-split;
                            buf.curdist2 = buf.curdist2-v0*v0+v1*v1;
                        }
                        buf.curboxmax[d] = split;
                    }
                    
                    //
                    // Decide: to dive into cell or not to dive
                    //
                    if( buf.curdist2<queryr2 )
                    {
                        partialcalcrec(s, buf, childoffs, invr2, queryr2, x, y, dy, d2y, needdy, _params);
                    }
                    
                    //
                    // Restore bounding box and distance
                    //
                    if( updatemin )
                    {
                        buf.curboxmin[d] = v;
                    }
                    else
                    {
                        buf.curboxmax[d] = v;
                    }
                    buf.curdist2 = prevdist2;
                }
                return;
            }
            
            //
            // Integrity failure
            //
            alglib.ap.assert(false, "PartialCalcRec: integrity check failed");
        }


        /*************************************************************************
        This function performs same operation as partialcalcrec(), but  for entire
        row of the grid. "Row" is a set of nodes (x0,x1,x2,x3) which share x1..x3,
        but have different x0's. (note: for 2D/3D problems x2..x3 are zero).

        Row is given by:
        * central point XC, which is located at the center of the row, and used to
          perform kd-tree requests
        * set of x0 coordinates stored in RX array (array may be unordered, but it
          is expected that spread of x0  is  no  more  than  R;  function  may  be
          inefficient for larger spreads).
        * set of YFlag values stored in RF

        INPUT PARAMETERS:
            S       -   V2 model
            Buf     -   calc-buffer, this function uses following fields:
                        * Buf.CurBoxMin - should be set by caller
                        * Buf.CurBoxMax - should be set by caller
                        * Buf.CurDist2  - squared distance from X to current bounding box,
                          should be set by caller
            RootIdx -   offset of partial kd-tree
            InvR2   -   1/R^2, where R is basis function radius
            RQuery2 -   squared query radius, usually it is (R*FarRadius(BasisFunction)+0.5*RowWidth)^2,
                        where RowWidth is its spatial  extent  (after  scaling  of
                        variables). This radius is used to perform  initial  query
                        for neighbors of CX.
            RFar2   -   squared far radius; far radius is used to perform actual
                        filtering of results of query made with RQuery2.
            CX      -   central point, array[NX], used for queries
            RX      -   x0 coordinates, array[RowSize]
            RF      -   sparsity flags, array[RowSize]
            RowSize -   row size in elements
            RY      -   input partial value, array[NY]
            
        OUTPUT PARAMETERS
            RY      -   updated partial value (function adds its results to RY)

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void partialrowcalcrec(rbfv2model s,
            rbfv2calcbuffer buf,
            int rootidx,
            double invr2,
            double rquery2,
            double rfar2,
            double[] cx,
            double[] rx,
            bool[] rf,
            int rowsize,
            double[] ry,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int i0 = 0;
            int i1 = 0;
            double partialptdist2 = 0;
            double ptdist2 = 0;
            double v = 0;
            double v0 = 0;
            double v1 = 0;
            int cwoffs = 0;
            int cwcnt = 0;
            int itemoffs = 0;
            int woffs = 0;
            double val = 0;
            int d = 0;
            double split = 0;
            int childle = 0;
            int childge = 0;
            int childoffs = 0;
            bool updatemin = new bool();
            double prevdist2 = 0;
            double t1 = 0;
            int nx = 0;
            int ny = 0;

            nx = s.nx;
            ny = s.ny;
            
            //
            // Leaf node.
            //
            if( s.kdnodes[rootidx]>0 )
            {
                cwcnt = s.kdnodes[rootidx+0];
                cwoffs = s.kdnodes[rootidx+1];
                for(i0=0; i0<=cwcnt-1; i0++)
                {
                    
                    //
                    // Calculate partial distance (components from 1 to NX-1)
                    //
                    itemoffs = cwoffs+i0*(nx+ny);
                    partialptdist2 = 0;
                    for(j=1; j<=nx-1; j++)
                    {
                        v = s.cw[itemoffs+j]-cx[j];
                        partialptdist2 = partialptdist2+v*v;
                    }
                    
                    //
                    // Process each element of the row
                    //
                    for(i1=0; i1<=rowsize-1; i1++)
                    {
                        if( rf[i1] )
                        {
                            
                            //
                            // Calculate distance
                            //
                            v = s.cw[itemoffs]-rx[i1];
                            ptdist2 = partialptdist2+v*v;
                            
                            //
                            // Skip points if distance too large
                            //
                            if( ptdist2>=rfar2 )
                            {
                                continue;
                            }
                            
                            //
                            // Update Y
                            //
                            val = rbfv2basisfunc(s.bf, ptdist2*invr2, _params);
                            woffs = itemoffs+nx;
                            for(j=0; j<=ny-1; j++)
                            {
                                ry[j+i1*ny] = ry[j+i1*ny]+val*s.cw[woffs+j];
                            }
                        }
                    }
                }
                return;
            }
            
            //
            // Simple split
            //
            if( s.kdnodes[rootidx]==0 )
            {
                
                //
                // Load:
                // * D      dimension to split
                // * Split  split position
                // * ChildLE, ChildGE - indexes of childs
                //
                d = s.kdnodes[rootidx+1];
                split = s.kdsplits[s.kdnodes[rootidx+2]];
                childle = s.kdnodes[rootidx+3];
                childge = s.kdnodes[rootidx+4];
                
                //
                // Navigate through childs
                //
                for(i=0; i<=1; i++)
                {
                    
                    //
                    // Select child to process:
                    // * ChildOffs      current child offset in Nodes[]
                    // * UpdateMin      whether minimum or maximum value
                    //                  of bounding box is changed on update
                    //
                    updatemin = i!=0;
                    if( i==0 )
                    {
                        childoffs = childle;
                    }
                    else
                    {
                        childoffs = childge;
                    }
                    
                    //
                    // Update bounding box and current distance
                    //
                    prevdist2 = buf.curdist2;
                    t1 = cx[d];
                    if( updatemin )
                    {
                        v = buf.curboxmin[d];
                        if( t1<=split )
                        {
                            v0 = v-t1;
                            if( v0<0 )
                            {
                                v0 = 0;
                            }
                            v1 = split-t1;
                            buf.curdist2 = buf.curdist2-v0*v0+v1*v1;
                        }
                        buf.curboxmin[d] = split;
                    }
                    else
                    {
                        v = buf.curboxmax[d];
                        if( t1>=split )
                        {
                            v0 = t1-v;
                            if( v0<0 )
                            {
                                v0 = 0;
                            }
                            v1 = t1-split;
                            buf.curdist2 = buf.curdist2-v0*v0+v1*v1;
                        }
                        buf.curboxmax[d] = split;
                    }
                    
                    //
                    // Decide: to dive into cell or not to dive
                    //
                    if( buf.curdist2<rquery2 )
                    {
                        partialrowcalcrec(s, buf, childoffs, invr2, rquery2, rfar2, cx, rx, rf, rowsize, ry, _params);
                    }
                    
                    //
                    // Restore bounding box and distance
                    //
                    if( updatemin )
                    {
                        buf.curboxmin[d] = v;
                    }
                    else
                    {
                        buf.curboxmax[d] = v;
                    }
                    buf.curdist2 = prevdist2;
                }
                return;
            }
            
            //
            // Integrity failure
            //
            alglib.ap.assert(false, "PartialCalcRec: integrity check failed");
        }


        /*************************************************************************
        This function prepares partial query

        INPUT PARAMETERS:
            X       -   query point
            kdBoxMin, kdBoxMax - current bounding box
            NX      -   problem size
            Buf     -   preallocated buffer; this function just loads data, but
                        does not allocate place for them.
            Cnt     -   counter variable which is set to zery by this function, as
                        convenience, and to remember about necessity to zero counter
                        prior to calling partialqueryrec().
            
        OUTPUT PARAMETERS
            Buf     -   calc-buffer:
                        * Buf.CurBoxMin - current box
                        * Buf.CurBoxMax - current box
                        * Buf.CurDist2  - squared distance from X to current box
            Cnt     -   set to zero

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void preparepartialquery(double[] x,
            double[] kdboxmin,
            double[] kdboxmax,
            int nx,
            rbfv2calcbuffer buf,
            ref int cnt,
            alglib.xparams _params)
        {
            int j = 0;

            cnt = 0;
            buf.curdist2 = 0;
            for(j=0; j<=nx-1; j++)
            {
                buf.curboxmin[j] = kdboxmin[j];
                buf.curboxmax[j] = kdboxmax[j];
                if( (double)(x[j])<(double)(buf.curboxmin[j]) )
                {
                    buf.curdist2 = buf.curdist2+math.sqr(buf.curboxmin[j]-x[j]);
                }
                else
                {
                    if( (double)(x[j])>(double)(buf.curboxmax[j]) )
                    {
                        buf.curdist2 = buf.curdist2+math.sqr(x[j]-buf.curboxmax[j]);
                    }
                }
            }
        }


        /*************************************************************************
        This function performs partial (for just one subtree of multi-tree)  query
        for neighbors located in R-sphere around X. It returns  squared  distances
        from X to points and offsets in S.CW[] array for points being found.

        INPUT PARAMETERS:
            kdNodes, kdSplits, CW, NX, NY - corresponding fields of V2 model
            Buf     -   calc-buffer, this function uses following fields:
                        * Buf.CurBoxMin - should be set by caller
                        * Buf.CurBoxMax - should be set by caller
                        * Buf.CurDist2  - squared distance from X to current
                          bounding box, should be set by caller
                        You may use preparepartialquery() function to initialize
                        these fields.
            RootIdx -   offset of partial kd-tree
            QueryR2 -   squared query radius
            X       -   array[NX], point being queried
            R2      -   preallocated output buffer; it is caller's responsibility
                        to make sure that R2 has enough space.
            Offs    -   preallocated output buffer; it is caller's responsibility
                        to make sure that Offs has enough space.
            K       -   MUST BE ZERO ON INITIAL CALL. This variable is incremented,
                        not set. So, any no-zero value will result in the incorrect
                        points count being returned.
            
        OUTPUT PARAMETERS
            R2      -   squared distances in first K elements
            Offs    -   offsets in S.CW in first K elements
            K       -   points count

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void partialqueryrec(int[] kdnodes,
            double[] kdsplits,
            double[] cw,
            int nx,
            int ny,
            rbfv2calcbuffer buf,
            int rootidx,
            double queryr2,
            double[] x,
            double[] r2,
            int[] offs,
            ref int k,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double ptdist2 = 0;
            double v = 0;
            int cwoffs = 0;
            int cwcnt = 0;
            int itemoffs = 0;
            int d = 0;
            double split = 0;
            int childle = 0;
            int childge = 0;
            int childoffs = 0;
            bool updatemin = new bool();
            double prevdist2 = 0;
            double t1 = 0;

            
            //
            // Leaf node.
            //
            if( kdnodes[rootidx]>0 )
            {
                cwcnt = kdnodes[rootidx+0];
                cwoffs = kdnodes[rootidx+1];
                for(i=0; i<=cwcnt-1; i++)
                {
                    
                    //
                    // Calculate distance
                    //
                    itemoffs = cwoffs+i*(nx+ny);
                    ptdist2 = 0;
                    for(j=0; j<=nx-1; j++)
                    {
                        v = cw[itemoffs+j]-x[j];
                        ptdist2 = ptdist2+v*v;
                    }
                    
                    //
                    // Skip points if distance too large
                    //
                    if( (double)(ptdist2)>=(double)(queryr2) )
                    {
                        continue;
                    }
                    
                    //
                    // Output
                    //
                    r2[k] = ptdist2;
                    offs[k] = itemoffs;
                    k = k+1;
                }
                return;
            }
            
            //
            // Simple split
            //
            if( kdnodes[rootidx]==0 )
            {
                
                //
                // Load:
                // * D      dimension to split
                // * Split  split position
                // * ChildLE, ChildGE - indexes of childs
                //
                d = kdnodes[rootidx+1];
                split = kdsplits[kdnodes[rootidx+2]];
                childle = kdnodes[rootidx+3];
                childge = kdnodes[rootidx+4];
                
                //
                // Navigate through childs
                //
                for(i=0; i<=1; i++)
                {
                    
                    //
                    // Select child to process:
                    // * ChildOffs      current child offset in Nodes[]
                    // * UpdateMin      whether minimum or maximum value
                    //                  of bounding box is changed on update
                    //
                    updatemin = i!=0;
                    if( i==0 )
                    {
                        childoffs = childle;
                    }
                    else
                    {
                        childoffs = childge;
                    }
                    
                    //
                    // Update bounding box and current distance
                    //
                    prevdist2 = buf.curdist2;
                    t1 = x[d];
                    if( updatemin )
                    {
                        v = buf.curboxmin[d];
                        if( (double)(t1)<=(double)(split) )
                        {
                            buf.curdist2 = buf.curdist2-math.sqr(Math.Max(v-t1, 0))+math.sqr(split-t1);
                        }
                        buf.curboxmin[d] = split;
                    }
                    else
                    {
                        v = buf.curboxmax[d];
                        if( (double)(t1)>=(double)(split) )
                        {
                            buf.curdist2 = buf.curdist2-math.sqr(Math.Max(t1-v, 0))+math.sqr(t1-split);
                        }
                        buf.curboxmax[d] = split;
                    }
                    
                    //
                    // Decide: to dive into cell or not to dive
                    //
                    if( (double)(buf.curdist2)<(double)(queryr2) )
                    {
                        partialqueryrec(kdnodes, kdsplits, cw, nx, ny, buf, childoffs, queryr2, x, r2, offs, ref k, _params);
                    }
                    
                    //
                    // Restore bounding box and distance
                    //
                    if( updatemin )
                    {
                        buf.curboxmin[d] = v;
                    }
                    else
                    {
                        buf.curboxmax[d] = v;
                    }
                    buf.curdist2 = prevdist2;
                }
                return;
            }
            
            //
            // Integrity failure
            //
            alglib.ap.assert(false, "PartialQueryRec: integrity check failed");
        }


        /*************************************************************************
        This function performs  partial  (for  just  one  subtree  of  multi-tree)
        counting of neighbors located in R-sphere around X.

        This function does not guarantee consistency of results with other partial
        queries, it should be used only to get approximate estimates (well, we  do
        not  use   approximate   algorithms,  but  rounding  errors  may  give  us
        inconsistent results in just-at-the-boundary cases).

        INPUT PARAMETERS:
            kdNodes, kdSplits, CW, NX, NY - corresponding fields of V2 model
            Buf     -   calc-buffer, this function uses following fields:
                        * Buf.CurBoxMin - should be set by caller
                        * Buf.CurBoxMax - should be set by caller
                        * Buf.CurDist2  - squared distance from X to current
                          bounding box, should be set by caller
                        You may use preparepartialquery() function to initialize
                        these fields.
            RootIdx -   offset of partial kd-tree
            QueryR2 -   squared query radius
            X       -   array[NX], point being queried
            
        RESULT:
            points count

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        private static int partialcountrec(int[] kdnodes,
            double[] kdsplits,
            double[] cw,
            int nx,
            int ny,
            rbfv2calcbuffer buf,
            int rootidx,
            double queryr2,
            double[] x,
            alglib.xparams _params)
        {
            int result = 0;
            int i = 0;
            int j = 0;
            double ptdist2 = 0;
            double v = 0;
            int cwoffs = 0;
            int cwcnt = 0;
            int itemoffs = 0;
            int d = 0;
            double split = 0;
            int childle = 0;
            int childge = 0;
            int childoffs = 0;
            bool updatemin = new bool();
            double prevdist2 = 0;
            double t1 = 0;

            result = 0;
            
            //
            // Leaf node.
            //
            if( kdnodes[rootidx]>0 )
            {
                cwcnt = kdnodes[rootidx+0];
                cwoffs = kdnodes[rootidx+1];
                for(i=0; i<=cwcnt-1; i++)
                {
                    
                    //
                    // Calculate distance
                    //
                    itemoffs = cwoffs+i*(nx+ny);
                    ptdist2 = 0;
                    for(j=0; j<=nx-1; j++)
                    {
                        v = cw[itemoffs+j]-x[j];
                        ptdist2 = ptdist2+v*v;
                    }
                    
                    //
                    // Skip points if distance too large
                    //
                    if( (double)(ptdist2)>=(double)(queryr2) )
                    {
                        continue;
                    }
                    
                    //
                    // Output
                    //
                    result = result+1;
                }
                return result;
            }
            
            //
            // Simple split
            //
            if( kdnodes[rootidx]==0 )
            {
                
                //
                // Load:
                // * D      dimension to split
                // * Split  split position
                // * ChildLE, ChildGE - indexes of childs
                //
                d = kdnodes[rootidx+1];
                split = kdsplits[kdnodes[rootidx+2]];
                childle = kdnodes[rootidx+3];
                childge = kdnodes[rootidx+4];
                
                //
                // Navigate through childs
                //
                for(i=0; i<=1; i++)
                {
                    
                    //
                    // Select child to process:
                    // * ChildOffs      current child offset in Nodes[]
                    // * UpdateMin      whether minimum or maximum value
                    //                  of bounding box is changed on update
                    //
                    updatemin = i!=0;
                    if( i==0 )
                    {
                        childoffs = childle;
                    }
                    else
                    {
                        childoffs = childge;
                    }
                    
                    //
                    // Update bounding box and current distance
                    //
                    prevdist2 = buf.curdist2;
                    t1 = x[d];
                    if( updatemin )
                    {
                        v = buf.curboxmin[d];
                        if( (double)(t1)<=(double)(split) )
                        {
                            buf.curdist2 = buf.curdist2-math.sqr(Math.Max(v-t1, 0))+math.sqr(split-t1);
                        }
                        buf.curboxmin[d] = split;
                    }
                    else
                    {
                        v = buf.curboxmax[d];
                        if( (double)(t1)>=(double)(split) )
                        {
                            buf.curdist2 = buf.curdist2-math.sqr(Math.Max(t1-v, 0))+math.sqr(t1-split);
                        }
                        buf.curboxmax[d] = split;
                    }
                    
                    //
                    // Decide: to dive into cell or not to dive
                    //
                    if( (double)(buf.curdist2)<(double)(queryr2) )
                    {
                        result = result+partialcountrec(kdnodes, kdsplits, cw, nx, ny, buf, childoffs, queryr2, x, _params);
                    }
                    
                    //
                    // Restore bounding box and distance
                    //
                    if( updatemin )
                    {
                        buf.curboxmin[d] = v;
                    }
                    else
                    {
                        buf.curboxmax[d] = v;
                    }
                    buf.curdist2 = prevdist2;
                }
                return result;
            }
            
            //
            // Integrity failure
            //
            alglib.ap.assert(false, "PartialCountRec: integrity check failed");
            return result;
        }


        /*************************************************************************
        This function performs partial (for just one subtree of multi-tree) unpack
        for RBF model. It appends center coordinates,  weights  and  per-dimension
        radii (according to current scaling) to preallocated output array.

        INPUT PARAMETERS:
            kdNodes, kdSplits, CW, S, NX, NY - corresponding fields of V2 model
            RootIdx -   offset of partial kd-tree
            R       -   radius for current partial tree
            XWR     -   preallocated output buffer; it is caller's responsibility
                        to make sure that XWR has enough space. First K rows are
                        already occupied.
            K       -   number of already occupied rows in XWR.
            
        OUTPUT PARAMETERS
            XWR     -   updated XWR
            K       -   updated rows count

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void partialunpackrec(int[] kdnodes,
            double[] kdsplits,
            double[] cw,
            double[] s,
            int nx,
            int ny,
            int rootidx,
            double r,
            double[,] xwr,
            ref int k,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int childle = 0;
            int childge = 0;
            int itemoffs = 0;
            int cwoffs = 0;
            int cwcnt = 0;

            
            //
            // Leaf node.
            //
            if( kdnodes[rootidx]>0 )
            {
                cwcnt = kdnodes[rootidx+0];
                cwoffs = kdnodes[rootidx+1];
                for(i=0; i<=cwcnt-1; i++)
                {
                    itemoffs = cwoffs+i*(nx+ny);
                    for(j=0; j<=nx+ny-1; j++)
                    {
                        xwr[k,j] = cw[itemoffs+j];
                    }
                    for(j=0; j<=nx-1; j++)
                    {
                        xwr[k,j] = xwr[k,j]*s[j];
                    }
                    for(j=0; j<=nx-1; j++)
                    {
                        xwr[k,nx+ny+j] = r*s[j];
                    }
                    k = k+1;
                }
                return;
            }
            
            //
            // Simple split
            //
            if( kdnodes[rootidx]==0 )
            {
                
                //
                // Load:
                // * ChildLE, ChildGE - indexes of childs
                //
                childle = kdnodes[rootidx+3];
                childge = kdnodes[rootidx+4];
                
                //
                // Process both parts of split
                //
                partialunpackrec(kdnodes, kdsplits, cw, s, nx, ny, childle, r, xwr, ref k, _params);
                partialunpackrec(kdnodes, kdsplits, cw, s, nx, ny, childge, r, xwr, ref k, _params);
                return;
            }
            
            //
            // Integrity failure
            //
            alglib.ap.assert(false, "PartialUnpackRec: integrity check failed");
        }


        /*************************************************************************
        This function returns size of design matrix row for evaluation point X0,
        given:
        * query radius multiplier (either RBFV2NearRadius() or RBFV2FarRadius())
        * hierarchy level: value in [0,NH) for single-level model, or negative
          value for multilevel model (all levels of hierarchy in single matrix,
          like one used by nonnegative RBF)

        INPUT PARAMETERS:
            kdNodes, kdSplits, CW, Ri, kdRoots, kdBoxMin, kdBoxMax, NX, NY, NH - corresponding fields of V2 model
            Level   -   value in [0,NH) for single-level design matrix, negative
                        value for multilevel design matrix
            RCoeff  -   radius coefficient, either RBFV2NearRadius() or RBFV2FarRadius()
            X0      -   query point
            CalcBuf -   buffer for PreparePartialQuery(), allocated by caller
            
        RESULT:
            row size

          -- ALGLIB --
             Copyright 28.09.2016 by Bochkanov Sergey
        *************************************************************************/
        private static int designmatrixrowsize(int[] kdnodes,
            double[] kdsplits,
            double[] cw,
            double[] ri,
            int[] kdroots,
            double[] kdboxmin,
            double[] kdboxmax,
            int nx,
            int ny,
            int nh,
            int level,
            double rcoeff,
            double[] x0,
            rbfv2calcbuffer calcbuf,
            alglib.xparams _params)
        {
            int result = 0;
            int dummy = 0;
            int levelidx = 0;
            int level0 = 0;
            int level1 = 0;
            double curradius2 = 0;

            alglib.ap.assert(nh>0, "DesignMatrixRowSize: integrity failure");
            if( level>=0 )
            {
                level0 = level;
                level1 = level;
            }
            else
            {
                level0 = 0;
                level1 = nh-1;
            }
            result = 0;
            for(levelidx=level0; levelidx<=level1; levelidx++)
            {
                curradius2 = math.sqr(ri[levelidx]*rcoeff);
                preparepartialquery(x0, kdboxmin, kdboxmax, nx, calcbuf, ref dummy, _params);
                result = result+partialcountrec(kdnodes, kdsplits, cw, nx, ny, calcbuf, kdroots[levelidx], curradius2, x0, _params);
            }
            return result;
        }


        /*************************************************************************
        This function generates design matrix row for evaluation point X0, given:
        * query radius multiplier (either RBFV2NearRadius() or RBFV2FarRadius())
        * hierarchy level: value in [0,NH) for single-level model, or negative
          value for multilevel model (all levels of hierarchy in single matrix,
          like one used by nonnegative RBF)

        INPUT PARAMETERS:
            kdNodes, kdSplits, CW, Ri, kdRoots, kdBoxMin, kdBoxMax, NX, NY, NH - corresponding fields of V2 model

            CWRange -   internal array[NH+1] used by RBF construction function,
                        stores ranges of CW occupied by NH trees.
            Level   -   value in [0,NH) for single-level design matrix, negative
                        value for multilevel design matrix
            BF      -   basis function type
            RCoeff  -   radius coefficient, either RBFV2NearRadius() or RBFV2FarRadius()
            RowsPerPoint-equal to:
                        * 1 for unpenalized regression model
                        * 1+NX for basic form of nonsmoothness penalty
            Penalty -   nonsmoothness penalty coefficient
            
            X0      -   query point
            
            CalcBuf -   buffer for PreparePartialQuery(), allocated by caller
            R2      -   preallocated temporary buffer, size is at least NPoints;
                        it is caller's responsibility to make sure that R2 has enough space.
            Offs    -   preallocated temporary buffer; size is at least NPoints;
                        it is caller's responsibility to make sure that Offs has enough space.
            K       -   MUST BE ZERO ON INITIAL CALL. This variable is incremented,
                        not set. So, any no-zero value will result in the incorrect
                        points count being returned.
            RowIdx  -   preallocated array, at least RowSize elements
            RowVal  -   preallocated array, at least RowSize*RowsPerPoint elements
            
        RESULT:
            RowIdx  -   RowSize elements are filled with column indexes of non-zero
                        design matrix entries
            RowVal  -   RowSize*RowsPerPoint elements are filled with design matrix
                        values, with column RowIdx[0] being stored in first RowsPerPoint
                        elements of RowVal, column RowIdx[1] being stored in next
                        RowsPerPoint elements, and so on.
                        
                        First element in contiguous set of RowsPerPoint elements
                        corresponds to 
                        
            RowSize -   number of columns per row

          -- ALGLIB --
             Copyright 28.09.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void designmatrixgeneraterow(int[] kdnodes,
            double[] kdsplits,
            double[] cw,
            double[] ri,
            int[] kdroots,
            double[] kdboxmin,
            double[] kdboxmax,
            int[] cwrange,
            int nx,
            int ny,
            int nh,
            int level,
            int bf,
            double rcoeff,
            int rowsperpoint,
            double penalty,
            double[] x0,
            rbfv2calcbuffer calcbuf,
            double[] tmpr2,
            int[] tmpoffs,
            int[] rowidx,
            double[] rowval,
            ref int rowsize,
            alglib.xparams _params)
        {
            int j = 0;
            int k = 0;
            int cnt = 0;
            int levelidx = 0;
            int level0 = 0;
            int level1 = 0;
            double invri2 = 0;
            double curradius2 = 0;
            double val = 0;
            double dval = 0;
            double d2val = 0;

            rowsize = 0;

            alglib.ap.assert(nh>0, "DesignMatrixGenerateRow: integrity failure (a)");
            alglib.ap.assert(rowsperpoint==1 || rowsperpoint==1+nx, "DesignMatrixGenerateRow: integrity failure (b)");
            if( level>=0 )
            {
                level0 = level;
                level1 = level;
            }
            else
            {
                level0 = 0;
                level1 = nh-1;
            }
            rowsize = 0;
            for(levelidx=level0; levelidx<=level1; levelidx++)
            {
                curradius2 = math.sqr(ri[levelidx]*rcoeff);
                invri2 = 1/math.sqr(ri[levelidx]);
                preparepartialquery(x0, kdboxmin, kdboxmax, nx, calcbuf, ref cnt, _params);
                partialqueryrec(kdnodes, kdsplits, cw, nx, ny, calcbuf, kdroots[levelidx], curradius2, x0, tmpr2, tmpoffs, ref cnt, _params);
                alglib.ap.assert(alglib.ap.len(tmpr2)>=cnt, "DesignMatrixRowSize: integrity failure (c)");
                alglib.ap.assert(alglib.ap.len(tmpoffs)>=cnt, "DesignMatrixRowSize: integrity failure (d)");
                alglib.ap.assert(alglib.ap.len(rowidx)>=rowsize+cnt, "DesignMatrixRowSize: integrity failure (e)");
                alglib.ap.assert(alglib.ap.len(rowval)>=rowsperpoint*(rowsize+cnt), "DesignMatrixRowSize: integrity failure (f)");
                for(j=0; j<=cnt-1; j++)
                {
                    
                    //
                    // Generate element corresponding to fitting error.
                    // Store derivative information which may be required later.
                    //
                    alglib.ap.assert((tmpoffs[j]-cwrange[level0])%(nx+ny)==0, "DesignMatrixRowSize: integrity failure (g)");
                    rbfv2basisfuncdiff2(bf, tmpr2[j]*invri2, ref val, ref dval, ref d2val, _params);
                    rowidx[rowsize+j] = (tmpoffs[j]-cwrange[level0])/(nx+ny);
                    rowval[(rowsize+j)*rowsperpoint+0] = val;
                    if( rowsperpoint==1 )
                    {
                        continue;
                    }
                    
                    //
                    // Generate elements corresponding to nonsmoothness penalty
                    //
                    alglib.ap.assert(rowsperpoint==1+nx, "DesignMatrixRowSize: integrity failure (h)");
                    for(k=0; k<=nx-1; k++)
                    {
                        rowval[(rowsize+j)*rowsperpoint+1+k] = penalty*(dval*2*invri2+d2val*math.sqr(2*(x0[k]-cw[tmpoffs[j]+k])*invri2));
                    }
                }
                
                //
                // Update columns counter
                //
                rowsize = rowsize+cnt;
            }
        }


        /*************************************************************************
        This function fills RBF model by zeros.

          -- ALGLIB --
             Copyright 17.11.2018 by Bochkanov Sergey
        *************************************************************************/
        private static void zerofill(rbfv2model s,
            int nx,
            int ny,
            int bf,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;

            s.bf = bf;
            s.nh = 0;
            s.ri = new double[0];
            s.s = new double[0];
            s.kdroots = new int[0];
            s.kdnodes = new int[0];
            s.kdsplits = new double[0];
            s.kdboxmin = new double[0];
            s.kdboxmax = new double[0];
            s.cw = new double[0];
            s.v = new double[ny, nx+1];
            for(i=0; i<=ny-1; i++)
            {
                for(j=0; j<=nx; j++)
                {
                    s.v[i,j] = 0;
                }
            }
        }


    }
    public class spline3d
    {
        /*************************************************************************
        3-dimensional spline inteprolant
        *************************************************************************/
        public class spline3dinterpolant : apobject
        {
            public int k;
            public int stype;
            public int n;
            public int m;
            public int l;
            public int d;
            public double[] x;
            public double[] y;
            public double[] z;
            public double[] f;
            public spline3dinterpolant()
            {
                init();
            }
            public override void init()
            {
                x = new double[0];
                y = new double[0];
                z = new double[0];
                f = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                spline3dinterpolant _result = new spline3dinterpolant();
                _result.k = k;
                _result.stype = stype;
                _result.n = n;
                _result.m = m;
                _result.l = l;
                _result.d = d;
                _result.x = (double[])x.Clone();
                _result.y = (double[])y.Clone();
                _result.z = (double[])z.Clone();
                _result.f = (double[])f.Clone();
                return _result;
            }
        };




        /*************************************************************************
        This subroutine calculates the value of the trilinear or tricubic spline at
        the given point (X,Y,Z).

        INPUT PARAMETERS:
            C   -   coefficients table.
                    Built by BuildBilinearSpline or BuildBicubicSpline.
            X, Y,
            Z   -   point

        Result:
            S(x,y,z)

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static double spline3dcalc(spline3dinterpolant c,
            double x,
            double y,
            double z,
            alglib.xparams _params)
        {
            double result = 0;
            double v = 0;
            double vx = 0;
            double vy = 0;
            double vxy = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline3DCalc: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert((math.isfinite(x) && math.isfinite(y)) && math.isfinite(z), "Spline3DCalc: X=NaN/Infinite, Y=NaN/Infinite or Z=NaN/Infinite");
            if( c.d!=1 )
            {
                result = 0;
                return result;
            }
            spline3ddiff(c, x, y, z, ref v, ref vx, ref vy, ref vxy, _params);
            result = v;
            return result;
        }


        /*************************************************************************
        This subroutine performs linear transformation of the spline argument.

        INPUT PARAMETERS:
            C       -   spline interpolant
            AX, BX  -   transformation coefficients: x = A*u + B
            AY, BY  -   transformation coefficients: y = A*v + B
            AZ, BZ  -   transformation coefficients: z = A*w + B
            
        OUTPUT PARAMETERS:
            C   -   transformed spline

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline3dlintransxyz(spline3dinterpolant c,
            double ax,
            double bx,
            double ay,
            double by,
            double az,
            double bz,
            alglib.xparams _params)
        {
            double[] x = new double[0];
            double[] y = new double[0];
            double[] z = new double[0];
            double[] f = new double[0];
            double[] v = new double[0];
            int i = 0;
            int j = 0;
            int k = 0;
            int di = 0;
            int i_ = 0;

            alglib.ap.assert(c.stype==-3 || c.stype==-1, "Spline3DLinTransXYZ: incorrect C (incorrect parameter C.SType)");
            x = new double[c.n];
            y = new double[c.m];
            z = new double[c.l];
            f = new double[c.m*c.n*c.l*c.d];
            for(j=0; j<=c.n-1; j++)
            {
                x[j] = c.x[j];
            }
            for(i=0; i<=c.m-1; i++)
            {
                y[i] = c.y[i];
            }
            for(i=0; i<=c.l-1; i++)
            {
                z[i] = c.z[i];
            }
            
            //
            // Handle different combinations of zero/nonzero AX/AY/AZ
            //
            if( ((double)(ax)!=(double)(0) && (double)(ay)!=(double)(0)) && (double)(az)!=(double)(0) )
            {
                for(i_=0; i_<=c.m*c.n*c.l*c.d-1;i_++)
                {
                    f[i_] = c.f[i_];
                }
            }
            if( ((double)(ax)==(double)(0) && (double)(ay)!=(double)(0)) && (double)(az)!=(double)(0) )
            {
                for(i=0; i<=c.m-1; i++)
                {
                    for(j=0; j<=c.l-1; j++)
                    {
                        spline3dcalcv(c, bx, y[i], z[j], ref v, _params);
                        for(k=0; k<=c.n-1; k++)
                        {
                            for(di=0; di<=c.d-1; di++)
                            {
                                f[c.d*(c.n*(c.m*j+i)+k)+di] = v[di];
                            }
                        }
                    }
                }
                ax = 1;
                bx = 0;
            }
            if( ((double)(ax)!=(double)(0) && (double)(ay)==(double)(0)) && (double)(az)!=(double)(0) )
            {
                for(i=0; i<=c.n-1; i++)
                {
                    for(j=0; j<=c.l-1; j++)
                    {
                        spline3dcalcv(c, x[i], by, z[j], ref v, _params);
                        for(k=0; k<=c.m-1; k++)
                        {
                            for(di=0; di<=c.d-1; di++)
                            {
                                f[c.d*(c.n*(c.m*j+k)+i)+di] = v[di];
                            }
                        }
                    }
                }
                ay = 1;
                by = 0;
            }
            if( ((double)(ax)!=(double)(0) && (double)(ay)!=(double)(0)) && (double)(az)==(double)(0) )
            {
                for(i=0; i<=c.n-1; i++)
                {
                    for(j=0; j<=c.m-1; j++)
                    {
                        spline3dcalcv(c, x[i], y[j], bz, ref v, _params);
                        for(k=0; k<=c.l-1; k++)
                        {
                            for(di=0; di<=c.d-1; di++)
                            {
                                f[c.d*(c.n*(c.m*k+j)+i)+di] = v[di];
                            }
                        }
                    }
                }
                az = 1;
                bz = 0;
            }
            if( ((double)(ax)==(double)(0) && (double)(ay)==(double)(0)) && (double)(az)!=(double)(0) )
            {
                for(i=0; i<=c.l-1; i++)
                {
                    spline3dcalcv(c, bx, by, z[i], ref v, _params);
                    for(k=0; k<=c.m-1; k++)
                    {
                        for(j=0; j<=c.n-1; j++)
                        {
                            for(di=0; di<=c.d-1; di++)
                            {
                                f[c.d*(c.n*(c.m*i+k)+j)+di] = v[di];
                            }
                        }
                    }
                }
                ax = 1;
                bx = 0;
                ay = 1;
                by = 0;
            }
            if( ((double)(ax)==(double)(0) && (double)(ay)!=(double)(0)) && (double)(az)==(double)(0) )
            {
                for(i=0; i<=c.m-1; i++)
                {
                    spline3dcalcv(c, bx, y[i], bz, ref v, _params);
                    for(k=0; k<=c.l-1; k++)
                    {
                        for(j=0; j<=c.n-1; j++)
                        {
                            for(di=0; di<=c.d-1; di++)
                            {
                                f[c.d*(c.n*(c.m*k+i)+j)+di] = v[di];
                            }
                        }
                    }
                }
                ax = 1;
                bx = 0;
                az = 1;
                bz = 0;
            }
            if( ((double)(ax)!=(double)(0) && (double)(ay)==(double)(0)) && (double)(az)==(double)(0) )
            {
                for(i=0; i<=c.n-1; i++)
                {
                    spline3dcalcv(c, x[i], by, bz, ref v, _params);
                    for(k=0; k<=c.l-1; k++)
                    {
                        for(j=0; j<=c.m-1; j++)
                        {
                            for(di=0; di<=c.d-1; di++)
                            {
                                f[c.d*(c.n*(c.m*k+j)+i)+di] = v[di];
                            }
                        }
                    }
                }
                ay = 1;
                by = 0;
                az = 1;
                bz = 0;
            }
            if( ((double)(ax)==(double)(0) && (double)(ay)==(double)(0)) && (double)(az)==(double)(0) )
            {
                spline3dcalcv(c, bx, by, bz, ref v, _params);
                for(k=0; k<=c.l-1; k++)
                {
                    for(j=0; j<=c.m-1; j++)
                    {
                        for(i=0; i<=c.n-1; i++)
                        {
                            for(di=0; di<=c.d-1; di++)
                            {
                                f[c.d*(c.n*(c.m*k+j)+i)+di] = v[di];
                            }
                        }
                    }
                }
                ax = 1;
                bx = 0;
                ay = 1;
                by = 0;
                az = 1;
                bz = 0;
            }
            
            //
            // General case: AX<>0, AY<>0, AZ<>0
            // Unpack, scale and pack again.
            //
            for(i=0; i<=c.n-1; i++)
            {
                x[i] = (x[i]-bx)/ax;
            }
            for(i=0; i<=c.m-1; i++)
            {
                y[i] = (y[i]-by)/ay;
            }
            for(i=0; i<=c.l-1; i++)
            {
                z[i] = (z[i]-bz)/az;
            }
            if( c.stype==-1 )
            {
                spline3dbuildtrilinearv(x, c.n, y, c.m, z, c.l, f, c.d, c, _params);
            }
        }


        /*************************************************************************
        This subroutine performs linear transformation of the spline.

        INPUT PARAMETERS:
            C   -   spline interpolant.
            A, B-   transformation coefficients: S2(x,y) = A*S(x,y,z) + B
            
        OUTPUT PARAMETERS:
            C   -   transformed spline

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline3dlintransf(spline3dinterpolant c,
            double a,
            double b,
            alglib.xparams _params)
        {
            double[] x = new double[0];
            double[] y = new double[0];
            double[] z = new double[0];
            double[] f = new double[0];
            int i = 0;
            int j = 0;

            alglib.ap.assert(c.stype==-3 || c.stype==-1, "Spline3DLinTransF: incorrect C (incorrect parameter C.SType)");
            x = new double[c.n];
            y = new double[c.m];
            z = new double[c.l];
            f = new double[c.m*c.n*c.l*c.d];
            for(j=0; j<=c.n-1; j++)
            {
                x[j] = c.x[j];
            }
            for(i=0; i<=c.m-1; i++)
            {
                y[i] = c.y[i];
            }
            for(i=0; i<=c.l-1; i++)
            {
                z[i] = c.z[i];
            }
            for(i=0; i<=c.m*c.n*c.l*c.d-1; i++)
            {
                f[i] = a*c.f[i]+b;
            }
            if( c.stype==-1 )
            {
                spline3dbuildtrilinearv(x, c.n, y, c.m, z, c.l, f, c.d, c, _params);
            }
        }


        /*************************************************************************
        This subroutine makes the copy of the spline model.

        INPUT PARAMETERS:
            C   -   spline interpolant

        OUTPUT PARAMETERS:
            CC  -   spline copy

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline3dcopy(spline3dinterpolant c,
            spline3dinterpolant cc,
            alglib.xparams _params)
        {
            int tblsize = 0;
            int i_ = 0;

            alglib.ap.assert(c.k==1 || c.k==3, "Spline3DCopy: incorrect C (incorrect parameter C.K)");
            cc.k = c.k;
            cc.n = c.n;
            cc.m = c.m;
            cc.l = c.l;
            cc.d = c.d;
            tblsize = c.n*c.m*c.l*c.d;
            cc.stype = c.stype;
            cc.x = new double[cc.n];
            cc.y = new double[cc.m];
            cc.z = new double[cc.l];
            cc.f = new double[tblsize];
            for(i_=0; i_<=cc.n-1;i_++)
            {
                cc.x[i_] = c.x[i_];
            }
            for(i_=0; i_<=cc.m-1;i_++)
            {
                cc.y[i_] = c.y[i_];
            }
            for(i_=0; i_<=cc.l-1;i_++)
            {
                cc.z[i_] = c.z[i_];
            }
            for(i_=0; i_<=tblsize-1;i_++)
            {
                cc.f[i_] = c.f[i_];
            }
        }


        /*************************************************************************
        Trilinear spline resampling

        INPUT PARAMETERS:
            A           -   array[0..OldXCount*OldYCount*OldZCount-1], function
                            values at the old grid, :
                                A[0]        x=0,y=0,z=0
                                A[1]        x=1,y=0,z=0
                                A[..]       ...
                                A[..]       x=oldxcount-1,y=0,z=0
                                A[..]       x=0,y=1,z=0
                                A[..]       ...
                                ...
            OldZCount   -   old Z-count, OldZCount>1
            OldYCount   -   old Y-count, OldYCount>1
            OldXCount   -   old X-count, OldXCount>1
            NewZCount   -   new Z-count, NewZCount>1
            NewYCount   -   new Y-count, NewYCount>1
            NewXCount   -   new X-count, NewXCount>1

        OUTPUT PARAMETERS:
            B           -   array[0..NewXCount*NewYCount*NewZCount-1], function
                            values at the new grid:
                                B[0]        x=0,y=0,z=0
                                B[1]        x=1,y=0,z=0
                                B[..]       ...
                                B[..]       x=newxcount-1,y=0,z=0
                                B[..]       x=0,y=1,z=0
                                B[..]       ...
                                ...

          -- ALGLIB routine --
             26.04.2012
             Copyright by Bochkanov Sergey
        *************************************************************************/
        public static void spline3dresampletrilinear(double[] a,
            int oldzcount,
            int oldycount,
            int oldxcount,
            int newzcount,
            int newycount,
            int newxcount,
            ref double[] b,
            alglib.xparams _params)
        {
            double xd = 0;
            double yd = 0;
            double zd = 0;
            double c0 = 0;
            double c1 = 0;
            double c2 = 0;
            double c3 = 0;
            int ix = 0;
            int iy = 0;
            int iz = 0;
            int i = 0;
            int j = 0;
            int k = 0;

            b = new double[0];

            alglib.ap.assert((oldycount>1 && oldzcount>1) && oldxcount>1, "Spline3DResampleTrilinear: length/width/height less than 1");
            alglib.ap.assert((newycount>1 && newzcount>1) && newxcount>1, "Spline3DResampleTrilinear: length/width/height less than 1");
            alglib.ap.assert(alglib.ap.len(a)>=oldycount*oldzcount*oldxcount, "Spline3DResampleTrilinear: length/width/height less than 1");
            b = new double[newxcount*newycount*newzcount];
            for(i=0; i<=newxcount-1; i++)
            {
                for(j=0; j<=newycount-1; j++)
                {
                    for(k=0; k<=newzcount-1; k++)
                    {
                        ix = i*(oldxcount-1)/(newxcount-1);
                        if( ix==oldxcount-1 )
                        {
                            ix = oldxcount-2;
                        }
                        xd = (double)(i*(oldxcount-1))/(double)(newxcount-1)-ix;
                        iy = j*(oldycount-1)/(newycount-1);
                        if( iy==oldycount-1 )
                        {
                            iy = oldycount-2;
                        }
                        yd = (double)(j*(oldycount-1))/(double)(newycount-1)-iy;
                        iz = k*(oldzcount-1)/(newzcount-1);
                        if( iz==oldzcount-1 )
                        {
                            iz = oldzcount-2;
                        }
                        zd = (double)(k*(oldzcount-1))/(double)(newzcount-1)-iz;
                        c0 = a[oldxcount*(oldycount*iz+iy)+ix]*(1-xd)+a[oldxcount*(oldycount*iz+iy)+(ix+1)]*xd;
                        c1 = a[oldxcount*(oldycount*iz+(iy+1))+ix]*(1-xd)+a[oldxcount*(oldycount*iz+(iy+1))+(ix+1)]*xd;
                        c2 = a[oldxcount*(oldycount*(iz+1)+iy)+ix]*(1-xd)+a[oldxcount*(oldycount*(iz+1)+iy)+(ix+1)]*xd;
                        c3 = a[oldxcount*(oldycount*(iz+1)+(iy+1))+ix]*(1-xd)+a[oldxcount*(oldycount*(iz+1)+(iy+1))+(ix+1)]*xd;
                        c0 = c0*(1-yd)+c1*yd;
                        c1 = c2*(1-yd)+c3*yd;
                        b[newxcount*(newycount*k+j)+i] = c0*(1-zd)+c1*zd;
                    }
                }
            }
        }


        /*************************************************************************
        This subroutine builds trilinear vector-valued spline.

        INPUT PARAMETERS:
            X   -   spline abscissas,  array[0..N-1]
            Y   -   spline ordinates,  array[0..M-1]
            Z   -   spline applicates, array[0..L-1] 
            F   -   function values, array[0..M*N*L*D-1]:
                    * first D elements store D values at (X[0],Y[0],Z[0])
                    * next D elements store D values at (X[1],Y[0],Z[0])
                    * next D elements store D values at (X[2],Y[0],Z[0])
                    * ...
                    * next D elements store D values at (X[0],Y[1],Z[0])
                    * next D elements store D values at (X[1],Y[1],Z[0])
                    * next D elements store D values at (X[2],Y[1],Z[0])
                    * ...
                    * next D elements store D values at (X[0],Y[0],Z[1])
                    * next D elements store D values at (X[1],Y[0],Z[1])
                    * next D elements store D values at (X[2],Y[0],Z[1])
                    * ...
                    * general form - D function values at (X[i],Y[j]) are stored
                      at F[D*(N*(M*K+J)+I)...D*(N*(M*K+J)+I)+D-1].
            M,N,
            L   -   grid size, M>=2, N>=2, L>=2
            D   -   vector dimension, D>=1

        OUTPUT PARAMETERS:
            C   -   spline interpolant

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline3dbuildtrilinearv(double[] x,
            int n,
            double[] y,
            int m,
            double[] z,
            int l,
            double[] f,
            int d,
            spline3dinterpolant c,
            alglib.xparams _params)
        {
            double t = 0;
            int tblsize = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int i0 = 0;
            int j0 = 0;

            alglib.ap.assert(m>=2, "Spline3DBuildTrilinearV: M<2");
            alglib.ap.assert(n>=2, "Spline3DBuildTrilinearV: N<2");
            alglib.ap.assert(l>=2, "Spline3DBuildTrilinearV: L<2");
            alglib.ap.assert(d>=1, "Spline3DBuildTrilinearV: D<1");
            alglib.ap.assert((alglib.ap.len(x)>=n && alglib.ap.len(y)>=m) && alglib.ap.len(z)>=l, "Spline3DBuildTrilinearV: length of X, Y or Z is too short (Length(X/Y/Z)<N/M/L)");
            alglib.ap.assert((apserv.isfinitevector(x, n, _params) && apserv.isfinitevector(y, m, _params)) && apserv.isfinitevector(z, l, _params), "Spline3DBuildTrilinearV: X, Y or Z contains NaN or Infinite value");
            tblsize = n*m*l*d;
            alglib.ap.assert(alglib.ap.len(f)>=tblsize, "Spline3DBuildTrilinearV: length of F is too short (Length(F)<N*M*L*D)");
            alglib.ap.assert(apserv.isfinitevector(f, tblsize, _params), "Spline3DBuildTrilinearV: F contains NaN or Infinite value");
            
            //
            // Fill interpolant
            //
            c.k = 1;
            c.n = n;
            c.m = m;
            c.l = l;
            c.d = d;
            c.stype = -1;
            c.x = new double[c.n];
            c.y = new double[c.m];
            c.z = new double[c.l];
            c.f = new double[tblsize];
            for(i=0; i<=c.n-1; i++)
            {
                c.x[i] = x[i];
            }
            for(i=0; i<=c.m-1; i++)
            {
                c.y[i] = y[i];
            }
            for(i=0; i<=c.l-1; i++)
            {
                c.z[i] = z[i];
            }
            for(i=0; i<=tblsize-1; i++)
            {
                c.f[i] = f[i];
            }
            
            //
            // Sort points:
            //  * sort x;
            //  * sort y;
            //  * sort z.
            //
            for(j=0; j<=c.n-1; j++)
            {
                k = j;
                for(i=j+1; i<=c.n-1; i++)
                {
                    if( (double)(c.x[i])<(double)(c.x[k]) )
                    {
                        k = i;
                    }
                }
                if( k!=j )
                {
                    for(i=0; i<=c.m-1; i++)
                    {
                        for(j0=0; j0<=c.l-1; j0++)
                        {
                            for(i0=0; i0<=c.d-1; i0++)
                            {
                                t = c.f[c.d*(c.n*(c.m*j0+i)+j)+i0];
                                c.f[c.d*(c.n*(c.m*j0+i)+j)+i0] = c.f[c.d*(c.n*(c.m*j0+i)+k)+i0];
                                c.f[c.d*(c.n*(c.m*j0+i)+k)+i0] = t;
                            }
                        }
                    }
                    t = c.x[j];
                    c.x[j] = c.x[k];
                    c.x[k] = t;
                }
            }
            for(i=0; i<=c.m-1; i++)
            {
                k = i;
                for(j=i+1; j<=c.m-1; j++)
                {
                    if( (double)(c.y[j])<(double)(c.y[k]) )
                    {
                        k = j;
                    }
                }
                if( k!=i )
                {
                    for(j=0; j<=c.n-1; j++)
                    {
                        for(j0=0; j0<=c.l-1; j0++)
                        {
                            for(i0=0; i0<=c.d-1; i0++)
                            {
                                t = c.f[c.d*(c.n*(c.m*j0+i)+j)+i0];
                                c.f[c.d*(c.n*(c.m*j0+i)+j)+i0] = c.f[c.d*(c.n*(c.m*j0+k)+j)+i0];
                                c.f[c.d*(c.n*(c.m*j0+k)+j)+i0] = t;
                            }
                        }
                    }
                    t = c.y[i];
                    c.y[i] = c.y[k];
                    c.y[k] = t;
                }
            }
            for(k=0; k<=c.l-1; k++)
            {
                i = k;
                for(j=i+1; j<=c.l-1; j++)
                {
                    if( (double)(c.z[j])<(double)(c.z[i]) )
                    {
                        i = j;
                    }
                }
                if( i!=k )
                {
                    for(j=0; j<=c.m-1; j++)
                    {
                        for(j0=0; j0<=c.n-1; j0++)
                        {
                            for(i0=0; i0<=c.d-1; i0++)
                            {
                                t = c.f[c.d*(c.n*(c.m*k+j)+j0)+i0];
                                c.f[c.d*(c.n*(c.m*k+j)+j0)+i0] = c.f[c.d*(c.n*(c.m*i+j)+j0)+i0];
                                c.f[c.d*(c.n*(c.m*i+j)+j0)+i0] = t;
                            }
                        }
                    }
                    t = c.z[k];
                    c.z[k] = c.z[i];
                    c.z[i] = t;
                }
            }
        }


        /*************************************************************************
        This subroutine calculates bilinear or bicubic vector-valued spline at the
        given point (X,Y,Z).

        INPUT PARAMETERS:
            C   -   spline interpolant.
            X, Y,
            Z   -   point
            F   -   output buffer, possibly preallocated array. In case array size
                    is large enough to store result, it is not reallocated.  Array
                    which is too short will be reallocated

        OUTPUT PARAMETERS:
            F   -   array[D] (or larger) which stores function values

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline3dcalcvbuf(spline3dinterpolant c,
            double x,
            double y,
            double z,
            ref double[] f,
            alglib.xparams _params)
        {
            double xd = 0;
            double yd = 0;
            double zd = 0;
            double c0 = 0;
            double c1 = 0;
            double c2 = 0;
            double c3 = 0;
            int ix = 0;
            int iy = 0;
            int iz = 0;
            int l = 0;
            int r = 0;
            int h = 0;
            int i = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline3DCalcVBuf: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert((math.isfinite(x) && math.isfinite(y)) && math.isfinite(z), "Spline3DCalcVBuf: X, Y or Z contains NaN/Infinite");
            apserv.rvectorsetlengthatleast(ref f, c.d, _params);
            
            //
            // Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
            //
            l = 0;
            r = c.n-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.x[h])>=(double)(x) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            ix = l;
            
            //
            // Binary search in the [ y[0], ..., y[n-2] ] (y[n-1] is not included)
            //
            l = 0;
            r = c.m-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.y[h])>=(double)(y) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            iy = l;
            
            //
            // Binary search in the [ z[0], ..., z[n-2] ] (z[n-1] is not included)
            //
            l = 0;
            r = c.l-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.z[h])>=(double)(z) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            iz = l;
            xd = (x-c.x[ix])/(c.x[ix+1]-c.x[ix]);
            yd = (y-c.y[iy])/(c.y[iy+1]-c.y[iy]);
            zd = (z-c.z[iz])/(c.z[iz+1]-c.z[iz]);
            for(i=0; i<=c.d-1; i++)
            {
                
                //
                // Trilinear interpolation
                //
                if( c.stype==-1 )
                {
                    c0 = c.f[c.d*(c.n*(c.m*iz+iy)+ix)+i]*(1-xd)+c.f[c.d*(c.n*(c.m*iz+iy)+(ix+1))+i]*xd;
                    c1 = c.f[c.d*(c.n*(c.m*iz+(iy+1))+ix)+i]*(1-xd)+c.f[c.d*(c.n*(c.m*iz+(iy+1))+(ix+1))+i]*xd;
                    c2 = c.f[c.d*(c.n*(c.m*(iz+1)+iy)+ix)+i]*(1-xd)+c.f[c.d*(c.n*(c.m*(iz+1)+iy)+(ix+1))+i]*xd;
                    c3 = c.f[c.d*(c.n*(c.m*(iz+1)+(iy+1))+ix)+i]*(1-xd)+c.f[c.d*(c.n*(c.m*(iz+1)+(iy+1))+(ix+1))+i]*xd;
                    c0 = c0*(1-yd)+c1*yd;
                    c1 = c2*(1-yd)+c3*yd;
                    f[i] = c0*(1-zd)+c1*zd;
                }
            }
        }


        /*************************************************************************
        This subroutine calculates trilinear or tricubic vector-valued spline at the
        given point (X,Y,Z).

        INPUT PARAMETERS:
            C   -   spline interpolant.
            X, Y,
            Z   -   point

        OUTPUT PARAMETERS:
            F   -   array[D] which stores function values.  F is out-parameter and
                    it  is  reallocated  after  call to this function. In case you
                    want  to    reuse  previously  allocated  F,   you   may   use
                    Spline2DCalcVBuf(),  which  reallocates  F only when it is too
                    small.

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline3dcalcv(spline3dinterpolant c,
            double x,
            double y,
            double z,
            ref double[] f,
            alglib.xparams _params)
        {
            f = new double[0];

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline3DCalcV: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert((math.isfinite(x) && math.isfinite(y)) && math.isfinite(z), "Spline3DCalcV: X=NaN/Infinite, Y=NaN/Infinite or Z=NaN/Infinite");
            f = new double[c.d];
            spline3dcalcvbuf(c, x, y, z, ref f, _params);
        }


        /*************************************************************************
        This subroutine unpacks tri-dimensional spline into the coefficients table

        INPUT PARAMETERS:
            C   -   spline interpolant.

        Result:
            N   -   grid size (X)
            M   -   grid size (Y)
            L   -   grid size (Z)
            D   -   number of components
            SType-  spline type. Currently, only one spline type is supported:
                    trilinear spline, as indicated by SType=1.
            Tbl -   spline coefficients: [0..(N-1)*(M-1)*(L-1)*D-1, 0..13].
                    For T=0..D-1 (component index), I = 0...N-2 (x index),
                    J=0..M-2 (y index), K=0..L-2 (z index):
                        Q := T + I*D + J*D*(N-1) + K*D*(N-1)*(M-1),
                        
                        Q-th row stores decomposition for T-th component of the
                        vector-valued function
                        
                        Tbl[Q,0] = X[i]
                        Tbl[Q,1] = X[i+1]
                        Tbl[Q,2] = Y[j]
                        Tbl[Q,3] = Y[j+1]
                        Tbl[Q,4] = Z[k]
                        Tbl[Q,5] = Z[k+1]
                        
                        Tbl[Q,6] = C000
                        Tbl[Q,7] = C100
                        Tbl[Q,8] = C010
                        Tbl[Q,9] = C110
                        Tbl[Q,10]= C001
                        Tbl[Q,11]= C101
                        Tbl[Q,12]= C011
                        Tbl[Q,13]= C111
                    On each grid square spline is equals to:
                        S(x) = SUM(c[i,j,k]*(x^i)*(y^j)*(z^k), i=0..1, j=0..1, k=0..1)
                        t = x-x[j]
                        u = y-y[i]
                        v = z-z[k]
                    
                    NOTE: format of Tbl is given for SType=1. Future versions of
                          ALGLIB can use different formats for different values of
                          SType.

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void spline3dunpackv(spline3dinterpolant c,
            ref int n,
            ref int m,
            ref int l,
            ref int d,
            ref int stype,
            ref double[,] tbl,
            alglib.xparams _params)
        {
            int p = 0;
            int ci = 0;
            int cj = 0;
            int ck = 0;
            double du = 0;
            double dv = 0;
            double dw = 0;
            int i = 0;
            int j = 0;
            int k = 0;
            int di = 0;
            int i0 = 0;

            n = 0;
            m = 0;
            l = 0;
            d = 0;
            stype = 0;
            tbl = new double[0,0];

            alglib.ap.assert(c.stype==-1, "Spline3DUnpackV: incorrect C (incorrect parameter C.SType)");
            n = c.n;
            m = c.m;
            l = c.l;
            d = c.d;
            stype = Math.Abs(c.stype);
            tbl = new double[(n-1)*(m-1)*(l-1)*d, 14];
            
            //
            // Fill
            //
            for(i=0; i<=n-2; i++)
            {
                for(j=0; j<=m-2; j++)
                {
                    for(k=0; k<=l-2; k++)
                    {
                        for(di=0; di<=d-1; di++)
                        {
                            p = d*((n-1)*((m-1)*k+j)+i)+di;
                            tbl[p,0] = c.x[i];
                            tbl[p,1] = c.x[i+1];
                            tbl[p,2] = c.y[j];
                            tbl[p,3] = c.y[j+1];
                            tbl[p,4] = c.z[k];
                            tbl[p,5] = c.z[k+1];
                            du = 1/(tbl[p,1]-tbl[p,0]);
                            dv = 1/(tbl[p,3]-tbl[p,2]);
                            dw = 1/(tbl[p,5]-tbl[p,4]);
                            
                            //
                            // Trilinear interpolation
                            //
                            if( c.stype==-1 )
                            {
                                for(i0=6; i0<=13; i0++)
                                {
                                    tbl[p,i0] = 0;
                                }
                                tbl[p,6+2*(2*0+0)+0] = c.f[d*(n*(m*k+j)+i)+di];
                                tbl[p,6+2*(2*0+0)+1] = c.f[d*(n*(m*k+j)+(i+1))+di]-c.f[d*(n*(m*k+j)+i)+di];
                                tbl[p,6+2*(2*0+1)+0] = c.f[d*(n*(m*k+(j+1))+i)+di]-c.f[d*(n*(m*k+j)+i)+di];
                                tbl[p,6+2*(2*0+1)+1] = c.f[d*(n*(m*k+(j+1))+(i+1))+di]-c.f[d*(n*(m*k+(j+1))+i)+di]-c.f[d*(n*(m*k+j)+(i+1))+di]+c.f[d*(n*(m*k+j)+i)+di];
                                tbl[p,6+2*(2*1+0)+0] = c.f[d*(n*(m*(k+1)+j)+i)+di]-c.f[d*(n*(m*k+j)+i)+di];
                                tbl[p,6+2*(2*1+0)+1] = c.f[d*(n*(m*(k+1)+j)+(i+1))+di]-c.f[d*(n*(m*(k+1)+j)+i)+di]-c.f[d*(n*(m*k+j)+(i+1))+di]+c.f[d*(n*(m*k+j)+i)+di];
                                tbl[p,6+2*(2*1+1)+0] = c.f[d*(n*(m*(k+1)+(j+1))+i)+di]-c.f[d*(n*(m*(k+1)+j)+i)+di]-c.f[d*(n*(m*k+(j+1))+i)+di]+c.f[d*(n*(m*k+j)+i)+di];
                                tbl[p,6+2*(2*1+1)+1] = c.f[d*(n*(m*(k+1)+(j+1))+(i+1))+di]-c.f[d*(n*(m*(k+1)+(j+1))+i)+di]-c.f[d*(n*(m*(k+1)+j)+(i+1))+di]+c.f[d*(n*(m*(k+1)+j)+i)+di]-c.f[d*(n*(m*k+(j+1))+(i+1))+di]+c.f[d*(n*(m*k+(j+1))+i)+di]+c.f[d*(n*(m*k+j)+(i+1))+di]-c.f[d*(n*(m*k+j)+i)+di];
                            }
                            
                            //
                            // Rescale Cij
                            //
                            for(ci=0; ci<=1; ci++)
                            {
                                for(cj=0; cj<=1; cj++)
                                {
                                    for(ck=0; ck<=1; ck++)
                                    {
                                        tbl[p,6+2*(2*ck+cj)+ci] = tbl[p,6+2*(2*ck+cj)+ci]*Math.Pow(du, ci)*Math.Pow(dv, cj)*Math.Pow(dw, ck);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }


        /*************************************************************************
        This subroutine calculates the value of the trilinear(or tricubic;possible
        will be later) spline  at the given point X(and its derivatives; possible
        will be later).

        INPUT PARAMETERS:
            C       -   spline interpolant.
            X, Y, Z -   point

        OUTPUT PARAMETERS:
            F   -   S(x,y,z)
            FX  -   dS(x,y,z)/dX
            FY  -   dS(x,y,z)/dY
            FXY -   d2S(x,y,z)/dXdY

          -- ALGLIB PROJECT --
             Copyright 26.04.2012 by Bochkanov Sergey
        *************************************************************************/
        private static void spline3ddiff(spline3dinterpolant c,
            double x,
            double y,
            double z,
            ref double f,
            ref double fx,
            ref double fy,
            ref double fxy,
            alglib.xparams _params)
        {
            double xd = 0;
            double yd = 0;
            double zd = 0;
            double c0 = 0;
            double c1 = 0;
            double c2 = 0;
            double c3 = 0;
            int ix = 0;
            int iy = 0;
            int iz = 0;
            int l = 0;
            int r = 0;
            int h = 0;

            f = 0;
            fx = 0;
            fy = 0;
            fxy = 0;

            alglib.ap.assert(c.stype==-1 || c.stype==-3, "Spline3DDiff: incorrect C (incorrect parameter C.SType)");
            alglib.ap.assert(math.isfinite(x) && math.isfinite(y), "Spline3DDiff: X or Y contains NaN or Infinite value");
            
            //
            // Prepare F, dF/dX, dF/dY, d2F/dXdY
            //
            f = 0;
            fx = 0;
            fy = 0;
            fxy = 0;
            if( c.d!=1 )
            {
                return;
            }
            
            //
            // Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
            //
            l = 0;
            r = c.n-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.x[h])>=(double)(x) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            ix = l;
            
            //
            // Binary search in the [ y[0], ..., y[n-2] ] (y[n-1] is not included)
            //
            l = 0;
            r = c.m-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.y[h])>=(double)(y) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            iy = l;
            
            //
            // Binary search in the [ z[0], ..., z[n-2] ] (z[n-1] is not included)
            //
            l = 0;
            r = c.l-1;
            while( l!=r-1 )
            {
                h = (l+r)/2;
                if( (double)(c.z[h])>=(double)(z) )
                {
                    r = h;
                }
                else
                {
                    l = h;
                }
            }
            iz = l;
            xd = (x-c.x[ix])/(c.x[ix+1]-c.x[ix]);
            yd = (y-c.y[iy])/(c.y[iy+1]-c.y[iy]);
            zd = (z-c.z[iz])/(c.z[iz+1]-c.z[iz]);
            
            //
            // Trilinear interpolation
            //
            if( c.stype==-1 )
            {
                c0 = c.f[c.n*(c.m*iz+iy)+ix]*(1-xd)+c.f[c.n*(c.m*iz+iy)+(ix+1)]*xd;
                c1 = c.f[c.n*(c.m*iz+(iy+1))+ix]*(1-xd)+c.f[c.n*(c.m*iz+(iy+1))+(ix+1)]*xd;
                c2 = c.f[c.n*(c.m*(iz+1)+iy)+ix]*(1-xd)+c.f[c.n*(c.m*(iz+1)+iy)+(ix+1)]*xd;
                c3 = c.f[c.n*(c.m*(iz+1)+(iy+1))+ix]*(1-xd)+c.f[c.n*(c.m*(iz+1)+(iy+1))+(ix+1)]*xd;
                c0 = c0*(1-yd)+c1*yd;
                c1 = c2*(1-yd)+c3*yd;
                f = c0*(1-zd)+c1*zd;
            }
        }


    }
    public class intcomp
    {
        /*************************************************************************
        This function is left for backward compatibility.
        Use fitspheremc() instead.

                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void nsfitspheremcc(double[,] xy,
            int npoints,
            int nx,
            ref double[] cx,
            ref double rhi,
            alglib.xparams _params)
        {
            double dummy = 0;

            cx = new double[0];
            rhi = 0;

            nsfitspherex(xy, npoints, nx, 1, 0.0, 0, 0.0, ref cx, ref dummy, ref rhi, _params);
        }


        /*************************************************************************
        This function is left for backward compatibility.
        Use fitspheremi() instead.
                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void nsfitspheremic(double[,] xy,
            int npoints,
            int nx,
            ref double[] cx,
            ref double rlo,
            alglib.xparams _params)
        {
            double dummy = 0;

            cx = new double[0];
            rlo = 0;

            nsfitspherex(xy, npoints, nx, 2, 0.0, 0, 0.0, ref cx, ref rlo, ref dummy, _params);
        }


        /*************************************************************************
        This function is left for backward compatibility.
        Use fitspheremz() instead.
                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void nsfitspheremzc(double[,] xy,
            int npoints,
            int nx,
            ref double[] cx,
            ref double rlo,
            ref double rhi,
            alglib.xparams _params)
        {
            cx = new double[0];
            rlo = 0;
            rhi = 0;

            nsfitspherex(xy, npoints, nx, 3, 0.0, 0, 0.0, ref cx, ref rlo, ref rhi, _params);
        }


        /*************************************************************************
        This function is left for backward compatibility.
        Use fitspherex() instead.
                                            
          -- ALGLIB --
             Copyright 14.04.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void nsfitspherex(double[,] xy,
            int npoints,
            int nx,
            int problemtype,
            double epsx,
            int aulits,
            double penalty,
            ref double[] cx,
            ref double rlo,
            ref double rhi,
            alglib.xparams _params)
        {
            cx = new double[0];
            rlo = 0;
            rhi = 0;

            fitsphere.fitspherex(xy, npoints, nx, problemtype, epsx, aulits, penalty, ref cx, ref rlo, ref rhi, _params);
        }


        /*************************************************************************
        This function is an obsolete and deprecated version of fitting by
        penalized cubic spline.

        It was superseded by spline1dfit(), which is an orders of magnitude faster
        and more memory-efficient implementation.

        Do NOT use this function in the new code!

          -- ALGLIB PROJECT --
             Copyright 18.08.2009 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dfitpenalized(double[] x,
            double[] y,
            int n,
            int m,
            double rho,
            ref int info,
            spline1d.spline1dinterpolant s,
            spline1d.spline1dfitreport rep,
            alglib.xparams _params)
        {
            double[] w = new double[0];
            int i = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            info = 0;

            alglib.ap.assert(n>=1, "Spline1DFitPenalized: N<1!");
            alglib.ap.assert(m>=4, "Spline1DFitPenalized: M<4!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DFitPenalized: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DFitPenalized: Length(Y)<N!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DFitPenalized: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DFitPenalized: Y contains infinite or NAN values!");
            alglib.ap.assert(math.isfinite(rho), "Spline1DFitPenalized: Rho is infinite!");
            w = new double[n];
            for(i=0; i<=n-1; i++)
            {
                w[i] = 1;
            }
            spline1dfitpenalizedw(x, y, w, n, m, rho, ref info, s, rep, _params);
        }


        /*************************************************************************
        This function is an obsolete and deprecated version of fitting by
        penalized cubic spline.

        It was superseded by spline1dfit(), which is an orders of magnitude faster
        and more memory-efficient implementation.

        Do NOT use this function in the new code!

          -- ALGLIB PROJECT --
             Copyright 19.10.2010 by Bochkanov Sergey
        *************************************************************************/
        public static void spline1dfitpenalizedw(double[] x,
            double[] y,
            double[] w,
            int n,
            int m,
            double rho,
            ref int info,
            spline1d.spline1dinterpolant s,
            spline1d.spline1dfitreport rep,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            int b = 0;
            double v = 0;
            double relcnt = 0;
            double xa = 0;
            double xb = 0;
            double sa = 0;
            double sb = 0;
            double[] xoriginal = new double[0];
            double[] yoriginal = new double[0];
            double pdecay = 0;
            double tdecay = 0;
            double[,] fmatrix = new double[0,0];
            double[] fcolumn = new double[0];
            double[] y2 = new double[0];
            double[] w2 = new double[0];
            double[] xc = new double[0];
            double[] yc = new double[0];
            int[] dc = new int[0];
            double fdmax = 0;
            double admax = 0;
            double[,] amatrix = new double[0,0];
            double[,] d2matrix = new double[0,0];
            double fa = 0;
            double ga = 0;
            double fb = 0;
            double gb = 0;
            double lambdav = 0;
            double[] bx = new double[0];
            double[] by = new double[0];
            double[] bd1 = new double[0];
            double[] bd2 = new double[0];
            double[] tx = new double[0];
            double[] ty = new double[0];
            double[] td = new double[0];
            spline1d.spline1dinterpolant bs = new spline1d.spline1dinterpolant();
            double[,] nmatrix = new double[0,0];
            double[] rightpart = new double[0];
            fbls.fblslincgstate cgstate = new fbls.fblslincgstate();
            double[] c = new double[0];
            double[] tmp0 = new double[0];
            int i_ = 0;
            int i1_ = 0;

            x = (double[])x.Clone();
            y = (double[])y.Clone();
            w = (double[])w.Clone();
            info = 0;

            alglib.ap.assert(n>=1, "Spline1DFitPenalizedW: N<1!");
            alglib.ap.assert(m>=4, "Spline1DFitPenalizedW: M<4!");
            alglib.ap.assert(alglib.ap.len(x)>=n, "Spline1DFitPenalizedW: Length(X)<N!");
            alglib.ap.assert(alglib.ap.len(y)>=n, "Spline1DFitPenalizedW: Length(Y)<N!");
            alglib.ap.assert(alglib.ap.len(w)>=n, "Spline1DFitPenalizedW: Length(W)<N!");
            alglib.ap.assert(apserv.isfinitevector(x, n, _params), "Spline1DFitPenalizedW: X contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(y, n, _params), "Spline1DFitPenalizedW: Y contains infinite or NAN values!");
            alglib.ap.assert(apserv.isfinitevector(w, n, _params), "Spline1DFitPenalizedW: Y contains infinite or NAN values!");
            alglib.ap.assert(math.isfinite(rho), "Spline1DFitPenalizedW: Rho is infinite!");
            
            //
            // Prepare LambdaV
            //
            v = -(Math.Log(math.machineepsilon)/Math.Log(10));
            if( (double)(rho)<(double)(-v) )
            {
                rho = -v;
            }
            if( (double)(rho)>(double)(v) )
            {
                rho = v;
            }
            lambdav = Math.Pow(10, rho);
            
            //
            // Sort X, Y, W
            //
            spline1d.heapsortdpoints(ref x, ref y, ref w, n, _params);
            
            //
            // Scale X, Y, XC, YC
            //
            intfitserv.lsfitscalexy(ref x, ref y, ref w, n, ref xc, ref yc, dc, 0, ref xa, ref xb, ref sa, ref sb, ref xoriginal, ref yoriginal, _params);
            
            //
            // Allocate space
            //
            fmatrix = new double[n, m];
            amatrix = new double[m, m];
            d2matrix = new double[m, m];
            bx = new double[m];
            by = new double[m];
            fcolumn = new double[n];
            nmatrix = new double[m, m];
            rightpart = new double[m];
            tmp0 = new double[Math.Max(m, n)];
            c = new double[m];
            
            //
            // Fill:
            // * FMatrix by values of basis functions
            // * TmpAMatrix by second derivatives of I-th function at J-th point
            // * CMatrix by constraints
            //
            fdmax = 0;
            for(b=0; b<=m-1; b++)
            {
                
                //
                // Prepare I-th basis function
                //
                for(j=0; j<=m-1; j++)
                {
                    bx[j] = (double)(2*j)/(double)(m-1)-1;
                    by[j] = 0;
                }
                by[b] = 1;
                spline1d.spline1dgriddiff2cubic(bx, by, m, 2, 0.0, 2, 0.0, ref bd1, ref bd2, _params);
                spline1d.spline1dbuildcubic(bx, by, m, 2, 0.0, 2, 0.0, bs, _params);
                
                //
                // Calculate B-th column of FMatrix
                // Update FDMax (maximum column norm)
                //
                spline1d.spline1dconvcubic(bx, by, m, 2, 0.0, 2, 0.0, x, n, ref fcolumn, _params);
                for(i_=0; i_<=n-1;i_++)
                {
                    fmatrix[i_,b] = fcolumn[i_];
                }
                v = 0;
                for(i=0; i<=n-1; i++)
                {
                    v = v+math.sqr(w[i]*fcolumn[i]);
                }
                fdmax = Math.Max(fdmax, v);
                
                //
                // Fill temporary with second derivatives of basis function
                //
                for(i_=0; i_<=m-1;i_++)
                {
                    d2matrix[b,i_] = bd2[i_];
                }
            }
            
            //
            // * calculate penalty matrix A
            // * calculate max of diagonal elements of A
            // * calculate PDecay - coefficient before penalty matrix
            //
            for(i=0; i<=m-1; i++)
            {
                for(j=i; j<=m-1; j++)
                {
                    
                    //
                    // calculate integral(B_i''*B_j'') where B_i and B_j are
                    // i-th and j-th basis splines.
                    // B_i and B_j are piecewise linear functions.
                    //
                    v = 0;
                    for(b=0; b<=m-2; b++)
                    {
                        fa = d2matrix[i,b];
                        fb = d2matrix[i,b+1];
                        ga = d2matrix[j,b];
                        gb = d2matrix[j,b+1];
                        v = v+(bx[b+1]-bx[b])*(fa*ga+(fa*(gb-ga)+ga*(fb-fa))/2+(fb-fa)*(gb-ga)/3);
                    }
                    amatrix[i,j] = v;
                    amatrix[j,i] = v;
                }
            }
            admax = 0;
            for(i=0; i<=m-1; i++)
            {
                admax = Math.Max(admax, Math.Abs(amatrix[i,i]));
            }
            pdecay = lambdav*fdmax/admax;
            
            //
            // Calculate TDecay for Tikhonov regularization
            //
            tdecay = fdmax*(1+pdecay)*10*math.machineepsilon;
            
            //
            // Prepare system
            //
            // NOTE: FMatrix is spoiled during this process
            //
            for(i=0; i<=n-1; i++)
            {
                v = w[i];
                for(i_=0; i_<=m-1;i_++)
                {
                    fmatrix[i,i_] = v*fmatrix[i,i_];
                }
            }
            ablas.rmatrixgemm(m, m, n, 1.0, fmatrix, 0, 0, 1, fmatrix, 0, 0, 0, 0.0, nmatrix, 0, 0, _params);
            for(i=0; i<=m-1; i++)
            {
                for(j=0; j<=m-1; j++)
                {
                    nmatrix[i,j] = nmatrix[i,j]+pdecay*amatrix[i,j];
                }
            }
            for(i=0; i<=m-1; i++)
            {
                nmatrix[i,i] = nmatrix[i,i]+tdecay;
            }
            for(i=0; i<=m-1; i++)
            {
                rightpart[i] = 0;
            }
            for(i=0; i<=n-1; i++)
            {
                v = y[i]*w[i];
                for(i_=0; i_<=m-1;i_++)
                {
                    rightpart[i_] = rightpart[i_] + v*fmatrix[i,i_];
                }
            }
            
            //
            // Solve system
            //
            if( !trfac.spdmatrixcholesky(ref nmatrix, m, true, _params) )
            {
                info = -4;
                return;
            }
            fbls.fblscholeskysolve(nmatrix, 1.0, m, true, rightpart, ref tmp0, _params);
            for(i_=0; i_<=m-1;i_++)
            {
                c[i_] = rightpart[i_];
            }
            
            //
            // add nodes to force linearity outside of the fitting interval
            //
            spline1d.spline1dgriddiffcubic(bx, c, m, 2, 0.0, 2, 0.0, ref bd1, _params);
            tx = new double[m+2];
            ty = new double[m+2];
            td = new double[m+2];
            i1_ = (0) - (1);
            for(i_=1; i_<=m;i_++)
            {
                tx[i_] = bx[i_+i1_];
            }
            i1_ = (0) - (1);
            for(i_=1; i_<=m;i_++)
            {
                ty[i_] = rightpart[i_+i1_];
            }
            i1_ = (0) - (1);
            for(i_=1; i_<=m;i_++)
            {
                td[i_] = bd1[i_+i1_];
            }
            tx[0] = tx[1]-(tx[2]-tx[1]);
            ty[0] = ty[1]-td[1]*(tx[2]-tx[1]);
            td[0] = td[1];
            tx[m+1] = tx[m]+(tx[m]-tx[m-1]);
            ty[m+1] = ty[m]+td[m]*(tx[m]-tx[m-1]);
            td[m+1] = td[m];
            spline1d.spline1dbuildhermite(tx, ty, td, m+2, s, _params);
            spline1d.spline1dlintransx(s, 2/(xb-xa), -((xa+xb)/(xb-xa)), _params);
            spline1d.spline1dlintransy(s, sb-sa, sa, _params);
            info = 1;
            
            //
            // Fill report
            //
            rep.rmserror = 0;
            rep.avgerror = 0;
            rep.avgrelerror = 0;
            rep.maxerror = 0;
            relcnt = 0;
            spline1d.spline1dconvcubic(bx, rightpart, m, 2, 0.0, 2, 0.0, x, n, ref fcolumn, _params);
            for(i=0; i<=n-1; i++)
            {
                v = (sb-sa)*fcolumn[i]+sa;
                rep.rmserror = rep.rmserror+math.sqr(v-yoriginal[i]);
                rep.avgerror = rep.avgerror+Math.Abs(v-yoriginal[i]);
                if( (double)(yoriginal[i])!=(double)(0) )
                {
                    rep.avgrelerror = rep.avgrelerror+Math.Abs(v-yoriginal[i])/Math.Abs(yoriginal[i]);
                    relcnt = relcnt+1;
                }
                rep.maxerror = Math.Max(rep.maxerror, Math.Abs(v-yoriginal[i]));
            }
            rep.rmserror = Math.Sqrt(rep.rmserror/n);
            rep.avgerror = rep.avgerror/n;
            if( (double)(relcnt)!=(double)(0) )
            {
                rep.avgrelerror = rep.avgrelerror/relcnt;
            }
        }


    }
    public class rbf
    {
        /*************************************************************************
        Buffer object which is used  to  perform  RBF  model  calculation  in  the
        multithreaded mode (multiple threads working with same RBF object).

        This object should be created with RBFCreateCalcBuffer().
        *************************************************************************/
        public class rbfcalcbuffer : apobject
        {
            public int modelversion;
            public rbfv1.rbfv1calcbuffer bufv1;
            public rbfv2.rbfv2calcbuffer bufv2;
            public rbfv3.rbfv3calcbuffer bufv3;
            public double[] x;
            public double[] y;
            public double[] dy;
            public rbfcalcbuffer()
            {
                init();
            }
            public override void init()
            {
                bufv1 = new rbfv1.rbfv1calcbuffer();
                bufv2 = new rbfv2.rbfv2calcbuffer();
                bufv3 = new rbfv3.rbfv3calcbuffer();
                x = new double[0];
                y = new double[0];
                dy = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                rbfcalcbuffer _result = new rbfcalcbuffer();
                _result.modelversion = modelversion;
                _result.bufv1 = (rbfv1.rbfv1calcbuffer)bufv1.make_copy();
                _result.bufv2 = (rbfv2.rbfv2calcbuffer)bufv2.make_copy();
                _result.bufv3 = (rbfv3.rbfv3calcbuffer)bufv3.make_copy();
                _result.x = (double[])x.Clone();
                _result.y = (double[])y.Clone();
                _result.dy = (double[])dy.Clone();
                return _result;
            }
        };


        /*************************************************************************
        RBF model.

        Never try to directly work with fields of this object - always use  ALGLIB
        functions to use this object.
        *************************************************************************/
        public class rbfmodel : apobject
        {
            public int nx;
            public int ny;
            public int modelversion;
            public rbfv1.rbfv1model model1;
            public rbfv2.rbfv2model model2;
            public rbfv3.rbfv3model model3;
            public rbfcalcbuffer calcbuf;
            public double lambdav;
            public double radvalue;
            public double radzvalue;
            public int nlayers;
            public int aterm;
            public int algorithmtype;
            public int bftype;
            public double bfparam;
            public double epsort;
            public double epserr;
            public int maxits;
            public int nnmaxits;
            public int n;
            public double[,] x;
            public double[,] y;
            public bool hasscale;
            public double[] s;
            public int progress10000;
            public bool terminationrequest;
            public rbfmodel()
            {
                init();
            }
            public override void init()
            {
                model1 = new rbfv1.rbfv1model();
                model2 = new rbfv2.rbfv2model();
                model3 = new rbfv3.rbfv3model();
                calcbuf = new rbfcalcbuffer();
                x = new double[0,0];
                y = new double[0,0];
                s = new double[0];
            }
            public override alglib.apobject make_copy()
            {
                rbfmodel _result = new rbfmodel();
                _result.nx = nx;
                _result.ny = ny;
                _result.modelversion = modelversion;
                _result.model1 = (rbfv1.rbfv1model)model1.make_copy();
                _result.model2 = (rbfv2.rbfv2model)model2.make_copy();
                _result.model3 = (rbfv3.rbfv3model)model3.make_copy();
                _result.calcbuf = (rbfcalcbuffer)calcbuf.make_copy();
                _result.lambdav = lambdav;
                _result.radvalue = radvalue;
                _result.radzvalue = radzvalue;
                _result.nlayers = nlayers;
                _result.aterm = aterm;
                _result.algorithmtype = algorithmtype;
                _result.bftype = bftype;
                _result.bfparam = bfparam;
                _result.epsort = epsort;
                _result.epserr = epserr;
                _result.maxits = maxits;
                _result.nnmaxits = nnmaxits;
                _result.n = n;
                _result.x = (double[,])x.Clone();
                _result.y = (double[,])y.Clone();
                _result.hasscale = hasscale;
                _result.s = (double[])s.Clone();
                _result.progress10000 = progress10000;
                _result.terminationrequest = terminationrequest;
                return _result;
            }
        };


        /*************************************************************************
        RBF solution report:
        * TerminationType   -   termination type, positive values - success,
                                non-positive - failure.
                                
        Fields which are set by modern RBF solvers (hierarchical):
        * RMSError          -   root-mean-square error; NAN for old solvers (ML, QNN)
        * MaxError          -   maximum error; NAN for old solvers (ML, QNN)
        *************************************************************************/
        public class rbfreport : apobject
        {
            public double rmserror;
            public double maxerror;
            public int arows;
            public int acols;
            public int annz;
            public int iterationscount;
            public int nmv;
            public int terminationtype;
            public rbfreport()
            {
                init();
            }
            public override void init()
            {
            }
            public override alglib.apobject make_copy()
            {
                rbfreport _result = new rbfreport();
                _result.rmserror = rmserror;
                _result.maxerror = maxerror;
                _result.arows = arows;
                _result.acols = acols;
                _result.annz = annz;
                _result.iterationscount = iterationscount;
                _result.nmv = nmv;
                _result.terminationtype = terminationtype;
                return _result;
            }
        };




        public const double eps = 1.0E-6;
        public const double rbffarradius = 6;
        public const int rbffirstversion = 0;
        public const int rbfversion2 = 2;
        public const int rbfversion3 = 3;


        /*************************************************************************
        This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
        function in a NX-dimensional space (NX>=1).

        Newly created model is empty. It can be used for interpolation right after
        creation, but it just returns zeros. You have to add points to the  model,
        tune interpolation settings, and then  call  model  construction  function
        rbfbuildmodel() which will update model according to your specification.

        USAGE:
        1. User creates model with rbfcreate()
        2. User adds dataset with rbfsetpoints() or rbfsetpointsandscales()
        3. User selects RBF solver by calling:
           * rbfsetalgohierarchical() - for a HRBF solver,  a  hierarchical large-
             scale Gaussian RBFs  (works  well  for  uniformly  distributed  point
             clouds, but may fail when the data are non-uniform; use other solvers
             below in such cases)
           * rbfsetalgothinplatespline() - for a large-scale DDM-RBF  solver  with
             thin plate spline basis function being used
           * rbfsetalgobiharmonic() -  for  a  large-scale  DDM-RBF  solver   with
             biharmonic basis function being used
           * rbfsetalgomultiquadricauto() -  for a large-scale DDM-RBF solver with
             multiquadric basis function being used (automatic  selection  of  the
             scale parameter Alpha)
           * rbfsetalgomultiquadricmanual() -  for a  large-scale  DDM-RBF  solver
             with multiquadric basis function being used (manual selection  of the
             scale parameter Alpha)
        4. (OPTIONAL) User chooses polynomial term by calling:
           * rbflinterm() to set linear term (default)
           * rbfconstterm() to set constant term
           * rbfzeroterm() to set zero term
        5. User calls rbfbuildmodel() function which rebuilds model  according  to
           the specification
           
        INPUT PARAMETERS:
            NX      -   dimension of the space, NX>=1
            NY      -   function dimension, NY>=1

        OUTPUT PARAMETERS:
            S       -   RBF model (initially equals to zero)

        NOTE 1: memory requirements. RBF models require amount of memory  which is
                proportional  to the number of data points. Some additional memory
                is allocated during model construction, but most of this memory is
                freed after the model  coefficients  are   calculated.  Amount  of
                this additional memory depends  on  model  construction  algorithm
                being used.

          -- ALGLIB --
             Copyright 13.12.2011, 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfcreate(int nx,
            int ny,
            rbfmodel s,
            alglib.xparams _params)
        {
            alglib.ap.assert(nx>=1, "RBFCreate: NX<1");
            alglib.ap.assert(ny>=1, "RBFCreate: NY<1");
            s.nx = nx;
            s.ny = ny;
            rbfpreparenonserializablefields(s, _params);
            
            //
            // Select default model version according to NX.
            //
            // The idea is that when we call this function with NX=2 or NX=3, backward
            // compatible dummy (zero) V1 model is created, so serialization produces
            // model which are compatible with pre-3.11 ALGLIB.
            //
            initializev1(nx, ny, s.model1, _params);
            initializev2(nx, ny, s.model2, _params);
            initializev3(nx, ny, s.model3, _params);
            if( nx==2 || nx==3 )
            {
                s.modelversion = 1;
            }
            else
            {
                s.modelversion = 2;
            }
            
            //
            // Report fields
            //
            s.progress10000 = 0;
            s.terminationrequest = false;
            
            //
            // Prepare buffers
            //
            rbfcreatecalcbuffer(s, s.calcbuf, _params);
        }


        /*************************************************************************
        This function creates buffer  structure  which  can  be  used  to  perform
        parallel  RBF  model  evaluations  (with  one  RBF  model  instance  being
        used from multiple threads, as long as  different  threads  use  different
        instances of the buffer).

        This buffer object can be used with  rbftscalcbuf()  function  (here  "ts"
        stands for "thread-safe", "buf" is a suffix which denotes  function  which
        reuses previously allocated output space).

        A buffer creation function (this function) is also thread-safe.  I.e.  you
        may safely create multiple buffers for the same  RBF  model  from multiple
        threads.

        NOTE: the  buffer  object  is  just  a  collection of several preallocated
              dynamic arrays and precomputed values. If you  delete  its  "parent"
              RBF model when the buffer is still alive, nothing  bad  will  happen
              (no dangling pointers or resource leaks).  The  buffer  will  simply
              become useless.

        How to use it:
        * create RBF model structure with rbfcreate()
        * load data, tune parameters
        * call rbfbuildmodel()
        * call rbfcreatecalcbuffer(), once per thread working with RBF model  (you
          should call this function only AFTER call to rbfbuildmodel(), see  below
          for more information)
        * call rbftscalcbuf() from different threads,  with  each  thread  working
          with its own copy of buffer object.
        * it is recommended to reuse buffer as much  as  possible  because  buffer
          creation involves allocation of several large dynamic arrays.  It  is  a
          huge waste of resource to use it just once.

        INPUT PARAMETERS
            S           -   RBF model

        OUTPUT PARAMETERS
            Buf         -   external buffer.
            
        IMPORTANT: buffer object should be used only with  RBF model object  which
                   was used to initialize buffer. Any attempt to use buffer   with
                   different object is dangerous - you may  get  memory  violation
                   error because sizes of internal arrays do not fit to dimensions
                   of RBF structure.
                   
        IMPORTANT: you  should  call  this function only for model which was built
                   with rbfbuildmodel() function, after successful  invocation  of
                   rbfbuildmodel().  Sizes   of   some   internal  structures  are
                   determined only after model is built, so buffer object  created
                   before model  construction  stage  will  be  useless  (and  any
                   attempt to use it will result in exception).

          -- ALGLIB --
             Copyright 02.04.2016 by Sergey Bochkanov
        *************************************************************************/
        public static void rbfcreatecalcbuffer(rbfmodel s,
            rbfcalcbuffer buf,
            alglib.xparams _params)
        {
            if( s.modelversion==1 )
            {
                buf.modelversion = 1;
                rbfv1.rbfv1createcalcbuffer(s.model1, buf.bufv1, _params);
                return;
            }
            if( s.modelversion==2 )
            {
                buf.modelversion = 2;
                rbfv2.rbfv2createcalcbuffer(s.model2, buf.bufv2, _params);
                return;
            }
            if( s.modelversion==3 )
            {
                buf.modelversion = 3;
                rbfv3.rbfv3createcalcbuffer(s.model3, buf.bufv3, _params);
                return;
            }
            alglib.ap.assert(false, "RBFCreateCalcBuffer: integrity check failed");
        }


        /*************************************************************************
        This function adds dataset.

        This function overrides results of the previous calls, i.e. multiple calls
        of this function will result in only the last set being added.

        IMPORTANT: ALGLIB version 3.11 and later allows you to specify  a  set  of
                   per-dimension scales. Interpolation radii are multiplied by the
                   scale vector. It may be useful if you have mixed spatio-temporal
                   data (say, a set of 3D slices recorded at different times).
                   You should call rbfsetpointsandscales() function  to  use  this
                   feature.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by rbfcreate() call.
            XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
                        in the dataset. First NX elements  are  coordinates,  next
                        NY elements are function values. Array may  be larger than 
                        specified, in  this  case  only leading [N,NX+NY] elements 
                        will be used.
            N       -   number of points in the dataset

        After you've added dataset and (optionally) tuned algorithm  settings  you
        should call rbfbuildmodel() in order to build a model for you.

        NOTE: dataset added by this function is not saved during model serialization.
              MODEL ITSELF is serialized, but data used to build it are not.
              
              So, if you 1) add dataset to  empty  RBF  model,  2)  serialize  and
              unserialize it, then you will get an empty RBF model with no dataset
              being attached.
              
              From the other side, if you call rbfbuildmodel() between (1) and (2),
              then after (2) you will get your fully constructed RBF model  -  but
              again with no dataset attached, so subsequent calls to rbfbuildmodel()
              will produce empty model.
              

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetpoints(rbfmodel s,
            double[,] xy,
            int n,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;

            alglib.ap.assert(n>0, "RBFSetPoints: N<=0");
            alglib.ap.assert(alglib.ap.rows(xy)>=n, "RBFSetPoints: Rows(XY)<N");
            alglib.ap.assert(alglib.ap.cols(xy)>=s.nx+s.ny, "RBFSetPoints: Cols(XY)<NX+NY");
            alglib.ap.assert(apserv.apservisfinitematrix(xy, n, s.nx+s.ny, _params), "RBFSetPoints: XY contains infinite or NaN values!");
            s.n = n;
            s.hasscale = false;
            s.x = new double[s.n, s.nx];
            s.y = new double[s.n, s.ny];
            for(i=0; i<=s.n-1; i++)
            {
                for(j=0; j<=s.nx-1; j++)
                {
                    s.x[i,j] = xy[i,j];
                }
                for(j=0; j<=s.ny-1; j++)
                {
                    s.y[i,j] = xy[i,j+s.nx];
                }
            }
        }


        /*************************************************************************
        This function adds dataset and a vector of per-dimension scales.

        It may be useful if you have mixed spatio-temporal data - say, a set of 3D
        slices recorded at different times. Such data typically require  different
        RBF radii for spatial and temporal dimensions. ALGLIB solves this  problem
        by specifying single RBF radius, which is (optionally) multiplied  by  the
        scale vector.

        This function overrides results of the previous calls, i.e. multiple calls
        of this function will result in only the last set being added.

        IMPORTANT: only modern RBF algorithms  support  variable  scaling.  Legacy
                   algorithms like RBF-ML or QNN algorithms  will  result  in   -3
                   completion code being returned (incorrect algorithm).

        INPUT PARAMETERS:
            R       -   RBF model, initialized by rbfcreate() call.
            XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
                        in the dataset. First NX elements  are  coordinates,  next
                        NY elements are function values. Array may  be larger than 
                        specified, in  this  case  only leading [N,NX+NY] elements 
                        will be used.
            N       -   number of points in the dataset
            S       -   array[NX], scale vector, S[i]>0.

        After you've added dataset and (optionally) tuned algorithm  settings  you
        should call rbfbuildmodel() in order to build a model for you.

        NOTE: dataset added by this function is not saved during model serialization.
              MODEL ITSELF is serialized, but data used to build it are not.
              
              So, if you 1) add dataset to  empty  RBF  model,  2)  serialize  and
              unserialize it, then you will get an empty RBF model with no dataset
              being attached.
              
              From the other side, if you call rbfbuildmodel() between (1) and (2),
              then after (2) you will get your fully constructed RBF model  -  but
              again with no dataset attached, so subsequent calls to rbfbuildmodel()
              will produce empty model.
              

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetpointsandscales(rbfmodel r,
            double[,] xy,
            int n,
            double[] s,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;

            alglib.ap.assert(n>0, "RBFSetPointsAndScales: N<=0");
            alglib.ap.assert(alglib.ap.rows(xy)>=n, "RBFSetPointsAndScales: Rows(XY)<N");
            alglib.ap.assert(alglib.ap.cols(xy)>=r.nx+r.ny, "RBFSetPointsAndScales: Cols(XY)<NX+NY");
            alglib.ap.assert(alglib.ap.len(s)>=r.nx, "RBFSetPointsAndScales: Length(S)<NX");
            r.n = n;
            r.hasscale = true;
            r.x = new double[r.n, r.nx];
            r.y = new double[r.n, r.ny];
            for(i=0; i<=r.n-1; i++)
            {
                for(j=0; j<=r.nx-1; j++)
                {
                    r.x[i,j] = xy[i,j];
                }
                for(j=0; j<=r.ny-1; j++)
                {
                    r.y[i,j] = xy[i,j+r.nx];
                }
            }
            r.s = new double[r.nx];
            for(i=0; i<=r.nx-1; i++)
            {
                alglib.ap.assert(math.isfinite(s[i]), "RBFSetPointsAndScales: S[i] is not finite number");
                alglib.ap.assert((double)(s[i])>(double)(0), "RBFSetPointsAndScales: S[i]<=0");
                r.s[i] = s[i];
            }
        }


        /*************************************************************************
        DEPRECATED: this function is deprecated. ALGLIB  includes  new  RBF  model
                    construction algorithms: DDM-RBF (since version 3.19) and HRBF
                    (since version 3.11).

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetalgoqnn(rbfmodel s,
            double q,
            double z,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(q), "RBFSetAlgoQNN: Q is infinite or NAN");
            alglib.ap.assert((double)(q)>(double)(0), "RBFSetAlgoQNN: Q<=0");
            alglib.ap.assert(math.isfinite(z), "RBFSetAlgoQNN: Z is infinite or NAN");
            alglib.ap.assert((double)(z)>(double)(0), "RBFSetAlgoQNN: Z<=0");
            s.radvalue = q;
            s.radzvalue = z;
            s.algorithmtype = 1;
        }


        /*************************************************************************
        DEPRECATED: this function is deprecated. ALGLIB  includes  new  RBF  model
                    construction algorithms: DDM-RBF (since version 3.19) and HRBF
                    (since version 3.11).
           
          -- ALGLIB --
             Copyright 02.03.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetalgomultilayer(rbfmodel s,
            double rbase,
            int nlayers,
            double lambdav,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(rbase), "RBFSetAlgoMultiLayer: RBase is infinite or NaN");
            alglib.ap.assert((double)(rbase)>(double)(0), "RBFSetAlgoMultiLayer: RBase<=0");
            alglib.ap.assert(nlayers>=0, "RBFSetAlgoMultiLayer: NLayers<0");
            alglib.ap.assert(math.isfinite(lambdav), "RBFSetAlgoMultiLayer: LambdaV is infinite or NAN");
            alglib.ap.assert((double)(lambdav)>=(double)(0), "RBFSetAlgoMultiLayer: LambdaV<0");
            s.radvalue = rbase;
            s.nlayers = nlayers;
            s.algorithmtype = 2;
            s.lambdav = lambdav;
        }


        /*************************************************************************
        This function chooses HRBF solver, a 2nd version of ALGLIB RBFs.

        This  algorithm is called Hierarchical RBF. It  similar  to  its  previous
        incarnation, RBF-ML, i.e.  it  also  builds  a  sequence  of  models  with
        decreasing radii. However, it uses more economical way of  building  upper
        layers (ones with large radii), which results in faster model construction
        and evaluation, as well as smaller memory footprint during construction.

        This algorithm has following important features:
        * ability to handle millions of points
        * controllable smoothing via nonlinearity penalization
        * support for specification of per-dimensional  radii  via  scale  vector,
          which is set by means of rbfsetpointsandscales() function. This  feature
          is useful if you solve  spatio-temporal  interpolation  problems,  where
          different radii are required for spatial and temporal dimensions.

        Running times are roughly proportional to:
        * N*log(N)*NLayers - for the model construction
        * N*NLayers - for the model evaluation
        You may see that running time does not depend on search radius  or  points
        density, just on the number of layers in the hierarchy.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by rbfcreate() call
            RBase   -   RBase parameter, RBase>0
            NLayers -   NLayers parameter, NLayers>0, recommended value  to  start
                        with - about 5.
            LambdaNS-   >=0, nonlinearity penalty coefficient, negative values are
                        not allowed. This parameter adds controllable smoothing to
                        the problem, which may reduce noise. Specification of non-
                        zero lambda means that in addition to fitting error solver
                        will  also  minimize   LambdaNS*|S''(x)|^2  (appropriately
                        generalized to multiple dimensions.
                        
                        Specification of exactly zero value means that no  penalty
                        is added  (we  do  not  even  evaluate  matrix  of  second
                        derivatives which is necessary for smoothing).
                        
                        Calculation of nonlinearity penalty is costly - it results
                        in  several-fold  increase  of  model  construction  time.
                        Evaluation time remains the same.
                        
                        Optimal  lambda  is  problem-dependent and requires  trial
                        and  error.  Good  value to  start  from  is  1e-5...1e-6,
                        which corresponds to slightly noticeable smoothing  of the
                        function.  Value  1e-2  usually  means  that  quite  heavy
                        smoothing is applied.

        TUNING ALGORITHM

        In order to use this algorithm you have to choose three parameters:
        * initial radius RBase
        * number of layers in the model NLayers
        * penalty coefficient LambdaNS

        Initial radius is easy to choose - you can pick any number  several  times
        larger  than  the  average  distance between points. Algorithm won't break
        down if you choose radius which is too large (model construction time will
        increase, but model will be built correctly).

        Choose such number of layers that RLast=RBase/2^(NLayers-1)  (radius  used
        by  the  last  layer)  will  be  smaller than the typical distance between
        points.  In  case  model  error  is  too large, you can increase number of
        layers.  Having  more  layers  will make model construction and evaluation
        proportionally slower, but it will allow you to have model which precisely
        fits your data. From the other side, if you want to  suppress  noise,  you
        can DECREASE number of layers to make your model less flexible (or specify
        non-zero LambdaNS).

        TYPICAL ERRORS

        1. Using too small number of layers - RBF models with large radius are not
           flexible enough to reproduce small variations in the  target  function.
           You  need  many  layers  with  different radii, from large to small, in
           order to have good model.

        2. Using  initial  radius  which  is  too  small.  You will get model with
           "holes" in the areas which are too far away from interpolation centers.
           However, algorithm will work correctly (and quickly) in this case.

          -- ALGLIB --
             Copyright 20.06.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetalgohierarchical(rbfmodel s,
            double rbase,
            int nlayers,
            double lambdans,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(rbase), "RBFSetAlgoHierarchical: RBase is infinite or NaN");
            alglib.ap.assert((double)(rbase)>(double)(0), "RBFSetAlgoHierarchical: RBase<=0");
            alglib.ap.assert(nlayers>=0, "RBFSetAlgoHierarchical: NLayers<0");
            alglib.ap.assert(math.isfinite(lambdans) && (double)(lambdans)>=(double)(0), "RBFSetAlgoHierarchical: LambdaNS<0 or infinite");
            s.radvalue = rbase;
            s.nlayers = nlayers;
            s.algorithmtype = 3;
            s.lambdav = lambdans;
        }


        /*************************************************************************
        This function chooses a thin plate  spline  DDM-RBF  solver,  a  fast  RBF
        solver with f(r)=r^2*ln(r) basis function.

        This algorithm has following important features:
        * easy setup - no tunable parameters
        * C1 continuous RBF model (gradient is defined everywhere, but Hessian  is
          undefined at nodes), high-quality interpolation
        * fast  model construction algorithm with O(N) memory and  O(N^2)  running
          time requirements. Hundreds of thousands of points can be  handled  with
          this algorithm.
        * controllable smoothing via optional nonlinearity penalty

        INPUT PARAMETERS:
            S       -   RBF model, initialized by rbfcreate() call
            LambdaV -   smoothing parameter, LambdaV>=0, defaults to 0.0:
                        * LambdaV=0 means that no smoothing is applied,  i.e.  the
                          spline tries to pass through all dataset points exactly
                        * LambdaV>0 means that a smoothing thin  plate  spline  is
                          built, with larger LambdaV corresponding to models  with
                          less nonlinearities. Smoothing spline reproduces  target
                          values at nodes with small error; from the  other  side,
                          it is much more stable.
                          Recommended values:
                          * 1.0E-6 for minimal stability improving smoothing
                          * 1.0E-3 a good value to start experiments; first results
                            are visible
                          * 1.0 for strong smoothing

        IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.19
                   and  produces  models  which  are  INCOMPATIBLE  with  previous
                   versions of ALGLIB. You can  not  unserialize  models  produced
                   with this function in ALGLIB 3.18 or earlier.
                   
        NOTE:      polyharmonic RBFs, including thin plate splines,  are  somewhat
                   slower than compactly supported RBFs built with  HRBF algorithm
                   due to the fact that non-compact basis function does not vanish
                   far away from the nodes. From the other side, polyharmonic RBFs
                   often produce much better results than HRBFs.

        NOTE:      this algorithm supports specification of per-dimensional  radii
                   via scale vector, which is set by means of rbfsetpointsandscales()
                   function. This feature is useful if  you solve  spatio-temporal
                   interpolation problems where different radii are  required  for
                   spatial and temporal dimensions.

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetalgothinplatespline(rbfmodel s,
            double lambdav,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(lambdav), "RBFSetAlgoThinPlateSpline: LambdaV is not finite number");
            alglib.ap.assert((double)(lambdav)>=(double)(0), "RBFSetAlgoThinPlateSpline: LambdaV is negative");
            s.algorithmtype = 4;
            s.bftype = 2;
            s.bfparam = 0;
            s.lambdav = lambdav;
        }


        /*************************************************************************
        This function chooses a multiquadric DDM-RBF solver,  a  fast  RBF  solver
        with f(r)=sqrt(r^2+Alpha^2) as a basis function,  with  manual  choice  of
        the scale parameter Alpha.

        This algorithm has following important features:
        * C2 continuous RBF model (when Alpha>0 is used; for Alpha=0 the model  is
          merely C0 continuous)
        * fast  model construction algorithm with O(N) memory and  O(N^2)  running
          time requirements. Hundreds of thousands of points can be  handled  with
          this algorithm.
        * controllable smoothing via optional nonlinearity penalty
          
        One important point is that  this  algorithm  includes  tunable  parameter
        Alpha, which should be carefully chosen. Selecting too  large  value  will
        result in extremely badly  conditioned  problems  (interpolation  accuracy
        may degrade up to complete breakdown) whilst selecting too small value may
        produce models that are precise but nearly nonsmooth at the nodes.

        Good value to  start  from  is  mean  distance  between  nodes. Generally,
        choosing too small Alpha is better than choosing too large - in the former
        case you still have model that reproduces target values at the nodes.

        In most cases, better option is to choose good Alpha automatically - it is
        done by another version of the same algorithm that is activated by calling
        rbfsetalgomultiquadricauto() method.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by rbfcreate() call
            Alpha   -   basis function parameter, Alpha>=0:
                        * Alpha>0  means that multiquadric algorithm is used which
                          produces C2-continuous RBF model
                        * Alpha=0  means that the multiquadric kernel  effectively
                          becomes a biharmonic one: f=r. As a  result,  the  model
                          becomes nonsmooth at nodes, and hence is C0 continuous
            LambdaV -   smoothing parameter, LambdaV>=0, defaults to 0.0:
                        * LambdaV=0 means that no smoothing is applied,  i.e.  the
                          spline tries to pass through all dataset points exactly
                        * LambdaV>0 means that a multiquadric spline is built with
                          larger  LambdaV   corresponding   to  models  with  less
                          nonlinearities.  Smoothing   spline   reproduces  target
                          values at nodes with small error; from the  other  side,
                          it is much more stable.
                          Recommended values:
                          * 1.0E-6 for minimal stability improving smoothing
                          * 1.0E-3 a good value to start experiments; first results
                            are visible
                          * 1.0 for strong smoothing

        IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.19
                   and  produces  models  which  are  INCOMPATIBLE  with  previous
                   versions of ALGLIB. You can  not  unserialize  models  produced
                   with this function in ALGLIB 3.18 or earlier.
                   
        NOTE:      polyharmonic RBFs, including thin plate splines,  are  somewhat
                   slower than compactly supported RBFs built with  HRBF algorithm
                   due to the fact that non-compact basis function does not vanish
                   far away from the nodes. From the other side, polyharmonic RBFs
                   often produce much better results than HRBFs.

        NOTE:      this algorithm supports specification of per-dimensional  radii
                   via scale vector, which is set by means of rbfsetpointsandscales()
                   function. This feature is useful if  you solve  spatio-temporal
                   interpolation problems where different radii are  required  for
                   spatial and temporal dimensions.

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetalgomultiquadricmanual(rbfmodel s,
            double alpha,
            double lambdav,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(alpha), "RBFSetAlgoMultiquadricManual: Alpha is infinite or NAN");
            alglib.ap.assert((double)(alpha)>=(double)(0), "RBFSetAlgoMultiquadricManual: Alpha<0");
            alglib.ap.assert(math.isfinite(lambdav), "RBFSetAlgoMultiquadricManual: LambdaV is not finite number");
            alglib.ap.assert((double)(lambdav)>=(double)(0), "RBFSetAlgoMultiquadricManual: LambdaV is negative");
            s.algorithmtype = 4;
            s.bftype = 1;
            s.bfparam = alpha;
            s.lambdav = lambdav;
        }


        /*************************************************************************
        This function chooses a multiquadric DDM-RBF solver,  a  fast  RBF  solver
        with f(r)=sqrt(r^2+Alpha^2)  as  a  basis  function,  with   Alpha   being
        automatically determined.

        This algorithm has following important features:
        * easy setup - no need to tune Alpha, good value is automatically assigned
        * C2 continuous RBF model
        * fast  model construction algorithm with O(N) memory and  O(N^2)  running
          time requirements. Hundreds of thousands of points can be  handled  with
          this algorithm.
        * controllable smoothing via optional nonlinearity penalty

        This algorithm automatically selects Alpha  as  a  mean  distance  to  the
        nearest neighbor (ignoring neighbors that are too close).

        INPUT PARAMETERS:
            S       -   RBF model, initialized by rbfcreate() call
            LambdaV -   smoothing parameter, LambdaV>=0, defaults to 0.0:
                        * LambdaV=0 means that no smoothing is applied,  i.e.  the
                          spline tries to pass through all dataset points exactly
                        * LambdaV>0 means that a multiquadric spline is built with
                          larger  LambdaV   corresponding   to  models  with  less
                          nonlinearities.  Smoothing   spline   reproduces  target
                          values at nodes with small error; from the  other  side,
                          it is much more stable.
                          Recommended values:
                          * 1.0E-6 for minimal stability improving smoothing
                          * 1.0E-3 a good value to start experiments; first results
                            are visible
                          * 1.0 for strong smoothing

        IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.19
                   and  produces  models  which  are  INCOMPATIBLE  with  previous
                   versions of ALGLIB. You can  not  unserialize  models  produced
                   with this function in ALGLIB 3.18 or earlier.
                   
        NOTE:      polyharmonic RBFs, including thin plate splines,  are  somewhat
                   slower than compactly supported RBFs built with  HRBF algorithm
                   due to the fact that non-compact basis function does not vanish
                   far away from the nodes. From the other side, polyharmonic RBFs
                   often produce much better results than HRBFs.

        NOTE:      this algorithm supports specification of per-dimensional  radii
                   via scale vector, which is set by means of rbfsetpointsandscales()
                   function. This feature is useful if  you solve  spatio-temporal
                   interpolation problems where different radii are  required  for
                   spatial and temporal dimensions.

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetalgomultiquadricauto(rbfmodel s,
            double lambdav,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(lambdav), "RBFSetAlgoMultiquadricAuto: LambdaV is not finite number");
            alglib.ap.assert((double)(lambdav)>=(double)(0), "RBFSetAlgoMultiquadricAuto: LambdaV is negative");
            s.algorithmtype = 4;
            s.bftype = 1;
            s.bfparam = -1.0;
            s.lambdav = lambdav;
        }


        /*************************************************************************
        This  function  chooses  a  biharmonic DDM-RBF solver, a fast  RBF  solver
        with f(r)=r as a basis function.

        This algorithm has following important features:
        * no tunable parameters
        * C0 continuous RBF model (the model has discontinuous derivatives at  the
          interpolation nodes)
        * fast  model construction algorithm with O(N) memory and  O(N^2)  running
          time requirements. Hundreds of thousands of points can be  handled  with
          this algorithm.
        * controllable smoothing via optional nonlinearity penalty

        INPUT PARAMETERS:
            S       -   RBF model, initialized by rbfcreate() call
            LambdaV -   smoothing parameter, LambdaV>=0, defaults to 0.0:
                        * LambdaV=0 means that no smoothing is applied,  i.e.  the
                          spline tries to pass through all dataset points exactly
                        * LambdaV>0 means that a multiquadric spline is built with
                          larger  LambdaV   corresponding   to  models  with  less
                          nonlinearities.  Smoothing   spline   reproduces  target
                          values at nodes with small error; from the  other  side,
                          it is much more stable.
                          Recommended values:
                          * 1.0E-6 for minimal stability improving smoothing
                          * 1.0E-3 a good value to start experiments; first results
                            are visible
                          * 1.0 for strong smoothing

        IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.19
                   and  produces  models  which  are  INCOMPATIBLE  with  previous
                   versions of ALGLIB. You can  not  unserialize  models  produced
                   with this function in ALGLIB 3.18 or earlier.
                   
        NOTE:      polyharmonic RBFs, including thin plate splines,  are  somewhat
                   slower than compactly supported RBFs built with  HRBF algorithm
                   due to the fact that non-compact basis function does not vanish
                   far away from the nodes. From the other side, polyharmonic RBFs
                   often produce much better results than HRBFs.

        NOTE:      this algorithm supports specification of per-dimensional  radii
                   via scale vector, which is set by means of rbfsetpointsandscales()
                   function. This feature is useful if  you solve  spatio-temporal
                   interpolation problems where different radii are  required  for
                   spatial and temporal dimensions.

          -- ALGLIB --
             Copyright 12.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetalgobiharmonic(rbfmodel s,
            double lambdav,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(lambdav), "RBFSetAlgoBiharmonic: LambdaV is not finite number");
            alglib.ap.assert((double)(lambdav)>=(double)(0), "RBFSetAlgoBiharmonic: LambdaV is negative");
            s.algorithmtype = 4;
            s.bftype = 1;
            s.bfparam = 0;
            s.lambdav = lambdav;
        }


        /*************************************************************************
        This function sets linear term (model is a sum of radial  basis  functions
        plus linear polynomial). This function won't have effect until  next  call 
        to RBFBuildModel().

        Using linear term is a default option and it is the best one - it provides
        best convergence guarantees for all RBF model  types: legacy  RBF-QNN  and
        RBF-ML, Gaussian HRBFs and all types of DDM-RBF models.

        Other options, like constant or zero term, work for HRBFs,  almost  always
        work for DDM-RBFs but provide no stability  guarantees  in the latter case
        (e.g. the solver may fail on some carefully prepared problems).

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetlinterm(rbfmodel s,
            alglib.xparams _params)
        {
            s.aterm = 1;
        }


        /*************************************************************************
        This function sets constant term (model is a sum of radial basis functions
        plus constant).  This  function  won't  have  effect  until  next  call to 
        RBFBuildModel().

        IMPORTANT: thin plate splines require  polynomial term to be  linear,  not
                   constant,  in  order  to  provide   interpolation   guarantees.
                   Although  failures  are  exceptionally  rare,  some  small  toy
                   problems may result in degenerate linear systems. Thus,  it  is
                   advised to use linear term when one fits data with TPS.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetconstterm(rbfmodel s,
            alglib.xparams _params)
        {
            s.aterm = 2;
        }


        /*************************************************************************
        This  function  sets  zero  term (model is a sum of radial basis functions 
        without polynomial term). This function won't have effect until next  call
        to RBFBuildModel().

        IMPORTANT: only  Gaussian  RBFs  (HRBF  algorithm)  provide  interpolation
                   guarantees when no polynomial term is used.  Most  other  RBFs,
                   including   biharmonic  splines,   thin   plate   splines   and
                   multiquadrics, require at least constant term  (biharmonic  and
                   multiquadric) or linear one (thin plate splines)  in  order  to
                   guarantee non-degeneracy of linear systems being solved.
                   
                   Although  failures  are  exceptionally  rare,  some  small  toy
                   problems still may result in degenerate linear systems. Thus,it
                   is advised to use constant/linear term, unless one is 100% sure
                   that he needs zero term.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetzeroterm(rbfmodel s,
            alglib.xparams _params)
        {
            s.aterm = 3;
        }


        /*************************************************************************
        This function sets basis function type, which can be:
        * 0 for classic Gaussian
        * 1 for fast and compact bell-like basis function, which  becomes  exactly
          zero at distance equal to 3*R (default option).

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call
            BF      -   basis function type:
                        * 0 - classic Gaussian
                        * 1 - fast and compact one

          -- ALGLIB --
             Copyright 01.02.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetv2bf(rbfmodel s,
            int bf,
            alglib.xparams _params)
        {
            alglib.ap.assert(bf==0 || bf==1, "RBFSetV2Its: BF<>0 and BF<>1");
            s.model2.basisfunction = bf;
        }


        /*************************************************************************
        This function sets stopping criteria of the underlying linear  solver  for
        hierarchical (version 2) RBF constructor.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call
            MaxIts  -   this criterion will stop algorithm after MaxIts iterations.
                        Typically a few hundreds iterations is required,  with 400
                        being a good default value to start experimentation.
                        Zero value means that default value will be selected.

          -- ALGLIB --
             Copyright 01.02.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetv2its(rbfmodel s,
            int maxits,
            alglib.xparams _params)
        {
            alglib.ap.assert(maxits>=0, "RBFSetV2Its: MaxIts is negative");
            s.model2.maxits = maxits;
        }


        /*************************************************************************
        This function sets support radius parameter  of  hierarchical  (version 2)
        RBF constructor.

        Hierarchical RBF model achieves great speed-up  by removing from the model
        excessive (too dense) nodes. Say, if you have RBF radius equal to 1 meter,
        and two nodes are just 1 millimeter apart, you  may  remove  one  of  them
        without reducing model quality.

        Support radius parameter is used to justify which points need removal, and
        which do not. If two points are less than  SUPPORT_R*CUR_RADIUS  units  of
        distance apart, one of them is removed from the model. The larger  support
        radius  is, the faster model  construction  AND  evaluation are.  However,
        too large values result in "bumpy" models.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call
            R       -   support radius coefficient, >=0.
                        Recommended values are [0.1,0.4] range, with 0.1 being
                        default value.

          -- ALGLIB --
             Copyright 01.02.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetv2supportr(rbfmodel s,
            double r,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(r), "RBFSetV2SupportR: R is not finite");
            alglib.ap.assert((double)(r)>=(double)(0), "RBFSetV2SupportR: R<0");
            s.model2.supportr = r;
        }


        /*************************************************************************
        This function sets stopping criteria of the underlying linear solver.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call
            EpsOrt  -   orthogonality stopping criterion, EpsOrt>=0. Algorithm will
                        stop when ||A'*r||<=EpsOrt where A' is a transpose of  the 
                        system matrix, r is a residual vector.
                        Recommended value of EpsOrt is equal to 1E-6.
                        This criterion will stop algorithm when we have "bad fit"
                        situation, i.e. when we should stop in a point with large,
                        nonzero residual.
            EpsErr  -   residual stopping  criterion.  Algorithm  will  stop  when
                        ||r||<=EpsErr*||b||, where r is a residual vector, b is  a
                        right part of the system (function values).
                        Recommended value of EpsErr is equal to 1E-3 or 1E-6.
                        This  criterion  will  stop  algorithm  in  a  "good  fit" 
                        situation when we have near-zero residual near the desired
                        solution.
            MaxIts  -   this criterion will stop algorithm after MaxIts iterations.
                        It should be used for debugging purposes only!
                        Zero MaxIts means that no limit is placed on the number of
                        iterations.

        We  recommend  to  set  moderate  non-zero  values   EpsOrt   and   EpsErr 
        simultaneously. Values equal to 10E-6 are good to start with. In case  you
        need high performance and do not need high precision ,  you  may  decrease
        EpsErr down to 0.001. However, we do not recommend decreasing EpsOrt.

        As for MaxIts, we recommend to leave it zero unless you know what you do.

        NOTE: this   function  has   some   serialization-related  subtleties.  We
              recommend you to study serialization examples from ALGLIB  Reference
              Manual if you want to perform serialization of your models.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfsetcond(rbfmodel s,
            double epsort,
            double epserr,
            int maxits,
            alglib.xparams _params)
        {
            alglib.ap.assert(math.isfinite(epsort) && (double)(epsort)>=(double)(0), "RBFSetCond: EpsOrt is negative, INF or NAN");
            alglib.ap.assert(math.isfinite(epserr) && (double)(epserr)>=(double)(0), "RBFSetCond: EpsB is negative, INF or NAN");
            alglib.ap.assert(maxits>=0, "RBFSetCond: MaxIts is negative");
            if( ((double)(epsort)==(double)(0) && (double)(epserr)==(double)(0)) && maxits==0 )
            {
                s.epsort = eps;
                s.epserr = eps;
                s.maxits = 0;
            }
            else
            {
                s.epsort = epsort;
                s.epserr = epserr;
                s.maxits = maxits;
            }
        }


        /*************************************************************************
        This   function  builds  RBF  model  and  returns  report  (contains  some 
        information which can be used for evaluation of the algorithm properties).

        Call to this function modifies RBF model by calculating its centers/radii/
        weights  and  saving  them  into  RBFModel  structure.  Initially RBFModel 
        contain zero coefficients, but after call to this function  we  will  have
        coefficients which were calculated in order to fit our dataset.

        After you called this function you can call RBFCalc(),  RBFGridCalc()  and
        other model calculation functions.

        INPUT PARAMETERS:
            S       -   RBF model, initialized by RBFCreate() call
            Rep     -   report:
                        * Rep.TerminationType:
                          * -5 - non-distinct basis function centers were detected,
                                 interpolation  aborted;  only  QNN  returns  this
                                 error   code, other  algorithms  can  handle non-
                                 distinct nodes.
                          * -4 - nonconvergence of the internal SVD solver
                          * -3   incorrect model construction algorithm was chosen:
                                 QNN or RBF-ML, combined with one of the incompatible
                                 features:
                                 * NX=1 or NX>3
                                 * points with per-dimension scales.
                          *  1 - successful termination
                          *  8 - a termination request was submitted via
                                 rbfrequesttermination() function.
                        
                        Fields which are set only by modern RBF solvers (hierarchical
                        or nonnegative; older solvers like QNN and ML initialize these
                        fields by NANs):
                        * rep.rmserror - root-mean-square error at nodes
                        * rep.maxerror - maximum error at nodes
                        
                        Fields are used for debugging purposes:
                        * Rep.IterationsCount - iterations count of the LSQR solver
                        * Rep.NMV - number of matrix-vector products
                        * Rep.ARows - rows count for the system matrix
                        * Rep.ACols - columns count for the system matrix
                        * Rep.ANNZ - number of significantly non-zero elements
                          (elements above some algorithm-determined threshold)

        NOTE:  failure  to  build  model will leave current state of the structure
        unchanged.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfbuildmodel(rbfmodel s,
            rbfreport rep,
            alglib.xparams _params)
        {
            rbfv1.rbfv1report rep1 = new rbfv1.rbfv1report();
            rbfv2.rbfv2report rep2 = new rbfv2.rbfv2report();
            rbfv3.rbfv3report rep3 = new rbfv3.rbfv3report();
            double[,] x3 = new double[0,0];
            double[] scalevec = new double[0];
            int i = 0;
            int v3bftype = 0;
            double v3bfparam = 0;
            int curalgorithmtype = 0;

            
            //
            // Clean fields prior to processing
            //
            clearreportfields(rep, _params);
            s.progress10000 = 0;
            s.terminationrequest = false;
            
            //
            // Autoselect algorithm
            //
            v3bftype = -999;
            v3bfparam = 0.0;
            if( s.algorithmtype==0 )
            {
                curalgorithmtype = 4;
                v3bftype = 2;
                v3bfparam = 0.0;
            }
            else
            {
                curalgorithmtype = s.algorithmtype;
                if( s.algorithmtype==4 )
                {
                    v3bftype = s.bftype;
                    v3bfparam = s.bfparam;
                }
            }
            
            //
            // Algorithms which generate V1 models
            //
            if( curalgorithmtype==1 || curalgorithmtype==2 )
            {
                
                //
                // Perform compatibility checks
                //
                if( (s.nx<2 || s.nx>3) || s.hasscale )
                {
                    rep.terminationtype = -3;
                    return;
                }
                
                //
                // Try to build model.
                //
                // NOTE: due to historical reasons RBFV1BuildModel() accepts points
                //       cast to 3-dimensional space, even if they are really 2-dimensional.
                //       So, for 2D data we have to explicitly convert them to 3D.
                //
                if( s.nx==2 )
                {
                    
                    //
                    // Convert data to 3D
                    //
                    apserv.rmatrixsetlengthatleast(ref x3, s.n, 3, _params);
                    for(i=0; i<=s.n-1; i++)
                    {
                        x3[i,0] = s.x[i,0];
                        x3[i,1] = s.x[i,1];
                        x3[i,2] = 0;
                    }
                    rbfv1.rbfv1buildmodel(x3, s.y, s.n, s.aterm, curalgorithmtype, s.nlayers, s.radvalue, s.radzvalue, s.lambdav, s.epsort, s.epserr, s.maxits, s.model1, rep1, _params);
                }
                else
                {
                    
                    //
                    // Work with raw data
                    //
                    rbfv1.rbfv1buildmodel(s.x, s.y, s.n, s.aterm, curalgorithmtype, s.nlayers, s.radvalue, s.radzvalue, s.lambdav, s.epsort, s.epserr, s.maxits, s.model1, rep1, _params);
                }
                s.modelversion = 1;
                rbfcreatecalcbuffer(s, s.calcbuf, _params);
                
                //
                // Convert report fields
                //
                rep.arows = rep1.arows;
                rep.acols = rep1.acols;
                rep.annz = rep1.annz;
                rep.iterationscount = rep1.iterationscount;
                rep.nmv = rep1.nmv;
                rep.terminationtype = rep1.terminationtype;
                
                //
                // Done
                //
                return;
            }
            
            //
            // Algorithms which generate V2 models
            //
            if( curalgorithmtype==3 )
            {
                
                //
                // Prepare scale vector - use unit values or user supplied ones
                //
                scalevec = new double[s.nx];
                for(i=0; i<=s.nx-1; i++)
                {
                    if( s.hasscale )
                    {
                        scalevec[i] = s.s[i];
                    }
                    else
                    {
                        scalevec[i] = 1;
                    }
                }
                
                //
                // Build model
                //
                rbfv2.rbfv2buildhierarchical(s.x, s.y, s.n, scalevec, s.aterm, s.nlayers, s.radvalue, s.lambdav, s.model2, ref s.progress10000, ref s.terminationrequest, rep2, _params);
                s.modelversion = 2;
                rbfcreatecalcbuffer(s, s.calcbuf, _params);
                
                //
                // Convert report fields
                //
                rep.terminationtype = rep2.terminationtype;
                rep.rmserror = rep2.rmserror;
                rep.maxerror = rep2.maxerror;
                
                //
                // Done
                //
                return;
            }
            
            //
            // Algorithms which generate DDM-RBF models
            //
            if( curalgorithmtype==4 )
            {
                
                //
                // Prepare scale vector - use unit values or user supplied ones
                //
                scalevec = new double[s.nx];
                for(i=0; i<=s.nx-1; i++)
                {
                    if( s.hasscale )
                    {
                        scalevec[i] = s.s[i];
                    }
                    else
                    {
                        scalevec[i] = 1;
                    }
                }
                
                //
                // Build model
                //
                rbfv3.rbfv3build(s.x, s.y, s.n, scalevec, v3bftype, v3bfparam, s.lambdav, s.aterm, s.model3, ref s.progress10000, ref s.terminationrequest, rep3, _params);
                s.modelversion = 3;
                rbfcreatecalcbuffer(s, s.calcbuf, _params);
                
                //
                // Convert report fields
                //
                rep.iterationscount = rep3.iterationscount;
                rep.terminationtype = rep3.terminationtype;
                rep.rmserror = rep3.rmserror;
                rep.maxerror = rep3.maxerror;
                
                //
                // Done
                //
                return;
            }
            
            //
            // Critical error
            //
            alglib.ap.assert(false, "RBFBuildModel: integrity check failure");
        }


        /*************************************************************************
        This function calculates values of the 1-dimensional RBF model with scalar
        output (NY=1) at the given point.

        IMPORTANT: this function works only with modern  (hierarchical)  RBFs.  It 
                   can not be used with legacy (version 1) RBFs because older  RBF
                   code does not support 1-dimensional models.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftscalcbuf() with per-thread buffer object.

        This function returns 0.0 when:
        * the model is not initialized
        * NX<>1
        * NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   X-coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfcalc1(rbfmodel s,
            double x0,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc1: invalid value for X0 (X0 is Inf)!");
            result = 0;
            if( s.ny!=1 || s.nx!=1 )
            {
                return result;
            }
            if( s.modelversion==1 )
            {
                result = 0;
                return result;
            }
            if( s.modelversion==2 )
            {
                result = rbfv2.rbfv2calc1(s.model2, x0, _params);
                return result;
            }
            if( s.modelversion==3 )
            {
                result = rbfv3.rbfv3calc1(s.model3, x0, _params);
                return result;
            }
            alglib.ap.assert(false, "RBFCalc1: integrity check failed");
            return result;
        }


        /*************************************************************************
        This function calculates values of the 2-dimensional RBF model with scalar
        output (NY=1) at the given point.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftscalcbuf() with per-thread buffer object.

        This function returns 0.0 when:
        * model is not initialized
        * NX<>2
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfcalc2(rbfmodel s,
            double x0,
            double x1,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc2: invalid value for X0 (X0 is Inf)!");
            alglib.ap.assert(math.isfinite(x1), "RBFCalc2: invalid value for X1 (X1 is Inf)!");
            result = 0;
            if( s.ny!=1 || s.nx!=2 )
            {
                return result;
            }
            if( s.modelversion==1 )
            {
                result = rbfv1.rbfv1calc2(s.model1, x0, x1, _params);
                return result;
            }
            if( s.modelversion==2 )
            {
                result = rbfv2.rbfv2calc2(s.model2, x0, x1, _params);
                return result;
            }
            if( s.modelversion==3 )
            {
                result = rbfv3.rbfv3calc2(s.model3, x0, x1, _params);
                return result;
            }
            alglib.ap.assert(false, "RBFCalc2: integrity check failed");
            return result;
        }


        /*************************************************************************
        This function calculates values of the 3-dimensional RBF model with scalar
        output (NY=1) at the given point.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftscalcbuf() with per-thread buffer object.

        This function returns 0.0 when:
        * model is not initialized
        * NX<>3
         *NY<>1

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number
            X2      -   third coordinate, finite number

        RESULT:
            value of the model or 0.0 (as defined above)

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfcalc3(rbfmodel s,
            double x0,
            double x1,
            double x2,
            alglib.xparams _params)
        {
            double result = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFCalc3: invalid value for X0 (X0 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x1), "RBFCalc3: invalid value for X1 (X1 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x2), "RBFCalc3: invalid value for X2 (X2 is Inf or NaN)!");
            result = 0;
            if( s.ny!=1 || s.nx!=3 )
            {
                return result;
            }
            if( s.modelversion==1 )
            {
                result = rbfv1.rbfv1calc3(s.model1, x0, x1, x2, _params);
                return result;
            }
            if( s.modelversion==2 )
            {
                result = rbfv2.rbfv2calc3(s.model2, x0, x1, x2, _params);
                return result;
            }
            if( s.modelversion==3 )
            {
                result = rbfv3.rbfv3calc3(s.model3, x0, x1, x2, _params);
                return result;
            }
            alglib.ap.assert(false, "RBFCalc3: integrity check failed");
            return result;
        }


        /*************************************************************************
        This function calculates value and derivatives of  the  1-dimensional  RBF
        model with scalar output (NY=1) at the given point.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftscalcbuf() with per-thread buffer object.

        This function returns 0.0 in Y and/or DY in the following cases:
        * the model is not initialized (Y=0, DY=0)
        * NX<>1 or NY<>1 (Y=0, DY=0)
        * the gradient is undefined at the trial point. Some basis  functions have
          discontinuous derivatives at the interpolation nodes:
          * biharmonic splines f=r have no Hessian and no gradient at the nodes
          In these cases only DY is set to zero (Y is still returned)

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number

        OUTPUT PARAMETERS:
            Y       -   value of the model or 0.0 (as defined above)
            DY0     -   derivative with respect to X0

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfdiff1(rbfmodel s,
            double x0,
            ref double y,
            ref double dy0,
            alglib.xparams _params)
        {
            y = 0;
            dy0 = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFDiff1: invalid value for X0 (X0 is Inf or NaN)!");
            y = 0;
            dy0 = 0;
            if( s.ny!=1 || s.nx!=1 )
            {
                return;
            }
            ablasf.rallocv(1, ref s.calcbuf.x, _params);
            s.calcbuf.x[0] = x0;
            rbftsdiffbuf(s, s.calcbuf, s.calcbuf.x, ref s.calcbuf.y, ref s.calcbuf.dy, _params);
            y = s.calcbuf.y[0];
            dy0 = s.calcbuf.dy[0];
        }


        /*************************************************************************
        This function calculates value and derivatives of  the  2-dimensional  RBF
        model with scalar output (NY=1) at the given point.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftscalcbuf() with per-thread buffer object.

        This function returns 0.0 in Y and/or DY in the following cases:
        * the model is not initialized (Y=0, DY=0)
        * NX<>2 or NY<>1 (Y=0, DY=0)
        * the gradient is undefined at the trial point. Some basis  functions have
          discontinuous derivatives at the interpolation nodes:
          * biharmonic splines f=r have no Hessian and no gradient at the nodes
          In these cases only DY is set to zero (Y is still returned)

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number

        OUTPUT PARAMETERS:
            Y       -   value of the model or 0.0 (as defined above)
            DY0     -   derivative with respect to X0
            DY1     -   derivative with respect to X1

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfdiff2(rbfmodel s,
            double x0,
            double x1,
            ref double y,
            ref double dy0,
            ref double dy1,
            alglib.xparams _params)
        {
            y = 0;
            dy0 = 0;
            dy1 = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFDiff2: invalid value for X0 (X0 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x1), "RBFDiff2: invalid value for X1 (X1 is Inf or NaN)!");
            y = 0;
            dy0 = 0;
            dy1 = 0;
            if( s.ny!=1 || s.nx!=2 )
            {
                return;
            }
            ablasf.rallocv(2, ref s.calcbuf.x, _params);
            s.calcbuf.x[0] = x0;
            s.calcbuf.x[1] = x1;
            rbftsdiffbuf(s, s.calcbuf, s.calcbuf.x, ref s.calcbuf.y, ref s.calcbuf.dy, _params);
            y = s.calcbuf.y[0];
            dy0 = s.calcbuf.dy[0];
            dy1 = s.calcbuf.dy[1];
        }


        /*************************************************************************
        This function calculates value and derivatives of  the  3-dimensional  RBF
        model with scalar output (NY=1) at the given point.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftscalcbuf() with per-thread buffer object.

        This function returns 0.0 in Y and/or DY in the following cases:
        * the model is not initialized (Y=0, DY=0)
        * NX<>3 or NY<>1 (Y=0, DY=0)
        * the gradient is undefined at the trial point. Some basis  functions have
          discontinuous derivatives at the interpolation nodes:
          * biharmonic splines f=r have no Hessian and no gradient at the nodes
          In these cases only DY is set to zero (Y is still returned)

        INPUT PARAMETERS:
            S       -   RBF model
            X0      -   first coordinate, finite number
            X1      -   second coordinate, finite number
            X2      -   third coordinate, finite number

        OUTPUT PARAMETERS:
            Y       -   value of the model or 0.0 (as defined above)
            DY0     -   derivative with respect to X0
            DY1     -   derivative with respect to X1
            DY2     -   derivative with respect to X2

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfdiff3(rbfmodel s,
            double x0,
            double x1,
            double x2,
            ref double y,
            ref double dy0,
            ref double dy1,
            ref double dy2,
            alglib.xparams _params)
        {
            y = 0;
            dy0 = 0;
            dy1 = 0;
            dy2 = 0;

            alglib.ap.assert(math.isfinite(x0), "RBFDiff3: invalid value for X0 (X0 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x1), "RBFDiff3: invalid value for X1 (X1 is Inf or NaN)!");
            alglib.ap.assert(math.isfinite(x2), "RBFDiff3: invalid value for X2 (X2 is Inf or NaN)!");
            y = 0;
            dy0 = 0;
            dy1 = 0;
            dy2 = 0;
            if( s.ny!=1 || s.nx!=3 )
            {
                return;
            }
            ablasf.rallocv(3, ref s.calcbuf.x, _params);
            s.calcbuf.x[0] = x0;
            s.calcbuf.x[1] = x1;
            s.calcbuf.x[2] = x2;
            rbftsdiffbuf(s, s.calcbuf, s.calcbuf.x, ref s.calcbuf.y, ref s.calcbuf.dy, _params);
            y = s.calcbuf.y[0];
            dy0 = s.calcbuf.dy[0];
            dy1 = s.calcbuf.dy[1];
            dy2 = s.calcbuf.dy[2];
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point.

        This is general function which can be used for arbitrary NX (dimension  of 
        the space of arguments) and NY (dimension of the function itself). However
        when  you  have  NY=1  you  may  find more convenient to use rbfcalc2() or 
        rbfcalc3().

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftscalcbuf() with per-thread buffer object.

        This function returns 0.0 when model is not initialized.

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is out-parameter and 
                        reallocated after call to this function. In case you  want
                        to reuse previously allocated Y, you may use RBFCalcBuf(),
                        which reallocates Y only when it is too small.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfcalc(rbfmodel s,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            y = new double[0];

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFCalc: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFCalc: X contains infinite or NaN values");
            rbfcalcbuf(s, x, ref y, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model and  its  derivatives  at
        the given point.

        This is general function which can be used for arbitrary NX (dimension  of 
        the space of arguments) and NY (dimension of the function itself). However
        if you have NX=3 and NY=1, you may find more convenient to use rbfdiff3().

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftsdiffbuf() with per-thread buffer object.

        This function returns 0.0 in Y and/or DY in the following cases:
        * the model is not initialized (Y=0, DY=0)
        * the gradient is undefined at the trial point. Some basis  functions have
          discontinuous derivatives at the interpolation nodes:
          * biharmonic splines f=r have no Hessian and no gradient at the nodes
          In these cases only DY is set to zero (Y is still returned)

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is out-parameter and 
                        reallocated after call to this function. In case you  want
                        to reuse previously allocated Y, you may use RBFDiffBuf(),
                        which reallocates Y only when it is too small.
            DY      -   derivatives, array[NX*NY]:
                        * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                          function component I with respect to input J.
                        * for NY=1 it is simply NX-dimensional gradient of the
                          scalar NX-dimensional function
                        DY is out-parameter and reallocated  after  call  to  this
                        function. In case you want to reuse  previously  allocated
                        DY, you may use RBFDiffBuf(), which  reallocates  DY  only
                        when it is too small to store the result.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfdiff(rbfmodel s,
            double[] x,
            ref double[] y,
            ref double[] dy,
            alglib.xparams _params)
        {
            y = new double[0];
            dy = new double[0];

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFDiff: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFDiff: X contains infinite or NaN values");
            rbfdiffbuf(s, x, ref y, ref dy, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model and  its first and second
        derivatives (Hessian matrix) at the given point.

        This function supports both scalar (NY=1) and vector-valued (NY>1) RBFs.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftshessbuf() with per-thread buffer object.

        This function returns 0 in Y and/or DY and/or D2Y in the following cases:
        * the model is not initialized (Y=0, DY=0, D2Y=0)
        * the gradient and/or Hessian is undefined at the trial point.  Some basis
          functions have discontinuous derivatives at the interpolation nodes:
          * thin plate splines have no Hessian at the nodes
          * biharmonic splines f=r have no Hessian and no gradient at the  nodes
          In these cases only corresponding derivative is set  to  zero,  and  the
          rest of the derivatives is still returned.

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY].
                        Y is out-parameter and  reallocated  after  call  to  this
                        function. In case you  want to reuse previously  allocated
                        Y, you may use RBFHessBuf(), which reallocates Y only when
                        it is too small.
            DY      -   first derivatives, array[NY*NX]:
                        * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                          function component I with respect to input J.
                        * for NY=1 it is simply NX-dimensional gradient of the
                          scalar NX-dimensional function
                        DY is out-parameter and reallocated  after  call  to  this
                        function. In case you want to reuse  previously  allocated
                        DY, you may use RBFHessBuf(), which  reallocates  DY  only
                        when it is too small to store the result.
            D2Y     -   second derivatives, array[NY*NX*NX]:
                        * for NY=1 it is NX*NX array that stores  Hessian  matrix,
                          with Y[I*NX+J]=Y[J*NX+I].
                        * for  a  vector-valued  RBF  with  NY>1  it  contains  NY
                          subsequently stored Hessians: an element Y[K*NX*NX+I*NX+J]
                          with  0<=K<NY,  0<=I<NX  and  0<=J<NX    stores   second
                          derivative of the function #K  with  respect  to  inputs
                          #I and #J.
                        D2Y is out-parameter and reallocated  after  call  to this
                        function. In case you want to reuse  previously  allocated
                        D2Y, you may use RBFHessBuf(), which  reallocates D2Y only
                        when it is too small to store the result.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfhess(rbfmodel s,
            double[] x,
            ref double[] y,
            ref double[] dy,
            ref double[] d2y,
            alglib.xparams _params)
        {
            y = new double[0];
            dy = new double[0];
            d2y = new double[0];

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFHess: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFHess: X contains infinite or NaN values");
            rbftshessbuf(s, s.calcbuf, x, ref y, ref dy, ref d2y, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point.

        Same as rbfcalc(), but does not reallocate Y when in is large enough to 
        store function values.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftscalcbuf() with per-thread buffer object.

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfcalcbuf(rbfmodel s,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFCalcBuf: X contains infinite or NaN values");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = 0;
            }
            if( s.modelversion==1 )
            {
                rbfv1.rbfv1calcbuf(s.model1, x, ref y, _params);
                return;
            }
            if( s.modelversion==2 )
            {
                rbfv2.rbfv2calcbuf(s.model2, x, ref y, _params);
                return;
            }
            if( s.modelversion==3 )
            {
                rbfv3.rbfv3calcbuf(s.model3, x, ref y, _params);
                return;
            }
            alglib.ap.assert(false, "RBFCalcBuf: integrity check failed");
        }


        /*************************************************************************
        This function calculates values of the RBF model and  its  derivatives  at
        the given point. It is a buffered version of the RBFDiff() which tries  to
        reuse possibly preallocated output arrays Y/DY as much as possible.

        This is general function which can be used for arbitrary NX (dimension  of 
        the space of arguments) and NY (dimension of the function itself). However
        if you have NX=1, 2 or 3 and NY=1, you may find  more  convenient  to  use
        rbfdiff1(), rbfdiff2() or rbfdiff3().

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftsdiffbuf() with per-thread buffer object.

        This function returns 0.0 in Y and/or DY in the following cases:
        * the model is not initialized (Y=0, DY=0)
        * the gradient is undefined at the trial point. Some basis  functions have
          discontinuous derivatives at the interpolation nodes:
          * biharmonic splines f=r have no Hessian and no gradient at the nodes
          In these cases only DY is set to zero (Y is still returned)

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y, DY   -   possibly preallocated arrays; if array size is large enough
                        to store results, this function does not  reallocate  array
                        to fit output size exactly.

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY].
            DY      -   derivatives, array[NX*NY]:
                        * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                          function component I with respect to input J.
                        * for NY=1 it is simply NX-dimensional gradient of the
                          scalar NX-dimensional function

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfdiffbuf(rbfmodel s,
            double[] x,
            ref double[] y,
            ref double[] dy,
            alglib.xparams _params)
        {
            int i = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFDiffBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFDiffBuf: X contains infinite or NaN values");
            alglib.ap.assert(s.modelversion==s.calcbuf.modelversion, "RBF: integrity check 3945 failed");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = 0;
            }
            for(i=0; i<=s.ny*s.nx-1; i++)
            {
                dy[i] = 0;
            }
            if( s.modelversion==1 )
            {
                rbfv1.rbfv1tsdiffbuf(s.model1, s.calcbuf.bufv1, x, ref y, ref dy, _params);
                return;
            }
            if( s.modelversion==2 )
            {
                rbfv2.rbfv2tsdiffbuf(s.model2, s.calcbuf.bufv2, x, ref y, ref dy, _params);
                return;
            }
            if( s.modelversion==3 )
            {
                rbfv3.rbfv3tsdiffbuf(s.model3, s.calcbuf.bufv3, x, ref y, ref dy, _params);
                return;
            }
            alglib.ap.assert(false, "RBFDiffBuf: integrity check failed");
        }


        /*************************************************************************
        This function calculates values of the RBF model and  its first and second
        derivatives (Hessian matrix) at the given point. It is a buffered  version
        that reuses memory  allocated  in  output  buffers  Y/DY/D2Y  as  much  as
        possible.

        This function supports both scalar (NY=1) and vector-valued (NY>1) RBFs.

        IMPORTANT: THIS FUNCTION IS THREAD-UNSAFE. It uses fields of  rbfmodel  as
                   temporary arrays, i.e. it is  impossible  to  perform  parallel
                   evaluation on the same rbfmodel object (parallel calls of  this
                   function for independent rbfmodel objects are safe).
                   
                   If you want to perform parallel model evaluation  from multiple
                   threads, use rbftshessbuf() with per-thread buffer object.

        This function returns 0 in Y and/or DY and/or D2Y in the following cases:
        * the model is not initialized (Y=0, DY=0, D2Y=0)
        * the gradient and/or Hessian is undefined at the trial point.  Some basis
          functions have discontinuous derivatives at the interpolation nodes:
          * thin plate splines have no Hessian at the nodes
          * biharmonic splines f=r have no Hessian and no gradient at the  nodes
          In these cases only corresponding derivative is set  to  zero,  and  the
          rest of the derivatives is still returned.

        INPUT PARAMETERS:
            S       -   RBF model
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y,DY,D2Y-   possible preallocated output arrays. If these  arrays  are
                        smaller than  required  to  store  the  result,  they  are
                        automatically reallocated. If array is large enough, it is
                        not resized.

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY].
            DY      -   first derivatives, array[NY*NX]:
                        * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                          function component I with respect to input J.
                        * for NY=1 it is simply NX-dimensional gradient of the
                          scalar NX-dimensional function
            D2Y     -   second derivatives, array[NY*NX*NX]:
                        * for NY=1 it is NX*NX array that stores  Hessian  matrix,
                          with Y[I*NX+J]=Y[J*NX+I].
                        * for  a  vector-valued  RBF  with  NY>1  it  contains  NY
                          subsequently stored Hessians: an element Y[K*NX*NX+I*NX+J]
                          with  0<=K<NY,  0<=I<NX  and  0<=J<NX    stores   second
                          derivative of the function #K  with  respect  to  inputs
                          #I and #J.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfhessbuf(rbfmodel s,
            double[] x,
            ref double[] y,
            ref double[] dy,
            ref double[] d2y,
            alglib.xparams _params)
        {
            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFHess: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFHess: X contains infinite or NaN values");
            rbftshessbuf(s, s.calcbuf, x, ref y, ref dy, ref d2y, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model at the given point, using
        external  buffer  object  (internal  temporaries  of  RBF  model  are  not
        modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use  different  instances  of  buffer
        structure.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y       -   possibly preallocated array

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY]. Y is not reallocated when it
                        is larger than NY.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbftscalcbuf(rbfmodel s,
            rbfcalcbuffer buf,
            double[] x,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFCalcBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFCalcBuf: X contains infinite or NaN values");
            alglib.ap.assert(s.modelversion==buf.modelversion, "RBFCalcBuf: buffer object is not compatible with RBF model");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = 0;
            }
            if( s.modelversion==1 )
            {
                rbfv1.rbfv1tscalcbuf(s.model1, buf.bufv1, x, ref y, _params);
                return;
            }
            if( s.modelversion==2 )
            {
                rbfv2.rbfv2tscalcbuf(s.model2, buf.bufv2, x, ref y, _params);
                return;
            }
            if( s.modelversion==3 )
            {
                rbfv3.rbfv3tscalcbuf(s.model3, buf.bufv3, x, ref y, _params);
                return;
            }
            alglib.ap.assert(false, "RBFTsCalcBuf: integrity check failed");
        }


        /*************************************************************************
        This function calculates values of the RBF model and  its  derivatives  at
        the given point, using external buffer object (internal temporaries of the
        RBF model are not modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use different instances of the buffer
        structure.

        This function returns 0.0 in Y and/or DY in the following cases:
        * the model is not initialized (Y=0, DY=0)
        * the gradient is undefined at the trial point. Some basis  functions have
          discontinuous derivatives at the interpolation nodes:
          * biharmonic splines f=r have no Hessian and no gradient at the nodes
          In these cases only DY is set to zero (Y is still returned)

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y, DY   -   possibly preallocated arrays; if array size is large enough
                        to store results, this function does not  reallocate  array
                        to fit output size exactly.

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY].
            DY      -   derivatives, array[NX*NY]:
                        * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                          function component I with respect to input J.
                        * for NY=1 it is simply NX-dimensional gradient of the
                          scalar NX-dimensional function
                        Zero is returned when the first derivative is undefined.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbftsdiffbuf(rbfmodel s,
            rbfcalcbuffer buf,
            double[] x,
            ref double[] y,
            ref double[] dy,
            alglib.xparams _params)
        {
            int i = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFTsDiffBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFTsDiffBuf: X contains infinite or NaN values");
            alglib.ap.assert(s.modelversion==buf.modelversion, "RBFTsDiffBuf: integrity check 3985 failed");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = 0;
            }
            for(i=0; i<=s.ny*s.nx-1; i++)
            {
                dy[i] = 0;
            }
            if( s.modelversion==1 )
            {
                rbfv1.rbfv1tsdiffbuf(s.model1, buf.bufv1, x, ref y, ref dy, _params);
                return;
            }
            if( s.modelversion==2 )
            {
                rbfv2.rbfv2tsdiffbuf(s.model2, buf.bufv2, x, ref y, ref dy, _params);
                return;
            }
            if( s.modelversion==3 )
            {
                rbfv3.rbfv3tsdiffbuf(s.model3, buf.bufv3, x, ref y, ref dy, _params);
                return;
            }
            alglib.ap.assert(false, "RBFDiffBuf: integrity check failed");
        }


        /*************************************************************************
        This function calculates values of the RBF model and  its first and second
        derivatives (Hessian matrix) at the given  point,  using  external  buffer
        object (internal temporaries of the RBF  model  are  not  modified).

        This function allows to use same RBF model object  in  different  threads,
        assuming  that  different   threads  use different instances of the buffer
        structure.

        This function returns 0 in Y and/or DY and/or D2Y in the following cases:
        * the model is not initialized (Y=0, DY=0, D2Y=0)
        * the gradient and/or Hessian is undefined at the trial point.  Some basis
          functions have discontinuous derivatives at the interpolation nodes:
          * thin plate splines have no Hessian at the nodes
          * biharmonic splines f=r have no Hessian and no gradient at the  nodes
          In these cases only corresponding derivative is set  to  zero,  and  the
          rest of the derivatives is still returned.

        INPUT PARAMETERS:
            S       -   RBF model, may be shared between different threads
            Buf     -   buffer object created for this particular instance of  RBF
                        model with rbfcreatecalcbuffer().
            X       -   coordinates, array[NX].
                        X may have more than NX elements, in this case only 
                        leading NX will be used.
            Y,DY,D2Y-   possible preallocated output arrays. If these  arrays  are
                        smaller than  required  to  store  the  result,  they  are
                        automatically reallocated. If array is large enough, it is
                        not resized.

        OUTPUT PARAMETERS:
            Y       -   function value, array[NY].
            DY      -   first derivatives, array[NY*NX]:
                        * Y[I*NX+J] with 0<=I<NY and 0<=J<NX  stores derivative of
                          function component I with respect to input J.
                        * for NY=1 it is simply NX-dimensional gradient of the
                          scalar NX-dimensional function
                        Zero is returned when the first derivative is undefined.
            D2Y     -   second derivatives, array[NY*NX*NX]:
                        * for NY=1 it is NX*NX array that stores  Hessian  matrix,
                          with Y[I*NX+J]=Y[J*NX+I].
                        * for  a  vector-valued  RBF  with  NY>1  it  contains  NY
                          subsequently stored Hessians: an element Y[K*NX*NX+I*NX+J]
                          with  0<=K<NY,  0<=I<NX  and  0<=J<NX    stores   second
                          derivative of the function #K  with  respect  to  inputs
                          #I and #J.
                        Zero is returned when the second derivative is undefined.

          -- ALGLIB --
             Copyright 13.12.2021 by Bochkanov Sergey
        *************************************************************************/
        public static void rbftshessbuf(rbfmodel s,
            rbfcalcbuffer buf,
            double[] x,
            ref double[] y,
            ref double[] dy,
            ref double[] d2y,
            alglib.xparams _params)
        {
            int i = 0;

            alglib.ap.assert(alglib.ap.len(x)>=s.nx, "RBFTsHessBuf: Length(X)<NX");
            alglib.ap.assert(apserv.isfinitevector(x, s.nx, _params), "RBFTsHessBuf: X contains infinite or NaN values");
            alglib.ap.assert(s.modelversion==buf.modelversion, "RBFTsHessBuf: integrity check 3953 failed");
            if( alglib.ap.len(y)<s.ny )
            {
                y = new double[s.ny];
            }
            if( alglib.ap.len(dy)<s.ny*s.nx )
            {
                dy = new double[s.ny*s.nx];
            }
            if( alglib.ap.len(d2y)<s.ny*s.nx*s.nx )
            {
                d2y = new double[s.ny*s.nx*s.nx];
            }
            for(i=0; i<=s.ny-1; i++)
            {
                y[i] = 0;
            }
            for(i=0; i<=s.ny*s.nx-1; i++)
            {
                dy[i] = 0;
            }
            for(i=0; i<=s.ny*s.nx*s.nx-1; i++)
            {
                d2y[i] = 0;
            }
            if( s.modelversion==1 )
            {
                rbfv1.rbfv1tshessbuf(s.model1, buf.bufv1, x, ref y, ref dy, ref d2y, _params);
                return;
            }
            if( s.modelversion==2 )
            {
                rbfv2.rbfv2tshessbuf(s.model2, buf.bufv2, x, ref y, ref dy, ref d2y, _params);
                return;
            }
            if( s.modelversion==3 )
            {
                rbfv3.rbfv3tshessbuf(s.model3, buf.bufv3, x, ref y, ref dy, ref d2y, _params);
                return;
            }
            alglib.ap.assert(false, "RBFDiffBuf: integrity check failed");
        }


        /*************************************************************************
        This is legacy function for gridded calculation of RBF model.

        It is superseded by rbfgridcalc2v() and  rbfgridcalc2vsubset()  functions.

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfgridcalc2(rbfmodel s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            ref double[,] y,
            alglib.xparams _params)
        {
            int i = 0;
            int j = 0;
            double[] yy = new double[0];

            y = new double[0,0];

            alglib.ap.assert(n0>0, "RBFGridCalc2: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc2: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc2: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc2: Length(X1)<N1");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc2: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc2: X1 contains infinite or NaN values!");
            if( s.modelversion==1 )
            {
                rbfv1.rbfv1gridcalc2(s.model1, x0, n0, x1, n1, ref y, _params);
                return;
            }
            if( s.modelversion==2 )
            {
                rbfv2.rbfv2gridcalc2(s.model2, x0, n0, x1, n1, ref y, _params);
                return;
            }
            if( s.modelversion==3 )
            {
                ablasf.rallocm(n0, n1, ref y, _params);
                if( s.nx!=2 || s.ny!=1 )
                {
                    ablasf.rsetm(n0, n1, 0.0, y, _params);
                    return;
                }
                rbfgridcalc2v(s, x0, n0, x1, n1, ref yy, _params);
                for(i=0; i<=n0-1; i++)
                {
                    for(j=0; j<=n1-1; j++)
                    {
                        y[i,j] = yy[i+j*n0];
                    }
                }
                return;
            }
            alglib.ap.assert(false, "RBFGridCalc2: integrity check failed");
        }


        /*************************************************************************
        This function calculates values of the RBF  model  at  the  regular  grid,
        which  has  N0*N1 points, with Point[I,J] = (X0[I], X1[J]).  Vector-valued
        RBF models are supported.

        This function returns 0.0 when:
        * model is not initialized
        * NX<>2

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
              RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
              processed serially.

        INPUT PARAMETERS:
            S       -   RBF model, used in read-only mode, can be  shared  between
                        multiple   invocations  of  this  function  from  multiple
                        threads.
            
            X0      -   array of grid nodes, first coordinates, array[N0].
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N0      -   grid size (number of nodes) in the first dimension
            
            X1      -   array of grid nodes, second coordinates, array[N1]
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N1      -   grid size (number of nodes) in the second dimension

        OUTPUT PARAMETERS:
            Y       -   function values, array[NY*N0*N1], where NY is a  number of
                        "output" vector values (this  function   supports  vector-
                        valued RBF models). Y is out-variable and  is  reallocated
                        by this function.
                        Y[K+NY*(I0+I1*N0)]=F_k(X0[I0],X1[I1]), for:
                        *  K=0...NY-1
                        * I0=0...N0-1
                        * I1=0...N1-1

        NOTE: this function supports weakly ordered grid nodes, i.e. you may  have                
              X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
              benefits  due  to   duplication  of  points,  just  convenience  and
              flexibility.
              
        NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
              structure in multiple threads calling  this function  for  different
              grids.
              
        NOTE: if you need function values on some subset  of  regular  grid, which
              may be described as "several compact and  dense  islands",  you  may
              use rbfgridcalc2vsubset().

          -- ALGLIB --
             Copyright 27.01.2017 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfgridcalc2v(rbfmodel s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;
            bool[] dummy = new bool[0];

            y = new double[0];

            alglib.ap.assert(n0>0, "RBFGridCalc2V: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc2V: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc2V: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc2V: Length(X1)<N1");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc2V: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc2V: X1 contains infinite or NaN values!");
            for(i=0; i<=n0-2; i++)
            {
                alglib.ap.assert((double)(x0[i])<=(double)(x0[i+1]), "RBFGridCalc2V: X0 is not ordered by ascending");
            }
            for(i=0; i<=n1-2; i++)
            {
                alglib.ap.assert((double)(x1[i])<=(double)(x1[i+1]), "RBFGridCalc2V: X1 is not ordered by ascending");
            }
            rbfgridcalc2vx(s, x0, n0, x1, n1, dummy, false, ref y, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model at some subset of regular
        grid:
        * grid has N0*N1 points, with Point[I,J] = (X0[I], X1[J])
        * only values at some subset of this grid are required
        Vector-valued RBF models are supported.

        This function returns 0.0 when:
        * model is not initialized
        * NX<>2

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
              RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
              processed serially.

        INPUT PARAMETERS:
            S       -   RBF model, used in read-only mode, can be  shared  between
                        multiple   invocations  of  this  function  from  multiple
                        threads.
            
            X0      -   array of grid nodes, first coordinates, array[N0].
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N0      -   grid size (number of nodes) in the first dimension
            
            X1      -   array of grid nodes, second coordinates, array[N1]
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N1      -   grid size (number of nodes) in the second dimension
            
            FlagY   -   array[N0*N1]:
                        * Y[I0+I1*N0] corresponds to node (X0[I0],X1[I1])
                        * it is a "bitmap" array which contains  False  for  nodes
                          which are NOT calculated, and True for nodes  which  are
                          required.

        OUTPUT PARAMETERS:
            Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
                        of "output" vector values (this function  supports vector-
                        valued RBF models):
                        * Y[K+NY*(I0+I1*N0)]=F_k(X0[I0],X1[I1]),
                          for K=0...NY-1, I0=0...N0-1, I1=0...N1-1.
                        * elements of Y[] which correspond  to  FlagY[]=True   are
                          loaded by model values (which may be  exactly  zero  for
                          some nodes).
                        * elements of Y[] which correspond to FlagY[]=False MAY be
                          initialized by zeros OR may be calculated. This function
                          processes  grid  as  a  hierarchy  of  nested blocks and
                          micro-rows. If just one element of micro-row is required,
                          entire micro-row (up to 8 nodes in the current  version,
                          but no promises) is calculated.

        NOTE: this function supports weakly ordered grid nodes, i.e. you may  have                
              X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
              benefits  due  to   duplication  of  points,  just  convenience  and
              flexibility.
              
        NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
              structure in multiple threads calling  this function  for  different
              grids.

          -- ALGLIB --
             Copyright 04.03.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfgridcalc2vsubset(rbfmodel s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            bool[] flagy,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;

            y = new double[0];

            alglib.ap.assert(n0>0, "RBFGridCalc2VSubset: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc2VSubset: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc2VSubset: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc2VSubset: Length(X1)<N1");
            alglib.ap.assert(alglib.ap.len(flagy)>=n0*n1, "RBFGridCalc2VSubset: Length(FlagY)<N0*N1*N2");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc2VSubset: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc2VSubset: X1 contains infinite or NaN values!");
            for(i=0; i<=n0-2; i++)
            {
                alglib.ap.assert((double)(x0[i])<=(double)(x0[i+1]), "RBFGridCalc2VSubset: X0 is not ordered by ascending");
            }
            for(i=0; i<=n1-2; i++)
            {
                alglib.ap.assert((double)(x1[i])<=(double)(x1[i+1]), "RBFGridCalc2VSubset: X1 is not ordered by ascending");
            }
            rbfgridcalc2vx(s, x0, n0, x1, n1, flagy, true, ref y, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF  model  at  the  regular  grid,
        which  has  N0*N1*N2  points,  with  Point[I,J,K] = (X0[I], X1[J], X2[K]).
        Vector-valued RBF models are supported.

        This function returns 0.0 when:
        * model is not initialized
        * NX<>3

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
              RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
              processed serially.

        INPUT PARAMETERS:
            S       -   RBF model, used in read-only mode, can be  shared  between
                        multiple   invocations  of  this  function  from  multiple
                        threads.
            
            X0      -   array of grid nodes, first coordinates, array[N0].
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N0      -   grid size (number of nodes) in the first dimension
            
            X1      -   array of grid nodes, second coordinates, array[N1]
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N1      -   grid size (number of nodes) in the second dimension
            
            X2      -   array of grid nodes, third coordinates, array[N2]
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N2      -   grid size (number of nodes) in the third dimension

        OUTPUT PARAMETERS:
            Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
                        of "output" vector values (this function  supports vector-
                        valued RBF models). Y is out-variable and  is  reallocated
                        by this function.
                        Y[K+NY*(I0+I1*N0+I2*N0*N1)]=F_k(X0[I0],X1[I1],X2[I2]), for:
                        *  K=0...NY-1
                        * I0=0...N0-1
                        * I1=0...N1-1
                        * I2=0...N2-1

        NOTE: this function supports weakly ordered grid nodes, i.e. you may  have                
              X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
              benefits  due  to   duplication  of  points,  just  convenience  and
              flexibility.
              
        NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
              structure in multiple threads calling  this function  for  different
              grids.
              
        NOTE: if you need function values on some subset  of  regular  grid, which
              may be described as "several compact and  dense  islands",  you  may
              use rbfgridcalc3vsubset().

          -- ALGLIB --
             Copyright 04.03.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfgridcalc3v(rbfmodel s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;
            bool[] dummy = new bool[0];

            y = new double[0];

            alglib.ap.assert(n0>0, "RBFGridCalc3V: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc3V: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(n2>0, "RBFGridCalc3V: invalid value for N2 (N2<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc3V: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc3V: Length(X1)<N1");
            alglib.ap.assert(alglib.ap.len(x2)>=n2, "RBFGridCalc3V: Length(X2)<N2");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc3V: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc3V: X1 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x2, n2, _params), "RBFGridCalc3V: X2 contains infinite or NaN values!");
            for(i=0; i<=n0-2; i++)
            {
                alglib.ap.assert((double)(x0[i])<=(double)(x0[i+1]), "RBFGridCalc3V: X0 is not ordered by ascending");
            }
            for(i=0; i<=n1-2; i++)
            {
                alglib.ap.assert((double)(x1[i])<=(double)(x1[i+1]), "RBFGridCalc3V: X1 is not ordered by ascending");
            }
            for(i=0; i<=n2-2; i++)
            {
                alglib.ap.assert((double)(x2[i])<=(double)(x2[i+1]), "RBFGridCalc3V: X2 is not ordered by ascending");
            }
            rbfgridcalc3vx(s, x0, n0, x1, n1, x2, n2, dummy, false, ref y, _params);
        }


        /*************************************************************************
        This function calculates values of the RBF model at some subset of regular
        grid:
        * grid has N0*N1*N2 points, with Point[I,J,K] = (X0[I], X1[J], X2[K])
        * only values at some subset of this grid are required
        Vector-valued RBF models are supported.

        This function returns 0.0 when:
        * model is not initialized
        * NX<>3

          ! COMMERCIAL EDITION OF ALGLIB:
          ! 
          ! Commercial Edition of ALGLIB includes following important improvements
          ! of this function:
          ! * high-performance native backend with same C# interface (C# version)
          ! * multithreading support (C++ and C# versions)
          ! 
          ! We recommend you to read 'Working with commercial version' section  of
          ! ALGLIB Reference Manual in order to find out how to  use  performance-
          ! related features provided by commercial edition of ALGLIB.

        NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
              RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
              processed serially.

        INPUT PARAMETERS:
            S       -   RBF model, used in read-only mode, can be  shared  between
                        multiple   invocations  of  this  function  from  multiple
                        threads.
            
            X0      -   array of grid nodes, first coordinates, array[N0].
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N0      -   grid size (number of nodes) in the first dimension
            
            X1      -   array of grid nodes, second coordinates, array[N1]
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N1      -   grid size (number of nodes) in the second dimension
            
            X2      -   array of grid nodes, third coordinates, array[N2]
                        Must be ordered by ascending. Exception is generated
                        if the array is not correctly ordered.
            N2      -   grid size (number of nodes) in the third dimension
            
            FlagY   -   array[N0*N1*N2]:
                        * Y[I0+I1*N0+I2*N0*N1] corresponds to node (X0[I0],X1[I1],X2[I2])
                        * it is a "bitmap" array which contains  False  for  nodes
                          which are NOT calculated, and True for nodes  which  are
                          required.

        OUTPUT PARAMETERS:
            Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
                        of "output" vector values (this function  supports vector-
                        valued RBF models):
                        * Y[K+NY*(I0+I1*N0+I2*N0*N1)]=F_k(X0[I0],X1[I1],X2[I2]),
                          for K=0...NY-1, I0=0...N0-1, I1=0...N1-1, I2=0...N2-1.
                        * elements of Y[] which correspond  to  FlagY[]=True   are
                          loaded by model values (which may be  exactly  zero  for
                          some nodes).
                        * elements of Y[] which correspond to FlagY[]=False MAY be
                          initialized by zeros OR may be calculated. This function
                          processes  grid  as  a  hierarchy  of  nested blocks and
                          micro-rows. If just one element of micro-row is required,
                          entire micro-row (up to 8 nodes in the current  version,
                          but no promises) is calculated.

        NOTE: this function supports weakly ordered grid nodes, i.e. you may  have                
              X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
              benefits  due  to   duplication  of  points,  just  convenience  and
              flexibility.
              
        NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
              structure in multiple threads calling  this function  for  different
              grids.

          -- ALGLIB --
             Copyright 04.03.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfgridcalc3vsubset(rbfmodel s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            bool[] flagy,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;

            y = new double[0];

            alglib.ap.assert(n0>0, "RBFGridCalc3VSubset: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc3VSubset: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(n2>0, "RBFGridCalc3VSubset: invalid value for N2 (N2<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc3VSubset: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc3VSubset: Length(X1)<N1");
            alglib.ap.assert(alglib.ap.len(x2)>=n2, "RBFGridCalc3VSubset: Length(X2)<N2");
            alglib.ap.assert(alglib.ap.len(flagy)>=n0*n1*n2, "RBFGridCalc3VSubset: Length(FlagY)<N0*N1*N2");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc3VSubset: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc3VSubset: X1 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x2, n2, _params), "RBFGridCalc3VSubset: X2 contains infinite or NaN values!");
            for(i=0; i<=n0-2; i++)
            {
                alglib.ap.assert((double)(x0[i])<=(double)(x0[i+1]), "RBFGridCalc3VSubset: X0 is not ordered by ascending");
            }
            for(i=0; i<=n1-2; i++)
            {
                alglib.ap.assert((double)(x1[i])<=(double)(x1[i+1]), "RBFGridCalc3VSubset: X1 is not ordered by ascending");
            }
            for(i=0; i<=n2-2; i++)
            {
                alglib.ap.assert((double)(x2[i])<=(double)(x2[i+1]), "RBFGridCalc3VSubset: X2 is not ordered by ascending");
            }
            rbfgridcalc3vx(s, x0, n0, x1, n1, x2, n2, flagy, true, ref y, _params);
        }


        /*************************************************************************
        This function, depending on SparseY, acts as RBFGridCalc2V (SparseY=False)
        or RBFGridCalc2VSubset (SparseY=True) function.  See  comments  for  these
        functions for more information

          -- ALGLIB --
             Copyright 04.03.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfgridcalc2vx(rbfmodel s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            bool[] flagy,
            bool sparsey,
            ref double[] y,
            alglib.xparams _params)
        {
            int nx = 0;
            int ny = 0;
            int ylen = 0;
            hqrnd.hqrndstate rs = new hqrnd.hqrndstate();
            double[] dummyx2 = new double[0];
            double[] dummyx3 = new double[0];
            int i = 0;
            int j = 0;
            int k = 0;
            int l = 0;
            double[] tx = new double[0];
            double[] ty = new double[0];
            int dstoffs = 0;
            rbfcalcbuffer calcbuf = new rbfcalcbuffer();

            alglib.ap.assert(n0>0, "RBFGridCalc2VX: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc2VX: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc2VX: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc2VX: Length(X1)<N1");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc2VX: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc2VX: X1 contains infinite or NaN values!");
            for(i=0; i<=n0-2; i++)
            {
                alglib.ap.assert((double)(x0[i])<=(double)(x0[i+1]), "RBFGridCalc2VX: X0 is not ordered by ascending");
            }
            for(i=0; i<=n1-2; i++)
            {
                alglib.ap.assert((double)(x1[i])<=(double)(x1[i+1]), "RBFGridCalc2VX: X1 is not ordered by ascending");
            }
            
            //
            // Prepare local variables
            //
            nx = s.nx;
            ny = s.ny;
            hqrnd.hqrndseed(325, 46345, rs, _params);
            
            //
            // Prepare output array
            //
            ylen = ny*n0*n1;
            y = new double[ylen];
            for(i=0; i<=ylen-1; i++)
            {
                y[i] = 0;
            }
            if( s.nx!=2 )
            {
                return;
            }
            
            //
            // Reference code for V3 models
            //
            if( s.modelversion==3 )
            {
                dummyx2 = new double[1];
                dummyx2[0] = 0;
                dummyx3 = new double[1];
                dummyx3[0] = 0;
                rbfv3.rbfv3gridcalcvx(s.model3, x0, n0, x1, n1, dummyx2, 1, dummyx3, 1, flagy, sparsey, y, _params);
                return;
            }
            
            //
            // Process V2 model
            //
            if( s.modelversion==2 )
            {
                dummyx2 = new double[1];
                dummyx2[0] = 0;
                dummyx3 = new double[1];
                dummyx3[0] = 0;
                rbfv2.rbfv2gridcalcvx(s.model2, x0, n0, x1, n1, dummyx2, 1, dummyx3, 1, flagy, sparsey, y, _params);
                return;
            }
            
            //
            // Reference code for V1 models
            //
            if( s.modelversion==1 )
            {
                tx = new double[nx];
                rbfcreatecalcbuffer(s, calcbuf, _params);
                for(i=0; i<=n0-1; i++)
                {
                    for(j=0; j<=n1-1; j++)
                    {
                        k = i+j*n0;
                        dstoffs = ny*k;
                        if( sparsey && !flagy[k] )
                        {
                            for(l=0; l<=ny-1; l++)
                            {
                                y[l+dstoffs] = 0;
                            }
                            continue;
                        }
                        tx[0] = x0[i];
                        tx[1] = x1[j];
                        rbftscalcbuf(s, calcbuf, tx, ref ty, _params);
                        for(l=0; l<=ny-1; l++)
                        {
                            y[l+dstoffs] = ty[l];
                        }
                    }
                }
                return;
            }
            
            //
            // Unknown model
            //
            alglib.ap.assert(false, "RBFGridCalc2VX: integrity check failed");
        }


        /*************************************************************************
        This function, depending on SparseY, acts as RBFGridCalc3V (SparseY=False)
        or RBFGridCalc3VSubset (SparseY=True) function.  See  comments  for  these
        functions for more information

          -- ALGLIB --
             Copyright 04.03.2016 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfgridcalc3vx(rbfmodel s,
            double[] x0,
            int n0,
            double[] x1,
            int n1,
            double[] x2,
            int n2,
            bool[] flagy,
            bool sparsey,
            ref double[] y,
            alglib.xparams _params)
        {
            int i = 0;
            int ylen = 0;
            int nx = 0;
            int ny = 0;
            double rmax = 0;
            int[] blocks0 = new int[0];
            int[] blocks1 = new int[0];
            int[] blocks2 = new int[0];
            int blockscnt0 = 0;
            int blockscnt1 = 0;
            int blockscnt2 = 0;
            double blockwidth = 0;
            double searchradius = 0;
            double avgfuncpernode = 0;
            int ntrials = 0;
            int maxblocksize = 0;
            rbfv1.gridcalc3v1buf bufseedv1 = new rbfv1.gridcalc3v1buf();
            alglib.smp.shared_pool bufpool = new alglib.smp.shared_pool();
            hqrnd.hqrndstate rs = new hqrnd.hqrndstate();
            double[] dummyx3 = new double[0];

            alglib.ap.assert(n0>0, "RBFGridCalc3V: invalid value for N0 (N0<=0)!");
            alglib.ap.assert(n1>0, "RBFGridCalc3V: invalid value for N1 (N1<=0)!");
            alglib.ap.assert(n2>0, "RBFGridCalc3V: invalid value for N2 (N2<=0)!");
            alglib.ap.assert(alglib.ap.len(x0)>=n0, "RBFGridCalc3V: Length(X0)<N0");
            alglib.ap.assert(alglib.ap.len(x1)>=n1, "RBFGridCalc3V: Length(X1)<N1");
            alglib.ap.assert(alglib.ap.len(x2)>=n2, "RBFGridCalc3V: Length(X2)<N2");
            alglib.ap.assert(apserv.isfinitevector(x0, n0, _params), "RBFGridCalc3V: X0 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x1, n1, _params), "RBFGridCalc3V: X1 contains infinite or NaN values!");
            alglib.ap.assert(apserv.isfinitevector(x2, n2, _params), "RBFGridCalc3V: X2 contains infinite or NaN values!");
            for(i=0; i<=n0-2; i++)
            {
                alglib.ap.assert((double)(x0[i])<=(double)(x0[i+1]), "RBFGridCalc3V: X0 is not ordered by ascending");
            }
            for(i=0; i<=n1-2; i++)
            {
                alglib.ap.assert((double)(x1[i])<=(double)(x1[i+1]), "RBFGridCalc3V: X1 is not ordered by ascending");
            }
            for(i=0; i<=n2-2; i++)
            {
                alglib.ap.assert((double)(x2[i])<=(double)(x2[i+1]), "RBFGridCalc3V: X2 is not ordered by ascending");
            }
            
            //
            // Prepare local variables
            //
            nx = s.nx;
            ny = s.ny;
            hqrnd.hqrndseed(325, 46345, rs, _params);
            
            //
            // Prepare output array
            //
            ylen = ny*n0*n1*n2;
            y = new double[ylen];
            for(i=0; i<=ylen-1; i++)
            {
                y[i] = 0;
            }
            if( s.nx!=3 )
            {
                return;
            }
            
            //
            // Process V1 model
            //
            if( s.modelversion==1 )
            {
                
                //
                // Fast exit for models without centers
                //
                if( s.model1.nc==0 )
                {
                    return;
                }
                
                //
                // Prepare seed, create shared pool of temporary buffers
                //
                bufseedv1.cx = new double[nx];
                bufseedv1.tx = new double[nx];
                bufseedv1.ty = new double[ny];
                bufseedv1.expbuf0 = new double[n0];
                bufseedv1.expbuf1 = new double[n1];
                bufseedv1.expbuf2 = new double[n2];
                nearestneighbor.kdtreecreaterequestbuffer(s.model1.tree, bufseedv1.requestbuf, _params);
                alglib.smp.ae_shared_pool_set_seed(bufpool, bufseedv1);
                
                //
                // Analyze input grid:
                // * analyze average number of basis functions per grid node
                // * partition grid in into blocks
                //
                rmax = s.model1.rmax;
                blockwidth = 2*rmax;
                maxblocksize = 8;
                searchradius = rmax*rbffarradius+0.5*Math.Sqrt(s.nx)*blockwidth;
                ntrials = 100;
                avgfuncpernode = 0.0;
                for(i=0; i<=ntrials-1; i++)
                {
                    bufseedv1.tx[0] = x0[hqrnd.hqrnduniformi(rs, n0, _params)];
                    bufseedv1.tx[1] = x1[hqrnd.hqrnduniformi(rs, n1, _params)];
                    bufseedv1.tx[2] = x2[hqrnd.hqrnduniformi(rs, n2, _params)];
                    avgfuncpernode = avgfuncpernode+(double)nearestneighbor.kdtreetsqueryrnn(s.model1.tree, bufseedv1.requestbuf, bufseedv1.tx, searchradius, true, _params)/(double)ntrials;
                }
                blocks0 = new int[n0+1];
                blockscnt0 = 0;
                blocks0[0] = 0;
                for(i=1; i<=n0-1; i++)
                {
                    if( (double)(x0[i]-x0[blocks0[blockscnt0]])>(double)(blockwidth) || i-blocks0[blockscnt0]>=maxblocksize )
                    {
                        apserv.inc(ref blockscnt0, _params);
                        blocks0[blockscnt0] = i;
                    }
                }
                apserv.inc(ref blockscnt0, _params);
                blocks0[blockscnt0] = n0;
                blocks1 = new int[n1+1];
                blockscnt1 = 0;
                blocks1[0] = 0;
                for(i=1; i<=n1-1; i++)
                {
                    if( (double)(x1[i]-x1[blocks1[blockscnt1]])>(double)(blockwidth) || i-blocks1[blockscnt1]>=maxblocksize )
                    {
                        apserv.inc(ref blockscnt1, _params);
                        blocks1[blockscnt1] = i;
                    }
                }
                apserv.inc(ref blockscnt1, _params);
                blocks1[blockscnt1] = n1;
                blocks2 = new int[n2+1];
                blockscnt2 = 0;
                blocks2[0] = 0;
                for(i=1; i<=n2-1; i++)
                {
                    if( (double)(x2[i]-x2[blocks2[blockscnt2]])>(double)(blockwidth) || i-blocks2[blockscnt2]>=maxblocksize )
                    {
                        apserv.inc(ref blockscnt2, _params);
                        blocks2[blockscnt2] = i;
                    }
                }
                apserv.inc(ref blockscnt2, _params);
                blocks2[blockscnt2] = n2;
                
                //
                // Perform calculation in multithreaded mode
                //
                rbfv1.rbfv1gridcalc3vrec(s.model1, x0, n0, x1, n1, x2, n2, blocks0, 0, blockscnt0, blocks1, 0, blockscnt1, blocks2, 0, blockscnt2, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _params);
                
                //
                // Done
                //
                return;
            }
            
            //
            // Process V2 model
            //
            if( s.modelversion==2 )
            {
                dummyx3 = new double[1];
                dummyx3[0] = 0;
                rbfv2.rbfv2gridcalcvx(s.model2, x0, n0, x1, n1, x2, n2, dummyx3, 1, flagy, sparsey, y, _params);
                return;
            }
            
            //
            // Process V3 model
            //
            if( s.modelversion==3 )
            {
                dummyx3 = new double[1];
                dummyx3[0] = 0;
                rbfv3.rbfv3gridcalcvx(s.model3, x0, n0, x1, n1, x2, n2, dummyx3, 1, flagy, sparsey, y, _params);
                return;
            }
            
            //
            // Unknown model
            //
            alglib.ap.assert(false, "RBFGridCalc3VX: integrity check failed");
        }


        /*************************************************************************
        This function "unpacks" RBF model by extracting its coefficients.

        INPUT PARAMETERS:
            S       -   RBF model

        OUTPUT PARAMETERS:
            NX      -   dimensionality of argument
            NY      -   dimensionality of the target function
            XWR     -   model  information ,  2D  array.  One  row  of  the  array
                        corresponds to one basis function.
                        
                        For ModelVersion=1 we have NX+NY+1 columns:
                        * first NX columns  - coordinates of the center 
                        * next  NY columns  - weights, one per dimension of the 
                                              function being modeled
                        * last column       - radius, same for all dimensions of
                                              the function being modeled
                        
                        For ModelVersion=2 we have NX+NY+NX columns:
                        * first NX columns  - coordinates of the center 
                        * next  NY columns  - weights, one per dimension of the 
                                              function being modeled
                        * last NX columns   - radii, one per dimension
                        
                        For ModelVersion=3 we have NX+NY+NX+3 columns:
                        * first NX columns  - coordinates of the center 
                        * next  NY columns  - weights, one per dimension of the 
                                              function being modeled
                        * next NX columns   - radii, one per dimension
                        * next column       - basis function type:
                                              * 1  for f=r
                                              * 2  for f=r^2*ln(r)
                                              * 10 for multiquadric f=sqrt(r^2+alpha^2)
                        * next column       - basis function parameter:
                                              * alpha, for basis function type 10
                                              * ignored (zero) for other basis function types
                        * next column       - point index in the original dataset,
                                              or -1 for an artificial node created
                                              by the solver. The algorithm may reorder
                                              the nodes, drop some nodes or add
                                              artificial nodes. Thus, one parsing
                                              this column should expect all these
                                              kinds of alterations in the dataset.
                        
            NC      -   number of the centers
            V       -   polynomial  term , array[NY,NX+1]. One row per one 
                        dimension of the function being modelled. First NX 
                        elements are linear coefficients, V[NX] is equal to the 
                        constant part.
            ModelVersion-version of the RBF model:
                        * 1 - for models created by QNN and RBF-ML algorithms,
                          compatible with ALGLIB 3.10 or earlier.
                        * 2 - for models created by HierarchicalRBF, requires
                          ALGLIB 3.11 or later
                        * 3 - for models created by DDM-RBF, requires
                          ALGLIB 3.19 or later

          -- ALGLIB --
             Copyright 13.12.2011 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfunpack(rbfmodel s,
            ref int nx,
            ref int ny,
            ref double[,] xwr,
            ref int nc,
            ref double[,] v,
            ref int modelversion,
            alglib.xparams _params)
        {
            nx = 0;
            ny = 0;
            xwr = new double[0,0];
            nc = 0;
            v = new double[0,0];
            modelversion = 0;

            if( s.modelversion==1 )
            {
                modelversion = 1;
                rbfv1.rbfv1unpack(s.model1, ref nx, ref ny, ref xwr, ref nc, ref v, _params);
                return;
            }
            if( s.modelversion==2 )
            {
                modelversion = 2;
                rbfv2.rbfv2unpack(s.model2, ref nx, ref ny, ref xwr, ref nc, ref v, _params);
                return;
            }
            if( s.modelversion==3 )
            {
                modelversion = 3;
                rbfv3.rbfv3unpack(s.model3, ref nx, ref ny, ref xwr, ref nc, ref v, _params);
                return;
            }
            alglib.ap.assert(false, "RBFUnpack: integrity check failure");
        }


        /*************************************************************************
        This function returns model version.

        INPUT PARAMETERS:
            S       -   RBF model

        RESULT:
            * 1 - for models created by QNN and RBF-ML algorithms,
              compatible with ALGLIB 3.10 or earlier.
            * 2 - for models created by HierarchicalRBF, requires
              ALGLIB 3.11 or later

          -- ALGLIB --
             Copyright 06.07.2016 by Bochkanov Sergey
        *************************************************************************/
        public static int rbfgetmodelversion(rbfmodel s,
            alglib.xparams _params)
        {
            int result = 0;

            result = s.modelversion;
            return result;
        }


        /*************************************************************************
        This function is used to peek into hierarchical RBF  construction  process
        from  some  other  thread  and  get current progress indicator. It returns
        value in [0,1].

        IMPORTANT: only HRBFs (hierarchical RBFs) support  peeking  into  progress
                   indicator. Legacy RBF-ML and RBF-QNN do  not  support  it.  You
                   will always get 0 value.

        INPUT PARAMETERS:
            S           -   RBF model object

        RESULT:
            progress value, in [0,1]

          -- ALGLIB --
             Copyright 17.11.2018 by Bochkanov Sergey
        *************************************************************************/
        public static double rbfpeekprogress(rbfmodel s,
            alglib.xparams _params)
        {
            double result = 0;

            result = (double)s.progress10000/(double)10000;
            return result;
        }


        /*************************************************************************
        This function  is  used  to  submit  a  request  for  termination  of  the
        hierarchical RBF construction process from some other thread.  As  result,
        RBF construction is terminated smoothly (with proper deallocation  of  all
        necessary resources) and resultant model is filled by zeros.

        A rep.terminationtype=8 will be returned upon receiving such request.

        IMPORTANT: only  HRBFs  (hierarchical  RBFs) support termination requests.
                   Legacy RBF-ML and RBF-QNN do not  support  it.  An  attempt  to
                   terminate their construction will be ignored.

        IMPORTANT: termination request flag is cleared when the model construction
                   starts. Thus, any pre-construction termination requests will be
                   silently ignored - only ones submitted AFTER  construction  has
                   actually began will be handled.

        INPUT PARAMETERS:
            S           -   RBF model object

          -- ALGLIB --
             Copyright 17.11.2018 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfrequesttermination(rbfmodel s,
            alglib.xparams _params)
        {
            s.terminationrequest = true;
        }


        /*************************************************************************
        Serializer: allocation

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfalloc(alglib.serializer s,
            rbfmodel model,
            alglib.xparams _params)
        {
            
            //
            // Header
            //
            s.alloc_entry();
            
            //
            // V1 model
            //
            if( model.modelversion==1 )
            {
                
                //
                // Header
                //
                s.alloc_entry();
                rbfv1.rbfv1alloc(s, model.model1, _params);
                return;
            }
            
            //
            // V2 model
            //
            if( model.modelversion==2 )
            {
                
                //
                // Header
                //
                s.alloc_entry();
                rbfv2.rbfv2alloc(s, model.model2, _params);
                return;
            }
            
            //
            // V3 model
            //
            if( model.modelversion==3 )
            {
                
                //
                // Header
                //
                s.alloc_entry();
                rbfv3.rbfv3alloc(s, model.model3, _params);
                return;
            }
            alglib.ap.assert(false);
        }


        /*************************************************************************
        Serializer: serialization

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfserialize(alglib.serializer s,
            rbfmodel model,
            alglib.xparams _params)
        {
            
            //
            // Header
            //
            s.serialize_int(scodes.getrbfserializationcode(_params));
            
            //
            // V1 model
            //
            if( model.modelversion==1 )
            {
                s.serialize_int(rbffirstversion);
                rbfv1.rbfv1serialize(s, model.model1, _params);
                return;
            }
            
            //
            // V2 model
            //
            if( model.modelversion==2 )
            {
                
                //
                // Header
                //
                s.serialize_int(rbfversion2);
                rbfv2.rbfv2serialize(s, model.model2, _params);
                return;
            }
            
            //
            // V3 model
            //
            if( model.modelversion==3 )
            {
                
                //
                // Header
                //
                s.serialize_int(rbfversion3);
                rbfv3.rbfv3serialize(s, model.model3, _params);
                return;
            }
            alglib.ap.assert(false);
        }


        /*************************************************************************
        Serializer: unserialization

          -- ALGLIB --
             Copyright 02.02.2012 by Bochkanov Sergey
        *************************************************************************/
        public static void rbfunserialize(alglib.serializer s,
            rbfmodel model,
            alglib.xparams _params)
        {
            int i0 = 0;
            int i1 = 0;

            rbfpreparenonserializablefields(model, _params);
            
            //
            // Header
            //
            i0 = s.unserialize_int();
            alglib.ap.assert(i0==scodes.getrbfserializationcode(_params), "RBFUnserialize: stream header corrupted");
            i1 = s.unserialize_int();
            alglib.ap.assert((i1==rbffirstversion || i1==rbfversion2) || i1==rbfversion3, "RBFUnserialize: stream header corrupted");
            
            //
            // V1 model
            //
            if( i1==rbffirstversion )
            {
                rbfv1.rbfv1unserialize(s, model.model1, _params);
                model.modelversion = 1;
                model.ny = model.model1.ny;
                model.nx = model.model1.nx;
                initializev2(model.nx, model.ny, model.model2, _params);
                initializev3(model.nx, model.ny, model.model3, _params);
                rbfcreatecalcbuffer(model, model.calcbuf, _params);
                return;
            }
            
            //
            // V2 model
            //
            if( i1==rbfversion2 )
            {
                rbfv2.rbfv2unserialize(s, model.model2, _params);
                model.modelversion = 2;
                model.ny = model.model2.ny;
                model.nx = model.model2.nx;
                initializev1(model.nx, model.ny, model.model1, _params);
                initializev3(model.nx, model.ny, model.model3, _params);
                rbfcreatecalcbuffer(model, model.calcbuf, _params);
                return;
            }
            
            //
            // V3 model
            //
            if( i1==rbfversion3 )
            {
                rbfv3.rbfv3unserialize(s, model.model3, _params);
                model.modelversion = 3;
                model.ny = model.model3.ny;
                model.nx = model.model3.nx;
                initializev1(model.nx, model.ny, model.model1, _params);
                initializev2(model.nx, model.ny, model.model2, _params);
                rbfcreatecalcbuffer(model, model.calcbuf, _params);
                return;
            }
            alglib.ap.assert(false, "RBF: unserialiation error (unexpected model type)");
        }


        /*************************************************************************
        Initialize empty model

          -- ALGLIB --
             Copyright 12.05.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void rbfpreparenonserializablefields(rbfmodel s,
            alglib.xparams _params)
        {
            s.n = 0;
            s.hasscale = false;
            s.radvalue = 1;
            s.radzvalue = 5;
            s.nlayers = 0;
            s.lambdav = 0;
            s.aterm = 1;
            s.algorithmtype = 0;
            s.epsort = eps;
            s.epserr = eps;
            s.maxits = 0;
            s.nnmaxits = 100;
        }


        /*************************************************************************
        Initialize V1 model (skip initialization for NX=1 or NX>3)

          -- ALGLIB --
             Copyright 12.05.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void initializev1(int nx,
            int ny,
            rbfv1.rbfv1model s,
            alglib.xparams _params)
        {
            if( nx==2 || nx==3 )
            {
                rbfv1.rbfv1create(nx, ny, s, _params);
            }
        }


        /*************************************************************************
        Initialize V2 model

          -- ALGLIB --
             Copyright 12.05.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void initializev2(int nx,
            int ny,
            rbfv2.rbfv2model s,
            alglib.xparams _params)
        {
            rbfv2.rbfv2create(nx, ny, s, _params);
        }


        /*************************************************************************
        Initialize V3 model

          -- ALGLIB --
             Copyright 12.05.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void initializev3(int nx,
            int ny,
            rbfv3.rbfv3model s,
            alglib.xparams _params)
        {
            rbfv3.rbfv3create(nx, ny, 2, 0, s, _params);
        }


        /*************************************************************************
        Cleans report fields

          -- ALGLIB --
             Copyright 16.06.2016 by Bochkanov Sergey
        *************************************************************************/
        private static void clearreportfields(rbfreport rep,
            alglib.xparams _params)
        {
            rep.rmserror = Double.NaN;
            rep.maxerror = Double.NaN;
            rep.arows = 0;
            rep.acols = 0;
            rep.annz = 0;
            rep.iterationscount = 0;
            rep.nmv = 0;
            rep.terminationtype = 0;
        }


    }
}

